"use strict";

var CABLES=CABLES||{};
CABLES.OPS=CABLES.OPS||{};

var Ops=Ops || {};
Ops.Gl=Ops.Gl || {};
Ops.Ui=Ops.Ui || {};
Ops.Api=Ops.Api || {};
Ops.Dev=Ops.Dev || {};
Ops.Net=Ops.Net || {};
Ops.Anim=Ops.Anim || {};
Ops.Date=Ops.Date || {};
Ops.Game=Ops.Game || {};
Ops.Html=Ops.Html || {};
Ops.Json=Ops.Json || {};
Ops.Libs=Ops.Libs || {};
Ops.Math=Ops.Math || {};
Ops.Time=Ops.Time || {};
Ops.Vars=Ops.Vars || {};
Ops.Array=Ops.Array || {};
Ops.Audio=Ops.Audio || {};
Ops.Color=Ops.Color || {};
Ops.Debug=Ops.Debug || {};
Ops.Patch=Ops.Patch || {};
Ops.Value=Ops.Value || {};
Ops.WebXr=Ops.WebXr || {};
Ops.Arrays=Ops.Arrays || {};
Ops.Cables=Ops.Cables || {};
Ops.Dev.Gl=Ops.Dev.Gl || {};
Ops.Device=Ops.Device || {};
Ops.Gl.Pbr=Ops.Gl.Pbr || {};
Ops.Points=Ops.Points || {};
Ops.String=Ops.String || {};
Ops.Values=Ops.Values || {};
Ops.Boolean=Ops.Boolean || {};
Ops.Browser=Ops.Browser || {};
Ops.Devices=Ops.Devices || {};
Ops.Gl.GLTF=Ops.Gl.GLTF || {};
Ops.Physics=Ops.Physics || {};
Ops.Sidebar=Ops.Sidebar || {};
Ops.Systems=Ops.Systems || {};
Ops.Trigger=Ops.Trigger || {};
Ops.Website=Ops.Website || {};
Ops.Dev.Json=Ops.Dev.Json || {};
Ops.Geometry=Ops.Geometry || {};
Ops.Gl.Phong=Ops.Gl.Phong || {};
Ops.Graphics=Ops.Graphics || {};
Ops.TimeLine=Ops.TimeLine || {};
Ops.WebAudio=Ops.WebAudio || {};
Ops.WebXr.Vr=Ops.WebXr.Vr || {};
Ops.Dev.Array=Ops.Dev.Array || {};
Ops.Gl.Matrix=Ops.Gl.Matrix || {};
Ops.Gl.Meshes=Ops.Gl.Meshes || {};
Ops.Gl.Shader=Ops.Gl.Shader || {};
Ops.Templates=Ops.Templates || {};
Ops.Api.FxHash=Ops.Api.FxHash || {};
Ops.Dev.String=Ops.Dev.String || {};
Ops.Dev.WebGpu=Ops.Dev.WebGpu || {};
Ops.Gl.CubeMap=Ops.Gl.CubeMap || {};
Ops.Html.Event=Ops.Html.Event || {};
Ops.Gl.Geometry=Ops.Gl.Geometry || {};
Ops.Gl.Textures=Ops.Gl.Textures || {};
Ops.Libs.Lottie=Ops.Libs.Lottie || {};
Ops.Dev.Graphics=Ops.Dev.Graphics || {};
Ops.Devices.Midi=Ops.Devices.Midi || {};
Ops.Math.Compare=Ops.Math.Compare || {};
Ops.Physics.Ammo=Ops.Physics.Ammo || {};
Ops.Device.Mobile=Ops.Device.Mobile || {};
Ops.Devices.Mouse=Ops.Devices.Mouse || {};
Ops.Libs.OpenType=Ops.Libs.OpenType || {};
Ops.Net.WebSocket=Ops.Net.WebSocket || {};
Ops.Api.SoundCloud=Ops.Api.SoundCloud || {};
Ops.Devices.Mobile=Ops.Devices.Mobile || {};
Ops.Libs.Mediapipe=Ops.Libs.Mediapipe || {};
Ops.Dev.Gl.Geometry=Ops.Dev.Gl.Geometry || {};
Ops.Devices.GamePad=Ops.Devices.GamePad || {};
Ops.Libs.Trackingjs=Ops.Libs.Trackingjs || {};
Ops.Array.PointArray=Ops.Array.PointArray || {};
Ops.Devices.Keyboard=Ops.Devices.Keyboard || {};
Ops.Gl.ShaderEffects=Ops.Gl.ShaderEffects || {};
Ops.Gl.TextureEffect=Ops.Gl.TextureEffect || {};
Ops.Dev.VertexTexture=Ops.Dev.VertexTexture || {};
Ops.Gl.TextureEffects=Ops.Gl.TextureEffects || {};
Ops.Graphics.Geometry=Ops.Graphics.Geometry || {};
Ops.Dev.Gl.ShaderGraph=Ops.Dev.Gl.ShaderGraph || {};
Ops.Dev.Gl.Shadergraph=Ops.Dev.Gl.Shadergraph || {};
Ops.Dev.Graphics.Meshes=Ops.Dev.Graphics.Meshes || {};
Ops.Dev.Gl.TextureEffects=Ops.Dev.Gl.TextureEffects || {};
Ops.WebAudio.TextToSpeech=Ops.WebAudio.TextToSpeech || {};
Ops.Gl.TextureEffects.Math=Ops.Gl.TextureEffects.Math || {};
Ops.Gl.TextureEffects.Noise=Ops.Gl.TextureEffects.Noise || {};



// **************************************************************
// 
// Ops.Anim.AnimNumber
// 
// **************************************************************

Ops.Anim.AnimNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    inValue = op.inValue("Value"),
    duration = op.inValueFloat("duration"),
    next = op.outTrigger("Next"),
    result = op.outNumber("result"),
    finished = op.outTrigger("Finished");

const anim = new CABLES.Anim();
anim.createPort(op, "easing", init);

anim.loop = false;
duration.set(0.5);

duration.onChange =
    inValue.onChange = init;

let lastTime = 0;
let startTime = 0;
let offset = 0;

let firsttime = true;

function init()
{
    startTime = performance.now();
    anim.clear(CABLES.now() / 1000.0);

    if (firsttime) anim.setValue(CABLES.now() / 1000.0, inValue.get());

    anim.setValue(duration.get() + CABLES.now() / 1000.0, inValue.get(), triggerFinished);

    firsttime = false;
}

function triggerFinished()
{
    finished.trigger();
}

exe.onTriggered = function ()
{
    let t = CABLES.now() / 1000;

    if (performance.now() - lastTime > 300)
    {
        firsttime = true;
        init();
    }

    lastTime = performance.now();

    let v = anim.getValue(t);

    result.set(v);
    next.trigger();
};


};

Ops.Anim.AnimNumber.prototype = new CABLES.Op();
CABLES.OPS["e5b0b016-9663-4c9d-9365-f54ae3c5fbb6"]={f:Ops.Anim.AnimNumber,objName:"Ops.Anim.AnimNumber"};




// **************************************************************
// 
// Ops.Anim.Bang
// 
// **************************************************************

Ops.Anim.Bang = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpdate = op.inTrigger("update"),
    inBang = op.inTriggerButton("Bang"),
    inDuration = op.inValue("Duration", 0.1),
    invert = op.inBool("Invert", false),
    outTrigger = op.outTrigger("Trigger Out"),
    outValue = op.outNumber("Value");

const anim = new CABLES.Anim();
let startTime = CABLES.now();
op.toWorkPortsNeedToBeLinked(inUpdate);

inBang.onTriggered = function ()
{
    startTime = CABLES.now();

    anim.clear();
    anim.setValue(0, 1);
    anim.setValue(inDuration.get(), 0);
};

inUpdate.onTriggered = function ()
{
    let v = anim.getValue((CABLES.now() - startTime) / 1000);
    if (invert.get()) outValue.set(1.0 - v);
    else outValue.set(v);

    outTrigger.trigger();
};


};

Ops.Anim.Bang.prototype = new CABLES.Op();
CABLES.OPS["92ca45a7-5b4b-4238-956e-23d79bdc659f"]={f:Ops.Anim.Bang,objName:"Ops.Anim.Bang"};




// **************************************************************
// 
// Ops.Anim.BoolAnim
// 
// **************************************************************

Ops.Anim.BoolAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const anim = new CABLES.Anim();

const
    exe = op.inTrigger("exe"),
    bool = op.inValueBool("bool"),
    pease = anim.createPort(op, "easing"),
    duration = op.inValue("duration", 0.5),
    dir = op.inValueSelect("Direction", ["Animate Both", "Only True", "Only False"], "Both"),
    valueFalse = op.inValue("value false", 0),
    valueTrue = op.inValue("value true", 1),
    next = op.outTrigger("trigger"),
    value = op.outNumber("value"),
    finished = op.outBoolNum("finished"),
    finishedTrigger = op.outTrigger("Finished Trigger");

const startTime = CABLES.now();
op.toWorkPortsNeedToBeLinked(exe);
op.setPortGroup("Animation", [duration, pease]);
op.setPortGroup("Values", [valueFalse, valueTrue]);

dir.onChange = bool.onChange = valueFalse.onChange = valueTrue.onChange = duration.onChange = setAnim;
setAnim();

function setAnim()
{
    finished.set(false);
    const now = (CABLES.now() - startTime) / 1000;
    const oldValue = anim.getValue(now);
    anim.clear();

    anim.setValue(now, oldValue);

    if (!bool.get())
    {
        if (dir.get() != "Only True") anim.setValue(now + duration.get(), valueFalse.get());
        else anim.setValue(now, valueFalse.get());
    }
    else
    {
        if (dir.get() != "Only False") anim.setValue(now + duration.get(), valueTrue.get());
        else anim.setValue(now, valueTrue.get());
    }
}

exe.onTriggered = function ()
{
    const t = (CABLES.now() - startTime) / 1000;
    value.set(anim.getValue(t));

    if (anim.hasEnded(t))
    {
        if (!finished.get()) finishedTrigger.trigger();
        finished.set(true);
    }

    next.trigger();
};


};

Ops.Anim.BoolAnim.prototype = new CABLES.Op();
CABLES.OPS["06ad9d35-ccf5-4d31-889c-e23fa062588a"]={f:Ops.Anim.BoolAnim,objName:"Ops.Anim.BoolAnim"};




// **************************************************************
// 
// Ops.Anim.FrameRangeAnimSwitcher
// 
// **************************************************************

Ops.Anim.FrameRangeAnimSwitcher = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    idx = op.inValueInt("Index"),
    inDur = op.inValue("Duration", 0.5),
    resultTime1 = op.outNumber("Time 1"),
    resultFade = op.outNumber("Time Fade"),
    resultTime2 = op.outNumber("Time 2");

let anim = new CABLES.Anim();
anim.createPort(op, "easing");

let startTime = 0;
let valuePorts = [];
let oldIdx = -1;

idx.onChange = setIndex;

for (let i = 0; i < 10; i++)
{
    let p = op.inValue("Value " + i);
    valuePorts.push(p);
    p.onChange = update;
}

setIndex();

function update()
{
    if (!valuePorts[oldIdx]) return;
    if (!valuePorts[idx.get()]) return;

    resultTime1.set(valuePorts[oldIdx].get());
    resultTime2.set(valuePorts[idx.get()].get());
    let fade = anim.getValue(CABLES.now() / 1000);
    resultFade.set(fade);
}

function setIndex()
{
    let now = (CABLES.now()) / 1000;
    let startTime = now;
    anim.clear();

    if (oldIdx == -1)oldIdx = idx.get();

    anim.setValue(now, 0);
    anim.setValue(now + inDur.get(), 1,
        function ()
        {
            oldIdx = idx.get();
            let now = (CABLES.now()) / 1000;
            anim.setValue(now, 0);
        });
    update();
}


};

Ops.Anim.FrameRangeAnimSwitcher.prototype = new CABLES.Op();
CABLES.OPS["d801703b-af5f-4988-af90-39d57706c4b6"]={f:Ops.Anim.FrameRangeAnimSwitcher,objName:"Ops.Anim.FrameRangeAnimSwitcher"};




// **************************************************************
// 
// Ops.Anim.FrameRangeAnim_v2
// 
// **************************************************************

Ops.Anim.FrameRangeAnim_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inTime = op.inValue("Time");
let inStr = op.inString("Frames");
let inLoop = op.inValueBool("Loop");
let inRewind = op.inTriggerButton("Rewind");
let outValue = op.outNumber("result time");
let outArr = op.outArray("Expanded Frames");
let finished = op.outBoolNum("Finished", false);
let finishedTrigger = op.outTrigger("Finished Trigger");
let outAnimLength = op.outNumber("Anim Length");
let outProgress = op.outNumber("Progress");

let anim = new CABLES.Anim();
let FPS = 30;

let timeOffset = 0;
inStr.onChange =
inLoop.onChange = parse;

inRewind.onTriggered = function ()
{
    timeOffset = inTime.get();
};

function setupAnim(frames)
{
    anim.clear();
    anim.loop = inLoop.get();

    for (let i = 0; i < frames.length; i++)
    {
        anim.defaultEasing = CABLES.ANIM.EASING_ABSOLUTE;
        if (i < frames.length - 1)
        {
            if (frames[i + 1] == frames[i] + 1 || frames[i + 1] == frames[i] - 1)
                anim.defaultEasing = CABLES.ANIM.EASING_LINEAR;
        }

        anim.setValue(i / FPS, frames[i] / FPS);
    }
}

function parse()
{
    let str = inStr.get();
    let frames = [];
    let parts = str.split(",");

    for (let i = 0; i < parts.length; i++)
    {
        if (CABLES.UTILS.isNumeric(parts[i]))
        {
            frames.push(parseInt(parts[i], 10));
        }
        else if (parts[i].indexOf("-") > -1)
        {
            let r = parts[i].split("-");
            r[0] = parseInt(r[0], 10);
            r[1] = parseInt(r[1], 10);

            if (r[1] > r[0])
                for (var j = r[0]; j <= r[1]; j++) frames.push(j);
            else
                for (var j = r[0]; j >= r[1]; j--) frames.push(j);
        }
    }

    outArr.set(null);
    outArr.set(frames);
    outAnimLength.set(frames.length / FPS);
    setupAnim(frames);
}

inTime.onChange = function ()
{
    let t = inTime.get() - timeOffset;
    outValue.set(anim.getValue(t));

    if (anim.keys.length > 1)
    {
        let l = anim.keys[anim.keys.length - 1].time - anim.keys[0].time;
        let p = (t % l) / (l);
        if (!inLoop.get()) p = Math.min(t / l, 1);
        outProgress.set(p);
    }

    if (anim.hasEnded(t))
    {
        if (!finished.get()) finishedTrigger.trigger();
        finished.set(true);
    }
    else
    {
        finished.set(false);
    }
};


};

Ops.Anim.FrameRangeAnim_v2.prototype = new CABLES.Op();
CABLES.OPS["c0613f9e-5ddb-479e-bc90-4ffc23f97860"]={f:Ops.Anim.FrameRangeAnim_v2,objName:"Ops.Anim.FrameRangeAnim_v2"};




// **************************************************************
// 
// Ops.Anim.InOutInAnim
// 
// **************************************************************

Ops.Anim.InOutInAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const anim = new CABLES.Anim();

const
    update = op.inTrigger("Update"),
    duration1 = op.inValue("Duration Out", 0.25),
    easing1 = anim.createPort(op, "Easing Out"),
    value1 = op.inValue("Value Out", 0),
    holdDuration = op.inValue("Hold duration", 0.0),
    duration2 = op.inValue("Duration In", 0.25),
    easing2 = anim.createPort(op, "Easing In"),
    value2 = op.inValue("Value In", 1),
    trigger = op.inTriggerButton("Start"),
    next = op.outTrigger("Next"),
    outVal = op.outNumber("Result", 0),
    started = op.outTrigger("Started"),
    middle = op.outTrigger("Middle"),
    finished = op.outTrigger("finished");

let time = 0;
trigger.onTriggered = setupAnim;

update.onTriggered = function ()
{
    time = CABLES.now() / 1000.0;
    if (anim.isStarted(time)) outVal.set(anim.getValue(time));
    else outVal.set(value2.get());

    next.trigger();
};

value2.onChange = function ()
{
    outVal.set(value2.get());
};

function setupAnim()
{
    anim.clear();
    // start
    anim.setValue(time, value2.get(), function ()
    {
        started.trigger();
    });
    // attack
    anim.setValue(time +
                        duration1.get(), value1.get(), function ()
    {

    });
    // Hold
    anim.setValue(time +
                        duration1.get() + holdDuration.get(), value1.get(), function ()
    {
        middle.trigger();
    });
    // release
    anim.setValue(time +
                        duration1.get() +
                        duration2.get() + holdDuration.get(), value2.get(), function ()
    {
        finished.trigger();
    });

    anim.keys[0].setEasing(
        anim.easingFromString(easing1.get()));

    anim.keys[2].setEasing(
        anim.easingFromString(easing2.get()));
}


};

Ops.Anim.InOutInAnim.prototype = new CABLES.Op();
CABLES.OPS["ae46d30d-9ea6-417b-968b-e7b5726afdde"]={f:Ops.Anim.InOutInAnim,objName:"Ops.Anim.InOutInAnim"};




// **************************************************************
// 
// Ops.Anim.LFO
// 
// **************************************************************

Ops.Anim.LFO = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    time = op.inValue("Time"),
    type = op.inValueSelect("Type", ["sine", "triangle", "ramp up", "ramp down", "block"], "sine"),
    phase = op.inValue("Phase", 0),
    amplitude = op.inValue("Amplitude", 1),
    result = op.outNumber("Result");

let v = 0;
type.onChange = updateType;

updateType();

const PI2 = Math.PI / 2;

function updateType()
{
    if (type.get() == "sine") time.onChange = sine;
    if (type.get() == "ramp up") time.onChange = rampUp;
    if (type.get() == "ramp down") time.onChange = rampDown;
    if (type.get() == "block") time.onChange = block;
    if (type.get() == "triangle") time.onChange = triangle;
}

function updateTime()
{
    return time.get() + phase.get();
}

function block()
{
    let t = updateTime() + 0.5;
    v = t % 2.0;
    if (v <= 1.0)v = -1;
    else v = 1;
    v *= amplitude.get();
    result.set(v);
}

function rampUp()
{
    let t = (updateTime() + 1);
    t *= 0.5;
    v = t % 1.0;
    v -= 0.5;
    v *= 2.0;
    v *= amplitude.get();
    result.set(v);
}

function rampDown()
{
    let t = updateTime();
    v = t % 1.0;
    v -= 0.5;
    v *= -2.0;
    v *= amplitude.get();
    result.set(v);
}

function triangle()
{
    let t = updateTime();
    v = t % 2.0;
    if (v > 1) v = 2.0 - v;
    v -= 0.5;
    v *= 2.0;
    v *= amplitude.get();
    result.set(v);
}

function sine()
{
    let t = updateTime() * Math.PI - (PI2);
    v = Math.sin((t));
    v *= amplitude.get();
    result.set(v);
}


};

Ops.Anim.LFO.prototype = new CABLES.Op();
CABLES.OPS["559bb980-78fb-47a7-a199-16f10808b150"]={f:Ops.Anim.LFO,objName:"Ops.Anim.LFO"};




// **************************************************************
// 
// Ops.Anim.RandomAnim
// 
// **************************************************************

Ops.Anim.RandomAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),

    min = op.inValue("min", 0),
    max = op.inValue("max", 1),
    seed = op.inValue("random seed", 0),

    duration = op.inValue("duration", 0.5),
    pause = op.inValue("pause between", 0),
    next = op.outTrigger("Next"),
    result = op.outNumber("result"),
    looped = op.outTrigger("Looped");

const anim = new CABLES.Anim();
anim.createPort(op, "easing", reinit);

op.setPortGroup("Timing", [duration, pause]);
op.setPortGroup("Value", [min, max, seed]);

op.toWorkPortsNeedToBeLinked(exe);

let counter = 0;

min.onChange =
    max.onChange =
    pause.onChange =
    seed.onChange =
    duration.onChange = reinitLater;

let needsReinit = true;

function reinitLater()
{
    needsReinit = true;
}

function getRandom()
{
    const minVal = (min.get());
    return Math.seededRandom() * (max.get() - minVal) + minVal;
}

function reinit()
{
    Math.randomSeed = seed.get() + counter * 100;
    init(getRandom());
    needsReinit = false;
}

function init(v)
{
    anim.clear();

    anim.setValue(CABLES.now() / 1000.0, v);
    if (pause.get() !== 0.0) anim.setValue(CABLES.now() / 1000.0 + pause.get(), v);

    anim.setValue(duration.get() + CABLES.now() / 1000.0 + pause.get(), getRandom());
}

exe.onTriggered = updateExe;

function updateExe()
{
    if (needsReinit)reinit();

    const t = CABLES.now() / 1000.0;
    const v = anim.getValue(t);

    if (anim.hasEnded(t))
    {
        counter++;
        anim.clear();
        init(v);
        looped.trigger();
    }
    result.set(v);
    next.trigger();
}


};

Ops.Anim.RandomAnim.prototype = new CABLES.Op();
CABLES.OPS["2d2e5f0e-b69f-4789-9a48-1ee6ade5049a"]={f:Ops.Anim.RandomAnim,objName:"Ops.Anim.RandomAnim"};




// **************************************************************
// 
// Ops.Anim.SimpleAnim
// 
// **************************************************************

Ops.Anim.SimpleAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    reset = op.inTriggerButton("reset"),
    rewind = op.inTriggerButton("rewind"),
    inStart = op.inValueFloat("start", 0),
    inEnd = op.inValueFloat("end", 1),
    duration = op.inValueFloat("duration", 0.5),
    loop = op.inValueBool("loop"),
    waitForReset = op.inValueBool("Wait for Reset", true),
    next = op.outTrigger("Next"),
    result = op.outNumber("result"),
    finished = op.outNumber("finished"),
    finishedTrigger = op.outTrigger("Finished Trigger");

const anim = new CABLES.Anim();
let resetted = false;
anim.createPort(op, "easing", init);
let currentEasing = -1;
loop.onChange = init;
init();

duration.onChange = init;


function init()
{
    if (anim.keys.length != 3)
    {
        anim.setValue(0, 0);
        anim.setValue(1, 0);
        anim.setValue(2, 0);
    }

    anim.keys[0].time = CABLES.now() / 1000.0;
    anim.keys[0].value = inStart.get();
    if (anim.defaultEasing != currentEasing) anim.keys[0].setEasing(anim.defaultEasing);

    anim.keys[1].time = duration.get() + CABLES.now() / 1000.0;
    anim.keys[1].value = inEnd.get();

    if (anim.defaultEasing != currentEasing) anim.keys[1].setEasing(anim.defaultEasing);

    anim.loop = loop.get();
    if (anim.loop)
    {
        anim.keys[2].time = (2.0 * duration.get()) + CABLES.now() / 1000.0;
        anim.keys[2].value = inStart.get();
        if (anim.defaultEasing != currentEasing) anim.keys[2].setEasing(anim.defaultEasing);
    }
    else
    {
        anim.keys[2].time = anim.keys[1].time;
        anim.keys[2].value = anim.keys[1].value;
        if (anim.defaultEasing != currentEasing) anim.keys[2].setEasing(anim.defaultEasing);
    }
    finished.set(false);

    currentEasing = anim.defaultEasing;
}

reset.onTriggered = function ()
{
    resetted = true;
    init();
};

rewind.onTriggered = function ()
{
    anim.keys[0].time = CABLES.now() / 1000.0;
    anim.keys[0].value = inStart.get();

    anim.keys[1].time = CABLES.now() / 1000.0;
    anim.keys[1].value = inStart.get();

    anim.keys[2].time = CABLES.now() / 1000.0;
    anim.keys[2].value = inStart.get();

    result.set(inStart.get());
};

exe.onTriggered = function ()
{
    if (waitForReset.get() && !resetted)
    {
        result.set(inStart.get());
        return;
    }
    let t = CABLES.now() / 1000;
    let v = anim.getValue(t);
    result.set(v);
    if (anim.hasEnded(t))
    {
        if (!finished.get()) finishedTrigger.trigger();
        finished.set(true);
    }

    next.trigger();
};


};

Ops.Anim.SimpleAnim.prototype = new CABLES.Op();
CABLES.OPS["5b244b6e-c505-4743-b2cc-8119ef720028"]={f:Ops.Anim.SimpleAnim,objName:"Ops.Anim.SimpleAnim"};




// **************************************************************
// 
// Ops.Anim.SineAnim
// 
// **************************************************************

Ops.Anim.SineAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    mode = op.inSwitch("Mode", ["Sine", "Cosine"], "Sine"),
    phase = op.inValueFloat("phase", 0),
    mul = op.inValueFloat("frequency", 1),
    amplitude = op.inValueFloat("amplitude", 1),
    trigOut = op.outTrigger("Trigger out"),
    result = op.outNumber("result");

let selectIndex = 0;
const SINE = 0;
const COSINE = 1;

op.toWorkPortsNeedToBeLinked(exe);

exe.onTriggered = exec;
mode.onChange = onModeChange;

exec();
onModeChange();

function onModeChange()
{
    let modeSelectValue = mode.get();

    if (modeSelectValue === "Sine") selectIndex = SINE;
    else if (modeSelectValue === "Cosine") selectIndex = COSINE;

    exec();
}

function exec()
{
    if (selectIndex == SINE) result.set(amplitude.get() * Math.sin((op.patch.freeTimer.get() * mul.get()) + phase.get()));
    else result.set(amplitude.get() * Math.cos((op.patch.freeTimer.get() * mul.get()) + phase.get()));
    trigOut.trigger();
}


};

Ops.Anim.SineAnim.prototype = new CABLES.Op();
CABLES.OPS["736d3d0e-c920-449e-ade0-f5ca6018fb5c"]={f:Ops.Anim.SineAnim,objName:"Ops.Anim.SineAnim"};




// **************************************************************
// 
// Ops.Anim.Smooth
// 
// **************************************************************

Ops.Anim.Smooth = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Update"),
    inMode = op.inBool("Separate inc/dec", false),
    inVal = op.inValue("Value"),
    next = op.outTrigger("Next"),
    inDivisorUp = op.inValue("Inc factor", 4),
    inDivisorDown = op.inValue("Dec factor", 4),
    result = op.outNumber("Result", 0);

let val = 0;
let goal = 0;
let oldVal = 0;
let lastTrigger = 0;

op.toWorkPortsNeedToBeLinked(exec);

let divisorUp;
let divisorDown;
let divisor = 4;
let finished = true;

let selectIndex = 0;
const MODE_SINGLE = 0;
const MODE_UP_DOWN = 1;

onFilterChange();
getDivisors();

inMode.setUiAttribs({ "hidePort": true });

inDivisorUp.onChange = inDivisorDown.onChange = getDivisors;
inMode.onChange = onFilterChange;
update();

function onFilterChange()
{
    const selectedMode = inMode.get();
    if (!selectedMode) selectIndex = MODE_SINGLE;
    else selectIndex = MODE_UP_DOWN;

    if (selectIndex == MODE_SINGLE)
    {
        inDivisorDown.setUiAttribs({ "greyout": true });
        inDivisorUp.setUiAttribs({ "title": "Inc/Dec factor" });
    }
    else if (selectIndex == MODE_UP_DOWN)
    {
        inDivisorDown.setUiAttribs({ "greyout": false });
        inDivisorUp.setUiAttribs({ "title": "Inc factor" });
    }

    getDivisors();
    update();
}

function getDivisors()
{
    if (selectIndex == MODE_SINGLE)
    {
        divisorUp = inDivisorUp.get();
        divisorDown = inDivisorUp.get();
    }
    else if (selectIndex == MODE_UP_DOWN)
    {
        divisorUp = inDivisorUp.get();
        divisorDown = inDivisorDown.get();
    }

    if (divisorUp <= 0.2 || divisorUp != divisorUp)divisorUp = 0.2;
    if (divisorDown <= 0.2 || divisorDown != divisorDown)divisorDown = 0.2;
}

inVal.onChange = function ()
{
    finished = false;
    let oldGoal = goal;
    goal = inVal.get();
};

inDivisorUp.onChange = function ()
{
    getDivisors();
};

function update()
{
    let tm = 1;
    if (performance.now() - lastTrigger > 500 || lastTrigger === 0) val = inVal.get() || 0;
    else tm = (performance.now() - lastTrigger) / (performance.now() - lastTrigger);
    lastTrigger = performance.now();

    if (val != val)val = 0;

    if (divisor <= 0)divisor = 0.0001;

    const diff = goal - val;

    if (diff >= 0) val += (diff) / (divisorDown * tm);
    else val += (diff) / (divisorUp * tm);

    if (Math.abs(diff) < 0.00001)val = goal;

    if (divisor != divisor)val = 0;
    if (val != val || val == -Infinity || val == Infinity)val = inVal.get();

    if (oldVal != val)
    {
        result.set(val);
        oldVal = val;
    }

    if (val == goal && !finished)
    {
        finished = true;
        result.set(val);
    }

    next.trigger();
}

exec.onTriggered = function ()
{
    update();
};


};

Ops.Anim.Smooth.prototype = new CABLES.Op();
CABLES.OPS["5677b5b5-753a-4fbf-9e91-64c81ec68a2f"]={f:Ops.Anim.Smooth,objName:"Ops.Anim.Smooth"};




// **************************************************************
// 
// Ops.Anim.Snap
// 
// **************************************************************

Ops.Anim.Snap = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inVal = op.inValue("Delta"),

    snapVals = op.inArray("Snap at Values"),
    snapDist = op.inValue("Snap Distance"),
    snapDistRelease = op.inValue("Snap Distance Release"),
    inSlow = op.inValue("Slowdown", 0.4),
    inBlock = op.inValue("Block Input after snap"),
    inReset = op.inTriggerButton("Reset"),
    inMin = op.inValue("Min", 0),
    inMax = op.inValue("Max", 0),

    inMul = op.inValue("Value Mul", 1),
    inEnabled = op.inValueBool("Enabled", true),

    outVal = op.outNumber("Result"),
    outDist = op.outNumber("Distance"),
    outSnapped = op.outBoolNum("Snapped"),
    outWasSnapped = op.outBoolNum("was snapped");

inVal.onChange = update;
inVal.changeAlways = true;

let snapped = false;
let val = 0;
let hasError = false;
let timeout = 0;
let blocking = false;
let lastValue = -1;
let snappedArr = [];

snapVals.onChange = checkError;

inReset.onTriggered = function ()
{
    val = 0;
    outVal.set(val);
    // update();
};

function checkError()
{
    let snaps = snapVals.get();
    if (!snaps || snaps.length == 0)
    {
        op.setUiError("snapsnull", "needs array containing snap points");
        hasError = true;
        return;
    }

    if (hasError)
    {
        op.setUiError("snapsnull", null);
        hasError = false;
        setTimeout(update, 500);
    }

    snappedArr = [];
    for (let i = 0; i < snapVals.length; i++)
    {
        snappedArr[i] = false;
    }
}

function update()
{
    if (blocking) return;
    let snaps = snapVals.get();

    let d = 999999999;
    let snapvalue = 0;
    let currentIndex = -1;

    for (let i = 0; i < snaps.length; i++)
    {
        let dd = Math.abs(val - snaps[i]) + 0.01;
        if (dd < d)
        {
            d = dd;
            snapvalue = snaps[i];
            currentIndex = i;
        }

        if (val > snaps[i] && !snappedArr[i])
        {
            val = snaps[i];
            d = 0;
            currentIndex = i;
        }
    }

    if (d === 0) return;
    if (inVal.get() === 0) return;

    if (d < snapDistRelease.get())
    {
        let vv = inVal.get() * Math.abs(((d / snapDistRelease.get()) * inSlow.get())) * inMul.get();
        val += vv;

        clearTimeout(timeout);

        timeout = setTimeout(function ()
        {
            val = snapvalue;
            outVal.set(val);
        }, 250);
    }
    else
    {
        clearTimeout(timeout);
        val += inVal.get();
    }

    if (!inEnabled.get())
    {
        outVal.set(val);
        lastValue = val;
    }

    inVal.set(0);

    d = Math.abs(val - snapvalue);
    outDist.set(d);
    let wassnapped = false;

    if (d > snapDist.get())
    {
        snapped = false;
        wassnapped = false;
    }

    if (!snapped)
    {
        if (d < snapDist.get())
        {
            val = snapvalue;
            if (inBlock.get() > 0)
            {
                blocking = true;
                setTimeout(function ()
                {
                    blocking = false;
                }, inBlock.get() * 1000);
            }
            snappedArr[currentIndex] = true;
            snapped = true;
            wassnapped = true;
        }
        else
        {
            snapped = false;
        }
    }

    outSnapped.set(snapped);
    outWasSnapped.set(wassnapped);

    if (inMax.get() != inMin.get() != 0)
    {
        if (val > inMax.get())val = inMax.get();
        else if (val < inMin.get())val = inMin.get();
    }

    outVal.set(val);
    lastValue = val;
}


};

Ops.Anim.Snap.prototype = new CABLES.Op();
CABLES.OPS["7319d30d-bce2-4e66-8143-e4c0ff5a37a2"]={f:Ops.Anim.Snap,objName:"Ops.Anim.Snap"};




// **************************************************************
// 
// Ops.Anim.StringTypeAnimation_v2
// 
// **************************************************************

Ops.Anim.StringTypeAnimation_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let text = op.inStringEditor("text", "hello world");
let inRestart = op.inTriggerButton("Restart");
let speed = op.inValue("Speed", 500);
let speedVariation = op.inValueSlider("Speed Variation");
const showCursor = op.inBool("Show Cursor", true);

let outText = op.outString("Result");
let outChanged = op.outTrigger("Changed");
let outFinished = op.outTrigger("Finished");

outText.set("  \n  ");
let pos = 0;
let updateInterval = 0;
let cursorblink = true;
let finished = false;

function setNewTimeout()
{
    clearTimeout(updateInterval);
    let ms = speed.get() * (Math.random() * (speedVariation.get() * 2 - 1));
    if (text.get() && pos > text.get().length)ms = speed.get();
    updateInterval = setTimeout(update, speed.get() + ms);
}

inRestart.onTriggered = function ()
{
    finished = false;
    pos = 0;
    setNewTimeout();
};

function update()
{
    if (!text.get() || text.get() === "" || text.get() === "0" || text.get() == "0")
    {
        outText.set(" ");
        return;
    }

    let t = text.get().substring(0, pos);
    cursorblink = !cursorblink;

    if (pos > text.get().length && cursorblink)
    {
        if (showCursor.get())
        {
            // t+=' ';
            // pos++;
        }

        if (!finished)
        {
            outFinished.trigger();
            finished = true;
        }
    }
    else
    {
        finished = false;
        if (showCursor.get())
        {
            t += "_";
        }
        pos++;
    }

    outText.set(t);
    outChanged.trigger();
    setNewTimeout();
}

text.onChange = function ()
{
    finished = false;
    pos = 0;
    setNewTimeout();
    outText.set("");
};


};

Ops.Anim.StringTypeAnimation_v2.prototype = new CABLES.Op();
CABLES.OPS["66723fea-7d5f-4509-98fc-8d892a8f8d89"]={f:Ops.Anim.StringTypeAnimation_v2,objName:"Ops.Anim.StringTypeAnimation_v2"};




// **************************************************************
// 
// Ops.Anim.TimeDelta
// 
// **************************************************************

Ops.Anim.TimeDelta = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTriggerButton("exe"),
    smooth = op.inValueBool("Smooth", false),
    seconds = op.inValueBool("Seconds", false),
    trigger = op.outTrigger("trigger"),
    result = op.outNumber("result");

let lastTime = CABLES.now();
let diff = 0;
let smoothed = -1;

exe.onTriggered = function ()
{
    diff = (CABLES.now() - lastTime);
    if (seconds.get()) diff /= 1000;

    if (smooth.get())
    {
        if (smoothed == -1)smoothed = diff;
        else
        {
            smoothed = smoothed * 0.8 + diff * 0.2;
            diff = smoothed;
        }
    }

    result.set(diff);
    lastTime = CABLES.now();
    trigger.trigger();
};

exe.onTriggered();


};

Ops.Anim.TimeDelta.prototype = new CABLES.Op();
CABLES.OPS["fba0e516-b50e-4372-9a0c-dc605669ffed"]={f:Ops.Anim.TimeDelta,objName:"Ops.Anim.TimeDelta"};




// **************************************************************
// 
// Ops.Anim.Timer_v2
// 
// **************************************************************

Ops.Anim.Timer_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inSpeed = op.inValue("Speed", 1),
    playPause = op.inValueBool("Play", true),
    reset = op.inTriggerButton("Reset"),
    inSyncTimeline = op.inValueBool("Sync to timeline", false),
    outTime = op.outNumber("Time");

op.setPortGroup("Controls", [playPause, reset, inSpeed]);

const timer = new CABLES.Timer();
let lastTime = null;
let time = 0;
let syncTimeline = false;

playPause.onChange = setState;
setState();

function setState()
{
    if (playPause.get())
    {
        timer.play();
        op.patch.addOnAnimFrame(op);
    }
    else
    {
        timer.pause();
        op.patch.removeOnAnimFrame(op);
    }
}

reset.onTriggered = doReset;

function doReset()
{
    time = 0;
    lastTime = null;
    timer.setTime(0);
    outTime.set(0);
}

inSyncTimeline.onChange = function ()
{
    syncTimeline = inSyncTimeline.get();
    playPause.setUiAttribs({ "greyout": syncTimeline });
    reset.setUiAttribs({ "greyout": syncTimeline });
};

op.onAnimFrame = function (tt)
{
    if (timer.isPlaying())
    {
        if (CABLES.overwriteTime !== undefined)
        {
            outTime.set(CABLES.overwriteTime * inSpeed.get());
        }
        else

        if (syncTimeline)
        {
            outTime.set(tt * inSpeed.get());
        }
        else
        {
            timer.update();
            const timerVal = timer.get();

            if (lastTime === null)
            {
                lastTime = timerVal;
                return;
            }

            const t = Math.abs(timerVal - lastTime);
            lastTime = timerVal;

            time += t * inSpeed.get();
            if (time != time)time = 0;
            outTime.set(time);
        }
    }
};


};

Ops.Anim.Timer_v2.prototype = new CABLES.Op();
CABLES.OPS["aac7f721-208f-411a-adb3-79adae2e471a"]={f:Ops.Anim.Timer_v2,objName:"Ops.Anim.Timer_v2"};




// **************************************************************
// 
// Ops.Api.FxHash.FxHash
// 
// **************************************************************

Ops.Api.FxHash.FxHash = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
if (!CABLES.fakefxhash && !window.fxhash || CABLES.fakefxhash)
{
    CABLES.fakefxhash = true;
}

const
    isReal = !CABLES.fakefxhash,
    alphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";

const
    inHash = op.inString("Hash", ""),
    inRandomizeHash = op.inTriggerButton("Randomize Hash"),
    outHash = op.outString("fxhash"),
    outRandom1 = op.outNumber("fxrand 1"),
    outRandom2 = op.outNumber("fxrand 2"),
    outRandom3 = op.outNumber("fxrand 3"),
    outRandom4 = op.outNumber("fxrand 4"),
    outArr = op.outArray("Random Numbers"),
    outEmbedded = op.outBoolNum("fxhash environment", isReal);

inHash.onChange = init;

let inited = false;

init();

inRandomizeHash.onTriggered = () =>
{
    inHash.set(randomHash());
    op.refreshParams();
};

function randomHash()
{
    let str = "";
    const all = alphabet.length - 1;

    for (let i = 0; i < 51; i++)
    {
        str += alphabet[Math.round(Math.random() * all)];
    }
    return str;
}

function init()
{
    if (isReal && inited) return;
    if (!isReal)
    {
        window.fxhash = inHash.get() || randomHash();
        let b58dec = (str) => [...str].reduce((p, c) => p * alphabet.length + alphabet.indexOf(c) | 0, 0);
        let fxhashTrunc = fxhash.slice(2);
        let regex = new RegExp(".{" + ((fxhash.length / 4) | 0) + "}", "g");
        let hashes = fxhashTrunc.match(regex).map((h) => b58dec(h));

        let sfc32 = (a, b, c, d) =>
            () =>
            {
                a |= 0; b |= 0; c |= 0; d |= 0;
                let t = (a + b | 0) + d | 0;
                d = d + 1 | 0;
                a = b ^ b >>> 9;
                b = c + (c << 3) | 0;
                c = c << 21 | c >>> 11;
                c = c + t | 0;
                return (t >>> 0) / 4294967296;
            };

        window.fxrand = sfc32(...hashes);
    }

    inited = true;

    outHash.set(window.fxhash);

    outRandom1.set(0);
    outRandom2.set(0);
    outRandom3.set(0);
    outRandom4.set(0);

    outRandom1.set(fxrand());
    outRandom2.set(fxrand());
    outRandom3.set(fxrand());
    outRandom4.set(fxrand());

    const arr = [];
    for (let i = 0; i < 1000; i++)arr.push(fxrand());
    outArr.set(arr);
}


};

Ops.Api.FxHash.FxHash.prototype = new CABLES.Op();
CABLES.OPS["090355fe-6ad9-457c-8192-9e306a9fe1eb"]={f:Ops.Api.FxHash.FxHash,objName:"Ops.Api.FxHash.FxHash"};




// **************************************************************
// 
// Ops.Api.SoundCloud.SoundCloud_v2
// 
// **************************************************************

Ops.Api.SoundCloud.SoundCloud_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    soundCloudUrl = op.inString("SoundCloud URL"),
    clientId = op.inString("SoundCloud Client Id", "6f693b837b47b59a17403e79bcff3626"),
    clientSecret = op.inString("SoundCloud Client Secret", "efdeff51dee9e7357e2a4394b49d340a"),
    streamFormats = op.inDropDown("Formats", []),
    streamUrl = op.outString("Stream URL"),
    artworkUrl = op.outString("Artwork URL"),
    title = op.outString("Title"),
    result = op.outObject("Result");

streamUrl.ignoreValueSerialize = true;
artworkUrl.ignoreValueSerialize = true;
streamUrl.ignoreValueSerialize = true;
title.ignoreValueSerialize = true;
soundCloudUrl.onChange = streamFormats.onChange = resolve;

let accessToken = null;

const fetchData = (token) =>
{
    op.setUiError("error", null);

    const baseUrl = "https://api.soundcloud.com";
    const resolveUrl = baseUrl + "/resolve.json?url=" + soundCloudUrl.get();
    fetch(resolveUrl, {
        "headers": {
            "Authorization": "OAuth " + token
        }
    }).then((response) => { return response.json(); }).then((data) =>
    {
        const trackUrl = baseUrl + "/tracks/" + data.id + "/streams";
        fetch(trackUrl, {
            "headers": {
                "Authorization": "OAuth " + token
            }
        }).then((response) => { return response.json(); }).then((trackData) =>
        {
            const availableFormats = Object.keys(trackData);
            streamFormats.setUiAttribs({ "values": availableFormats });
            let formatUrl = trackData[availableFormats[0]];
            if (streamFormats.get() && trackData.hasOwnProperty(streamFormats.get()))
            {
                formatUrl = trackData[streamFormats.get()];
            }
            try
            {
                streamUrl.set(formatUrl);
                artworkUrl.set(data.artwork_url);
                title.set(data.title);
                result.set(data);
            }
            catch (e)
            {
                op.setUiError("error", "failed to load track from soundcloud");
                op.logError(e);
            }
        });
    });
};

function resolve()
{
    op.setUiError("credentials", null);
    if (!clientId.get() || !clientSecret.get())
    {
        op.setUiError("credentials", "SoundClound credentials missing - provide client id and secret");
    }
    if (soundCloudUrl.get())
    {
        fetch("https://api.soundcloud.com/oauth2/token", {
            "method": "POST",
            "headers": {
                "Content-Type": "application/x-www-form-urlencoded"
            },
            "body": new URLSearchParams({
                "client_id": clientId.get(),
                "client_secret": clientSecret.get(),
                "grant_type": "client_credentials"
            })
        }).then((response) => { return response.json(); }).then((data) =>
        {
            const newToken = data.access_token;
            accessToken = newToken;
            fetchData(newToken);
        });
    }
}


};

Ops.Api.SoundCloud.SoundCloud_v2.prototype = new CABLES.Op();
CABLES.OPS["1b6b0679-4f26-4886-af31-ee696936ea8f"]={f:Ops.Api.SoundCloud.SoundCloud_v2,objName:"Ops.Api.SoundCloud.SoundCloud_v2"};




// **************************************************************
// 
// Ops.Array.AnglesBetweenPoints
// 
// **************************************************************

Ops.Array.AnglesBetweenPoints = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Points"),
    inTheta = op.inFloat("Theta", 0),
    inPhi = op.inFloat("Phi", 0),
    outArr = op.outArray("Rotations");

let q = quat.create();

inTheta.onChange =
inPhi.onChange =
inArr.onChange = () =>
{
    const arr = inArr.get();
    const result = [];

    if (!arr || arr.length == 0)
    {
        outArr.set(null);
        return;
    }

    let vUp = vec3.create();

    let qprev = quat.create();
    let prevqs = [];

    for (let i = 0; i < arr.length - 3; i += 3)
    {
        let va = [arr[i + 0], arr[i + 1], arr[i + 2]];
        let vb = [arr[i + 3 + 0], arr[i + 3 + 1], arr[i + 3 + 2]];

        const
            x = vb[0] - va[0],
            y = vb[1] - va[1],
            z = vb[2] - va[2],
            r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2)),
            theta = Math.acos(y / r) * (180 / Math.PI) + inTheta.get(),
            phi = Math.atan2(x, z) * (180 / Math.PI) + inPhi.get();

        result.push(phi, -theta, 0);
        // beamContainer.transform.rotation = Quaternion.Euler(-90 + phi, -theta, 0f);

        /// ///////////////////////////

        // vec3.set(vb,
        //     vb[0] - va[0],
        //     vb[1] - va[1],
        //     vb[2] - va[2]);

        // vec3.normalize(vb, vb);

        // vec3.copy(va,vUp);

        // quat.rotationTo(q, va, vb);

        // result.push(q[0],q[1],q[2],q[3]);
    }

    outArr.set(null);
    outArr.set(result);
};


};

Ops.Array.AnglesBetweenPoints.prototype = new CABLES.Op();
CABLES.OPS["0d9eb214-c1a2-4ef5-8bcb-79b89fcfba57"]={f:Ops.Array.AnglesBetweenPoints,objName:"Ops.Array.AnglesBetweenPoints"};




// **************************************************************
// 
// Ops.Array.AnimArray_v2
// 
// **************************************************************

Ops.Array.AnimArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrigger = op.inTrigger("Update"),
    inArr = op.inArray("Next Array"),
    inDur = op.inFloat("Duration", 1),
    next = op.outTrigger("Next"),
    outArr = op.outArray("Matrix");

let lastTime = 0;
let startTime = 0;
let firsttime = true;
let cycle = 1;

const anim = new CABLES.Anim();
anim.createPort(op, "easing", init);
anim.loop = false;

let lastArr = null;

inDur.onChange = inArr.onChange = init;

let arr1, arr2;
let result = [];

inTrigger.onTriggered = () =>
{
    let t = CABLES.now() / 1000;
    const perc = anim.getValue(t);
    if (arr1 && arr2) ipMat(perc);
};

inArr.onLinkChanged = () =>
{
    if (inArr) inArr.copyLinkedUiAttrib("stride", outArr);
};

function copyArray(a)
{
    let b = [];
    b.length = a.length;
    for (let i = 0; i < a.length; i++) b[i] = a[i];
    return b;
}

function init()
{
    if (!inArr.get()) return;

    // if (inArr.get() == lastArr) return; // cant dothat, then changes in array ref are not working...
    // if (lastArr)
    //     if (inArr.get() == lastArr)
    //         return;

    lastArr = inArr.get();
    startTime = performance.now();
    anim.clear(CABLES.now() / 1000.0);

    anim.setValue(CABLES.now() / 1000.0, cycle);

    if (cycle == 1) cycle = 0;
    else cycle = 1;

    if (result.length != lastArr.length)result = copyArray(lastArr);

    if (cycle == 0)
    {
        arr1 = inArr.get();
        arr2 = copyArray(result);
    }
    else
    {
        arr1 = copyArray(result);
        arr2 = inArr.get();
    }

    anim.setValue(inDur.get() + CABLES.now() / 1000.0, cycle);

    firsttime = false;
}

function ip(val1, val2, perc)
{
    return ((val2 - val1) * perc + val1);
}

function ipMat(perc)
{
    if (!arr1 || !arr2 || arr1.length != arr2.length)
    {
        outArr.set(null);
        op.logError("arrays wrong", arr1.length, arr2.length);
    }
    else
    {
        for (let i = 0; i < arr1.length; i++)
        {
            result[i] = ip(arr1[i], arr2[i], perc);
        }

        outArr.set(null);
        outArr.set(result);
    }
    next.trigger();
}


};

Ops.Array.AnimArray_v2.prototype = new CABLES.Op();
CABLES.OPS["048e852b-62ea-4314-b6f2-9ac5e7cbb066"]={f:Ops.Array.AnimArray_v2,objName:"Ops.Array.AnimArray_v2"};




// **************************************************************
// 
// Ops.Array.Array1To3
// 
// **************************************************************

Ops.Array.Array1To3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArr = op.inArray("Array1x"),
    outArr = op.outArray("Array3x", null, 3),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

let arr = [];

inArr.onChange = function ()
{
    let theArray = inArr.get();
    if (!theArray)
    {
        outArr.set(null);
        outTotalPoints.set(0);
        outArrayLength.set(0);
        return;
    }

    if ((theArray.length) * 3 != arr.length)
    {
        arr.length = (theArray.length) * 3;
    }

    for (let i = 0; i < theArray.length; i++)
    {
        arr[i * 3 + 0] = i;
        arr[i * 3 + 1] = theArray[i];
        arr[i * 3 + 2] = 0;
    }

    outArr.set(null);
    outArr.set(arr);
    outTotalPoints.set(arr.length / 3);
    outArrayLength.set(arr.length);
};


};

Ops.Array.Array1To3.prototype = new CABLES.Op();
CABLES.OPS["0d67fdf1-8e60-465e-9897-6aae6676e4c9"]={f:Ops.Array.Array1To3,objName:"Ops.Array.Array1To3"};




// **************************************************************
// 
// Ops.Array.Array1toX
// 
// **************************************************************

Ops.Array.Array1toX = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array1x"),
    format = op.inSwitch("Format", ["AB", "ABC", "ABCD"], "ABC"),
    axisA = op.inSwitch("A", ["Input", "index", "0-1", "-1-1", "0", "1"], "Input"),
    axisB = op.inSwitch("B", ["Input", "index", "0-1", "-1-1", "0", "1"], "0-1"),
    axisC = op.inSwitch("C", ["Input", "index", "0-1", "-1-1", "0", "1"], "0"),
    axisD = op.inSwitch("D", ["Input", "index", "0-1", "-1-1", "0", "1"], "0"),
    outArr = op.outArray("Array3x"),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

const arr = [];

axisA.onChange =
axisB.onChange =
axisC.onChange =
axisD.onChange =
inArr.onChange = update;

format.onChange = function ()
{
    axisC.setUiAttribs({ "greyout": format.get().length < 3 });
    axisD.setUiAttribs({ "greyout": format.get().length < 4 });

    update();
};

function fillArr_0(off, num, stride)
{
    for (let i = 0; i < num; i += stride)
    {
        arr[i + off] = 0;
    }
}

function fillArr_1(off, num, stride)
{
    for (let i = 0; i < num; i += stride)
    {
        arr[i + off] = 1;
    }
}

function fillArr_input(off, num, stride)
{
    const theArray = inArr.get();
    for (let i = 0; i < num; i += stride)
    {
        arr[i + off] = theArray[i / stride];
    }
}

function fillArr_01(off, num, stride)
{
    for (let i = 0; i < num; i += stride)
    {
        arr[i + off] = (i / (num)) || 0;
    }
}

function fillArr_index(off, num, stride)
{
    for (let i = 0; i < num; i += stride)
    {
        arr[i + off] = i / stride;
    }
}

function fillArr(off, meth, stride)
{
    if (meth == "0")fillArr_0(off, arr.length, stride);
    if (meth == "0-1")fillArr_01(off, arr.length, stride);
    if (meth == "1")fillArr_1(off, arr.length, stride);
    if (meth == "Input")fillArr_input(off, arr.length, stride);
    if (meth == "index")fillArr_index(off, arr.length, stride);
}

function update()
{
    const theArray = inArr.get();
    if (!theArray)
    {
        outArr.set(null);
        outTotalPoints.set(0);
        outArrayLength.set(0);
        return;
    }

    const stride = format.get().length;
    const l = theArray.length * stride;
    arr.length = l;

    if (stride >= 2) fillArr(0, axisA.get(), stride);
    if (stride >= 2) fillArr(1, axisB.get(), stride);
    if (stride >= 3) fillArr(2, axisC.get(), stride);
    if (stride >= 4) fillArr(3, axisD.get(), stride);

    // for(var i=0;i<theArray.length;i++)
    // {
    //     arr[i*3+0]=i;
    //     arr[i*3+1]=theArray[i];
    //     arr[i*3+2]=0;
    // }

    outArr.set(null);
    outArr.set(arr);
    outTotalPoints.set(arr.length / stride);
    outArrayLength.set(arr.length);
}


};

Ops.Array.Array1toX.prototype = new CABLES.Op();
CABLES.OPS["6a8947be-79c8-4998-9853-1e0912654800"]={f:Ops.Array.Array1toX,objName:"Ops.Array.Array1toX"};




// **************************************************************
// 
// Ops.Array.Array2To3
// 
// **************************************************************

Ops.Array.Array2To3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array2x", 2),
    outArr = op.outArray("Array3x", 3),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

let arr = [];
let showingError = false;

inArr.onChange = function ()
{
    let theArray = inArr.get();
    if (!theArray)
    {
        outArr.set(null);
        return;
    }

    if (theArray.length % 2 != 0)
    {
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays length not divisible by 2e !" });
            showingError = true;
        }
        outArr.set(null);
        outTotalPoints.set(0);
        outArrayLength.set(0);
        return;
    }
    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    if ((theArray.length / 2) * 3 != arr.length)
    {
        arr.length = (theArray.length / 2) * 3;
    }

    for (let i = 0; i < theArray.length / 2; i++)
    {
        arr[i * 3 + 0] = theArray[i * 2 + 0];
        arr[i * 3 + 1] = theArray[i * 2 + 1];
        arr[i * 3 + 2] = 0;
    }

    outArr.set(null);
    outArr.set(arr);
    outTotalPoints.set(arr.length / 3);
    outArrayLength.set(arr.length);
};


};

Ops.Array.Array2To3.prototype = new CABLES.Op();
CABLES.OPS["9854162e-d415-4300-a47b-173772b454e9"]={f:Ops.Array.Array2To3,objName:"Ops.Array.Array2To3"};




// **************************************************************
// 
// Ops.Array.Array3
// 
// **************************************************************

Ops.Array.Array3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNum = op.inValueInt("Num Triplets", 100),
    inX = op.inValueFloat("X", 0),
    inY = op.inValueFloat("Y", 0),
    inZ = op.inValueFloat("Z", 0),
    outArr = op.outArray("Array", null, 3),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

inNum.onChange =
    inX.onChange =
    inY.onChange =
    inZ.onChange = update;

let arr = [];
update();

function update()
{
    let num = inNum.get() * 3;

    if (num < 0)num = 0;
    if (arr.length != num) arr.length = num;

    const x = inX.get();
    const y = inY.get();
    const z = inZ.get();

    for (let i = 0; i < num; i += 3)
    {
        arr[i] = x;
        arr[i + 1] = y;
        arr[i + 2] = z;
    }

    outArr.set(null);
    outArr.set(arr);
    outTotalPoints.set(num / 3);
    outArrayLength.set(num);
}


};

Ops.Array.Array3.prototype = new CABLES.Op();
CABLES.OPS["2766606a-3ea0-4204-8613-b8950a124435"]={f:Ops.Array.Array3,objName:"Ops.Array.Array3"};




// **************************************************************
// 
// Ops.Array.Array3AreaRemove
// 
// **************************************************************

Ops.Array.Array3AreaRemove = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;

const inTrigger = op.inTrigger("In Trigger");
const inArray = op.inArray("In Array", 3);
const inMode = op.inDropDown("Mode", [
    "Sphere",
    "Box",
    "Axis X",
    "Axis Y",
    "Axis Z",
    "Axis X Infinite",
    "Axis Y Infinite",
    "Axis Z Infinite"
], "Sphere");
const inSize = op.inFloat("Size", 0);
const inInvert = op.inBool("Invert", false);


op.setPortGroup("Settings", [inMode, inSize, inInvert]);
const inPosX = op.inFloat("X", 0);
const inPosY = op.inFloat("Y", 0);
const inPosZ = op.inFloat("Z", 0);

op.setPortGroup("Position", [inPosX, inPosY, inPosZ]);

const outTrigger = op.outTrigger("Out Trigger");
const outArray = op.outArray("Out Array");
const outLength = op.outNumber("Array Length");
const outX = op.outNumber("Out X");
const outY = op.outNumber("Out Y");
const outZ = op.outNumber("Out Z");

const transVec = vec3.create();

const tempVec = vec3.create();
const rootVec = vec3.fromValues(inPosX.get(), inPosY.get(), inPosZ.get());

let parametersChanged = true;
inArray.onChange = inMode.onChange = inSize.onChange = inInvert.onChange = inPosX.onChange = inPosY.onChange = inPosZ.onChange = () =>
{
    parametersChanged = true;
};

const DISCARD_FUNCS = {
    "Sphere": (inArr) =>
    {
        const newArr = [];
        const radiusSquared = inSize.get() * inSize.get();
        let CONDITION = (a, b) => { return a > b; };
        if (inInvert.get()) CONDITION = (a, b) => { return a < b; };

        for (let i = 0, len = inArr.length / 3; i < len; i += 1)
        {
            vec3.set(tempVec, inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            const distSquared = vec3.squaredDistance(tempVec, rootVec);

            if (CONDITION(distSquared, radiusSquared))
            {
                newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
        }

        return newArr;
    },
    "Box": (inArr) =>
    {
        const size = inSize.get();
        const newArr = [];
        for (let i = 0, len = inArr.length / 3; i < len; i += 1)
        {
            vec3.set(tempVec, inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);

            if (
                Math.abs(tempVec[1] - rootVec[1]) > size
                || Math.abs(tempVec[0] - rootVec[0]) > size
                || Math.abs(tempVec[2] - rootVec[2]) > size
            )
            {
                if (!inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
            else
            {
                if (inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
        }

        return newArr;
    },
    "Axis X": (inArr) =>
    {
        const size = inSize.get();
        const newArr = [];
        for (let i = 0, len = inArr.length / 3; i < len; i += 1)
        {
            if (Math.abs(inArr[i * 3] - rootVec[0]) > size)
            {
                if (!inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
            else
            {
                if (inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
        }

        return newArr;
    },
    "Axis Y": (inArr) =>
    {
        const size = inSize.get();
        const newArr = [];
        for (let i = 0, len = inArr.length / 3; i < len; i += 1)
        {
            if (Math.abs(inArr[i * 3 + 1] - rootVec[1]) > size)
            {
                if (!inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
            else
            {
                if (inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
        }

        return newArr;
    },
    "Axis Z": (inArr) =>
    {
        const size = inSize.get();
        const newArr = [];
        for (let i = 0, len = inArr.length / 3; i < len; i += 1)
        {
            if (Math.abs(inArr[i * 3 + 2] - rootVec[2]) > size)
            {
                if (!inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
            else
            {
                if (inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
        }

        return newArr;
    },
    "Axis X Infinite": (inArr) =>
    {
        const size = inSize.get();
        const newArr = [];
        for (let i = 0, len = inArr.length / 3; i < len; i += 1)
        {
            if (inArr[i * 3] - rootVec[0] > size)
            {
                if (!inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
            else
            {
                if (inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
        }

        return newArr;
    },
    "Axis Y Infinite": (inArr) =>
    {
        const size = inSize.get();
        const newArr = [];
        for (let i = 0, len = inArr.length / 3; i < len; i += 1)
        {
            if (inArr[i * 3 + 1] - rootVec[1] > size)
            {
                if (!inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
            else
            {
                if (inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
        }

        return newArr;
    },
    "Axis Z Infinite": (inArr) =>
    {
        const size = inSize.get();
        const newArr = [];
        for (let i = 0, len = inArr.length / 3; i < len; i += 1)
        {
            if (inArr[i * 3 + 2] - rootVec[2] > size)
            {
                if (!inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
            else
            {
                if (inInvert.get()) newArr.push(inArr[i * 3 + 0], inArr[i * 3 + 1], inArr[i * 3 + 2]);
            }
        }

        return newArr;
    },
};

inTrigger.onTriggered = () =>
{
    const inArr = inArray.get();
    drawHelpers();


    vec3.set(transVec, inPosX.get(), inPosY.get(), inPosZ.get());
    vec3.transformMat4(rootVec, transVec, cgl.mMatrix);

    if (!inArr)
    {
        outTrigger.trigger();
        outArray.set(null);
        return;
    }

    if (parametersChanged)
    {
        const newArr = DISCARD_FUNCS[inMode.get()](inArr);

        outArray.set(null);
        outArray.set(newArr);
        outLength.set(newArr.length);

        parametersChanged = false;
    }


    outX.set(rootVec[0]);
    outY.set(rootVec[1]);
    outZ.set(rootVec[2]);
    outTrigger.trigger();
};

const HELPER_FUNCS = {
    "Sphere": () => { return CABLES.GL_MARKER.drawSphere(op, inSize.get()); },
    "Box": () => { return CABLES.GL_MARKER.drawCube(op, inSize.get(), inSize.get(), inSize.get()); },
    "Axis X": () => { return CABLES.GL_MARKER.drawCube(op, inSize.get(), 2, 2); },
    "Axis Y": () => { return CABLES.GL_MARKER.drawCube(op, 2, inSize.get(), 2); },
    "Axis Z": () => { return CABLES.GL_MARKER.drawCube(op, 2, 2, inSize.get()); },
    "Axis X Infinite": () => { return CABLES.GL_MARKER.drawCube(op, inSize.get(), 2, 2); },
    "Axis Y Infinite": () => { return CABLES.GL_MARKER.drawCube(op, 2, inSize.get(), 2); },
    "Axis Z Infinite": () => { return CABLES.GL_MARKER.drawCube(op, 2, 2, inSize.get()); },
};

function drawHelpers()
{
    if (cgl.shouldDrawHelpers(op))
    {
        gui.setTransformGizmo({ "posX": inPosX, "posY": inPosY, "posZ": inPosZ });
        cgl.pushModelMatrix();
        mat4.translate(cgl.mMatrix, cgl.mMatrix, rootVec);
        HELPER_FUNCS[inMode.get()]();
        cgl.popModelMatrix();
    }
}


};

Ops.Array.Array3AreaRemove.prototype = new CABLES.Op();
CABLES.OPS["db93f8c7-6bad-467e-b38f-333e84838d1d"]={f:Ops.Array.Array3AreaRemove,objName:"Ops.Array.Array3AreaRemove"};




// **************************************************************
// 
// Ops.Array.Array3FlipAxis
// 
// **************************************************************

Ops.Array.Array3FlipAxis = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Points", 3),
    inAxis1 = op.inSwitch("Axis 1", ["X", "Y", "Z"], "X"),
    inAxis2 = op.inSwitch("Axis 2", ["X", "Y", "Z"], "Y"),
    inAxis3 = op.inSwitch("Axis 3", ["X", "Y", "Z"], "Z"),

    inFlipX = op.inBool("Flip Order X", false),
    inFlipY = op.inBool("Flip Order Y", false),
    inFlipZ = op.inBool("Flip Order Z", false),

    result = op.outArray("Result");

const arr = [];

inArr.onChange =
inFlipX.onChange =
inFlipY.onChange =
inFlipZ.onChange =
inAxis1.onChange =
inAxis2.onChange =
inAxis3.onChange = () =>
{
    const oldArr = inArr.get();
    if (!oldArr || oldArr.length == 0)
    {
        result.set(null);
        return;
    }

    arr.length = oldArr.length;

    let len = oldArr.length;

    if (inAxis1.get() == "X") for (let i = 0; i < len; i += 3) arr[i + 0] = oldArr[i + 0];
    if (inAxis1.get() == "Y") for (let i = 0; i < len; i += 3) arr[i + 0] = oldArr[i + 1];
    if (inAxis1.get() == "Z") for (let i = 0; i < len; i += 3) arr[i + 0] = oldArr[i + 2];

    if (inAxis2.get() == "X") for (let i = 0; i < len; i += 3) arr[i + 1] = oldArr[i + 0];
    if (inAxis2.get() == "Y") for (let i = 0; i < len; i += 3) arr[i + 1] = oldArr[i + 1];
    if (inAxis2.get() == "Z") for (let i = 0; i < len; i += 3) arr[i + 1] = oldArr[i + 2];

    if (inAxis3.get() == "X") for (let i = 0; i < len; i += 3) arr[i + 2] = oldArr[i + 0];
    if (inAxis3.get() == "Y") for (let i = 0; i < len; i += 3) arr[i + 2] = oldArr[i + 1];
    if (inAxis3.get() == "Z") for (let i = 0; i < len; i += 3) arr[i + 2] = oldArr[i + 2];


    const maxi = len;

    if (inFlipX.get())
        for (let i = 0; i < len / 2; i += 3)
        {
            const temp = arr[i + 0];
            arr[i + 0] = arr[len - i];
            arr[len - i] = temp;
        }

    if (inFlipY.get())
        for (let i = 0; i < len / 2; i += 3)
        {
            const temp = arr[i + 1];
            arr[i + 1] = arr[(len - i) + 1];
            arr[(len - i) + 1] = temp;
        }


    if (inFlipZ.get())
        for (let i = 0; i < len / 2; i += 3)
        {
            const temp = arr[i + 2];
            arr[i + 2] = arr[(len - i) + 2];
            arr[(len - i) + 2] = temp;
        }


    result.set(null);
    result.set(arr);
};


};

Ops.Array.Array3FlipAxis.prototype = new CABLES.Op();
CABLES.OPS["1a9a0178-5906-423b-b8f3-0532499ba169"]={f:Ops.Array.Array3FlipAxis,objName:"Ops.Array.Array3FlipAxis"};




// **************************************************************
// 
// Ops.Array.Array3GetAverage
// 
// **************************************************************

Ops.Array.Array3GetAverage = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array", 3),
    avgX = op.outNumber("Average X"),
    avgY = op.outNumber("Average Y"),
    avgZ = op.outNumber("Average Z");

inArr.onChange = function ()
{
    let arr = inArr.get();
    if (!arr)
    {
        avgX.set(0);
        avgY.set(0);
        avgZ.set(0);
        return;
    }
    let x = 0;
    let y = 0;
    let z = 0;

    for (let i = 0; i < arr.length; i += 3)
    {
        x += arr[i + 0];
        y += arr[i + 1];
        z += arr[i + 2];
    }

    x /= arr.length / 3;
    y /= arr.length / 3;
    z /= arr.length / 3;

    avgX.set(x);
    avgY.set(y);
    avgZ.set(z);
};


};

Ops.Array.Array3GetAverage.prototype = new CABLES.Op();
CABLES.OPS["9643edc7-e479-4b26-9f7a-343cdcdc81f4"]={f:Ops.Array.Array3GetAverage,objName:"Ops.Array.Array3GetAverage"};




// **************************************************************
// 
// Ops.Array.Array3GetNumbers
// 
// **************************************************************

Ops.Array.Array3GetNumbers = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    pArr = op.inArray("Array", 3),
    pIndex = op.inValueInt("Index"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z");

pArr.onChange =
    pIndex.onChange = update;

function update()
{
    let arr = pArr.get();
    if (!arr)
    {
        outX.set(0);
        outY.set(0);
        outZ.set(0);
        return;
    }
    let ind = Math.min(arr.length - 3, pIndex.get() * 3);
    if (arr)
    {
        outX.set(arr[ind + 0]);
        outY.set(arr[ind + 1]);
        outZ.set(arr[ind + 2]);
    }
}


};

Ops.Array.Array3GetNumbers.prototype = new CABLES.Op();
CABLES.OPS["56882cc4-c40d-4dc0-bf7c-db1b5a7acad0"]={f:Ops.Array.Array3GetNumbers,objName:"Ops.Array.Array3GetNumbers"};




// **************************************************************
// 
// Ops.Array.Array3InterpolateDistributed
// 
// **************************************************************

Ops.Array.Array3InterpolateDistributed = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Update"),
    inArr1 = op.inArray("Array 1", 3),
    inArr2 = op.inArray("Array 2", 3),
    inProgress = op.inValueSlider("Progress"),
    arrOut = op.outArray("Result"),
    outArrayLength = op.outNumber("Array length");

let resultArr = [];
let indexArray = [];

inArr2.onChange = updateArr2;
inArr1.onChange = updateArr1;


function updateArr1()
{
    if (!inArr1.get())
    {
        arrOut.set(null);
        outArrayLength.set(0);
        return;
    }
    resultArr.length = inArr1.get().length;
}

function updateArr2()
{
    if (!inArr2.get())
    {
        arrOut.set(null);
        outArrayLength.set(0);
        return;
    }

    indexArray.length = Math.ceil(inArr2.get().length / 3);

    let arr2 = inArr2.get();

    for (let i = 0; i < indexArray.length; i += 3)
    {
        let index2 = Math.floor(arr2.length / 3 * Math.random());
        // indexArray[i+0]=arr2[index2*3+0];
        // indexArray[i+1]=arr2[index2*3+1];
        // indexArray[i+2]=arr2[index2*3+2];
        indexArray[i / 3] = index2 * 3;
        // indexArray[i+1]=arr2[index2*3+1];
        // indexArray[i+2]=arr2[index2*3+2];
    }

    // arrOut.set(null);
    // arrOut.set(resultArr);
    // updateArr1();
}

exec.onTriggered = function ()
{
    let perc = inProgress.get();
    let val1 = 0, val2 = 0;
    let arr1 = inArr1.get();
    let arr2 = inArr2.get();

    let l1 = 0;
    let l2 = 0;
    if (arr1)l1 = arr1.length;
    if (arr2)l2 = arr2.length;

    let l = Math.min(l1, l2);


    for (let i = 0; i < l; i += 3)
    {
        val1 = arr1[i];
        val2 = arr2[indexArray[(i / 3)]];
        resultArr[i] = ((val2 - val1) * perc + val1);

        val1 = arr1[i + 1];
        val2 = arr2[indexArray[(i / 3)] + 1];
        resultArr[i + 1] = ((val2 - val1) * perc + val1);

        val1 = arr1[i + 2];
        val2 = arr2[indexArray[(i / 3)] + 2];
        resultArr[i + 2] = ((val2 - val1) * perc + val1);
    }

    arrOut.set(null);
    arrOut.set(resultArr);
    outArrayLength.set(resultArr.length);
};


};

Ops.Array.Array3InterpolateDistributed.prototype = new CABLES.Op();
CABLES.OPS["a004a6e9-a05f-42dc-91d3-69aa88e67a87"]={f:Ops.Array.Array3InterpolateDistributed,objName:"Ops.Array.Array3InterpolateDistributed"};




// **************************************************************
// 
// Ops.Array.Array3Multiply
// 
// **************************************************************

Ops.Array.Array3Multiply = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array3x", 3),
    mulX = op.inValue("Mul X", 1),
    mulY = op.inValue("Mul Y", 1),
    mulZ = op.inValue("Mul Z", 1),
    outArr = op.outArray("Result");

let arr = [];

mulY.onChange = mulX.onChange = mulZ.onChange =
inArr.onChange = function ()
{
    let newArr = inArr.get();
    if (newArr)
    {
        if (arr.length != newArr.length)arr.length = newArr.length;

        for (let i = 0; i < newArr.length; i += 3)
        {
            arr[i + 0] = newArr[i + 0] * mulX.get();
            arr[i + 1] = newArr[i + 1] * mulY.get();
            arr[i + 2] = newArr[i + 2] * mulZ.get();
        }

        outArr.set(null);
        outArr.set(arr);
    }
    else
    {
        outArr.set(null);
    }
};


};

Ops.Array.Array3Multiply.prototype = new CABLES.Op();
CABLES.OPS["a1e4d85f-0955-4ada-819c-c597cec40365"]={f:Ops.Array.Array3Multiply,objName:"Ops.Array.Array3Multiply"};




// **************************************************************
// 
// Ops.Array.Array3PushNumbers_v2
// 
// **************************************************************

Ops.Array.Array3PushNumbers_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exePort = op.inTriggerButton('Execute'),
    inArrayPort = op.inArray('Array'),
    value1Port = op.inValue('Value 1'),
    value2Port = op.inValue('Value 2'),
    value3Port = op.inValue('Value 3'),

    inReset=op.inTriggerButton("Reset"),
    nextPort = op.outTrigger('Next'),
    outArray=op.outArray("Result Array");

const newArr=[];
exePort.onTriggered = update;


inReset.onTriggered=
inArrayPort.onChange=function()
{
    let arr=inArrayPort.get();
    if(!arr)
    {
        outArray.set([]);
        return;
    }
    newArr.length=arr.length;
    for(let i=0;i<arr.length;i++)
    {
        newArr[i]=arr[i];
    }

    outArray.set(null);
    outArray.set(newArr);
};



function update() {
    var arr = newArr;
    if(arr) {
        arr.push(value1Port.get(), value2Port.get(), value3Port.get());
        nextPort.trigger();
    }



    outArray.set(null);
    outArray.set(arr);
}


};

Ops.Array.Array3PushNumbers_v2.prototype = new CABLES.Op();
CABLES.OPS["e898374c-5651-4f43-82d5-f06c7695444b"]={f:Ops.Array.Array3PushNumbers_v2,objName:"Ops.Array.Array3PushNumbers_v2"};




// **************************************************************
// 
// Ops.Array.Array3RandomSelection
// 
// **************************************************************

Ops.Array.Array3RandomSelection = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArray = op.inArray("Array", 3),
    inNum = op.inValueInt("Elements", 10),
    inSeed = op.inValue("Seed", 1),
    result = op.outArray("Result"),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

let arr = [];
inSeed.onChange = inArray.onChange = inNum.onChange = update;

function update()
{
    if (Math.floor(inNum.get()) < 0 || !inArray.get())
    {
        result.set(null);
        outTotalPoints.set(0);
        outArrayLength.set(0);
        return;
    }

    let oldArr = inArray.get();

    arr.length = Math.floor(inNum.get() * 3);

    let nums = [];
    for (var i = 0; i < Math.max(arr.length / 3, oldArr.length / 3); i++)
        nums[i] = i % (oldArr.length / 3);

    Math.randomSeed = inSeed.get();
    nums = CABLES.shuffleArray(nums);

    for (var i = 0; i < inNum.get(); i++)
    {
        let index = nums[i] * 3;
        arr[i * 3 + 0] = oldArr[index + 0];
        arr[i * 3 + 1] = oldArr[index + 1];
        arr[i * 3 + 2] = oldArr[index + 2];
    }

    result.set(null);
    result.set(arr);
    outTotalPoints.set(arr.length / 3);
    outArrayLength.set(arr.length);
}


};

Ops.Array.Array3RandomSelection.prototype = new CABLES.Op();
CABLES.OPS["c6967443-9d2a-4d3a-8d8c-eab529f52518"]={f:Ops.Array.Array3RandomSelection,objName:"Ops.Array.Array3RandomSelection"};




// **************************************************************
// 
// Ops.Array.Array3Sum
// 
// **************************************************************

Ops.Array.Array3Sum = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array3x", 3),
    addX = op.inValue("Add X", 1),
    addY = op.inValue("Add Y", 1),
    addZ = op.inValue("Add Z", 1),
    outArr = op.outArray("Result");

outArr.setUiAttribs({ "stride": 3 });

let arr = [];

addY.onChange =
addX.onChange =
addZ.onChange =
inArr.onChange = function ()
{
    let newArr = inArr.get();
    if (newArr)
    {
        if (arr.length != newArr.length)arr.length = newArr.length;

        for (let i = 0; i < newArr.length; i += 3)
        {
            arr[i + 0] = newArr[i + 0] + addX.get();
            arr[i + 1] = newArr[i + 1] + addY.get();
            arr[i + 2] = newArr[i + 2] + addZ.get();
        }

        outArr.set(null);
        outArr.set(arr);
    }
    else
    {
        outArr.set(null);
    }
};


};

Ops.Array.Array3Sum.prototype = new CABLES.Op();
CABLES.OPS["5120ca09-6ce3-457a-afc1-79b15a06137c"]={f:Ops.Array.Array3Sum,objName:"Ops.Array.Array3Sum"};




// **************************************************************
// 
// Ops.Array.Array3To2
// 
// **************************************************************

Ops.Array.Array3To2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inArr = op.inArray("Array3x", 3);
let outArr = op.outArray("Array2x", 2);

let arr = [];

inArr.onChange = function ()
{
    let theArray = inArr.get();
    if (!theArray || (theArray.length / 3) % 1.0 != 0)
    {
        return;
    }
    if (!theArray) return;

    if ((theArray.length / 3) * 2 != arr.length)
    {
        arr.length = (theArray.length / 3) * 2;
    }

    for (let i = 0; i < theArray.length / 3; i++)
    {
        arr[i * 2 + 0] = theArray[i * 3 + 0];
        arr[i * 2 + 1] = theArray[i * 3 + 1];
    }

    outArr.set(null);
    outArr.set(arr);
};


};

Ops.Array.Array3To2.prototype = new CABLES.Op();
CABLES.OPS["c451ee12-67f4-4dc9-8fb8-7a6cc4295a4c"]={f:Ops.Array.Array3To2,objName:"Ops.Array.Array3To2"};




// **************************************************************
// 
// Ops.Array.Array3To4
// 
// **************************************************************

Ops.Array.Array3To4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array3x", 3),
    outArr = op.outArray("Array4x", 4),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

let arr = [];
let showingError = false;

inArr.onChange = function ()
{
    let theArray = inArr.get();
    if (!theArray)
    {
        outArr.set(null);
        return;
    }

    if (theArray.length % 3 != 0)
    {
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays length not divisible by 3 !" });
            showingError = true;
        }
        outArr.set(null);
        outTotalPoints.set(0);
        outArrayLength.set(0);
        return;
    }
    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    if ((theArray.length / 3) * 4 != arr.length)
    {
        arr.length = (theArray.length / 3) * 4;
    }

    for (let i = 0; i < theArray.length / 3; i++)
    {
        arr[i * 4 + 0] = theArray[i * 3 + 0];
        arr[i * 4 + 1] = theArray[i * 3 + 1];
        arr[i * 4 + 2] = theArray[i * 3 + 2];
        arr[i * 4 + 3] = 1;
    }

    outArr.set(null);
    outArr.set(arr);
    outTotalPoints.set(arr.length / 4);
    outArrayLength.set(arr.length);
};


};

Ops.Array.Array3To4.prototype = new CABLES.Op();
CABLES.OPS["91fc24d6-ecba-4f35-8986-8d13087d2370"]={f:Ops.Array.Array3To4,objName:"Ops.Array.Array3To4"};




// **************************************************************
// 
// Ops.Array.Array3VectorDistance
// 
// **************************************************************

Ops.Array.Array3VectorDistance = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray1 = op.inArray("Array in 1", null, 3),
    inArray2 = op.inArray("Array in 2", null, 3),
    outArray = op.outArray("Array out", null, 3),
    newArr = [];

outArray.set(newArr);

let showingError = false;

inArray1.onChange = inArray2.onChange = update;
function update()
{
    let arr1 = inArray1.get();
    let arr2 = inArray2.get();

    newArr.length = 0;

    if (!arr1 || !arr2)
    {
        outArray.set(null);
        return;
    }

    if (arr1.length !== arr2.length)
        op.setUiError("arraytriple", "Arrays do not have the same length !");
    else op.setUiError("arraytriple", null);

    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    if (newArr.length != arr1.length)newArr.length = arr1.length;

    let divisibleBy3 = newArr.length % 3 === 0;
    newArr.length = Math.floor(arr1.length / 3);

    if (divisibleBy3 === false) op.setUiError("arraytriple", "Arrays length not divisible by 3 !");
    else op.setUiError("arraytriple", null);

    let vec1 = vec3.create();
    let vec2 = vec3.create();

    for (let i = 0; i < newArr.length; i++)
    {
        vec3.set(vec1,
            arr1[i * 3 + 0],
            arr1[i * 3 + 1],
            arr1[i * 3 + 2]);

        vec3.set(vec2,
            arr2[i * 3 + 0],
            arr2[i * 3 + 1],
            arr2[i * 3 + 2]);

        newArr[i] = vec3.distance(vec1, vec2);
    }

    outArray.set(null);
    outArray.set(newArr);
}


};

Ops.Array.Array3VectorDistance.prototype = new CABLES.Op();
CABLES.OPS["d8f245ef-4639-4c76-aa87-b9101f666d9e"]={f:Ops.Array.Array3VectorDistance,objName:"Ops.Array.Array3VectorDistance"};




// **************************************************************
// 
// Ops.Array.Array3VectorLength
// 
// **************************************************************

Ops.Array.Array3VectorLength = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array in", 3),
    outArray = op.outArray("Array out"),
    outArrayLength = op.outNumber("Array lengths"),
    newArr = [];

outArray.set(newArr);

let showingError = false;

inArray.onChange =
inArray.onChange = function ()
{
    let arr = inArray.get();

    if (!arr)
    {
        outArray.set(null);
        return;
    }

    if (newArr.length != arr.length)newArr.length = arr.length;

    newArr.length = Math.floor(arr.length / 3);

    if (arr.length % 3 !== 0)
    {
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays length not divisible by 3 !" });
            showingError = true;
        }
        return;
    }

    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    let vec = vec3.create();

    for (let i = 0; i < newArr.length; i++)
    {
        // get xyz components place into a vec3
        vec3.set(vec, arr[i * 3 + 0], arr[i * 3 + 1], arr[i * 3 + 2]);
        // get length of vector and place into array- note single number !
        newArr[i] = vec3.len(vec);
    }

    outArray.set(null);
    outArray.set(newArr);
    outArrayLength.set(newArr.length);
};


};

Ops.Array.Array3VectorLength.prototype = new CABLES.Op();
CABLES.OPS["2218a974-c3d0-4fcb-9689-3113914edb8e"]={f:Ops.Array.Array3VectorLength,objName:"Ops.Array.Array3VectorLength"};




// **************************************************************
// 
// Ops.Array.Array4toArray3
// 
// **************************************************************

Ops.Array.Array4toArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array", 4),
    result = op.outArray("Result", 3),
    outArrayLength = op.outNumber("Array length");

let arr = [];
inArr.onChange = function ()
{
    let ia = inArr.get();
    if (!ia)
    {
        result.set([]);
        outArrayLength.set(0);
        return;
    }

    arr.length = ia.length / 4 * 3;

    for (let i = 0; i < ia.length; i += 4)
    {
        let ind = (i / 4) * 3;
        arr[ind + 0] = ia[i];
        arr[ind + 1] = ia[i + 1];
        arr[ind + 2] = ia[i + 2];
    }

    result.set(null);
    result.set(arr);
    outArrayLength.set(arr.length);
};


};

Ops.Array.Array4toArray3.prototype = new CABLES.Op();
CABLES.OPS["a3315052-fd88-43c8-94c1-ebae0be05848"]={f:Ops.Array.Array4toArray3,objName:"Ops.Array.Array4toArray3"};




// **************************************************************
// 
// Ops.Array.ArrayAbs
// 
// **************************************************************

Ops.Array.ArrayAbs = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inArray = op.inArray("In");
let outArray = op.outArray("Result");

let newArr = [];
outArray.set(newArr);

inArray.onChange = function ()
{
    let arr = inArray.get();

    if (!arr) return;

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.abs(arr[i]);
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayAbs.prototype = new CABLES.Op();
CABLES.OPS["f3629406-f393-4b2d-970e-cf47a0c5ca75"]={f:Ops.Array.ArrayAbs,objName:"Ops.Array.ArrayAbs"};




// **************************************************************
// 
// Ops.Array.ArrayAppendArray
// 
// **************************************************************

Ops.Array.ArrayAppendArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTriggerButton("Join"),
    inArr = op.inArray("Array"),
    inReset = op.inTriggerButton("Reset"),
    outArr = op.outArray("Result"),
    outArrayLength = op.outNumber("Array length");

let arr = [];
outArr.set(arr);

inReset.onTriggered = function ()
{
    outArr.set(null);
    outArrayLength.set(0);
    arr.length = 0;
};

exec.onTriggered = function ()
{
    let newArray = inArr.get();
    if (Array.isArray(newArray))
    {
        arr = arr.concat(newArray);
        outArr.set(null);
        outArr.set(arr);
        outArrayLength.set(arr.length);
    }
};


};

Ops.Array.ArrayAppendArray.prototype = new CABLES.Op();
CABLES.OPS["c2bbf5a7-0e98-416b-aadf-49d09242821c"]={f:Ops.Array.ArrayAppendArray,objName:"Ops.Array.ArrayAppendArray"};




// **************************************************************
// 
// Ops.Array.ArrayBuffer
// 
// **************************************************************

Ops.Array.ArrayBuffer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exec = op.inTriggerButton("exec"),
    val = op.inValue("Value"),
    outTrigger = op.outTrigger("Trigger out"),
    arrOut = op.outArray("Result"),
    outArrayLength = op.outNumber("Array length");

let arr = [];

let maxLength = op.inInt("Max Length", 100);
let inReset = op.inTriggerButton("Reset");
arrOut.set(arr);

maxLength.onChange = reset;
inReset.onTriggered = reset;
reset();

function reset()
{
    arr.length = Math.abs(Math.floor(maxLength.get())) || 0;
    for (let i = 0; i < arr.length; i++) arr[i] = 0;
    arrOut.set(null);
    arrOut.set(arr);
    outArrayLength.set(0);
}

exec.onTriggered = function ()
{
    for (let i = 1; i < arr.length; i++)arr[i - 1] = arr[i];
    arr[arr.length - 1] = val.get();
    arrOut.set(null);
    arrOut.set(arr);
    outArrayLength.set(arr.length);
    outTrigger.trigger();
};


};

Ops.Array.ArrayBuffer.prototype = new CABLES.Op();
CABLES.OPS["332174c6-af8f-4c4a-9ea2-a0be249ecd72"]={f:Ops.Array.ArrayBuffer,objName:"Ops.Array.ArrayBuffer"};




// **************************************************************
// 
// Ops.Array.ArrayBuffer3
// 
// **************************************************************

Ops.Array.ArrayBuffer3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exec = op.inTrigger("exec"),
    maxLength = op.inValue("Max Num Elements", 100),
    valX = op.inValue("Value X"),
    valY = op.inValue("Value Y"),
    valZ = op.inValue("Value Z"),
    inReset = op.inTriggerButton("Reset"),
    outTrigger = op.outTrigger("Trigger out"),
    arrOut = op.outArray("Result"),
    outArrayLength = op.outNumber("Array length");

let arr = [];
let wasReset = true;

arrOut.set(arr);

maxLength.onChange = reset;
inReset.onTriggered = reset;
reset();

function reset()
{
    if (maxLength === 0)
    {
        arr.set(null);
        outArrayLength.set(0);
        return;
    }
    arr.length = Math.abs(Math.floor(maxLength.get() * 3)) || 0;
    for (let i = 0; i < arr.length; i++) arr[i] = 0;

    wasReset = true;
    arrOut.set(null);
    arrOut.set(arr);
}

exec.onTriggered = function ()
{
    // if(op.instanced(exec))return;
    if (wasReset)
    {
        for (var i = 0, len = arr.length; i < len; i += 3)
        {
            arr[i + 0] = valX.get();
            arr[i + 1] = valY.get();
            arr[i + 2] = valZ.get();
        }

        wasReset = false;
    }

    for (var i = 0, len = arr.length; i < len; i++)
        arr[i - 3] = arr[i];

    // for(var i=3;i<arr.length;i++)

    arr[arr.length - 3] = valX.get();
    arr[arr.length - 2] = valY.get();
    arr[arr.length - 1] = valZ.get();
    arrOut.set(null);
    arrOut.set(arr);
    outArrayLength.set(arr.length);
    outTrigger.trigger();
};


};

Ops.Array.ArrayBuffer3.prototype = new CABLES.Op();
CABLES.OPS["156762c6-1c10-4e9b-9cca-8dbc329a82bd"]={f:Ops.Array.ArrayBuffer3,objName:"Ops.Array.ArrayBuffer3"};




// **************************************************************
// 
// Ops.Array.ArrayCeil
// 
// **************************************************************

Ops.Array.ArrayCeil = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("In"),
    outArray = op.outArray("Result");

let newArr = [];
outArray.set(newArr);

inArray.onChange = function ()
{
    let arr = inArray.get();

    if (!arr)
    {
        outArray.set(null);
        return;
    }
    if (newArr.length != arr.length) newArr.length = arr.length;

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.ceil(arr[i]);
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayCeil.prototype = new CABLES.Op();
CABLES.OPS["a21f03eb-e5a5-44e2-bc0d-a76359ed1cf1"]={f:Ops.Array.ArrayCeil,objName:"Ops.Array.ArrayCeil"};




// **************************************************************
// 
// Ops.Array.ArrayChangedTrigger
// 
// **************************************************************

Ops.Array.ArrayChangedTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr=op.inArray("Array"),
    next=op.outTrigger("Changed Trigger"),
    outArr=op.outArray("New Array");

inArr.onChange=function()
{
    outArr.set(inArr.get());
    next.trigger();

};

};

Ops.Array.ArrayChangedTrigger.prototype = new CABLES.Op();
CABLES.OPS["bb55860d-a186-4e39-9542-8d21185e7e12"]={f:Ops.Array.ArrayChangedTrigger,objName:"Ops.Array.ArrayChangedTrigger"};




// **************************************************************
// 
// Ops.Array.ArrayChunk
// 
// **************************************************************

Ops.Array.ArrayChunk = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
const inArrayPort = op.inArray("Input Array"),
    beginPort = op.inValueInt("Begin Index", 0),
    sizePort = op.inValueInt("Chunk Size", 1),
    circularPort = op.inValueBool("Circular", false),
    outArrayPort = op.outArray("Output Array"),
    outArrayLength = op.outNumber("Array length");

let newArr = [];

// functions
function setOutarray()
{
    let inArr = inArrayPort.get();
    let begin = beginPort.get();
    let size = sizePort.get();
    let circular = circularPort.get();

    if (!inArr)
    {
        outArrayPort.set(null);
        return;
    }
    if (begin < 0)
    {
        begin = 0;
    }
    if (circular && begin >= inArr.length)
    {
        begin %= inArr.length;
    }

    if (!inArr || size < 1)
    {
        outArrayPort.set(null);
        return;
    }
    let end = size + begin;

    let newLen = Math.min(inArr.length, begin + end) - begin;
    if (newLen < 0)
    {
        op.setUiError("idx", "invalid index/array length");
        newLen = 0;
    }
    else op.setUiError("idx", null);
    newLen = Math.min(newLen, size);

    if (newLen > size) newLen = inArr.length;
    newArr.length = newLen;
    for (let i = begin; i < newLen + begin; i++)
    {
        newArr[i - begin] = inArr[i];
    }

    outArrayPort.set(null);
    outArrayLength.set(newLen);
    outArrayPort.set(newArr);
}

// change listeners
inArrayPort.onChange = setOutarray;
beginPort.onChange = setOutarray;
sizePort.onChange = setOutarray;
circularPort.onChange = setOutarray;


};

Ops.Array.ArrayChunk.prototype = new CABLES.Op();
CABLES.OPS["c7ee6c6e-ca88-4c24-b289-78bb922bf5f7"]={f:Ops.Array.ArrayChunk,objName:"Ops.Array.ArrayChunk"};




// **************************************************************
// 
// Ops.Array.ArrayChunkDuplicate
// 
// **************************************************************

Ops.Array.ArrayChunkDuplicate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr=op.inArray("Array"),
    inChunks=op.inInt("Chunk Size",3),
    inRepeats=op.inInt("Repeats",10),
    outArr=op.outArray("Result");


inArr.onChange=
inChunks.onChange=
inRepeats.onChange=()=>
{
    let chu=inChunks.get();
    let reps=inRepeats.get();
    let arr=inArr.get();

    if(!arr)return;
    if(chu<=0)return;
    if(chu<=0)return;

    let rArr=[];
    let count=0;

    for(let i=0;i<arr.length;i+=chu)
    {
        for(let r=0;r<reps;r++)
        {
            for(let c=0;c<chu;c++)
            {
                rArr[count]=arr[i+c];
                count++;
            }
        }
    }

    outArr.set(null);
    outArr.set(rArr);
};

};

Ops.Array.ArrayChunkDuplicate.prototype = new CABLES.Op();
CABLES.OPS["a3425fda-2c3c-42a4-b943-122d0a9b3c7e"]={f:Ops.Array.ArrayChunkDuplicate,objName:"Ops.Array.ArrayChunkDuplicate"};




// **************************************************************
// 
// Ops.Array.ArrayClamp
// 
// **************************************************************

Ops.Array.ArrayClamp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArray = op.inArray("Array In"),
    inMinValue = op.inFloat("Min", 0.0),
    inMaxValue = op.inFloat("Max", 1.0),
    outArray = op.outArray("Array Out");

let newArr = [];
outArray.set(newArr);
inArray.onChange = inMinValue.onChange = inMaxValue.onChange = function ()
{
    const arr = inArray.get();
    if (!arr) return;

    const inMin = inMinValue.get();
    const inMax = inMaxValue.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.min(Math.max(arr[i], inMin), inMax);
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayClamp.prototype = new CABLES.Op();
CABLES.OPS["29ff1261-5dfb-4628-893d-288bcefddc97"]={f:Ops.Array.ArrayClamp,objName:"Ops.Array.ArrayClamp"};




// **************************************************************
// 
// Ops.Array.ArrayContains_v2
// 
// **************************************************************

Ops.Array.ArrayContains_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr=op.inArray("Array"),
    inValue=op.inFloat("SearchValue"),
    outFound=op.outBool("Found",false),
    outIndex=op.outNumber("Index",-1);

inValue.onChange=
    inArr.onChange=exec;

function exec()
{
    if(inArr.get())
    {
        const index=inArr.get().indexOf(inValue.get());

        outIndex.set(index);
        outFound.set(index>-1);
    }
}

};

Ops.Array.ArrayContains_v2.prototype = new CABLES.Op();
CABLES.OPS["b982d7e3-c9cf-41dd-aead-66daad785fa8"]={f:Ops.Array.ArrayContains_v2,objName:"Ops.Array.ArrayContains_v2"};




// **************************************************************
// 
// Ops.Array.ArrayDivide
// 
// **************************************************************

Ops.Array.ArrayDivide = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inArray = op.inArray("Array In");
let inValue = op.inValue("Value", 1.0);
let outArray = op.outArray("Array Out");

let newArr = [];
outArray.set(newArr);
inArray.onChange = inValue.onChange = inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let divide = inValue.get();

    if (newArr.length != arr.length) newArr.length = arr.length;

    let i = 0;
    for (i = 0; i < arr.length; i++)
    {
        newArr[i] = arr[i] / divide;
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayDivide.prototype = new CABLES.Op();
CABLES.OPS["e9406477-1f1c-4cf3-8a64-f6009df05c7c"]={f:Ops.Array.ArrayDivide,objName:"Ops.Array.ArrayDivide"};




// **************************************************************
// 
// Ops.Array.ArrayFloor
// 
// **************************************************************

Ops.Array.ArrayFloor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray=op.inArray("In"),
    outArray=op.outArray("Result"),
    newArr=[];

outArray.set(newArr);

inArray.onChange=function()
{
    var arr=inArray.get();

    if(!arr)
    {
        outArray.set(null);
        return;
    }

    if(newArr.length!=arr.length)newArr.length=arr.length;

    for(var i=0;i<arr.length;i++)
    {
        newArr[i] = Math.floor(arr[i]);
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayFloor.prototype = new CABLES.Op();
CABLES.OPS["6ddbb878-5c95-4e4d-a068-760ff5bcf1f6"]={f:Ops.Array.ArrayFloor,objName:"Ops.Array.ArrayFloor"};




// **************************************************************
// 
// Ops.Array.ArrayFract
// 
// **************************************************************

Ops.Array.ArrayFract = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// returns the fractional remainder from array values
const inArray = op.inArray("In"),
    outArray = op.outArray("Result");

let newArr = [];
outArray.set(newArr);

inArray.onChange = function ()
{
    let arr = inArray.get();

    if (!arr)
    {
        outArray.set(null);
        return;
    }

    if (newArr.length != arr.length) newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.abs(arr[i]) % 1;
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayFract.prototype = new CABLES.Op();
CABLES.OPS["c23dcb59-a533-4c41-8d26-82ecbdd3c558"]={f:Ops.Array.ArrayFract,objName:"Ops.Array.ArrayFract"};




// **************************************************************
// 
// Ops.Array.ArrayFromNumbers
// 
// **************************************************************

Ops.Array.ArrayFromNumbers = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpdate = op.inTrigger("Update"),
    inLimit = op.inInt("Limit", 30),
    inSlider = op.inBool("Slider", false),
    next = op.outTrigger("Next"),
    outArr = op.outArray("Array");

const inPorts = [];
for (let i = 0; i < 30; i++)
{
    const inp = op.inFloat("Index " + i, 0);
    inPorts.push(inp);
}

const arr = [];
let to = null;

inUpdate.onTriggered = update;

inSlider.onChange = () =>
{
    const l = inLimit.get();

    for (let i = 0; i < inPorts.length; i++)
        if (inSlider.get()) inPorts[i].setUiAttribs({ "display": "range" });
        else inPorts[i].setUiAttribs({ "display": null });

    op.refreshParams();
};

inLimit.onChange = () =>
{
    clearTimeout(to);

    to = setTimeout(() =>
    {
        const l = inLimit.get();
        for (let i = 0; i < inPorts.length; i++)
        {
            inPorts[i].setUiAttribs({ "greyout": i >= l });
        }
    }, 300);
};

function update()
{
    const l = Math.max(0, Math.ceil(Math.min(inLimit.get(), inPorts.length)));
    arr.length = l;
    for (let i = 0; i < l; i++)
    {
        arr[i] = inPorts[i].get();
    }

    outArr.set(null);
    outArr.set(arr);
    next.trigger();
}


};

Ops.Array.ArrayFromNumbers.prototype = new CABLES.Op();
CABLES.OPS["fb698158-3cf8-49d6-805e-6ea38fdab8c1"]={f:Ops.Array.ArrayFromNumbers,objName:"Ops.Array.ArrayFromNumbers"};




// **************************************************************
// 
// Ops.Array.ArrayGetArray
// 
// **************************************************************

Ops.Array.ArrayGetArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArrays = op.inArray("Array of Arrays"),
    index = op.inValueInt("Index"),
    result = op.outArray("Result Array");

inArrays.onChange =
index.onChange = update;

function update()
{
    let theArray = inArrays.get();
    if (!theArray)
    {
        result.set(null);
        return;
    }

    let ind = Math.floor(index.get());
    if (ind < 0 || ind > theArray.length - 1)
    {
        result.set(null);
        op.log("index wrong");
        return;
    }

    result.set(null);
    result.set(theArray[ind]);
}


};

Ops.Array.ArrayGetArray.prototype = new CABLES.Op();
CABLES.OPS["b9d3f42b-3fbf-4522-9df2-a5c769a92d66"]={f:Ops.Array.ArrayGetArray,objName:"Ops.Array.ArrayGetArray"};




// **************************************************************
// 
// Ops.Array.ArrayGetNumber
// 
// **************************************************************

Ops.Array.ArrayGetNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    value = op.outNumber("value");

array.ignoreValueSerialize = true;

index.onChange = array.onChange = update;

function update()
{
    if (array.get())
    {
        let input = array.get()[index.get()];
        if (isNaN(input))
        {
            value.set(0);
            return;
        }
        value.set(parseFloat(input));
    }
}


};

Ops.Array.ArrayGetNumber.prototype = new CABLES.Op();
CABLES.OPS["d1189078-70cf-437d-9a37-b2ebe89acdaf"]={f:Ops.Array.ArrayGetNumber,objName:"Ops.Array.ArrayGetNumber"};




// **************************************************************
// 
// Ops.Array.ArrayGetObject
// 
// **************************************************************

Ops.Array.ArrayGetObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    value = op.outObject("value");

let last = null;

array.ignoreValueSerialize = true;
value.ignoreValueSerialize = true;

index.onChange = update;
array.onChange = update;

op.toWorkPortsNeedToBeLinked(array);

function update()
{
    if (index.get() < 0)
    {
        value.set(null);
        return;
    }

    const arr = array.get();
    if (!arr)
    {
        value.set(null);
        return;
    }

    const ind = index.get();
    if (ind >= arr.length)
    {
        value.set(null);
        return;
    }
    if (arr[ind])
    {
        value.set(null);
        value.set(arr[ind]);
        last = arr[ind];
    }
}


};

Ops.Array.ArrayGetObject.prototype = new CABLES.Op();
CABLES.OPS["44d34542-174c-47c6-b9c6-adde6fc371ac"]={f:Ops.Array.ArrayGetObject,objName:"Ops.Array.ArrayGetObject"};




// **************************************************************
// 
// Ops.Array.ArrayGetString
// 
// **************************************************************

Ops.Array.ArrayGetString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    result = op.outString("result");

array.ignoreValueSerialize = true;

index.onChange = update;

array.onChange = function ()
{
    update();
};

function update()
{
    const arr = array.get();
    if (arr) result.set(arr[index.get()]);
}


};

Ops.Array.ArrayGetString.prototype = new CABLES.Op();
CABLES.OPS["be8f16c0-0c8a-48a2-a92b-45dbf88c76c1"]={f:Ops.Array.ArrayGetString,objName:"Ops.Array.ArrayGetString"};




// **************************************************************
// 
// Ops.Array.ArrayGetTexture
// 
// **************************************************************

Ops.Array.ArrayGetTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    value = op.outTexture("value");

let last = null;

array.ignoreValueSerialize = true;
value.ignoreValueSerialize = true;

index.onChange = update;
array.onChange = update;

op.toWorkPortsNeedToBeLinked(array, value);

const emptyTex = CGL.Texture.getEmptyTexture(op.patch.cgl);

function update()
{
    if (index.get() < 0)
    {
        value.set(emptyTex);
        return;
    }

    let arr = array.get();
    if (!arr)
    {
        value.set(emptyTex);
        return;
    }

    let ind = index.get();
    if (ind >= arr.length)
    {
        value.set(emptyTex);
        return;
    }
    if (arr[ind])
    {
        value.set(emptyTex);
        value.set(arr[ind]);
        last = arr[ind];
    }
}


};

Ops.Array.ArrayGetTexture.prototype = new CABLES.Op();
CABLES.OPS["afea522b-ab72-4574-b721-5d37f5abaf77"]={f:Ops.Array.ArrayGetTexture,objName:"Ops.Array.ArrayGetTexture"};




// **************************************************************
// 
// Ops.Array.ArrayIndexBetween
// 
// **************************************************************

Ops.Array.ArrayIndexBetween = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr=op.inArray("Array"),
    inNum=op.inFloat("Value",0),
    outIndex=op.outNumber("Index");

inArr.onChange=
    inNum.onChange=update;

function update()
{
    const arr=inArr.get();

    if(!arr)
    {
        outIndex.set(-1);
        return;
    }

    const n=inNum.get();

    if(n<arr[0])return outIndex.set(0);

    for(let i=0;i<arr.length-1;i++)
    {

        if(n>arr[i] && n<arr[i+1])
        {
            outIndex.set(i+1);
            return;
        }
    }

}

};

Ops.Array.ArrayIndexBetween.prototype = new CABLES.Op();
CABLES.OPS["69faf293-140d-4a2c-ab2e-7e5577ab113d"]={f:Ops.Array.ArrayIndexBetween,objName:"Ops.Array.ArrayIndexBetween"};




// **************************************************************
// 
// Ops.Array.ArrayIndexMinMax
// 
// **************************************************************

Ops.Array.ArrayIndexMinMax = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr=op.inArray("Array"),
    outMax=op.outNumber("Max"),
    outIndexMax=op.outNumber("Index Max"),
    outMin=op.outNumber("Min"),
    outIndexMin=op.outNumber("Index Min");

inArr.onChange=
outMax.onChange=
outIndexMax.onChange=
outMin.onChange=
outIndexMin.onChange=()=>
{

    const arr=inArr.get();

    if(!arr)
    {
        outMax.set(0);
        outMin.set(0);
        return;
    }

    let min=Number.MAX_VALUE;
    let max=-Number.MAX_VALUE;
    let minIndex=-1;
    let maxIndex=-1;

    for(let i=0;i<arr.length;i++)
    {

        if(arr[i]<min)
        {
            minIndex=i;
            min=arr[i];
        }
        if(arr[i]>max)
        {
            maxIndex=i;
            max=arr[i];
        }

    }

    outMax.set(max);
    outIndexMax.set(maxIndex);
    outMin.set(min);
    outIndexMin.set(minIndex);


};

};

Ops.Array.ArrayIndexMinMax.prototype = new CABLES.Op();
CABLES.OPS["240172a6-7dde-4dcc-b862-bbe764aec3f3"]={f:Ops.Array.ArrayIndexMinMax,objName:"Ops.Array.ArrayIndexMinMax"};




// **************************************************************
// 
// Ops.Array.ArrayIteratorArray
// 
// **************************************************************

Ops.Array.ArrayIteratorArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    arr = op.inArray("array"),
    trigger = op.outTrigger("trigger"),
    idx = op.outNumber("index"),
    val = op.outArray("Result");

exe.onTriggered = function ()
{
    const theArr = arr.get();

    if (!theArr)
    {
        val.set(null);
        return;
    }

    for (let i = 0; i < theArr.length; i++)
    {
        idx.set(i);
        val.set(theArr[i]);
        trigger.trigger();
    }
};


};

Ops.Array.ArrayIteratorArray.prototype = new CABLES.Op();
CABLES.OPS["0efcd325-0ccf-452b-a87e-3c44d42f9165"]={f:Ops.Array.ArrayIteratorArray,objName:"Ops.Array.ArrayIteratorArray"};




// **************************************************************
// 
// Ops.Array.ArrayIteratorNumbers
// 
// **************************************************************

Ops.Array.ArrayIteratorNumbers = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe=op.inTrigger("exe"),
    arr=op.inArray("array"),
    trigger=op.outTrigger('trigger'),
    idx=op.addOutPort(new CABLES.Port(op,"index")),
    val=op.addOutPort(new CABLES.Port(op,"value"));

exe.onTriggered=function()
{
    if(!arr.get())return;

    for(var i=0;i<arr.get().length;i++)
    {
        idx.set(i);
        val.set(arr.get()[i]);
        trigger.trigger();
        op.patch.instancing.increment();
    }
};


};

Ops.Array.ArrayIteratorNumbers.prototype = new CABLES.Op();
CABLES.OPS["ec280011-1190-4333-9a68-adb4904fca1a"]={f:Ops.Array.ArrayIteratorNumbers,objName:"Ops.Array.ArrayIteratorNumbers"};




// **************************************************************
// 
// Ops.Array.ArrayIteratorObjects
// 
// **************************************************************

Ops.Array.ArrayIteratorObjects = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    arr = op.inArray("array"),
    trigger = op.outTrigger("trigger"),
    finished = op.outTrigger("finished"),
    idx = op.outNumber("index"),
    val = op.outObject("value");

exe.onTriggered = function ()
{
    const theArr = arr.get();
    if (!theArr) return;

    for (let i = 0; i < theArr.length; i++)
    {
        val.set(theArr[i]);
        idx.set(i);

        trigger.trigger();
    }
    finished.trigger();
};


};

Ops.Array.ArrayIteratorObjects.prototype = new CABLES.Op();
CABLES.OPS["481d2d8f-b9ee-42a0-a905-caf9dc23a63f"]={f:Ops.Array.ArrayIteratorObjects,objName:"Ops.Array.ArrayIteratorObjects"};




// **************************************************************
// 
// Ops.Array.ArrayIteratorStrings
// 
// **************************************************************

Ops.Array.ArrayIteratorStrings = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Exe"),
    arr = op.inArray("Array"),
    trigger = op.outTrigger("Trigger"),
    idx = op.outNumber("Index"),
    val = op.outString("Value");

exe.onTriggered = function ()
{
    if (!arr.get()) return;

    for (let i = 0; i < arr.get().length; i++)
    {
        idx.set(i);
        let value = null;
        if (arr.get()[i])
        {
            value = String(arr.get()[i]);
        }
        val.set(value);
        trigger.trigger();
        op.patch.instancing.increment();
    }
};


};

Ops.Array.ArrayIteratorStrings.prototype = new CABLES.Op();
CABLES.OPS["0f8ee026-e094-484d-8403-547c92293be9"]={f:Ops.Array.ArrayIteratorStrings,objName:"Ops.Array.ArrayIteratorStrings"};




// **************************************************************
// 
// Ops.Array.ArrayLength
// 
// **************************************************************

Ops.Array.ArrayLength = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    array = op.inArray("array"),
    outLength = op.outNumber("length");

outLength.ignoreValueSerialize = true;

function update()
{
    let l = 0;
    if (array.get()) l = array.get().length;
    else l = -1;
    outLength.set(l);
}

array.onChange = update;


};

Ops.Array.ArrayLength.prototype = new CABLES.Op();
CABLES.OPS["ea508405-833d-411a-86b4-1a012c135c8a"]={f:Ops.Array.ArrayLength,objName:"Ops.Array.ArrayLength"};




// **************************************************************
// 
// Ops.Array.ArrayLogic
// 
// **************************************************************

Ops.Array.ArrayLogic = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// The user can  pick a
// logical comparison which will be applied to the array.
// if it evaulates to true then it outputs 1 else 0 or defined value
// pass mode (p) allows the value from array 0 through if the
// comparison evaulates to true else its the value assigned to if false

const inArray_0 = op.inArray("array 0"),
    mathSelect = op.inValueSelect("Comparison mode", [">", "<", ">=", "<=", "==", "!=",
        ">pass", "<pass", ">=pass", "<=pass", "==pass", "!=pass"], ">"),
    numberIn = op.inValueFloat("Number for comparison", 0.5),
    inValueIfTrue = op.inFloat("value if true", 1.0),
    inValueIfFalse = op.inFloat("value if false", 0.0),
    outArray = op.outArray("Array result"),
    outArrayLength = op.outNumber("Array length");

op.toWorkPortsNeedToBeLinked(inArray_0);

let logicFunc;
let showingError = false;

let mathArray = [];
let selectIndex = 0;

mathSelect.onChange = onFilterChange;

inArray_0.onChange = numberIn.onChange = inValueIfFalse.onChange =
inValueIfTrue.onChange = update;

onFilterChange();

function onFilterChange()
{
    let mathSelectValue = mathSelect.get();
    if (mathSelectValue === ">") logicFunc = function (val, comp, t, f) { if (val > comp) return t; return f; };
    else if (mathSelectValue === "<") logicFunc = function (val, comp, t, f) { if (val < comp) return t; return f; };
    else if (mathSelectValue === ">=") logicFunc = function (val, comp, t, f) { if (val >= comp) return t; return f; };
    else if (mathSelectValue === "<=") logicFunc = function (val, comp, t, f) { if (val <= comp) return t; return f; };
    else if (mathSelectValue === "==") logicFunc = function (val, comp, t, f) { if (val === comp) return t; return f; };
    else if (mathSelectValue === "!=") logicFunc = function (val, comp, t, f) { if (val !== comp) return t; return f; };
    else if (mathSelectValue === ">pass") logicFunc = function (val, comp, t, f) { if (val > comp) return val; return f; };
    else if (mathSelectValue === "<pass") logicFunc = function (val, comp, t, f) { if (val < comp) return val; return f; };
    else if (mathSelectValue === ">=pass") logicFunc = function (val, comp, t, f) { if (val >= comp) return val; return f; };
    else if (mathSelectValue === "<=pass") logicFunc = function (val, comp, t, f) { if (val <= comp) return val; return f; };
    else if (mathSelectValue === "==pass") logicFunc = function (val, comp, t, f) { if (val === comp) return val; return f; };
    else if (mathSelectValue === "!=pass") logicFunc = function (val, comp, t, f) { if (val !== comp) return val; return f; };
    update();
    op.setUiAttrib({ "extendTitle": mathSelectValue });
}

function update()
{
    let array0 = inArray_0.get();

    let mathNumberIn = numberIn.get();
    let valueFalse = inValueIfFalse.get();
    let valueTrue = inValueIfTrue.get();

    mathArray.length = 0;

    if (!array0)
    {
        outArray.set(null);
        outArrayLength.set(0);
        return;
    }

    mathArray.length = array0.length;

    let i = 0;

    for (i = 0; i < array0.length; i++)
    {
        mathArray[i] = logicFunc(array0[i], mathNumberIn, valueTrue, valueFalse);
    }

    outArray.set(null);
    outArray.set(mathArray);
    outArrayLength.set(mathArray.length);
}


};

Ops.Array.ArrayLogic.prototype = new CABLES.Op();
CABLES.OPS["502083f2-8ade-4cb5-b1c5-e5b60eb3255f"]={f:Ops.Array.ArrayLogic,objName:"Ops.Array.ArrayLogic"};




// **************************************************************
// 
// Ops.Array.ArrayLogicArray
// 
// **************************************************************

Ops.Array.ArrayLogicArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// this op expects 2 arrays. The user can then pick a
// logical comparison which will be applied to the
// two arrays. If arrays have a different length then a warning
// is given in the panel
// pass allows the value from array 0 through if the
// comparison evaulates to true else zero

const inArray_0 = op.inArray("array 0"),
    inArray_1 = op.inArray("array 1"),
    inValueIfTrue = op.inFloat("value if true", 1.0),
    inValueIfFalse = op.inFloat("value if false", 0.0),
    mathSelect = op.inValueSelect("Comparison mode", [">", "<", ">=", "<=", "==", "!=",
        ">pass", "<pass", ">=pass", "<=pass", "==pass", "!=pass"], ">"),
    outArray = op.outArray("Array result"),
    outArrayLength = op.outNumber("Array length");

op.toWorkPortsNeedToBeLinked(inArray_1, inArray_0);

let logicFunc;
// cache for errors
let showingError = false;

// create array to store multiplied result from both arrays
let mathArray = [];
let selectIndex = 0;

mathSelect.onChange = onFilterChange;

inArray_0.onChange = inArray_1.onChange =
inValueIfTrue.onChange = inValueIfFalse.onChange = update;

onFilterChange();
function onFilterChange()
{
    let mathSelectValue = mathSelect.get();
    if (mathSelectValue === ">") logicFunc = function (val, comp, t, f) { if (val > comp) return t; return f; };
    else if (mathSelectValue === "<") logicFunc = function (val, comp, t, f) { if (val < comp) return t; return f; };
    else if (mathSelectValue === ">=") logicFunc = function (val, comp, t, f) { if (val >= comp) return t; return f; };
    else if (mathSelectValue === "<=") logicFunc = function (val, comp, t, f) { if (val <= comp) return t; return f; };
    else if (mathSelectValue === "==") logicFunc = function (val, comp, t, f) { if (val === comp) return t; return f; };
    else if (mathSelectValue === "!=") logicFunc = function (val, comp, t, f) { if (val !== comp) return t; return f; };
    else if (mathSelectValue === ">pass") logicFunc = function (val, comp, t, f) { if (val > comp) return val; return f; };
    else if (mathSelectValue === "<pass") logicFunc = function (val, comp, t, f) { if (val < comp) return val; return f; };
    else if (mathSelectValue === ">=pass") logicFunc = function (val, comp, t, f) { if (val >= comp) return val; return f; };
    else if (mathSelectValue === "<=pass") logicFunc = function (val, comp, t, f) { if (val <= comp) return val; return f; };
    else if (mathSelectValue === "==pass") logicFunc = function (val, comp, t, f) { if (val === comp) return val; return f; };
    else if (mathSelectValue === "!=pass") logicFunc = function (val, comp, t, f) { if (val !== comp) return val; return f; };

    update();
    op.setUiAttrib({ "extendTitle": mathSelectValue });
}

function update()
{
    let array0 = inArray_0.get();
    let array1 = inArray_1.get();

    let valueFalse = inValueIfFalse.get();
    let valueTrue = inValueIfTrue.get();

    mathArray.length = 0;

    if (!array0 || !array1)
    {
        outArray.set(null);
        outArrayLength.set(0);
        return;
    }

    if (array0.length !== array1.length)
    {
        outArray.set(null);
        outArrayLength.set(0);
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays do not have the same length !" });
            showingError = true;
        }
        return;
    }
    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    mathArray.length = array0.length;

    let i = 0;

    for (i = 0; i < array0.length; i++)
    {
        mathArray[i] = logicFunc(array0[i], array1[i], valueTrue, valueFalse);
    }

    outArray.set(null);
    outArray.set(mathArray);
    outArrayLength.set(mathArray.length);
}


};

Ops.Array.ArrayLogicArray.prototype = new CABLES.Op();
CABLES.OPS["850a40f5-f623-438f-9ff8-461b1a9aeefc"]={f:Ops.Array.ArrayLogicArray,objName:"Ops.Array.ArrayLogicArray"};




// **************************************************************
// 
// Ops.Array.ArrayLogicBetween_v2
// 
// **************************************************************

Ops.Array.ArrayLogicBetween_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArray = op.inArray("Array"),
    inMin = op.inFloat("Min", 0),
    inMax = op.inFloat("Max", 0.5),
    inPass = op.inBool("pass value when true", false),
    outArray = op.outArray("Result");

inArray.onChange =
inMin.onChange =
inMax.onChange =
inPass.onChange =
function update()
{
    let arr = inArray.get();
    if (!arr) return;

    let pass = inPass.get();
    const min = inMin.get();
    const max = inMax.get();

    let newArr = [];
    newArr.length = arr.length;

    if (!pass)
    {
        for (var i = 0; i < arr.length; i++)
        {
            if (arr[i] > min && arr[i] < max)
            {
                newArr[i] = 1.0;
            }
            else newArr[i] = 0.0;
        }
    }
    else
    {
        for (var i = 0; i < arr.length; i++)
        {
            if (arr[i] > min && arr[i] < max)
            {
                newArr[i] = arr[i];
            }
            else newArr[i] = 0.0;
        }
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayLogicBetween_v2.prototype = new CABLES.Op();
CABLES.OPS["c109a5d0-3338-4d7b-9dac-7c948d4663b8"]={f:Ops.Array.ArrayLogicBetween_v2,objName:"Ops.Array.ArrayLogicBetween_v2"};




// **************************************************************
// 
// Ops.Array.ArrayMath
// 
// **************************************************************

Ops.Array.ArrayMath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray_0 = op.inArray("array 0"),
    NumberIn = op.inValueFloat("Number for math", 0.0),
    mathSelect = op.inSwitch("Math function", ["+", "-", "*", "/", "%", "min", "max"], "+"),
    outArray = op.outArray("Array result"),
    outArrayLength = op.outNumber("Array length");

let mathFunc;

let showingError = false;

let mathArray = [];

inArray_0.onChange = NumberIn.onChange = update;
mathSelect.onChange = onFilterChange;

onFilterChange();

inArray_0.onLinkChanged = () =>
{
    if (inArray_0) inArray_0.copyLinkedUiAttrib("stride", outArray);
};

function onFilterChange()
{
    let mathSelectValue = mathSelect.get();

    if (mathSelectValue === "+") mathFunc = function (a, b) { return a + b; };
    else if (mathSelectValue === "-") mathFunc = function (a, b) { return a - b; };
    else if (mathSelectValue === "*") mathFunc = function (a, b) { return a * b; };
    else if (mathSelectValue === "/") mathFunc = function (a, b) { return a / b; };
    else if (mathSelectValue === "%") mathFunc = function (a, b) { return a % b; };
    else if (mathSelectValue === "min") mathFunc = function (a, b) { return Math.min(a, b); };
    else if (mathSelectValue === "max") mathFunc = function (a, b) { return Math.max(a, b); };
    update();
    op.setUiAttrib({ "extendTitle": mathSelectValue });
}

function update()
{
    let array0 = inArray_0.get();

    mathArray.length = 0;

    if (!array0)
    {
        outArrayLength.set(0);
        outArray.set(null);
        return;
    }

    let num = NumberIn.get();
    mathArray.length = array0.length;

    let i = 0;

    for (i = 0; i < array0.length; i++)
    {
        mathArray[i] = mathFunc(array0[i], num);
    }

    outArray.set(null);
    outArray.set(mathArray);
    outArrayLength.set(mathArray.length);
}


};

Ops.Array.ArrayMath.prototype = new CABLES.Op();
CABLES.OPS["c7617717-3114-452f-9625-e4fefd841e88"]={f:Ops.Array.ArrayMath,objName:"Ops.Array.ArrayMath"};




// **************************************************************
// 
// Ops.Array.ArrayMathArray
// 
// **************************************************************

Ops.Array.ArrayMathArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray_0 = op.inArray("array 0"),
    inArray_1 = op.inArray("array 1"),
    mathSelect = op.inSwitch("Math function", ["+", "-", "*", "/", "%", "min", "max"], "+"),
    outArray = op.outArray("Array result"),
    outArrayLength = op.outNumber("Array length");

let mathFunc;

let showingError = false;

const mathArray = [];

op.toWorkPortsNeedToBeLinked(inArray_1, inArray_0);

mathSelect.onChange = onFilterChange;

inArray_0.onChange = inArray_1.onChange = update;
onFilterChange();

function onFilterChange()
{
    const mathSelectValue = mathSelect.get();

    if (mathSelectValue === "+") mathFunc = function (a, b) { return a + b; };
    else if (mathSelectValue === "-") mathFunc = function (a, b) { return a - b; };
    else if (mathSelectValue === "*") mathFunc = function (a, b) { return a * b; };
    else if (mathSelectValue === "/") mathFunc = function (a, b) { return a / b; };
    else if (mathSelectValue === "%") mathFunc = function (a, b) { return a % b; };
    else if (mathSelectValue === "min") mathFunc = function (a, b) { return Math.min(a, b); };
    else if (mathSelectValue === "max") mathFunc = function (a, b) { return Math.max(a, b); };
    update();
    op.setUiAttrib({ "extendTitle": mathSelectValue });
}

function update()
{
    const array0 = inArray_0.get();
    const array1 = inArray_1.get();

    if (!array0 || !array1)
    {
        outArray.set(null);
        outArrayLength.set(0);
        return;
    }

    const l = mathArray.length = array0.length;

    for (let i = 0; i < l; i++)
    {
        mathArray[i] = mathFunc(array0[i], array1[i]);
    }

    outArray.set(null);
    outArrayLength.set(mathArray.length);
    outArray.set(mathArray);
}


};

Ops.Array.ArrayMathArray.prototype = new CABLES.Op();
CABLES.OPS["f31a1764-ce14-41de-9b3f-dc2fe249bb52"]={f:Ops.Array.ArrayMathArray,objName:"Ops.Array.ArrayMathArray"};




// **************************************************************
// 
// Ops.Array.ArrayMathExpression
// 
// **************************************************************

Ops.Array.ArrayMathExpression = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inA = op.inArray("A"),
    inB = op.inArray("B"),
    inC = op.inArray("C"),

    inX = op.inFloat("X", 1),
    inY = op.inFloat("Y", 1),
    inZ = op.inFloat("Z", 1),

    inExpression = op.inString("Expression", "a*(b+c+d)"),

    outResultArray = op.outArray("Result Array"),
    outLength = op.outNumber("Array Length"),
    outExpressionIsValid = op.outBool("Expression Valid");

op.setPortGroup("Expression", [inExpression]);
op.setPortGroup("Parameters", [inA, inB, inC, inX, inY, inZ]);

const functionChanged = false;
const inputsChanged = false;
const resultArray = [];
let currentFunction = inExpression.get();
let functionValid = false;
let showingError = false;

inA.onChange = inB.onChange = inC.onChange
    = inX.onChange = inY.onChange = inZ.onChange = evaluateFunction;
inExpression.onChange = createFunction;

function createFunction()
{
    try
    {
        currentFunction = new Function("m", "a", "b", "c", "x", "y", "z", "i", "len", `with(m) { return ${inExpression.get()} }`);
        functionValid = true;
        evaluateFunction();

        outExpressionIsValid.set(functionValid);
    }
    catch (e)
    {
        functionValid = false;

        outExpressionIsValid.set(functionValid);
        outResultArray.set(null);

        if (e instanceof ReferenceError || e instanceof SyntaxError) return;
    }
}

function evaluateFunction()
{
    const arrayA = inA.get();
    const arrayB = inB.get();
    const arrayC = inC.get();
    const arrays = [arrayA, arrayB, arrayC];

    const x = inX.get();
    const y = inY.get();
    const z = inZ.get();

    // * check if we have at least 2 arrays that are valid
    if (arrays.filter(Boolean).length === 0)
    {
        outResultArray.set(null);
        outLength.set(0);
        outResultArray.set(null);
        return;
    }
    else
    {
        const arrayLengths = arrays.map((arr) => (arr ? arr.length : undefined));
        const firstValidArrayLength = arrayLengths.find(Boolean);
        const sameLength = arrayLengths.filter(Boolean).every((length) => length === firstValidArrayLength);

        let validArrays = [];

        if (sameLength)
        {
            op.setUiError("notsamelength", null);
            const firstValidArray = arrays.find(Boolean);
            validArrays = arrays.map((arr, index) =>
            {
                // * map all undefined arrays to 0 values
                if (!arr) arr = arrays.find(Boolean).map((x) => 0);

                return arr;
            });

            resultArray.length = firstValidArray.length;

            if (functionValid)
            {
                for (let i = 0; i < firstValidArray.length; i += 1)
                {
                    resultArray[i] = currentFunction(
                        Math,
                        validArrays[0][i], validArrays[1][i], validArrays[2][i],
                        x, y, z,
                        i,
                        resultArray.length
                    );
                }

                outResultArray.set(null);
                outResultArray.set(resultArray);
                outLength.set(resultArray.length);
            }
        }
        else
        {
            outResultArray.set(null);
            outLength.set(0);
            op.setUiError("notsamelength", "Arrays do not have the same length!", 2);
            showingError = true;
        }
    }

    outExpressionIsValid.set(functionValid);
}


};

Ops.Array.ArrayMathExpression.prototype = new CABLES.Op();
CABLES.OPS["663e32a2-45a1-4141-a387-d8a44d4977d5"]={f:Ops.Array.ArrayMathExpression,objName:"Ops.Array.ArrayMathExpression"};




// **************************************************************
// 
// Ops.Array.ArrayMathExpressionTrigger
// 
// **************************************************************

Ops.Array.ArrayMathExpressionTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrigger = op.inTrigger("Update"),
    inA = op.inArray("A"),
    inB = op.inArray("B"),
    inC = op.inArray("C"),

    inX = op.inFloat("X", 1),
    inY = op.inFloat("Y", 1),
    inZ = op.inFloat("Z", 1),

    inExpression = op.inString("Expression", "a*(b+c+d)"),

    outNext = op.outTrigger("Next"),

    outResultArray = op.outArray("Result Array"),
    outLength = op.outNumber("Array Length"),
    outExpressionIsValid = op.outBool("Expression Valid");

op.setPortGroup("Expression", [inExpression]);
op.setPortGroup("Parameters", [inA, inB, inC, inX, inY, inZ]);

const functionChanged = false;
const inputsChanged = false;
const resultArray = [];
let currentFunction = inExpression.get();
let functionValid = false;
let showingError = false;
let needsupdate = true;

inA.onChange = inB.onChange = inC.onChange
    = inX.onChange = inY.onChange = inZ.onChange = () => { needsupdate = true; };

inTrigger.onTriggered = evaluateFunction;
inExpression.onChange = createFunction;

function createFunction()
{
    try
    {
        currentFunction = new Function("m", "a", "b", "c", "x", "y", "z", "i", "len", `with(m) { return ${inExpression.get()} }`);
        functionValid = true;
        evaluateFunction();

        outExpressionIsValid.set(functionValid);
    }
    catch (e)
    {
        functionValid = false;

        outExpressionIsValid.set(functionValid);
        outResultArray.set(null);

        if (e instanceof ReferenceError || e instanceof SyntaxError) return;
    }
}

function evaluateFunction()
{
    if (needsupdate)
    {
        const arrayA = inA.get();
        const arrayB = inB.get();
        const arrayC = inC.get();
        const arrays = [arrayA, arrayB, arrayC];

        const x = inX.get();
        const y = inY.get();
        const z = inZ.get();

        // * check if we have at least 2 arrays that are valid
        if (arrays.filter(Boolean).length === 0)
        {
            outResultArray.set(null);
            outLength.set(0);
            outResultArray.set(null);
            return;
        }
        else
        {
            const arrayLengths = arrays.map((arr) => (arr ? arr.length : undefined));
            const firstValidArrayLength = arrayLengths.find(Boolean);
            const sameLength = arrayLengths.filter(Boolean).every((length) => length === firstValidArrayLength);

            let validArrays = [];

            if (sameLength)
            {
                op.setUiError("notsamelength", null);
                const firstValidArray = arrays.find(Boolean);
                validArrays = arrays.map((arr, index) =>
                {
                // * map all undefined arrays to 0 values
                    if (!arr) arr = arrays.find(Boolean).map((x) => 0);

                    return arr;
                });

                resultArray.length = firstValidArray.length;

                if (functionValid)
                {
                    for (let i = 0; i < firstValidArray.length; i += 1)
                    {
                        resultArray[i] = currentFunction(
                            Math,
                            validArrays[0][i], validArrays[1][i], validArrays[2][i],
                            x, y, z,
                            i,
                            resultArray.length
                        );
                    }

                    outResultArray.set(null);
                    outResultArray.set(resultArray);
                    outLength.set(resultArray.length);
                }
            }
            else
            {
                outResultArray.set(null);
                outLength.set(0);
                op.setUiError("notsamelength", "Arrays do not have the same length!", 2);
                showingError = true;
            }
        }

        outExpressionIsValid.set(functionValid);
        needsupdate = false;
    }
    outNext.trigger();
}


};

Ops.Array.ArrayMathExpressionTrigger.prototype = new CABLES.Op();
CABLES.OPS["e0d5da32-8463-4dfb-89f5-0d755167cd49"]={f:Ops.Array.ArrayMathExpressionTrigger,objName:"Ops.Array.ArrayMathExpressionTrigger"};




// **************************************************************
// 
// Ops.Array.ArrayMax
// 
// **************************************************************

Ops.Array.ArrayMax = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array In");
const inValue = op.inValue("Value", 1.0);
const outArray = op.outArray("Array Out");

let newArr = [];
outArray.set(newArr);

inValue.onChange = inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let inMax = inValue.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    let i = 0;
    for (i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.max(arr[i], inMax);
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayMax.prototype = new CABLES.Op();
CABLES.OPS["3bf1ead6-e8d2-43dd-a631-93f7a15fc270"]={f:Ops.Array.ArrayMax,objName:"Ops.Array.ArrayMax"};




// **************************************************************
// 
// Ops.Array.ArrayMergeTrigger
// 
// **************************************************************

Ops.Array.ArrayMergeTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Merge"),
    next = op.outTrigger("Next");

const numArrays = 12;
const inArrs = [];
let needsUpdate = true;

for (let i = 0; i < numArrays; i++)
{
    inArrs[i] = op.inArray("Array " + i);
    inArrs[i].onChange = () =>
    {
        needsUpdate = true;
    };
}

const
    outArr = op.outArray("Result"),
    outArrayLength = op.outNumber("Array length");

let arr = [];

exec.onTriggered = () =>
{
    if (needsUpdate)
    {
        arr.length = 0;

        for (let i = 0; i < numArrays; i++)
        {
            const ar = inArrs[i].get();
            if (ar)arr = arr.concat(ar);
        }

        outArr.set(null);
        outArr.set(arr);
        outArrayLength.set(arr.length);
    }

    next.trigger();
};


};

Ops.Array.ArrayMergeTrigger.prototype = new CABLES.Op();
CABLES.OPS["f45fdd5e-b20a-4553-a83b-57eed8a98c80"]={f:Ops.Array.ArrayMergeTrigger,objName:"Ops.Array.ArrayMergeTrigger"};




// **************************************************************
// 
// Ops.Array.ArrayMerge_v3
// 
// **************************************************************

Ops.Array.ArrayMerge_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const numArrays = 8;
const inArrs = [];

for (let i = 0; i < numArrays; i++)
{
    inArrs[i] = op.inArray("Array " + i);
    inArrs[i].onChange = function ()
    {
        update();
    };
}

const
    outArr = op.outArray("Result"),
    outArrayLength = op.outNumber("Array length");

let arr = [];

function update()
{
    arr.length = 0;

    for (let i = 0; i < numArrays; i++)
    {
        const ar = inArrs[i].get();
        if (ar)arr = arr.concat(ar);
    }

    outArr.set(null);
    outArr.set(arr);
    outArrayLength.set(arr.length);
}


};

Ops.Array.ArrayMerge_v3.prototype = new CABLES.Op();
CABLES.OPS["753d053a-04a3-44c7-abf0-ae2676ced13e"]={f:Ops.Array.ArrayMerge_v3,objName:"Ops.Array.ArrayMerge_v3"};




// **************************************************************
// 
// Ops.Array.ArrayMin
// 
// **************************************************************

Ops.Array.ArrayMin = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array In");
const inValue = op.inValue("Value", 1.0);
const outArray = op.outArray("Array Out");

let newArr = [];
outArray.set(newArr);

inValue.onChange = inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let inMin = inValue.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    let i = 0;
    for (i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.min(arr[i], inMin);
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayMin.prototype = new CABLES.Op();
CABLES.OPS["fbb78acc-c004-4669-a277-98c47eb59598"]={f:Ops.Array.ArrayMin,objName:"Ops.Array.ArrayMin"};




// **************************************************************
// 
// Ops.Array.ArrayModulo
// 
// **************************************************************

Ops.Array.ArrayModulo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArray = op.inArray("Array In"),
    inValue = op.inValue("Value", 2.0),
    outArray = op.outArray("Array Out");

let newArr = [];
outArray.set(newArr);
inArray.onChange =
inValue.onChange = inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let modulo = inValue.get();

    if (newArr.length != arr.length) newArr.length = arr.length;

    let i = 0;
    for (i = 0; i < arr.length; i++)
    {
        newArr[i] = arr[i] % modulo;
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayModulo.prototype = new CABLES.Op();
CABLES.OPS["30a5568b-31da-4504-9525-578ee404993c"]={f:Ops.Array.ArrayModulo,objName:"Ops.Array.ArrayModulo"};




// **************************************************************
// 
// Ops.Array.ArrayMultiply
// 
// **************************************************************

Ops.Array.ArrayMultiply = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArray = op.inArray("In"),
    inValue = op.inValue("Value", 1.0),
    outArray = op.outArray("Result");

let newArr = [];
outArray.set(newArr);
inArray.onChange =
inValue.onChange = inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let mul = inValue.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = arr[i] * mul;
    }

    outArray.set(null);
    outArray.set(newArr);
};

inArray.onLinkChanged = () =>
{
    if (inArray) inArray.copyLinkedUiAttrib("stride", outArray);
};


};

Ops.Array.ArrayMultiply.prototype = new CABLES.Op();
CABLES.OPS["a01c344b-4129-4b01-9c8f-36cefe86d7cc"]={f:Ops.Array.ArrayMultiply,objName:"Ops.Array.ArrayMultiply"};




// **************************************************************
// 
// Ops.Array.ArrayOfArrays
// 
// **************************************************************

Ops.Array.ArrayOfArrays = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

const
    inExec = op.inTriggerButton("Update"),
    outArr = op.outArray("Result");

inExec.onTriggered = update;
const arrayPorts = [];
const finalArray = [];

for (let i = 0; i < 10; i++)
{
    arrayPorts.push(op.inArray("Array " + i));
}


function update()
{
    let count = 0;
    for (let i = 0; i < arrayPorts.length; i++) if (arrayPorts[i].get())
    {
        finalArray[count] = arrayPorts[i].get();
        count++;
    }

    finalArray.length = count;

    outArr.set(null);
    outArr.set(finalArray);
}


};

Ops.Array.ArrayOfArrays.prototype = new CABLES.Op();
CABLES.OPS["7a7b84c7-39e9-4e00-84cc-a8d7049d8247"]={f:Ops.Array.ArrayOfArrays,objName:"Ops.Array.ArrayOfArrays"};




// **************************************************************
// 
// Ops.Array.ArrayOfObjectsFilterByKeyValue
// 
// **************************************************************

Ops.Array.ArrayOfObjectsFilterByKeyValue = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array");
const inKeyToFilterBy = op.inString("Filter Key", "");
const inKeyShouldEqual = op.inString("Filter Value", "");
const inInvertEquality = op.inBool("Invert Filter", false);
const outArray = op.outArray("arrayOut");

const COMPARATOR_FUNC = (obj, comparator, key) => { return obj[key] == comparator; };
const INV_COMPARATOR_FUNC = (obj, comparator, key) => { return (obj[key] != comparator); };

inArray.onChange = inInvertEquality.onChange
= inKeyToFilterBy.onChange = inKeyShouldEqual.onChange = function () {
    const inValue = inArray.get();
    if (!inValue) {
        return;
    }

    if (Array.isArray(inValue)) {
        const key = inKeyToFilterBy.get();

        if (!inKeyShouldEqual.get()) {
            outArray.set(null);
            outArray.set(inValue);
            return; // no filter value given
        }

        const comparatorFunction = !inInvertEquality.get() ?
            COMPARATOR_FUNC : INV_COMPARATOR_FUNC;

        const filteredArray = [];
        const keyToEqual = inKeyShouldEqual.get();
        for (let i = 0, len = inValue.length; i < len; i += 1) {
            const obj = inValue[i];
            if (comparatorFunction(obj, keyToEqual, key)) {
                filteredArray.push(obj);
            }
        }

        outArray.set(null);
        outArray.set(filteredArray);
    }
    else
    {
        outArray.set(null);
    }
};


};

Ops.Array.ArrayOfObjectsFilterByKeyValue.prototype = new CABLES.Op();
CABLES.OPS["0d4b9bba-2c00-49f7-b486-86e4cde2428e"]={f:Ops.Array.ArrayOfObjectsFilterByKeyValue,objName:"Ops.Array.ArrayOfObjectsFilterByKeyValue"};




// **************************************************************
// 
// Ops.Array.ArrayOfObjectsFilterKeys
// 
// **************************************************************

Ops.Array.ArrayOfObjectsFilterKeys = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array");
const inKeysToKeep = op.inStringEditor("Keys",'1,2,3');
const inSeperator = op.inString("Seperator", ",");
const inInvert = op.inBool("Invert Filter", false);
const outArray = op.outArray("Array Out");

const COMPARATOR_FUNC = (arr, key) => arr.includes(key);
const INV_COMPARATOR_FUNC = (arr, key) => !(arr.includes(key));

inArray.onChange = inKeysToKeep.onChange = inInvert.onChange = inSeperator.onChange =
function () {
    if (!inKeysToKeep.get()) return;
    const keys = inKeysToKeep.get().split(inSeperator.get());
    const inValue = inArray.get();

    if (Array.isArray(inValue)) {
        const newArray = [];
        const comparatorFunc = !inInvert.get() ? COMPARATOR_FUNC : INV_COMPARATOR_FUNC

        for (let i = 0, len = inValue.length; i < len; i += 1) {
            const obj = inValue[i];
            const objKeys = Object.keys(obj);
            const newObj = {};

            for (let j = 0, len2 = objKeys.length; j < len2; j += 1) {
                const key = objKeys[j];
                if (comparatorFunc(keys, key))
                    Object.assign(newObj, { [key]: obj[key] });
            }

            newArray.push(newObj);
        }

        outArray.set(null);
        outArray.set(newArray);
    }
    else {
        outArray.set(null);
    }
};


};

Ops.Array.ArrayOfObjectsFilterKeys.prototype = new CABLES.Op();
CABLES.OPS["8c9a7621-51c7-46b7-934b-1924cb0ff0b6"]={f:Ops.Array.ArrayOfObjectsFilterKeys,objName:"Ops.Array.ArrayOfObjectsFilterKeys"};




// **************************************************************
// 
// Ops.Array.ArrayOfObjectsToString
// 
// **************************************************************

Ops.Array.ArrayOfObjectsToString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array In");
const outString = op.outString("String");

inArray.onChange = function() {
    if (!inArray.get()) {
        outString.set("");
        return;
    }

    const arr = inArray.get();
    let result = "";

    for (let i = 0; i < arr.length; i += 1) {
        const objToString = JSON.stringify(arr[i]);
        result += "\n" + objToString;
    }

    outString.set(result);
}

};

Ops.Array.ArrayOfObjectsToString.prototype = new CABLES.Op();
CABLES.OPS["1593cd67-2a90-43ab-b95e-ad6bbe9af37e"]={f:Ops.Array.ArrayOfObjectsToString,objName:"Ops.Array.ArrayOfObjectsToString"};




// **************************************************************
// 
// Ops.Array.ArrayPack
// 
// **************************************************************

Ops.Array.ArrayPack = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const outArr = op.outArray("Result");

const NUM_PORTS = 8;
const inArrPorts = [];

let showingError = false;

for (let i = 0; i < NUM_PORTS; i++)
{
    let p = op.inArray("Array " + i);
    p.onChange = update;
    inArrPorts.push(p);
}

function update()
{
    const arr = [];
    const inArrays = [];
    let i = 0;

    for (i = 0; i < NUM_PORTS; i++)
    {
        let a = inArrPorts[i].get();
        if (a)
        {
            inArrays.push(a);
            if (a.length != inArrays[0].length)
            {
                if (!showingError)op.setUiError("arraylen", "Arrays do not have the same length !");
                outArr.set(null);
                showingError = true;
                return;
            }
        }
    }

    if (inArrays.length === 0)
    {
        if (!showingError)op.setUiError("invalid", "No Valid Arrays");
        // op.uiAttr({ "error": "No Valid Arrays" });
        outArr.set(null);
        showingError = true;
        return;
    }

    if (showingError)
    {
        op.setUiError("arraylen", null);
        op.setUiError("invalid", null);
    }
    showingError = false;

    for (let j = 0; j < inArrays[0].length; j++)
        for (i = 0; i < inArrays.length; i++)
            arr.push(inArrays[i][j]);

    outArr.set(null);
    outArr.set(arr);
}


};

Ops.Array.ArrayPack.prototype = new CABLES.Op();
CABLES.OPS["51df396d-87be-4890-8fbd-c8bb3d364d3b"]={f:Ops.Array.ArrayPack,objName:"Ops.Array.ArrayPack"};




// **************************************************************
// 
// Ops.Array.ArrayPack2
// 
// **************************************************************

Ops.Array.ArrayPack2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTriggerButton("Trigger in"),
    inArr1 = op.inArray("Array 1"),
    inArr2 = op.inArray("Array 2"),
    exeOut = op.outTrigger("Trigger out"),
    outArr = op.outArray("Array out", null, 2),
    outArrayLength = op.outNumber("Array length");

let showingError = false;

let arr = [];
let emptyArray = [];
let needsCalc = true;

exe.onTriggered = update;

inArr1.onChange = inArr2.onChange = calcLater;
function calcLater()
{
    needsCalc = true;
}

function update()
{
    let array1 = inArr1.get();
    let array2 = inArr2.get();

    if (!array1 && !array2)
    {
        outArr.set(null);
        return;
    }
    if (needsCalc)
    {
        let arrlen = 0;

        if (!array1 || !array2)
        {
            if (array1) arrlen = array1.length;
            else if (array2) arrlen = array2.length;

            if (emptyArray.length != arrlen)
                for (var i = 0; i < arrlen; i++) emptyArray[i] = 0;

            if (!array1)array1 = emptyArray;
            if (!array2)array2 = emptyArray;
        }

        if (array1.length !== array2.length)
        {
            if (!showingError)
            {
                op.uiAttr({ "error": "Arrays do not have the same length !" });
                showingError = true;
            }
            return;
        }

        if (showingError)
        {
            showingError = false;
            op.uiAttr({ "error": null });
        }

        arr.length = array1.length;
        for (var i = 0; i < array1.length; i++)
        {
            arr[i * 2 + 0] = array1[i];
            arr[i * 2 + 1] = array2[i];
        }

        needsCalc = false;
        outArr.set(null);
        outArr.set(arr);
        outArrayLength.set(arr.length);
    }

    exeOut.trigger();
}


};

Ops.Array.ArrayPack2.prototype = new CABLES.Op();
CABLES.OPS["0db296db-e4a7-4356-9593-858f7e1bc7f3"]={f:Ops.Array.ArrayPack2,objName:"Ops.Array.ArrayPack2"};




// **************************************************************
// 
// Ops.Array.ArrayPack3
// 
// **************************************************************

Ops.Array.ArrayPack3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("Trigger in"),
    inArr1 = op.inArray("Array 1"),
    inArr2 = op.inArray("Array 2"),
    inArr3 = op.inArray("Array 3"),
    exeOut = op.outTrigger("Trigger out"),
    outArr = op.outArray("Array out", 3),
    outNum = op.outNumber("Num Points"),
    outArrayLength = op.outNumber("Array length");

let showingError = false;

let arr = [];
let emptyArray = [];
let needsCalc = true;

exe.onTriggered = update;

inArr1.onChange = inArr2.onChange = inArr3.onChange = calcLater;

function calcLater()
{
    needsCalc = true;
}

function update()
{
    let array1 = inArr1.get();
    let array2 = inArr2.get();
    let array3 = inArr3.get();

    if (!array1 && !array2 && !array3)
    {
        outArr.set(null);
        outNum.set(0);
        return;
    }
    // only update if array has changed
    if (needsCalc)
    {
        let arrlen = 0;

        if (!array1 || !array2 || !array3)
        {
            if (array1) arrlen = array1.length;
            else if (array2) arrlen = array2.length;
            else if (array3) arrlen = array3.length;

            if (emptyArray.length != arrlen)
                for (var i = 0; i < arrlen; i++) emptyArray[i] = 0;

            if (!array1)array1 = emptyArray;
            if (!array2)array2 = emptyArray;
            if (!array3)array3 = emptyArray;
        }

        if ((array1.length !== array2.length) || (array2.length !== array3.length))
        {
            op.setUiError("arraylen", "Arrays do not have the same length !");
            return;
        }
        op.setUiError("arraylen", null);

        arr.length = array1.length;
        for (var i = 0; i < array1.length; i++)
        {
            arr[i * 3 + 0] = array1[i];
            arr[i * 3 + 1] = array2[i];
            arr[i * 3 + 2] = array3[i];
        }

        needsCalc = false;
        outArr.set(null);
        outArr.set(arr);
        outNum.set(arr.length / 3);
        outArrayLength.set(arr.length);
    }

    exeOut.trigger();
}


};

Ops.Array.ArrayPack3.prototype = new CABLES.Op();
CABLES.OPS["2bcf32fe-3cbd-48fd-825a-61255bebda9b"]={f:Ops.Array.ArrayPack3,objName:"Ops.Array.ArrayPack3"};




// **************************************************************
// 
// Ops.Array.ArrayPack3Simple
// 
// **************************************************************

Ops.Array.ArrayPack3Simple = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr1 = op.inArray("Array 1"),
    inArr2 = op.inArray("Array 2"),
    inArr3 = op.inArray("Array 3"),

    outArr = op.outArray("Array out", 3),
    outNum = op.outNumber("Num Points"),
    outArrayLength = op.outNumber("Array length");

let showingError = false;

let arr = [];
let emptyArray = [];
let needsCalc = true;

inArr1.onChange = inArr2.onChange = inArr3.onChange = update;

function update()
{
    let array1 = inArr1.get();
    let array2 = inArr2.get();
    let array3 = inArr3.get();

    if (!array1 && !array2 && !array3)
    {
        outArr.set(null);
        outNum.set(0);
        return;
    }
    let arrlen = 0;

    if (!array1 || !array2 || !array3)
    {
        if (array1) arrlen = array1.length;
        else if (array2) arrlen = array2.length;
        else if (array3) arrlen = array3.length;

        if (emptyArray.length != arrlen)
            for (var i = 0; i < arrlen; i++) emptyArray[i] = 0;

        if (!array1)array1 = emptyArray;
        if (!array2)array2 = emptyArray;
        if (!array3)array3 = emptyArray;
    }

    if ((array1.length !== array2.length) || (array2.length !== array3.length))
    {
        //
        op.setUiError("arraylen", "Arrays do not have the same length !");
        return;
    }
    op.setUiError("arraylen", null);

    arr.length = array1.length;
    for (var i = 0; i < array1.length; i++)
    {
        arr[i * 3 + 0] = array1[i];
        arr[i * 3 + 1] = array2[i];
        arr[i * 3 + 2] = array3[i];
    }

    needsCalc = false;
    outArr.set(null);
    outArr.set(arr);
    outNum.set(arr.length / 3);
    outArrayLength.set(arr.length);
}


};

Ops.Array.ArrayPack3Simple.prototype = new CABLES.Op();
CABLES.OPS["9c48785b-4cac-472c-a70f-dbd3c240b782"]={f:Ops.Array.ArrayPack3Simple,objName:"Ops.Array.ArrayPack3Simple"};




// **************************************************************
// 
// Ops.Array.ArrayPack4
// 
// **************************************************************

Ops.Array.ArrayPack4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("Trigger in"),
    inArr1 = op.inArray("Array 1"),
    inArr2 = op.inArray("Array 2"),
    inArr3 = op.inArray("Array 3"),
    inArr4 = op.inArray("Array 4"),
    outTrigger = op.outTrigger("Trigger out"),
    outArr = op.outArray("Array out", 4),
    outArrayLength = op.outNumber("Array length");

let showingError = false;
let arr = [];
let emptyArray = [];
let needsCalc = true;

exe.onTriggered = update;

inArr1.onChange = inArr2.onChange = inArr3.onChange = inArr4.onChange = calcLater;
function calcLater()
{
    needsCalc = true;
}

function update()
{
    outTrigger.trigger();
    let array1 = inArr1.get();
    let array2 = inArr2.get();
    let array3 = inArr3.get();
    let array4 = inArr4.get();

    if (!array1 && !array2 && !array3 && !array4)
    {
        outArr.set(null);
        return;
    }

    if (needsCalc)
    {
        let arrlen = 0;

        if (!array1 || !array2 || !array3 || !array4)
        {
            if (array1) arrlen = array1.length;
            else if (array2) arrlen = array2.length;
            else if (array3) arrlen = array3.length;
            else if (array4) arrlen = array4.length;

            if (emptyArray.length != arrlen)
                for (var i = 0; i < arrlen; i++) emptyArray[i] = 0;

            if (!array1)array1 = emptyArray;
            if (!array2)array2 = emptyArray;
            if (!array3)array3 = emptyArray;
            if (!array4)array4 = emptyArray;
        }

        if ((array1.length !== array2.length) || (array2.length !== array3.length)
                || (array3.length !== array4.length))
        {
            if (!showingError)
            {
                op.setUiError("arrlength", "Arrays do not have the same length !");
                outArrayLength.set(0);
                showingError = true;
            }
            return;
        }

        if (showingError)
        {
            showingError = false;
            op.setUiError("arrlength", null);
        }

        arr.length = array1.length;

        for (var i = 0; i < array1.length; i++)
        {
            arr[i * 4 + 0] = array1[i];
            arr[i * 4 + 1] = array2[i];
            arr[i * 4 + 2] = array3[i];
            arr[i * 4 + 3] = array4[i];
        }
        needsCalc = false;
        outArr.set(null);
        outArr.set(arr);
        outArrayLength.set(arr.length);
    }
}


};

Ops.Array.ArrayPack4.prototype = new CABLES.Op();
CABLES.OPS["68ea2c83-05fc-47a7-aba8-3c400f1dd737"]={f:Ops.Array.ArrayPack4,objName:"Ops.Array.ArrayPack4"};




// **************************************************************
// 
// Ops.Array.ArrayPack4Simple
// 
// **************************************************************

Ops.Array.ArrayPack4Simple = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr1 = op.inArray("Array 1"),
    inArr2 = op.inArray("Array 2"),
    inArr3 = op.inArray("Array 3"),
    inArr4 = op.inArray("Array 4"),

    outArr = op.outArray("Array out", 4),
    outNum = op.outNumber("Num Points"),
    outArrayLength = op.outNumber("Array length");

let showingError = false;

let arr = [];
let emptyArray = [];
let needsCalc = true;

inArr1.onChange = inArr2.onChange = inArr3.onChange = inArr4.onChange = update;

function update()
{
    let array1 = inArr1.get();
    let array2 = inArr2.get();
    let array3 = inArr3.get();
    let array4 = inArr4.get();

    if (!array1 && !array2 && !array3 && !array4)
    {
        outArr.set(null);
        outNum.set(0);
        return;
    }
    let arrlen = 0;

    if (!array1 || !array2 || !array3 || !array4)
    {
        if (array1) arrlen = array1.length;
        else if (array2) arrlen = array2.length;
        else if (array3) arrlen = array3.length;
        else if (array4) arrlen = array4.length;

        if (emptyArray.length != arrlen)
            for (let i = 0; i < arrlen; i++) emptyArray[i] = 0;

        if (!array1)array1 = emptyArray;
        if (!array2)array2 = emptyArray;
        if (!array3)array3 = emptyArray;
        if (!array4)array4 = emptyArray;
    }

    if ((array1.length !== array2.length) || (array2.length !== array3.length))
    {
        //
        op.setUiError("arraylen", "Arrays do not have the same length !");
        return;
    }
    op.setUiError("arraylen", null);

    arr.length = array1.length * 4;
    for (let i = 0; i < array1.length; i++)
    {
        arr[i * 4 + 0] = array1[i];
        arr[i * 4 + 1] = array2[i];
        arr[i * 4 + 2] = array3[i];
        arr[i * 4 + 3] = array4[i];
    }

    needsCalc = false;
    outArr.set(null);
    outArr.set(arr);
    outNum.set(arr.length / 4);
    outArrayLength.set(arr.length);
}


};

Ops.Array.ArrayPack4Simple.prototype = new CABLES.Op();
CABLES.OPS["6fe2bb0e-4bfc-42c1-8bc1-19fda052e091"]={f:Ops.Array.ArrayPack4Simple,objName:"Ops.Array.ArrayPack4Simple"};




// **************************************************************
// 
// Ops.Array.ArrayPow
// 
// **************************************************************

Ops.Array.ArrayPow = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// The pow function will not work correctly with neagtive numbers
// Use the ArrayAbs op to make numbers have only positive values
// to work correctly with this op

let inArray = op.inArray("Array in");
let inValue = op.inValue("Pow factor", 1.0);
let outArray = op.outArray("Array out");

let newArr = [];
outArray.set(newArr);

inArray.onChange =
inValue.onChange = inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let pow = inValue.get();
    if (pow < 0.0)
    {
        pow = 0.0;
    }

    if (newArr.length !== arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.pow(arr[i], pow);
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArrayPow.prototype = new CABLES.Op();
CABLES.OPS["d60b6c52-d142-41dd-a38d-d185148be33f"]={f:Ops.Array.ArrayPow,objName:"Ops.Array.ArrayPow"};




// **************************************************************
// 
// Ops.Array.ArrayPushString
// 
// **************************************************************

Ops.Array.ArrayPushString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr=op.inArray("Array"),
    inString=op.inString("String",""),
    result=op.outArray("Result");

const arr=[];

    inString.onChange=
    inArr.onChange=
    function()
    {
        const oldArr=inArr.get();
        result.set(null);
        if(!oldArr)return;

        arr.length=oldArr.length+1;
        for(let i=0;i<oldArr.length;i++)
        {
            arr[i]=oldArr[i];
        }

        arr[oldArr.length]=inString.get();

        result.set(arr);

    };


};

Ops.Array.ArrayPushString.prototype = new CABLES.Op();
CABLES.OPS["074034c9-9698-4984-897a-849bcb2b9b62"]={f:Ops.Array.ArrayPushString,objName:"Ops.Array.ArrayPushString"};




// **************************************************************
// 
// Ops.Array.ArrayQuantizer
// 
// **************************************************************

Ops.Array.ArrayQuantizer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function closest(num, arr)
{
    let curr = arr[0];
    let diff = Math.abs(num - curr);
    for (let val = 0; val < arr.length; val++)
    {
        let newdiff = Math.abs(num - arr[val]);
        if (newdiff < diff)
        {
            diff = newdiff;
            curr = arr[val];
        }
    }

    return curr;
}

const inValue = op.inFloat("Value", 0);
const inScale = op.inArray("Constraints Array Input");
const outQuantized = op.outNumber("Quantized Value");
const outError = op.outNumber("Quantization Error");

inValue.onChange = () =>
{
    if (!inScale.get())
    {
        outQuantized.set(inValue.get());
        outError.set(0);
        return;
    }

    const arr = inScale.get();
    const quantized = closest(inValue.get(), arr);
    outQuantized.set(quantized);
    outError.set(quantized - inValue.get());
};


};

Ops.Array.ArrayQuantizer.prototype = new CABLES.Op();
CABLES.OPS["fc05b6ed-6584-4e37-aec2-fc659012ff60"]={f:Ops.Array.ArrayQuantizer,objName:"Ops.Array.ArrayQuantizer"};




// **************************************************************
// 
// Ops.Array.ArrayRandomSelection
// 
// **************************************************************

Ops.Array.ArrayRandomSelection = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array"),
    inNum = op.inValueInt("Elements", 10),
    inSeed = op.inValue("Seed", 1),
    result = op.outArray("Result"),
    outArrayLength = op.outNumber("Array length");

let arr = [];
inSeed.onChange = inArray.onChange = inNum.onChange = update;

function update()
{
    if (Math.floor(inNum.get()) < 0 || !inArray.get())
    {
        result.set(null);
        outArrayLength.set(0);
        return;
    }

    let oldArr = inArray.get();

    arr.length = Math.floor(inNum.get());

    let nums = [];

    for (var i = 0; i < Math.max(arr.length, oldArr.length); i++)
        nums[i] = i % (oldArr.length);

    nums = CABLES.shuffleArray(nums);

    Math.randomSeed = inSeed.get();

    for (var i = 0; i < inNum.get(); i++)
    {
        let index = nums[i];
        arr[i] = oldArr[index];
    }
    result.set(null);
    result.set(arr);
    outArrayLength.set(arr.length);
}


};

Ops.Array.ArrayRandomSelection.prototype = new CABLES.Op();
CABLES.OPS["3dc059c8-bcb3-4d63-b806-ce81215da3b5"]={f:Ops.Array.ArrayRandomSelection,objName:"Ops.Array.ArrayRandomSelection"};




// **************************************************************
// 
// Ops.Array.ArrayReverse
// 
// **************************************************************

Ops.Array.ArrayReverse = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Input"),
    outArr = op.outArray("Result");

inArr.onChange = function ()
{
    let arr = inArr.get();
    if (arr)
    {
        let arrCopy = arr.slice();
        outArr.set(arrCopy.reverse());
    }
};


};

Ops.Array.ArrayReverse.prototype = new CABLES.Op();
CABLES.OPS["88d8662f-2c01-42e6-943d-4d3cf90657b0"]={f:Ops.Array.ArrayReverse,objName:"Ops.Array.ArrayReverse"};




// **************************************************************
// 
// Ops.Array.ArraySetArray
// 
// **************************************************************

Ops.Array.ArraySetArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe=op.inTriggerButton("exe"),
    array=op.inArray("array"),
    index=op.inValueInt("index"),
    value=op.inArray("new Array"),
    values=op.outArray("values");

values.ignoreValueSerialize=true;

function updateIndex()
{
    if(exe.isLinked())return;
    update();
}

function copyArray(source)
{
    var dest=[];
    dest.length=source.length;
    for (var i = 0, n = source.length; i < n; i++) dest[i] = source[i];

    return dest;
}


function update()
{
    if(!array.get() || !value.get())return;
    array.get()[index.get()]=copyArray(value.get());

    values.set(null);
    values.set(array.get());
}

exe.onTriggered=update;


};

Ops.Array.ArraySetArray.prototype = new CABLES.Op();
CABLES.OPS["58ddcecb-3917-4118-81d3-344ee2b75469"]={f:Ops.Array.ArraySetArray,objName:"Ops.Array.ArraySetArray"};




// **************************************************************
// 
// Ops.Array.ArraySetNumber3
// 
// **************************************************************

Ops.Array.ArraySetNumber3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrigger = op.inTriggerButton("Execute"),
    inArray = op.inArray("Array"),
    inIndex = op.inInt("Index", 0),
    inValueX = op.inFloat("X", 1),
    inValueY = op.inFloat("Y", 1),
    inValueZ = op.inFloat("Z", 1),
    inReset = op.inTriggerButton("Reset"),
    outArray = op.outArray("Result");

const newArr = [];

inReset.onTriggered = function ()
{
    copyArray(true);
};
inArray.onChange = copyArray;

inTrigger.onTriggered =
function ()
{
    const arr = inArray.get();

    if (!arr) return;
    if (newArr.length != arr.length)newArr.length = arr.length;

    const idx = Math.floor(inIndex.get());

    if (idx >= 0)
    {
        newArr[idx * 3 + 0] = inValueX.get();
        newArr[idx * 3 + 1] = inValueY.get();
        newArr[idx * 3 + 2] = inValueZ.get();
    }

    inArray.onChange = null;
    outArray.set(null);
    outArray.set(newArr);
};

function copyArray(force)
{
    const arr = inArray.get();

    if (!arr) return;

    if (force === true || (arr && !outArray.get()))
    {
        if (newArr.length != arr.length) newArr.length = arr.length;
        for (let i = 0; i < arr.length; i++) newArr[i] = arr[i];

        outArray.set(null);
        outArray.set(newArr);
    }
}


};

Ops.Array.ArraySetNumber3.prototype = new CABLES.Op();
CABLES.OPS["4edd6ccc-17c4-48c0-8eda-91bbc08e97db"]={f:Ops.Array.ArraySetNumber3,objName:"Ops.Array.ArraySetNumber3"};




// **************************************************************
// 
// Ops.Array.ArraySetNumber_v2
// 
// **************************************************************

Ops.Array.ArraySetNumber_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrigger = op.inTriggerButton("Execute"),
    inArray = op.inArray("Array"),
    inIndex = op.inInt("Index", 0),
    inValue = op.inFloat("Number", 1),
    outNext = op.outTrigger("Next"),
    outArray = op.outArray("Result");

let arr = [];
inArray.onChange = () =>
{
    arr = inArray.get();
};

inTrigger.onTriggered = () =>
{
    if (!arr)
    {
        outArray.set(null);
        return;
    }

    const newArr = [];
    // if (newArr.length != arr.length) newArr.length = arr.length;
    for (let i = 0; i < arr.length; i++) newArr[i] = arr[i];
    const idx = Math.floor(inIndex.get());

    if (idx >= 0)
    // if (idx >= 0 && idx < arr.length)
    {
        newArr[idx] = inValue.get();
    }

    arr = newArr;
    outArray.set(null);
    outArray.set(newArr);
    outNext.trigger();
};


};

Ops.Array.ArraySetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["a6366c3e-dab0-4b4c-b790-e66b82b93a25"]={f:Ops.Array.ArraySetNumber_v2,objName:"Ops.Array.ArraySetNumber_v2"};




// **************************************************************
// 
// Ops.Array.ArraySetObject
// 
// **************************************************************

Ops.Array.ArraySetObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe=op.inTriggerButton("exe"),
    array=op.inArray("array"),
    index=op.inValueInt("index"),
    value=op.inObject("object"),
    values=op.outArray("values");

values.ignoreValueSerialize=true;
exe.onTriggered=update;

function updateIndex()
{
    if(exe.isLinked())return;
    update();
}

function update()
{
    var arr=array.get();
    if(!arr)return;
    arr[index.get()]=value.get();

    values.set(null);
    values.set(arr);
}



};

Ops.Array.ArraySetObject.prototype = new CABLES.Op();
CABLES.OPS["5cccb9a4-3653-4c58-b54e-932c4c585b5f"]={f:Ops.Array.ArraySetObject,objName:"Ops.Array.ArraySetObject"};




// **************************************************************
// 
// Ops.Array.ArraySetString
// 
// **************************************************************

Ops.Array.ArraySetString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTriggerButton("Execute"),
    array = op.inArray("Array"),
    index = op.inValueInt("Index"),
    value = op.inString("String"),
    values = op.outArray("Result");

values.ignoreValueSerialize = true;
exe.onTriggered = update;

function updateIndex()
{
    if (exe.isLinked()) return;
    update();
}

function update()
{
    const arr = array.get();
    if (!arr) return;
    arr[index.get()] = value.get();

    values.set("");
    values.set(arr);
}


};

Ops.Array.ArraySetString.prototype = new CABLES.Op();
CABLES.OPS["2752b35e-592d-41db-b8dd-cdc43a7ccbe2"]={f:Ops.Array.ArraySetString,objName:"Ops.Array.ArraySetString"};




// **************************************************************
// 
// Ops.Array.ArraySin
// 
// **************************************************************

Ops.Array.ArraySin = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// this op allows the user to perform sin or cos
// math functions on an array
const inArray = op.inArray("array in");
const mathSelect = op.inValueSelect("Math function", ["Sin", "Cos"], "Sin");
const outArray = op.outArray("Array result");

const phase = op.inValue("Phase", 0.0);
const multiply = op.inValue("Frequency", 1.0);
const amplitude = op.inValue("Amplitude", 1.0);

const mathArray = [];
let selectIndex = 0;

const MATH_FUNC_SIN = 0;
const MATH_FUNC_COS = 1;


inArray.onChange = update;
multiply.onChange = update;
amplitude.onChange = update;
phase.onChange = update;
mathSelect.onChange = onFilterChange;

function onFilterChange()
{
    const mathSelectValue = mathSelect.get();
    if (mathSelectValue === "Sin") selectIndex = MATH_FUNC_SIN;
    else if (mathSelectValue === "Cos") selectIndex = MATH_FUNC_COS;
    update();
}

function update()
{
    const arrayIn = inArray.get();


    if (!arrayIn)
    {
        mathArray.length = 0;
        return;
    }

    mathArray.length = arrayIn.length;

    const amp = amplitude.get();
    const mul = multiply.get();
    const pha = phase.get();

    let i = 0;
    if (selectIndex === MATH_FUNC_SIN)
    {
        for (i = 0; i < arrayIn.length; i++)
            mathArray[i] = amp * Math.sin((arrayIn[i]) * mul + pha);
    }
    else if (selectIndex === MATH_FUNC_COS)
    {
        for (i = 0; i < arrayIn.length; i++)
            mathArray[i] = amp * (Math.cos(arrayIn[i] * mul + pha));
    }
    outArray.set(null);
    outArray.set(mathArray);
}


};

Ops.Array.ArraySin.prototype = new CABLES.Op();
CABLES.OPS["ded44bae-a24e-48c5-9585-4cb31f331ab6"]={f:Ops.Array.ArraySin,objName:"Ops.Array.ArraySin"};




// **************************************************************
// 
// Ops.Array.ArraySmoothStep
// 
// **************************************************************

Ops.Array.ArraySmoothStep = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArray = op.inArray("Array In"),
    inMinimum = op.inValue("Min", 0.0),
    inMaximum = op.inValue("Max", 1.0),
    outArray = op.outArray("Array out");

let newArr = [];
outArray.set(newArr);

inArray.onChange =
inMinimum.onChange =
inMaximum.onChange = inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let min = inMinimum.get();
    let max = inMaximum.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = smoothstep(min, max, arr[i]);
    }
    outArray.set(null);
    outArray.set(newArr);
};

function smoothstep(min, max, value)
{
    let x = Math.max(0.0, Math.min(1.0, (value - min) / (max - min)));
    return x * x * (3 - 2 * x);
}


};

Ops.Array.ArraySmoothStep.prototype = new CABLES.Op();
CABLES.OPS["eb95b563-937b-4189-a8c9-ba6776971719"]={f:Ops.Array.ArraySmoothStep,objName:"Ops.Array.ArraySmoothStep"};




// **************************************************************
// 
// Ops.Array.ArraySqrt
// 
// **************************************************************

Ops.Array.ArraySqrt = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArray = op.inArray("In"),
    outArray = op.outArray("Result");

let newArr = [];
outArray.set(newArr);

inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = Math.sqrt(arr[i]);
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArraySqrt.prototype = new CABLES.Op();
CABLES.OPS["93f3dc25-a1e7-46f5-9069-527c1bd2c3a3"]={f:Ops.Array.ArraySqrt,objName:"Ops.Array.ArraySqrt"};




// **************************************************************
// 
// Ops.Array.ArraySubtract
// 
// **************************************************************

Ops.Array.ArraySubtract = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inArray = op.inArray("Array In");
let inValue = op.inValue("Value", 1.0);
let outArray = op.outArray("Array Out");

let newArr = [];
outArray.set(newArr);
inArray.onChange =
inValue.onChange = inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let subtract = inValue.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    let i = 0;
    for (i = 0; i < arr.length; i++)
    {
        newArr[i] = arr[i] - subtract;
    }
    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArraySubtract.prototype = new CABLES.Op();
CABLES.OPS["af78ab59-75d5-4ead-9a8d-27a63e1cbf3f"]={f:Ops.Array.ArraySubtract,objName:"Ops.Array.ArraySubtract"};




// **************************************************************
// 
// Ops.Array.ArraySum
// 
// **************************************************************

Ops.Array.ArraySum = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArray = op.inArray("In"),
    inValue = op.inValue("Value", 1.0),
    outArray = op.outArray("Result");

let newArr = [];
outArray.set(newArr);

inValue.onChange =
inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let add = inValue.get();

    if (newArr.length != arr.length)newArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        newArr[i] = arr[i] + add;
    }

    outArray.set(null);
    outArray.set(newArr);
};


};

Ops.Array.ArraySum.prototype = new CABLES.Op();
CABLES.OPS["c6b5bf63-0be8-4eea-acc0-9d32973e665a"]={f:Ops.Array.ArraySum,objName:"Ops.Array.ArraySum"};




// **************************************************************
// 
// Ops.Array.ArraySumPrevious
// 
// **************************************************************

Ops.Array.ArraySumPrevious = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr=op.inArray("Array"),
    inPad=op.inFloat("Padding",0),
    outArr=op.outArray("Result");

const newArr=[];

inPad.onChange=
inArr.onChange=()=>
{
    outArr.set(null);
    let arr=inArr.get();
    if(!arr || arr.length<1)return;

    newArr.length=arr.length;

    newArr[0]=arr[0];

    for(let i=1;i<arr.length;i++)
    {
        newArr[i]=newArr[i-1]+arr[i]+inPad.get();
    }

    outArr.set(newArr);


};

};

Ops.Array.ArraySumPrevious.prototype = new CABLES.Op();
CABLES.OPS["71494407-e618-425f-890b-dcf6c3d46cf1"]={f:Ops.Array.ArraySumPrevious,objName:"Ops.Array.ArraySumPrevious"};




// **************************************************************
// 
// Ops.Array.ArraySumUp
// 
// **************************************************************

Ops.Array.ArraySumUp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    result = op.outNumber("Sum");

inArr.onChange = function ()
{
    if (inArr.get())
    {
        let arr = inArr.get();
        let sum = 0;
        for (let i = 0; i < arr.length; i++)
        {
            sum += Number(arr[i]);
        }
        result.set(sum);
    }
    else
    {
        result.set(0);
    }
};


};

Ops.Array.ArraySumUp.prototype = new CABLES.Op();
CABLES.OPS["5593ea29-19d3-4161-af0c-b8d62079487d"]={f:Ops.Array.ArraySumUp,objName:"Ops.Array.ArraySumUp"};




// **************************************************************
// 
// Ops.Array.ArrayToByteBuffer
// 
// **************************************************************

Ops.Array.ArrayToByteBuffer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    outObject = op.outObject("Buffer");

const packet = new Uint8ClampedArray(4 + 8 * 8 * 3);

inArr.onChange = function ()
{
    const arr = inArr.get();
    if (arr)
    {
        for (let i = 0; i < arr.length; i++) packet[i] = arr[i];
        outObject.set(packet.buffer);
    }
    else outObject.set(null);
};


};

Ops.Array.ArrayToByteBuffer.prototype = new CABLES.Op();
CABLES.OPS["e826fe40-69b5-4a63-adfa-db8267bd56d1"]={f:Ops.Array.ArrayToByteBuffer,objName:"Ops.Array.ArrayToByteBuffer"};




// **************************************************************
// 
// Ops.Array.ArrayToString_v3
// 
// **************************************************************

Ops.Array.ArrayToString_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr=op.inArray("Array"),
    inSeperator=op.inString("Seperator",","),
    inNewLine=op.inValueBool("New Line"),
    outStr=op.outString("Result");

inArr.onChange=
    outStr.onChange=
    inSeperator.onChange=
    inNewLine.onChange=exec;


function exec()
{
    var arr=inArr.get();
    var result='';

    var sep=inSeperator.get();
    if(inNewLine.get())sep+='\n';

    if(arr && arr.join)
    {
        result=arr.join(sep);
    }

    outStr.set(result);
}

};

Ops.Array.ArrayToString_v3.prototype = new CABLES.Op();
CABLES.OPS["7b539bb3-8e86-4367-9e00-a637d3cfd87a"]={f:Ops.Array.ArrayToString_v3,objName:"Ops.Array.ArrayToString_v3"};




// **************************************************************
// 
// Ops.Array.ArrayTrigger
// 
// **************************************************************

Ops.Array.ArrayTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec=op.inTriggerButton("Exec"),
    inArr=op.inArray("Array"),
    outTrigger=op.outTrigger("Trigger out"),
    result=op.outArray("Result");

inExec.onTriggered=function()
{
    const arrValue = inArr.get();
    if(!arrValue) result.set(null);
    result.set(inArr.get());
    outTrigger.trigger();
};

};

Ops.Array.ArrayTrigger.prototype = new CABLES.Op();
CABLES.OPS["c1d7a502-5d91-4528-9833-3bf27a546d25"]={f:Ops.Array.ArrayTrigger,objName:"Ops.Array.ArrayTrigger"};




// **************************************************************
// 
// Ops.Array.ArrayUnique
// 
// **************************************************************

Ops.Array.ArrayUnique = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("array");
const inDedupeMode = op.inSwitch("Format", ["X", "XY", "XYZ"], "X");
const outArray = op.outArray("arrayOut");
const outLength = op.outNumber("Array Length Out");

inArray.onChange = inDedupeMode.onChange = () =>
{
    if (!inArray.get())
    {
        outArray.set(null);
        outLength.set(0);
        return;
    }

    const mode = inDedupeMode.get();
    const func = FUNCTIONS[mode];
    const newArray = func(inArray.get());

    outArray.set(null);
    outArray.set(newArray);
    outLength.set(newArray.length);
};

function compareSingle(arr)
{
    const len = arr.length;
    const seen = {};
    const deduped = [];

    for (let i = 0; i < len; i++)
    {
        if (!seen[arr[i]])
        {
            deduped.push(arr[i]);
            seen[arr[i]] = true;
        }
    }

    return deduped;
}

const FUNCTIONS = {
    "X": compareSingle,
    "XY": compareVec2,
    "XYZ": compareVec3,
};

function compareVec2(arr)
{
    const len = Math.floor(arr.length / 2);
    const seen = {};
    const deduped = [];

    for (let i = 0; i < len; i += 1)
    {
        const key = [arr[i * 2], arr[i * 2 + 1]].join();

        if (!seen[key])
        {
            deduped.push(arr[i * 2], arr[i * 2 + 1]);
            seen[key] = true;
        }
    }

    return deduped;
}

function compareVec3(arr)
{
    const len = Math.floor(arr.length / 3);
    const seen = {};
    const deduped = [];

    for (let i = 0; i < len; i += 1)
    {
        const key = [arr[i * 3], arr[i * 3 + 1], arr[i * 3 + 2]].join();

        if (!seen[key])
        {
            deduped.push(arr[i * 3], arr[i * 3 + 1], arr[i * 3 + 2]);
            seen[key] = true;
        }
    }

    return deduped;
}


/*
// OLD CODE IN CASE OF SOMETHING GOING WRONG

const inArray = op.inArray("array");
const outArray = op.outArray("arrayOut");

inArray.onChange = function ()
{
    const inValue = inArray.get();
    if (Array.isArray(inValue))
    {
        const unique = inValue.filter((v, i, a) => a.indexOf(v) === i);
        outArray.set(unique);
    }
    else
    {
        outArray.set(inValue);
    }
};

*/


};

Ops.Array.ArrayUnique.prototype = new CABLES.Op();
CABLES.OPS["81204fcc-c416-4948-9cba-2218763db4fc"]={f:Ops.Array.ArrayUnique,objName:"Ops.Array.ArrayUnique"};




// **************************************************************
// 
// Ops.Array.ArrayUniqueItemInfo
// 
// **************************************************************

Ops.Array.ArrayUniqueItemInfo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("array");
const outObject = op.outObject("objectOut");

inArray.onChange = function ()
{
    const inValue = inArray.get();
    const counts = {};
    if (Array.isArray(inValue))
    {
        for (let i = 0; i < inValue.length; i++)
        {
            const value = inValue[i];
            if (counts.hasOwnProperty(value))
            {
                counts[value]++;
            }
            else
            {
                counts[value] = 1;
            }
        }
        outObject.set(counts);
    }
    else
    {
        outObject.set(inValue);
    }
};


};

Ops.Array.ArrayUniqueItemInfo.prototype = new CABLES.Op();
CABLES.OPS["6c6927e6-abd3-4427-92b2-4095f6f0b1c0"]={f:Ops.Array.ArrayUniqueItemInfo,objName:"Ops.Array.ArrayUniqueItemInfo"};




// **************************************************************
// 
// Ops.Array.ArrayUnpack2
// 
// **************************************************************

Ops.Array.ArrayUnpack2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray1 = op.inArray("Array in xyz"),
    outArray1 = op.outArray("Array 1 out"),
    outArray2 = op.outArray("Array 2 out"),
    outArrayLength = op.outNumber("Array lengths");

let showingError = false;

const arr1 = [];
const arr2 = [];

inArray1.onChange = update;

function update()
{
    let array1 = inArray1.get();

    if (!array1)
    {
        outArray1.set(null);
        return;
    }

    if (array1.length % 2 !== 0)
    {
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays length not divisible by 2 !" });
            outArrayLength.set(0);
            showingError = true;
        }
        return;
    }
    if (array1.length === 0)
    {
        outArrayLength.set(0);
        outArray1.set(null);
        outArray2.set(null);
    }

    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    arr1.length = Math.floor(array1.length / 2);
    arr2.length = Math.floor(array1.length / 2);

    for (let i = 0; i < array1.length / 2; i++)
    {
        arr1[i] = array1[i * 2];
        arr2[i] = array1[i * 2 + 1];
    }

    outArray1.set(null);
    outArray2.set(null);
    outArray1.set(arr1);
    outArray2.set(arr2);
    outArrayLength.set(arr1.length);
}


};

Ops.Array.ArrayUnpack2.prototype = new CABLES.Op();
CABLES.OPS["3f789664-9937-4478-ba28-63ccb67e5114"]={f:Ops.Array.ArrayUnpack2,objName:"Ops.Array.ArrayUnpack2"};




// **************************************************************
// 
// Ops.Array.ArrayUnpack3
// 
// **************************************************************

Ops.Array.ArrayUnpack3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray1 = op.inArray("Array in xyz"),
    outArray1 = op.outArray("Array 1 out"),
    outArray2 = op.outArray("Array 2 out"),
    outArray3 = op.outArray("Array 3 out"),
    outArrayLength = op.outNumber("Array lengths");

let showingError = false;

const arr1 = [];
const arr2 = [];
const arr3 = [];

inArray1.onChange = update;

function update()
{
    let array1 = inArray1.get();

    if (!array1)
    {
        outArray1.set(null);
        return;
    }

    if (array1.length % 3 !== 0)
    {
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays length not divisible by 3 !" });
            outArrayLength.set(0);
            showingError = true;
        }
        return;
    }

    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    arr1.length = Math.floor(array1.length / 3);
    arr2.length = Math.floor(array1.length / 3);
    arr3.length = Math.floor(array1.length / 3);

    for (let i = 0; i < array1.length / 3; i++)
    {
        arr1[i] = array1[i * 3];
        arr2[i] = array1[i * 3 + 1];
        arr3[i] = array1[i * 3 + 2];
    }

    outArray1.set(null);
    outArray2.set(null);
    outArray3.set(null);
    outArray1.set(arr1);
    outArray2.set(arr2);
    outArray3.set(arr3);
    outArrayLength.set(arr1.length);
}


};

Ops.Array.ArrayUnpack3.prototype = new CABLES.Op();
CABLES.OPS["fa671f66-6957-41e6-ac35-d615b7c29285"]={f:Ops.Array.ArrayUnpack3,objName:"Ops.Array.ArrayUnpack3"};




// **************************************************************
// 
// Ops.Array.ArrayUnpack4
// 
// **************************************************************

Ops.Array.ArrayUnpack4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArray1 = op.inArray("Array in xyzw"),
    outArray1 = op.outArray("Array 1 out"),
    outArray2 = op.outArray("Array 2 out"),
    outArray3 = op.outArray("Array 3 out"),
    outArray4 = op.outArray("Array 4 out"),
    outArrayLength = op.outNumber("Array lengths");

let showingError = false;

const arr1 = [];
const arr2 = [];
const arr3 = [];
const arr4 = [];

inArray1.onChange = update;

function update()
{
    let array1 = inArray1.get();

    if (!array1)
    {
        outArray1.set(null);
        return;
    }

    if (array1.length % 4 !== 0)
    {
        if (!showingError)
        {
            op.uiAttr({ "error": "Arrays length not divisible by 4 !" });
            outArrayLength.set(0);
            showingError = true;
        }
        return;
    }

    if (showingError)
    {
        showingError = false;
        op.uiAttr({ "error": null });
    }

    arr1.length = Math.floor(array1.length / 4);
    arr2.length = Math.floor(array1.length / 4);
    arr3.length = Math.floor(array1.length / 4);
    arr4.length = Math.floor(array1.length / 4);

    for (let i = 0; i < array1.length / 4; i++)
    {
        arr1[i] = array1[i * 4];
        arr2[i] = array1[i * 4 + 1];
        arr3[i] = array1[i * 4 + 2];
        arr4[i] = array1[i * 4 + 3];
    }

    outArray1.set(null);
    outArray2.set(null);
    outArray3.set(null);
    outArray4.set(null);
    outArray1.set(arr1);
    outArray2.set(arr2);
    outArray3.set(arr3);
    outArray4.set(arr4);
    outArrayLength.set(arr1.length);
}


};

Ops.Array.ArrayUnpack4.prototype = new CABLES.Op();
CABLES.OPS["8d2127d8-f3e4-4036-8cd8-75c6a404b582"]={f:Ops.Array.ArrayUnpack4,objName:"Ops.Array.ArrayUnpack4"};




// **************************************************************
// 
// Ops.Array.ArrayUnshiftString
// 
// **************************************************************

Ops.Array.ArrayUnshiftString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inString = op.inString("String", ""),
    result = op.outArray("Result");

const arr = [];

inString.onChange =
    inArr.onChange =
    function ()
    {
        const oldArr = inArr.get();
        result.set(null);
        if (!oldArr) return;

        arr.length = oldArr.length + 1;
        arr[0] = inString.get();

        for (let i = 0; i < oldArr.length; i++)
        {
            arr[i + 1] = oldArr[i];
        }

        result.set(arr);
    };


};

Ops.Array.ArrayUnshiftString.prototype = new CABLES.Op();
CABLES.OPS["b6b78f4f-487e-4372-bd35-aaaa097083ff"]={f:Ops.Array.ArrayUnshiftString,objName:"Ops.Array.ArrayUnshiftString"};




// **************************************************************
// 
// Ops.Array.Array_v3
// 
// **************************************************************

Ops.Array.Array_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inLength = op.inValueInt("Array length", 10),
    modeSelect = op.inSwitch("Mode select", ["Number", "1,2,3,4", "0-1"], "Number"),
    inDefaultValue = op.inValueFloat("Default Value"),
    inReverse=op.inBool("Reverse",false),
    outArr = op.outArray("Array"),
    outArrayLength = op.outNumber("Array length out");

let arr = [];
let selectIndex = 0;
const MODE_NUMBER = 0;
const MODE_1_TO_4 = 1;
const MODE_0_TO_1 = 2;

modeSelect.onChange = onFilterChange;

inReverse.onChange =
    inDefaultValue.onChange =
    inLength.onChange = reset;

onFilterChange();
reset();

function onFilterChange()
{
    let selectedMode = modeSelect.get();
    if (selectedMode === "Number") selectIndex = MODE_NUMBER;
    else if (selectedMode === "1,2,3,4") selectIndex = MODE_1_TO_4;
    else if (selectedMode === "0-1") selectIndex = MODE_0_TO_1;

    inDefaultValue.setUiAttribs({ "greyout": selectIndex !== MODE_NUMBER });

    op.setUiAttrib({ "extendTitle": modeSelect.get() });

    reset();
}

function reset()
{
    arr.length = 0;

    let arrLength = inLength.get();
    let valueForArray = inDefaultValue.get();
    let i;

    // mode 0 - fill all array values with one number
    if (selectIndex === MODE_NUMBER)
    {
        for (i = 0; i < arrLength; i++)
        {
            arr[i] = valueForArray;
        }
    }
    // mode 1 Continuous number array - increments up to array length
    else if (selectIndex === MODE_1_TO_4)
    {
        for (i = 0; i < arrLength; i++)
        {
            arr[i] = i;
        }
    }
    // mode 2 Normalized array
    else if (selectIndex === MODE_0_TO_1)
    {
        for (i = 0; i < arrLength; i++)
        {
            arr[i] = i / (arrLength-1);
        }
    }

    if(inReverse.get())arr=arr.reverse();

    outArr.set(null);
    outArr.set(arr);
    outArrayLength.set(arr.length);
}


};

Ops.Array.Array_v3.prototype = new CABLES.Op();
CABLES.OPS["e4d31a46-bf64-42a8-be34-4cbb2bbc2600"]={f:Ops.Array.Array_v3,objName:"Ops.Array.Array_v3"};




// **************************************************************
// 
// Ops.Array.AverageArray
// 
// **************************************************************

Ops.Array.AverageArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array"),
    inIterations = op.inValueInt("Iterations", 1),
    inMode = op.inValueSelect("Mode", ["repeat", "clamp"], "repeat"),
    outArray = op.outArray("Smoothed array"),
    outArrayLength = op.outNumber("Array length");

let smoothed = [];

inArray.onChange = update;
inIterations.onChange = update;

function smooth(values)
{
    smoothed.length = values.length;
    let curr, prev, next, improved, i, pi, ni, mode;
    mode = inMode.get();

    for (i = 0; i < smoothed.length; i++)
    {
        pi = i - 1;
        ni = i + 1;
        curr = values[i];

        if (pi < 0)
        {
            if (mode == "repeat")
                prev = values[values.length - 1];
            else if (mode == "clamp")
                prev = curr;
        }
        else
            prev = smoothed[pi];

        if (ni == values.length)
        {
            if (mode == "repeat")
                next = values[0];
            else if (mode == "clamp")
                next = curr;
        }
        else
            next = values[ni];

        improved = (prev + curr + next) / 3;
        smoothed[i] = improved;
    }
    return smoothed;
}

function update()
{
    let array = inArray.get(), num = inIterations.get(), i;

    if (!array)
        return;

    for (i = 0; i < num; i++)
        array = smooth(array);

    outArray.set(null);
    outArray.set(array);
    outArrayLength.set(array.length);
}


};

Ops.Array.AverageArray.prototype = new CABLES.Op();
CABLES.OPS["40011294-10c4-4174-aa18-1b891826f436"]={f:Ops.Array.AverageArray,objName:"Ops.Array.AverageArray"};




// **************************************************************
// 
// Ops.Array.BoolStateArray
// 
// **************************************************************

Ops.Array.BoolStateArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// constants
let ARRAY_LENGTH_DEFAULT = 10;
let INACTIVE_VALUE = 0;
let ACTIVE_VALUE = 1;

// variables
let stateArray = [];

// inputs
let arrayLengthPort = op.inValue("Array Length", ARRAY_LENGTH_DEFAULT);
let activeIndexPort = op.inValue("Active Index", 0);
let inactiveValuePort = op.inValue("Inactive Value", 0);
let activeValuePort = op.inValue("Active Value", 1);

// outputs
let stateArrayPort = op.outArray("State Array");

// change listeners
arrayLengthPort.onChange = update;
activeIndexPort.onChange = update;
inactiveValuePort.onChange = update;
activeValuePort.onChange = update;

// init
update();

// functions

function update()
{
    let arrLength = Math.max(0, arrayLengthPort.get());
    let activeIndex = Math.round(activeIndexPort.get());
    let inactiveValue = inactiveValuePort.get();
    let activeValue = activeValuePort.get();
    for (let i = 0; i < arrLength; i++)
    {
        if (i === activeIndex)
        {
            stateArray[i] = activeValue;
        }
        else
        {
            stateArray[i] = inactiveValue;
        }
    }
    stateArray.length = arrLength;
    stateArrayPort.set(null);
    stateArrayPort.set(stateArray);
}


};

Ops.Array.BoolStateArray.prototype = new CABLES.Op();
CABLES.OPS["f8c30313-4251-4d39-bff3-fb1cc9234d54"]={f:Ops.Array.BoolStateArray,objName:"Ops.Array.BoolStateArray"};




// **************************************************************
// 
// Ops.Array.CopyArray
// 
// **************************************************************

Ops.Array.CopyArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTriggerButton("Exec"),
    inArr = op.inArray("Array"),
    inReset = op.inTriggerButton("Reset"),

    deflt = op.inArray("Default"),
    outArr = op.outArray("Result");


function copyArray(source)
{
    let dest = [];
    dest.length = source.length;
    for (let i = 0; i < source.length; i++)
    {
        dest[i] = source[i];
    }
    return dest;
}

inReset.onTriggered =
deflt.onChange = function ()
{
    let arr = deflt.get();
    outArr.set(null);
    if (arr) outArr.set(copyArray(arr));
};

inExec.onTriggered = function ()
{
    let arr = inArr.get();
    if (!arr || !arr.length) return;
    const cop = copyArray(arr);
    outArr.set(null);
    outArr.set(cop);
};


};

Ops.Array.CopyArray.prototype = new CABLES.Op();
CABLES.OPS["2f9b834e-c357-4dc7-ac2e-966b11735ef8"]={f:Ops.Array.CopyArray,objName:"Ops.Array.CopyArray"};




// **************************************************************
// 
// Ops.Array.CropArray
// 
// **************************************************************

Ops.Array.CropArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    srcArrayPort = op.inArray("Source Array"),
    inStartIndex = op.inInt("Start Index"),
    newLengthPort = op.inInt("New Length"),
    croppedArrayOutPort = op.outArray("Cropped Array"),
    outArrayLength = op.outNumber("Array length");

inStartIndex.onChange = srcArrayPort.onChange = newLengthPort.onChange = setOutPort;

function setOutPort()
{
    const srcArray = srcArrayPort.get();

    if(!srcArray)
    {
        croppedArrayOutPort.set(null);
        outArrayLength.set(0);
        return;
    }
    var newLength = parseInt(newLengthPort.get());
    const start=Math.floor(Math.abs(inStartIndex.get()));

    if(start+newLength >= srcArray.length) newLength = srcArray.length-start;
    if(start+newLength <= srcArray.length)
    {
        var croppedArr = srcArray.slice(start, start+newLength);
        croppedArrayOutPort.set(null);
        croppedArrayOutPort.set(croppedArr);
        outArrayLength.set(croppedArr.length);
    }

}

};

Ops.Array.CropArray.prototype = new CABLES.Op();
CABLES.OPS["d8deecd3-418f-43dd-8edb-dfe238b5327c"]={f:Ops.Array.CropArray,objName:"Ops.Array.CropArray"};




// **************************************************************
// 
// Ops.Array.CutArray
// 
// **************************************************************

Ops.Array.CutArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const srcArrayPort = op.inArray("Source Array");
const inStartIndex = op.inInt("Remove from Start");
const inEndIndex = op.inInt("Remove From End");
const croppedArrayOutPort = op.outArray("Cut Array");
const outArrayLength = op.outNumber("Array Length");

inStartIndex.onChange = inEndIndex.onChange = srcArrayPort.onChange = setOutPort;

function setOutPort()
{
    const srcArray = srcArrayPort.get();

    if (!srcArray)
    {
        croppedArrayOutPort.set(null);
        outArrayLength.set(0);
        return;
    }

    const oldLength = srcArray.length;
    const start = Math.max(0, Number(inStartIndex.get()));
    const end = Math.max(0, Number(inEndIndex.get()));

    const newArr = [];

    for (let i = start; i < oldLength - end; i += 1)
    {
        newArr.push(srcArray[i]);
    }

    croppedArrayOutPort.set(null);
    croppedArrayOutPort.set(newArr);
    outArrayLength.set(newArr.length);
}


};

Ops.Array.CutArray.prototype = new CABLES.Op();
CABLES.OPS["9e6ea32a-3f5d-417a-b437-05c59d47c56e"]={f:Ops.Array.CutArray,objName:"Ops.Array.CutArray"};




// **************************************************************
// 
// Ops.Array.EaseArray
// 
// **************************************************************

Ops.Array.EaseArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inMin = op.inValue("Min", 0),
    inMax = op.inValue("Max", 1),
    outArr = op.outArray("Result Array"),
    anim = new CABLES.Anim();

anim.createPort(op, "Easing", updateAnimEasing);
anim.setValue(0, 0);
anim.setValue(1, 1);
let resultArr = [];
op.onLoaded = inMin.onChange = inMax.onChange = updateMinMax;

inArr.onChange = updateArray;

function updateMinMax()
{
    anim.keys[0].time = anim.keys[0].value = Math.min(inMin.get(), inMax.get());
    anim.keys[1].time = anim.keys[1].value = Math.max(inMin.get(), inMax.get());
}

function updateAnimEasing()
{
    anim.keys[0].setEasing(anim.defaultEasing);
    updateArray();
}

function updateArray()
{
    const arr = inArr.get();
    if (!arr)
    {
        outArr.set(null);
        return;
    }
    resultArr.length = arr.length;

    for (let i = 0; i < arr.length; i++)
    {
        resultArr[i] = anim.getValue(arr[i]);
    }
    outArr.set(null);
    outArr.set(resultArr);
}


};

Ops.Array.EaseArray.prototype = new CABLES.Op();
CABLES.OPS["3bda237e-819a-43d8-9fb8-0f32bd3f7cc8"]={f:Ops.Array.EaseArray,objName:"Ops.Array.EaseArray"};




// **************************************************************
// 
// Ops.Array.FillArrayRandomDuplicates_v2
// 
// **************************************************************

Ops.Array.FillArrayRandomDuplicates_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inNum = op.inValueInt("Num Elements", 10),
    inSeed = op.inValueFloat("Random seed", 1),
    outArr = op.outArray("Result");

op.toWorkPortsNeedToBeLinked(inArr);

let arr = [];

inArr.onChange =
    inNum.onChange =
    inSeed.onChange = () =>
    {
        let oldArr = inArr.get();

        if (!oldArr) return outArr.set(null);

        let num = inNum.get();
        let numOld = oldArr.length;

        Math.randomSeed = inSeed.get();
        arr.length = num;

        for (let i = 0; i < num; i++)
        {
            let ind = Math.floor(Math.seededRandom() * numOld);
            arr[i] = oldArr[ind];
        }

        outArr.set(null);
        outArr.set(arr);
    };


};

Ops.Array.FillArrayRandomDuplicates_v2.prototype = new CABLES.Op();
CABLES.OPS["cbf5f595-9fbe-45a9-a324-5089665e8e51"]={f:Ops.Array.FillArrayRandomDuplicates_v2,objName:"Ops.Array.FillArrayRandomDuplicates_v2"};




// **************************************************************
// 
// Ops.Array.FilterArray
// 
// **************************************************************

Ops.Array.FilterArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inArrayStide = op.inSwitch("Stride", ["X", "XY", "XYZ", "XYZW"], "XYZ"),
    inEle = op.inSwitch("Compare Element", ["X", "Y", "Z", "W"], "Z"),
    inMeth = op.inSwitch("Filter Method", [">", "<"], "<"),
    inFilterNum = op.inFloat("Compare to", 0.5),
    outArr = op.outArray("Result");

let compEl = 2;
let stride = 3;

inEle.onChange = () =>
{
    if (inEle.get() == "X")compEl = 0;
    else if (inEle.get() == "Y")compEl = 1;
    else if (inEle.get() == "Z")compEl = 2;
    else if (inEle.get() == "W")compEl = 3;

    update();
};

inArrayStide.onChange = () =>
{
    if (inArrayStide.get() == "X")stride = 1;
    else if (inArrayStide.get() == "XY")stride = 2;
    else if (inArrayStide.get() == "XYZ")stride = 3;
    else if (inArrayStide.get() == "XYZW")stride = 4;

    update();
};

inMeth.onChange =
inFilterNum.onChange =
inArr.onChange = update;

function update()
{
    const arr = inArr.get();
    const newArr = [];
    if (!arr) return;

    if (inMeth.get() == "<")
    {
        for (let i = 0; i < arr.length; i += stride)
            if (arr[i + compEl] < inFilterNum.get()) // comparison
                for (let j = 0; j < stride; j++)
                    newArr.push(arr[i + j]);
    }
    else if (inMeth.get() == ">")
    {
        for (let i = 0; i < arr.length; i += stride)
            if (arr[i + compEl] > inFilterNum.get()) // comparison
                for (let j = 0; j < stride; j++)
                    newArr.push(arr[i + j]);
    }

    outArr.set(null);
    outArr.set(newArr);
}


};

Ops.Array.FilterArray.prototype = new CABLES.Op();
CABLES.OPS["ea396c36-c070-44d8-ae0b-fd0bffa56b35"]={f:Ops.Array.FilterArray,objName:"Ops.Array.FilterArray"};




// **************************************************************
// 
// Ops.Array.FilterValidArray
// 
// **************************************************************

Ops.Array.FilterValidArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inLength = op.inBool("Invalid when length is 0", true),

    outArray = op.outArray("Last Valid Array"),
    outValid = op.outBool("Is Valid");

inLength.onChange =
inArr.onChange =
    update;

function update()
{
    const arr = inArr.get();

    let r = true;

    if (!arr || !arr.length) r = false;
    else if (inLength.get() && arr.length == 0) r = false;

    if (r)
    {
        outArray.set([]);
        outArray.set(arr);
    }

    outValid.set(r);
}


};

Ops.Array.FilterValidArray.prototype = new CABLES.Op();
CABLES.OPS["f2669593-eb06-48a6-b94c-4bc243747ee1"]={f:Ops.Array.FilterValidArray,objName:"Ops.Array.FilterValidArray"};




// **************************************************************
// 
// Ops.Array.FlattenArray
// 
// **************************************************************

Ops.Array.FlattenArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArr=op.inArray("Array"),
 outArr=op.outArray("Result");

 inArr.onChange=function()
 {
     var arr=inArr.get();
    outArr.set(null);

     if(!arr)
     {
         return;
     }


    var newArr=arr.slice(0);
    newArr=newArr.flat(Infinity);

    outArr.set(newArr);


 };


};

Ops.Array.FlattenArray.prototype = new CABLES.Op();
CABLES.OPS["bd5f43cf-7a69-4bff-85b3-08df62b899b4"]={f:Ops.Array.FlattenArray,objName:"Ops.Array.FlattenArray"};




// **************************************************************
// 
// Ops.Array.GateArray_v2
// 
// **************************************************************

Ops.Array.GateArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const passThrough = op.inValueBool("Pass Through", true),
    arrayIn = op.inArray("Array in"),
    arrayOut = op.outArray("Array Out");

let oldArr = null;

function copyArray(source)
{
    if (!source) return null;
    const dest = [];
    dest.length = source.length;
    for (let i = 0; i < source.length; i++)
    {
        dest[i] = source[i];
    }
    return dest;
}

arrayIn.onChange = passThrough.onChange = function ()
{
    if (passThrough.get())
    {
        oldArr = copyArray(arrayIn.get());
        arrayOut.set(oldArr);
    }
    // else
    // {
    //     arrayOut.set(oldArr);
    // }
};


};

Ops.Array.GateArray_v2.prototype = new CABLES.Op();
CABLES.OPS["e28a489c-46b6-4279-928c-6b0cbaaaae2a"]={f:Ops.Array.GateArray_v2,objName:"Ops.Array.GateArray_v2"};




// **************************************************************
// 
// Ops.Array.GetValuesFromArrayOfObjects
// 
// **************************************************************

Ops.Array.GetValuesFromArrayOfObjects = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inKey = op.inString("Key"),
    inignoreNonNums = op.inBool("Numbers Only", false),
    inRemoveInvalid = op.inBool("Remove empty/invalid", false),
    outArray = op.outArray("Result");

inRemoveInvalid.onChange =
inKey.onChange =
inArr.onChange =
inignoreNonNums.onChange = exec;

function exec()
{
    const arr = inArr.get();

    if (!arr)
    {
        outArray.set(null);
        return;
    }

    const newArr = [];
    const key = inKey.get();
    const numsonly = inignoreNonNums.get();

    op.setUiAttrib({ "extendTitle": inKey.get() });

    const removeInvalid = inRemoveInvalid.get();

    for (let i = 0; i < arr.length; i++)
    {
        const obj = arr[i];

        if (obj)
        {
            if (!(key in obj)) continue;

            const v = obj[key];

            if (removeInvalid)
            {
                if (v === "" ||
                    v === null ||
                    v === undefined

                ) continue;
            }

            if (numsonly)
            {
                if (CABLES.UTILS.isNumeric(v)) newArr.push(parseFloat(v));
            }
            else
            {
                newArr.push(v);
            }
        }
    }

    outArray.set(null);
    outArray.set(newArr);
}


};

Ops.Array.GetValuesFromArrayOfObjects.prototype = new CABLES.Op();
CABLES.OPS["e068629a-7963-48b0-853f-a89348d03654"]={f:Ops.Array.GetValuesFromArrayOfObjects,objName:"Ops.Array.GetValuesFromArrayOfObjects"};




// **************************************************************
// 
// Ops.Array.HSBtoRGBArray
// 
// **************************************************************

Ops.Array.HSBtoRGBArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function HSBtoRGB(hue, saturation, lightness)
{
    // based on algorithm from http://en.wikipedia.org/wiki/HSL_and_HSV#Converting_to_RGB
    const chroma = (1 - Math.abs((2 * lightness) - 1)) * saturation;
    let huePrime = hue * 6; // / 60;
    let secondComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));

    huePrime = Math.floor(huePrime) || 0;
    let red = 0;
    let green = 0;
    let blue = 0;

    if (huePrime === 0)
    {
        red = chroma;
        green = secondComponent;
        blue = 0;
    }
    else if (huePrime === 1)
    {
        red = secondComponent;
        green = chroma;
        blue = 0;
    }
    else if (huePrime === 2)
    {
        red = 0;
        green = chroma;
        blue = secondComponent;
    }
    else if (huePrime === 3)
    {
        red = 0;
        green = secondComponent;
        blue = chroma;
    }
    else if (huePrime === 4)
    {
        red = secondComponent;
        green = 0;
        blue = chroma;
    }
    else if (huePrime >= 5)
    {
        red = chroma;
        green = 0;
        blue = secondComponent;
    }

    const lightnessAdjustment = (lightness - (chroma / 2));

    red += lightnessAdjustment;
    green += lightnessAdjustment;
    blue += lightnessAdjustment;

    return [red, green, blue];
}

const inTrigger = op.inTrigger("Trigger Input");
const inHue = op.inArray("In Hue Array");
const inSat = op.inArray("In Saturation Array");
const inBright = op.inArray("In Brightness Array");
const inAlpha = op.inArray("In Alpha Array");

const outTrigger = op.outTrigger("Trigger Output");
const outArray = op.outArray("Result Array");
const outLength = op.outNumber("Array Length", 0);
const outTupleLength = op.outNumber("RGBA Tuple Length", 0);

let newArr = [];
const emptyArr = [];
outArray.set(newArr);
outLength.set(newArr.length);
outTupleLength.set(newArr.length / 4);

outArray.ignoreValueSerialize = true;
inAlpha.ignoreValueSerialize = true;
inBright.ignoreValueSerialize = true;
inSat.ignoreValueSerialize = true;
inHue.ignoreValueSerialize = true;

let shouldRecalculate = true;

inTrigger.onTriggered = handleTrigger;
inHue.onChange = inSat.onChange = inBright.onChange = inAlpha.onChange = function () { shouldRecalculate = true; };

function handleTrigger()
{
    let arrH = inHue.get();
    let arrS = inSat.get();
    let arrB = inBright.get();
    let arrA = inAlpha.get();

    if (!arrH && !arrS && !arrB && !arrA)
    {
        outArray.set(null);
        outLength.set(0);
        outTupleLength.set(0);
        return;
    }

    let length = 0;

    if (shouldRecalculate)
    {
        if ([arrH, arrS, arrB, arrA].some(function (array) { return !array; }))
        {
            if (arrH) length = arrH.length;
            else if (arrS) length = arrS.length;
            else if (arrB) length = arrB.length;
            else if (arrA) length = arrA.length;

            emptyArr.length = length;
            for (let i = 0; i < length; i += 1) emptyArr[i] = 0;

            if (!arrH) arrH = emptyArr.map(function (val) { return 0; });
            if (!arrS) arrS = emptyArr.map(function (val) { return 1; });
            if (!arrB) arrB = emptyArr.map(function (val) { return 0.5; });
            if (!arrA) arrA = emptyArr.map(function (val) { return 1; });
        }
        else
        {
            length = arrH.length;
        }

        const areSameLength = [arrH, arrS, arrB, arrA].every(function (val, i, arr) { return val.length === length; });

        if (!areSameLength)
        {
            // op.log([arrH, arrS, arrB, arrA].map(a => a.length), length);
            op.setUiError("arrlen", "Arrays don't have the same length!");
        }
        else
        {
            op.setUiError("arrlen", null);
        }

        newArr.length = length * 4;

        for (let i = 0; i < newArr.length / 4; i += 1)
        {
            const hsbArray = HSBtoRGB(arrH[i], arrS[i], arrB[i]);
            newArr[i * 4 + 0] = hsbArray[0];
            newArr[i * 4 + 1] = hsbArray[1];
            newArr[i * 4 + 2] = hsbArray[2];
            newArr[i * 4 + 3] = arrA[i];
        }

        shouldRecalculate = false;
        outArray.set(null);
        outArray.set(newArr);
        outLength.set(newArr.length);
        outTupleLength.set(newArr.length / 4);
    }
    outTrigger.trigger();
}


};

Ops.Array.HSBtoRGBArray.prototype = new CABLES.Op();
CABLES.OPS["0f552671-7431-4031-97e3-211f2cf9f111"]={f:Ops.Array.HSBtoRGBArray,objName:"Ops.Array.HSBtoRGBArray"};




// **************************************************************
// 
// Ops.Array.InfoArray
// 
// **************************************************************

Ops.Array.InfoArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    outMin = op.outNumber("Min"),
    outMax = op.outNumber("Max"),
    outAvg = op.outNumber("Average");

inArr.onChange = function ()
{
    let arr = inArr.get();

    let min = 999999999;
    let max = -999999999;
    let avg = 0;

    if (arr)
    {
        for (let i = 0; i < arr.length; i++)
        {
            avg += arr[i];
            min = Math.min(min, arr[i]);
            max = Math.max(max, arr[i]);
        }
        avg /= arr.length;
    }
    outMin.set(min);
    outMax.set(max);
    outAvg.set(avg);
};


};

Ops.Array.InfoArray.prototype = new CABLES.Op();
CABLES.OPS["1db230c8-212f-4679-87d6-3531659363da"]={f:Ops.Array.InfoArray,objName:"Ops.Array.InfoArray"};




// **************************************************************
// 
// Ops.Array.InfoArray2
// 
// **************************************************************

Ops.Array.InfoArray2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inArr = op.inArray("Array", 2),

    outNum = op.outNumber("Num Items"),

    outMinX = op.outNumber("Min X"),
    outMaxX = op.outNumber("Max X"),
    outAvgX = op.outNumber("Average X"),

    outMinY = op.outNumber("Min Y"),
    outMaxY = op.outNumber("Max Y"),
    outAvgY = op.outNumber("Average Y");

inArr.onChange = function ()
{
    let arr = inArr.get();

    let minX = 999999999;
    let maxX = -999999999;
    let avgX = 0;

    let minY = 999999999;
    let maxY = -999999999;
    let avgY = 0;
    outNum.set(0);

    if (arr)
    {
        outNum.set(arr.length / 2);

        for (let i = 0; i < arr.length; i += 2)
        {
            avgX += arr[i];
            minX = Math.min(minX, arr[i]);
            maxX = Math.max(maxX, arr[i]);

            avgY += arr[i + 1];
            minY = Math.min(minY, arr[i + 1]);
            maxY = Math.max(maxY, arr[i + 1]);
        }

        avgX /= arr.length / 2;
        avgY /= arr.length / 2;
    }

    outMinX.set(minX);
    outMaxX.set(maxX);
    outAvgX.set(avgX);

    outMinY.set(minY);
    outMaxY.set(maxY);
    outAvgY.set(avgY);
};


};

Ops.Array.InfoArray2.prototype = new CABLES.Op();
CABLES.OPS["0ea5fb62-94e7-4a1b-928f-bdcab373c022"]={f:Ops.Array.InfoArray2,objName:"Ops.Array.InfoArray2"};




// **************************************************************
// 
// Ops.Array.InfoArray3
// 
// **************************************************************

Ops.Array.InfoArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inArr = op.inArray("Array"),

    outNum = op.outNumber("Num Items"),

    outMinX = op.outNumber("Min X"),
    outMaxX = op.outNumber("Max X"),
    outAvgX = op.outNumber("Average X"),

    outMinY = op.outNumber("Min Y"),
    outMaxY = op.outNumber("Max Y"),
    outAvgY = op.outNumber("Average Y"),

    outMinZ = op.outNumber("Min Z"),
    outMaxZ = op.outNumber("Max Z"),
    outAvgZ = op.outNumber("Average Z");

inArr.onChange = function ()
{
    let arr = inArr.get();

    let minX = 999999999;
    let maxX = -999999999;
    let avgX = 0;

    let minZ = 999999999;
    let maxZ = -999999999;
    let avgZ = 0;

    let minY = 999999999;
    let maxY = -999999999;
    let avgY = 0;
    outNum.set(0);

    if (arr)
    {
        outNum.set(arr.length / 3);

        for (let i = 0; i < arr.length; i += 3)
        {
            avgX += arr[i];
            minX = Math.min(minX, arr[i]);
            maxX = Math.max(maxX, arr[i]);

            avgY += arr[i + 1];
            minY = Math.min(minY, arr[i + 1]);
            maxY = Math.max(maxY, arr[i + 1]);

            avgZ += arr[i + 2];
            minZ = Math.min(minZ, arr[i + 2]);
            maxZ = Math.max(maxZ, arr[i + 2]);
        }

        avgX /= arr.length / 3;
        avgY /= arr.length / 3;
        avgZ /= arr.length / 3;
    }

    outMinX.set(minX);
    outMaxX.set(maxX);
    outAvgX.set(avgX);

    outMinY.set(minY);
    outMaxY.set(maxY);
    outAvgY.set(avgY);

    outMinZ.set(minZ);
    outMaxZ.set(maxZ);
    outAvgZ.set(avgZ);
};


};

Ops.Array.InfoArray3.prototype = new CABLES.Op();
CABLES.OPS["e2ace702-eed6-4b40-86f6-cea716ba8579"]={f:Ops.Array.InfoArray3,objName:"Ops.Array.InfoArray3"};




// **************************************************************
// 
// Ops.Array.InterpolateArrays
// 
// **************************************************************

Ops.Array.InterpolateArrays = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Exe"),
    inArr1 = op.inArray("Array 1"),
    inArr2 = op.inArray("Array 2"),
    inPerc = op.inValueSlider("perc"),
    next = op.outTrigger("Next"),
    outArr = op.outArray("Result");

let needsCalc = true;
let resultArr = [];

function calcLater()
{
    needsCalc = true;
}

inArr1.onChange = inArr2.onChange = inPerc.onChange = calcLater;

exe.onTriggered = execute;

function execute()
{
    let arr1 = inArr1.get();
    let arr2 = inArr2.get();

    let val1;
    let val2;
    let m;

    if (!arr1 || !arr2 || arr1.length < arr2.length)
    {
        outArr.set(null);
        return;
    }

    if (needsCalc)
    {
        if (resultArr.length != arr1.length) resultArr.length = arr1.length;

        let perc = inPerc.get();

        for (let i = 0; i < arr1.length; i++)
        {
            val1 = arr1[i];
            val2 = arr2[i];
            m = (val2 - val1) * perc + val1;
            resultArr[i] = m;
        }
        needsCalc = false;
        outArr.set(null);
        outArr.set(resultArr);
    }

    next.trigger();
}

// check that array input is string or not
inArr1.onLinkChanged = inArr2.onLinkChanged = function ()
{
    let arr1 = inArr1.get();
    let arr2 = inArr2.get();

    if (!arr1 || !arr2)
    {
        outArr.set(null);
        return;
    }

    let stringTest1 = arr1[0];
    let stringTest2 = arr2[0];

    if (typeof stringTest1 === "string" || typeof stringTest2 === "string")
    {
        outArr.set(null);
    }
};


};

Ops.Array.InterpolateArrays.prototype = new CABLES.Op();
CABLES.OPS["09296117-7312-4f80-982b-7b4a81d22cf8"]={f:Ops.Array.InterpolateArrays,objName:"Ops.Array.InterpolateArrays"};




// **************************************************************
// 
// Ops.Array.InterpolateArraysRange
// 
// **************************************************************

Ops.Array.InterpolateArraysRange = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("Exe");
const inArr1 = op.inArray("Array 1");
const inArr2 = op.inArray("Array 2");

const inPos = op.inValueSlider("Pos");
const inWidth = op.inValueSlider("Width");

const easing = op.inValueSelect("Easing", [
    "Linear",
    "Expo in", "Expo out", "Expo in out",
    "Cubic in", "Cubic out", "Cubic in out"],
"Linear");

const reverse = op.inValueBool("Reverse");

const next = op.outTrigger("Next");
const outArr = op.outArray("Result");

const resultArr = [];
let easingFunction = null;

easing.onChange = function ()
{
    if (easing.get() == "Expo in") easingFunction = CABLES.easeExpoIn;
    else if (easing.get() == "Expo out") easingFunction = CABLES.easeExpoOut;
    else if (easing.get() == "Expo in out") easingFunction = CABLES.easeExpoInOut;
    else if (easing.get() == "Cubic in") easingFunction = CABLES.easeCubicIn;
    else if (easing.get() == "Cubic out") easingFunction = CABLES.easeCubicOut;
    else if (easing.get() == "Cubic in out") easingFunction = CABLES.easeCubicInOut;
    else easingFunction = null;
};

let needsUpdate = true;

inArr1.onChange =
inArr2.onChange =
inPos.onChange =
inWidth.onChange = () =>
{
    needsUpdate = true;
};

exe.onTriggered = function ()
{
    const arr1 = inArr1.get();
    const arr2 = inArr2.get();

    if (needsUpdate)
        if (!arr1 || !arr2 || arr2.length < arr1.length)
        {
            outArr.set(null);
        }
        else
        {
            if (resultArr.length != arr1.length) resultArr.length = arr1.length;
            const distNum = inWidth.get() * (resultArr.length * 4);
            const pos = inPos.get() * (arr1.length + distNum);

            for (let i = 0; i < arr1.length; i++)
            {
                const val1 = arr1[i];
                const val2 = arr2[i];

                let ppos = pos - i;
                if (reverse.get())ppos = pos - (arr1.length - i);
                let dist = ppos / distNum;

                if (dist > 1) resultArr[i] = val2;
                else if (dist <= 0) resultArr[i] = val1;
                else
                {
                    if (easingFunction) dist = easingFunction(dist);
                    const m = ((val2 - val1) * dist + val1);
                    resultArr[i] = m;
                }
            }

            outArr.set(null);
            outArr.set(resultArr);
        }

    next.trigger();
    needsUpdate = false;
};


};

Ops.Array.InterpolateArraysRange.prototype = new CABLES.Op();
CABLES.OPS["f89f5664-7cfa-4598-b09c-e4320b588b45"]={f:Ops.Array.InterpolateArraysRange,objName:"Ops.Array.InterpolateArraysRange"};




// **************************************************************
// 
// Ops.Array.InterpolateNumbersArray
// 
// **************************************************************

Ops.Array.InterpolateNumbersArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inIndex = op.inValue("Index Position"),
    inArr = op.inArray("Array"),
    outX = op.outNumber("result");

inIndex.onChange = inArr.onChange = function ()
{
    let i = Math.floor(inIndex.get());
    let fr = inIndex.get() - Math.floor(inIndex.get());
    let arr = inArr.get();

    if (i < 0 || !arr)
    {
        return;
    }

    if (i >= arr.length - 1)
    {
        outX.set(arr[arr.length - 1]);
        return;
    }

    let x = arr[i + 0];

    let x2 = arr[i + 1];

    x += (x2 - x) * fr;

    outX.set(x);
};


};

Ops.Array.InterpolateNumbersArray.prototype = new CABLES.Op();
CABLES.OPS["d0894a6b-f921-4542-aafc-3f1b21615a44"]={f:Ops.Array.InterpolateNumbersArray,objName:"Ops.Array.InterpolateNumbersArray"};




// **************************************************************
// 
// Ops.Array.InterpolateNumbersArray3
// 
// **************************************************************

Ops.Array.InterpolateNumbersArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inIndex = op.inValue("Index Position"),
    inArr = op.inArray("Array"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z");

inIndex.onChange = inArr.onChange = function ()
{
    let i = inIndex.get();
    const arr = inArr.get();

    if (i < 0 || !arr)
    {
        return;
    }

    const maxIdx = Math.floor((arr.length / 3) - 1);
    const intIdx = Math.floor(inIndex.get());
    if (intIdx == maxIdx)
    {
        outX.set(arr[arr.length - 3]);
        outY.set(arr[arr.length - 2]);
        outZ.set(arr[arr.length - 1]);
        return;
    }

    const fr = inIndex.get() - Math.floor(inIndex.get());
    i = Math.floor((inIndex.get())) * 3;
    i %= (arr.length);

    let x = arr[i + 0];
    let y = arr[i + 1];
    let z = arr[i + 2];

    const x2 = arr[i + 3];
    const y2 = arr[i + 4];
    const z2 = arr[i + 5];

    x += (x2 - x) * fr;
    y += (y2 - y) * fr;
    z += (z2 - z) * fr;

    outX.set(x);
    outY.set(y);
    outZ.set(z);
};


};

Ops.Array.InterpolateNumbersArray3.prototype = new CABLES.Op();
CABLES.OPS["1feb4565-32c5-4fb9-b869-88502b461256"]={f:Ops.Array.InterpolateNumbersArray3,objName:"Ops.Array.InterpolateNumbersArray3"};




// **************************************************************
// 
// Ops.Array.IteratorArray3
// 
// **************************************************************

Ops.Array.IteratorArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Execute"),
    arr = op.inArray("Array"),
    pStep = op.inValue("Step"),
    trigger = op.outTrigger("Trigger"),
    idx = op.outNumber("Index"),
    valX = op.outNumber("Value 1"),
    valY = op.outNumber("Value 2"),
    valZ = op.outNumber("Value 3");

let ar = arr.get() || [];

let vstep = 1;
pStep.onChange = changeStep;
changeStep();

let i = 0;
let count = 0;

arr.onChange = function ()
{
    ar = arr.get() || [];
};

function changeStep()
{
    vstep = pStep.get() || 1;
    if (vstep < 1.0)vstep = 1.0;
    vstep = 3 * vstep;
}

exe.onTriggered = function ()
{
    count = 0;

    for (let i = 0, len = ar.length; i < len; i += vstep)
    // for (var i = ar.length-1; i >=0; i-=vstep)
    {
        idx.set(count);
        valX.set(ar[i + 0]);
        valY.set(ar[i + 1]);
        valZ.set(ar[i + 2]);
        trigger.trigger();
        count++;
    }
};


};

Ops.Array.IteratorArray3.prototype = new CABLES.Op();
CABLES.OPS["3f7db864-7409-418f-8c03-b2c966c050b3"]={f:Ops.Array.IteratorArray3,objName:"Ops.Array.IteratorArray3"};




// **************************************************************
// 
// Ops.Array.LissajouseSpline
// 
// **************************************************************

Ops.Array.LissajouseSpline = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inForm=op.inValueSelect("Formula",[1,2,3],1),
    inA=op.inValueInt("A",5),
    inB=op.inValueInt("B",4),
    inC=op.inValueInt("C",1),
    inD=op.inValueInt("D",2),
    result=op.outArray("Result"),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

inForm.onChange=inA.onChange=inB.onChange=inC.onChange=inD.onChange=calc;
calc();

function calc()
{
    var numPoints=13200;
    var step=40;

    var arr=[];
    var x=0,y=0,z=0;
    var form=parseInt(inForm.get());
    var th=0.03;

    for(var i = 0; i < numPoints; i+=step)
    {
        var index=i/step;

        if(form==1)
        {
            x=Math.sin( (i * inA.get()) * 0.001 );
            y=Math.cos( (i * inB.get()) * 0.001 );
            z=Math.sin( (i * inC.get()) * 0.001 );
        }
        else if(form==2)
        {
            x=(Math.cos( (i * inA.get()) * 0.001 )+Math.cos( (i * inB.get()) * 0.001 ) )/2;
            y=(Math.sin( (i * inA.get()) * 0.001 )+Math.sin( (i * inC.get()) * 0.001 ) )/2;
            z=(Math.sin( (i * inD.get()) * 0.001 ));
        }
        else if(form==3)
        {
            x=(Math.sin( (i * inA.get()) * 0.001 )*(1+Math.cos( (i * inB.get()) * 0.001 ) ))/2;
            y=(Math.sin( (i * inA.get()) * 0.001 )*(1+Math.sin( (i * inC.get()) * 0.001 ) ))/2;
            z=(Math.sin( (i * inD.get()) * 0.001 ));
        }

        arr[index*3+0] = x;
        arr[index*3+1] = y;
        arr[index*3+2] = z;

        if(index>10 && Math.abs(x-arr[0])<th && Math.abs(y-arr[1])<th && Math.abs(z-arr[2])<th)
        {
            // this method sucks but kinda works....
            break;
        }
    }

    result.set(arr);
    outTotalPoints.set(arr.length/3);
    outArrayLength.set(arr.length);
}



};

Ops.Array.LissajouseSpline.prototype = new CABLES.Op();
CABLES.OPS["b4be3f11-20ed-43a0-865d-2b88f0879a6f"]={f:Ops.Array.LissajouseSpline,objName:"Ops.Array.LissajouseSpline"};




// **************************************************************
// 
// Ops.Array.LoopArray3
// 
// **************************************************************

Ops.Array.LoopArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array in"),
    outArray = op.outArray("Array out");

let newArray = [];

inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr)
    {
        outArray.set(null);
        return;
    }

    if (newArray.length !== arr.length) newArray.length = arr.length + 3;
    let i;
    for (i = 0; i < arr.length; i += 3)
    {
        newArray[i + 0] = arr[i + 0];
        newArray[i + 1] = arr[i + 1];
        newArray[i + 2] = arr[i + 2];
    }

    newArray[i + 0] = arr[0];
    newArray[i + 1] = arr[1];
    newArray[i + 2] = arr[2];

    outArray.set(null);
    outArray.set(newArray);
};


};

Ops.Array.LoopArray3.prototype = new CABLES.Op();
CABLES.OPS["9a911a46-af51-47c4-acb6-4f7ad026caab"]={f:Ops.Array.LoopArray3,objName:"Ops.Array.LoopArray3"};




// **************************************************************
// 
// Ops.Array.MapRangeArray
// 
// **************************************************************

Ops.Array.MapRangeArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    result = op.outArray("result"),
    v = op.inArray("array"),
    old_min = op.inValueFloat("old min"),
    old_max = op.inValueFloat("old max"),
    new_min = op.inValueFloat("new min"),
    new_max = op.inValueFloat("new max"),
    easing = op.inValueSelect("Easing", ["Linear", "Smoothstep", "Smootherstep"], "Linear");

op.setPortGroup("Input Range", [old_min, old_max]);
op.setPortGroup("Output Range", [new_min, new_max]);

let ease = 0;
let r = 0;

easing.onChange = function ()
{
    if (easing.get() === "Smoothstep")
    {
        ease = 1;
    }
    else if (easing.get() === "Smootherstep")
    {
        ease = 2;
    }
    else
    {
        ease = 0;
    }
    exec();
};

function exec()
{
    const inArray = v.get();
    if (!inArray || inArray.length === 0)
    {
        result.set([]);
        return;
    }
    const outArray = Array(inArray.length);
    for (let i = 0; i < inArray.length; i++)
    {
        let x = inArray[i];

        if (x >= Math.max(old_max.get(), old_min.get()))
        {
            outArray[i] = new_max.get();
        }
        else if (x <= Math.min(old_max.get(), old_min.get()))
        {
            outArray[i] = new_min.get();
        }
        else
        {
            const nMin = new_min.get();
            const nMax = new_max.get();
            const oMin = old_min.get();
            const oMax = old_max.get();

            let reverseInput = false;
            const oldMin = Math.min(oMin, oMax);
            const oldMax = Math.max(oMin, oMax);
            if (oldMin !== oMin) reverseInput = true;

            let reverseOutput = false;
            const newMin = Math.min(nMin, nMax);
            const newMax = Math.max(nMin, nMax);
            if (newMin !== nMin) reverseOutput = true;

            let portion = 0;

            if (reverseInput)
            {
                portion = (oldMax - x) * (newMax - newMin) / (oldMax - oldMin);
            }
            else
            {
                portion = (x - oldMin) * (newMax - newMin) / (oldMax - oldMin);
            }

            if (reverseOutput)
            {
                r = newMax - portion;
            }
            else
            {
                r = portion + newMin;
            }

            if (ease === 0)
            {
                outArray[i] = r;
            }
            else if (ease === 1)
            {
                x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
                outArray[i] = nMin + x * x * (3 - 2 * x) * (nMax - nMin); // smoothstep
            }
            else if (ease === 2)
            {
                x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
                outArray[i] = nMin + x * x * x * (x * (x * 6 - 15) + 10) * (nMax - nMin); // smootherstep
            }
        }
    }
    result.set(outArray);
}

v.set(null);
old_min.set(0);
old_max.set(1);
new_min.set(-1);
new_max.set(1);

v.onChange = exec;
old_min.onChange = exec;
old_max.onChange = exec;
new_min.onChange = exec;
new_max.onChange = exec;

result.set(null);

exec();


};

Ops.Array.MapRangeArray.prototype = new CABLES.Op();
CABLES.OPS["20f921bf-adc2-45fb-b387-834af4f5e19b"]={f:Ops.Array.MapRangeArray,objName:"Ops.Array.MapRangeArray"};




// **************************************************************
// 
// Ops.Array.PaletteLibrary
// 
// **************************************************************

Ops.Array.PaletteLibrary = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const outArrayPalette = op.outArray("Palette Array out");

const colors=[
'#E6E2AF','#A7A37E','#EFECCA','#046380','002F2F',
'#468966','#FFF0A5','#FFB03B','#B64926','8E2800',
'#FCFFF5','#D1DBBD','#91AA9D','#3E606F','193441',
'#FF6138','#FFFF9D','#BEEB9F','#79BD8F','00A388',
'#105B63','#FFFAD5','#FFD34E','#DB9E36','BD4932',
'#225378','#1695A3','#ACF0F2','#F3FFE2','EB7F00',
'#2C3E50','#E74C3C','#ECF0F1','#3498DB','2980B9',
'#000000','#263248','#7E8AA2','#FFFFFF','FF9800',
'#004358','#1F8A70','#BEDB39','#FFE11A','FD7400',
'#DC3522','#D9CB9E','#374140','#2A2C2B','1E1E20',
'#7D8A2E','#C9D787','#FFFFFF','#FFC0A9','FF8598',
'#B9121B','#4C1B1B','#F6E497','#FCFAE1','BD8D46',
'#2E0927','#D90000','#FF2D00','#FF8C00','04756F',
'#595241','#B8AE9C','#FFFFFF','#ACCFCC','8A0917',
'#10222B','#95AB63','#BDD684','#E2F0D6','F6FFE0',
'#F6F792','#333745','#77C4D3','#DAEDE2','EA2E49',
'#703030','#2F343B','#7E827A','#E3CDA4','C77966',
'#2F2933','#01A2A6','#29D9C2','#BDF271','FFFFA6',
'#D8CAA8','#5C832F','#284907','#382513','363942',
'#FFF8E3','#CCCC9F','#33332D','#9FB4CC','DB4105',
'#85DB18','#CDE855','#F5F6D4','#A7C520','493F0B',
'#04BFBF','#CAFCD8','#F7E967','#A9CF54','588F27',
'#292929','#5B7876','#8F9E8B','#F2E6B6','412A22',
'#332532','#644D52','#F77A52','#FF974F','A49A87',
'#405952','#9C9B7A','#FFD393','#FF974F','F54F29',
'#2B3A42','#3F5765','#BDD4DE','#EFEFEF','FF530D',
'#962D3E','#343642','#979C9C','#F2EBC7','348899',
'#96CA2D','#B5E655','#EDF7F2','#4BB5C1','7FC6BC',
'#1C1D21','#31353D','#445878','#92CDCF','EEEFF7',
'#3E454C','#2185C5','#7ECEFD','#FFF6E5','FF7F66',
'#00585F','#009393','#FFFCC4','#F0EDBB','FF3800',
'#B4AF91','#787746','#40411E','#32331D','C03000',
'#63A69F','#F2E1AC','#F2836B','#F2594B','CD2C24',
'#88A825','#35203B','#911146','#CF4A30','ED8C2B',
'#F2385A','#F5A503','#E9F1DF','#4AD9D9','36B1BF',
'#CFC291','#FFF6C5','#A1E8D9','#FF712C','695D46',
'#FF5335','#B39C85','#306E73','#3B424D','1D181F',
'#000000','#333333','#FF358B','#01B0F0','AEEE00',
'#E8E595','#D0A825','#40627C','#26393D','FFFAE4',
'#E7E8D1','#D3CEAA','#FBF7E4','#424242','8E001C',
'#354242','#ACEBAE','#FFFF9D','#C9DE55','7D9100',
'#2F2933','#01A2A6','#29D9C2','#BDF271','FFFFA6',
'#DDDCC5','#958976','#611427','#1D2326','6A6A61',
'#6C6E58','#3E423A','#417378','#A4CFBE','F4F7D9',
'#E1E6FA','#C4D7ED','#ABC8E2','#375D81','183152',
'#6B0C22','#D9042B','#F4CB89','#588C8C','011C26',
'#304269','#91BED4','#D9E8F5','#FFFFFF','F26101',
'#96CEB4','#FFEEAD','#FF6F69','#FFCC5C','AAD8B0',
'#B0CC99','#677E52','#B7CA79','#F6E8B1','89725B',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF5A49',
'#16193B','#35478C','#4E7AC7','#7FB2F0','ADD5F7',
'#00261C','#044D29','#168039','#45BF55','96ED89',
'#36362C','#5D917D','#A8AD80','#E6D4A7','825534',
'#F9E4AD','#E6B098','#CC4452','#723147','31152B',
'#2C3E50','#FC4349','#D7DADB','#6DBCDB','FFFFFF',
'#002635','#013440','#AB1A25','#D97925','EFE7BE',
'#FF8000','#FFD933','#CCCC52','#8FB359','192B33',
'#272F32','#9DBDC6','#FFFFFF','#FF3D2E','DAEAEF',
'#B8ECD7','#083643','#B1E001','#CEF09D','476C5E',
'#002F32','#42826C','#A5C77F','#FFC861','C84663',
'#5C4B51','#8CBEB2','#F2EBBF','#F3B562','F06060',
'#5A1F00','#D1570D','#FDE792','#477725','A9CC66',
'#5E0042','#2C2233','#005869','#00856A','8DB500',
'#52656B','#FF3B77','#CDFF00','#FFFFFF','B8B89F',
'#801637','#047878','#FFB733','#F57336','C22121',
'#730046','#BFBB11','#FFC200','#E88801','C93C00',
'#24221F','#363F45','#4B5F6D','#5E7C88','FEB41C',
'#E64661','#FFA644','#998A2F','#2C594F','002D40',
'#C24704','#D9CC3C','#FFEB79','#A0E0A9','00ADA7',
'#484A47','#C1CE96','#ECEBF0','#687D77','353129',
'#588C7E','#F2E394','#F2AE72','#D96459','8C4646',
'#BAB293','#A39770','#EFE4BD','#A32500','2B2922',
'#6A7059','#FDEEA7','#9BCC93','#1A9481','003D5C',
'#174C4F','#207178','#FF9666','#FFE184','F5E9BE',
'#D5FBFF','#9FBCBF','#647678','#2F3738','59D8E6',
'#DB5800','#FF9000','#F0C600','#8EA106','59631E',
'#450003','#5C0002','#94090D','#D40D12','FF1D23',
'#211426','#413659','#656F8C','#9BBFAB','F2EFDF',
'#EA6045','#F8CA4D','#F5E5C0','#3F5666','2F3440',
'#F2F2F2','#C6E070','#91C46C','#287D7D','1C344D',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF5A49',
'#705B35','#C7B07B','#E8D9AC','#FFF6D9','570026',
'#F7F2B2','#ADCF4F','#84815B','#4A1A2C','8E3557',
'#1A1F2B','#30395C','#4A6491','#85A5CC','D0E4F2',
'#25064D','#36175E','#553285','#7B52AB','9768D1',
'#004056','#2C858D','#74CEB7','#C9FFD5','FFFFCB',
'#CFCA4C','#FCF5BF','#9FE5C2','#5EB299','745A33',
'#776045','#A8C545','#DFD3B6','#FFFFFF','0092B2',
'#CC3910','#F1F2C0','#CCC59E','#8FA68E','332F29',
'#FF6600','#C13B00','#5E6D70','#424E4F','1B1D1E',
'#690011','#BF0426','#CC2738','#F2D99C','E5B96F',
'#1B1D26','#425955','#778C7A','#F1F2D8','BFBD9F',
'#F6B1C3','#F0788C','#DE264C','#BC0D35','A20D1E',
'#597533','#332F28','#61B594','#E6DEA5','C44E18',
'#3FB8AF','#7FC7AF','#DAD8A7','#FF9E9D','FF3D7F',
'#0F2D40','#194759','#296B73','#3E8C84','D8F2F0',
'#42282F','#74A588','#D6CCAD','#DC9C76','D6655A',
'#002A4A','#17607D','#FFF1CE','#FF9311','D64700',
'#003056','#04518C','#00A1D9','#47D9BF','F2D03B',
'#13140F','#D4FF00','#E4FFE6','#68776C','00D6DD',
'#FCFAD0','#A1A194','#5B605F','#464646','A90641',
'#289976','#67CC8E','#B1FF91','#FFE877','FF5600',
'#302B1D','#3F522B','#737D26','#A99E46','D9CB84',
'#56626B','#6C9380','#C0CA55','#F07C6C','AD5472',
'#32450C','#717400','#DC8505','#EC5519','BE2805',
'#C7B773','#E3DB9A','#F5FCD0','#B1C2B3','778691',
'#E83A25','#FFE9A3','#98CC96','#004563','191B28',
'#3399CC','#67B8DE','#91C9E8','#B4DCED','E8F8FF',
'#1A212C','#1D7872','#71B095','#DEDBA7','D13F32',
'#7D2A35','#CC9258','#917A56','#B4BA6C','FEFFC2',
'#E7E9D1','#D3D4AA','#FCFAE6','#444444','901808',
'#FFFFFF','#AEAEAE','#E64C66','#2D3E50','1BBC9B',
'#E0FFB3','#61C791','#31797D','#2A2F36','F23C55',
'#EB5937','#1C1919','#403D3C','#456F74','D3CBBD',
'#E6DD00','#8CB302','#008C74','#004C66','332B40',
'#14A697','#F2C12E','#F29D35','#F27649','F25252',
'#261822','#40152A','#731630','#CC1E2C','FF5434',
'#261F27','#FEE169','#CDD452','#F9722E','C9313D',
'#5C4B51','#8CBEB2','#F2EBBF','#F3B562','F06060',
'#2F3837','#C5C7B6','#FFF8D3','#4C493E','222028',
'#E3CBAC','#9C9985','#C46D3B','#788880','324654',
'#3F0B1B','#7A1631','#CF423C','#FC7D49','FFD462',
'#14212B','#293845','#4F6373','#8F8164','D9D7AC',
'#98A89E','#BAC0AC','#FAFAC6','#FF4411','D40015',
'#FEFFFF','#3C3F36','#9FB03E','#EBE9DC','72918B',
'#CC6B32','#FFAB48','#FFE7AD','#A7C9AE','888A63',
'#262526','#404040','#8C8979','#F2F2F2','F60A20',
'#00305A','#004B8D','#0074D9','#4192D9','7ABAF2',
'#0C273D','#54D0ED','#FFFEF1','#70B85D','2C5E2E',
'#4C1B33','#EFE672','#98A942','#2D6960','141D14',
'#2F3540','#666A73','#F2EDE4','#D9D1C7','8C8681',
'#0D1F30','#3B6670','#8BADA3','#F0E3C0','DB6C0F',
'#FFBC67','#DA727E','#AC6C82','#685C79','455C7B',
'#092140','#024959','#F2C777','#F24738','BF2A2A',
'#133463','#365FB7','#799AE0','#F4EFDC','BA9B65',
'#C4D4CB','#55665E','#30282A','#542733','E84167',
'#CDDEC6','#4DAAAB','#1E4F6A','#2A423C','93A189',
'#EF5411','#FA5B0F','#FF6517','#FF6D1F','FF822E',
'#41434A','#6E9489','#DEDCC3','#F2F1E9','877963',
'#292929','#2BBFBD','#F2B33D','#F29B30','F22E2E',
'#F2385A','#F5A503','#E9F1DF','#56D9CD','3AA1BF',
'#D5F8B4','#A6E3A8','#8A9A85','#7E566B','422335',
'#3CBAC8','#93EDD4','#F3F5C4','#F9CB8F','F19181',
'#979926','#38CCB5','#EEFF8E','#FFD767','CC2A09',
'#404040','#024959','#037E8C','#F2EFDC','F24C27',
'#94B34D','#D3FF82','#363D52','#121D2B','111B1C',
'#282E33','#25373A','#164852','#495E67','FF3838',
'#313732','#8AA8B0','#DEDEDE','#FFFFFF','F26101',
'#FFFFFF','#E5E1D1','#52616D','#2C343B','C44741',
'#FFF6B8','#ABCCA7','#403529','#7A5E2F','A68236',
'#4F1025','#C5003E','#D9FF5B','#78AA00','15362D',
'#49404F','#596166','#D1FFCD','#A9BD8B','948A54',
'#FF2151','#FF7729','#FFAD29','#FFEBCA','1AB58A',
'#73603D','#BF8A49','#F2CA80','#5E5A59','0D0D0D',
'#3D4C53','#70B7BA','#F1433F','#E7E1D4','FFFFFF',
'#006D8D','#008A6E','#549E39','#8AB833','C0CF3A',
'#BDDFB3','#2BAA9C','#2F2E2E','#0F2625','465F3F',
'#F2F2F2','#BF0404','#8C0303','#590202','400101',
'#76A19A','#272123','#A68D60','#B0C5BB','D9593D',
'#0E3D59','#88A61B','#F29F05','#F25C05','D92525',
'#C1E1ED','#76C7C6','#273D3B','#131A19','E35C14',
'#2D112C','#530031','#820233','#CA293E','EF4339',
'#AF7575','#EFD8A1','#BCD693','#AFD7DB','3D9CA8',
'#D74B4B','#DCDDD8','#475F77','#354B5E','FFFFFF',
'#FFF6C9','#C8E8C7','#A4DEAB','#85CC9F','499E8D',
'#229396','#8BA88F','#C7C5A7','#F0DFD0','F23C3C',
'#57385C','#A75265','#EC7263','#FEBE7E','FFEDBC',
'#96526B','#D17869','#EBAD60','#F5CF66','8BAB8D',
'#0D1C33','#17373C','#2B6832','#4F9300','A1D700',
'#1B2B32','#37646F','#A3ABAF','#E1E7E8','B22E2F',
'#C5D9B2','#53A194','#572C2C','#3D2324','695A3B',
'#425957','#81AC8B','#F2E5A2','#F89883','D96666',
'#002E40','#2A5769','#FFFFFF','#FABD4A','FA9600',
'#FFFEFC','#E2E3DF','#515B5E','#2E3233','CAF200',
'#FFF0A3','#B8CC6E','#4B6000','#E4F8FF','004460',
'#3B596A','#427676','#3F9A82','#A1CD73','ECDB60',
'#F2E6CE','#8AB39F','#606362','#593325','1D1D1F',
'#212B40','#C2E078','#FFFFFF','#BADCDD','547B97',
'#0B3C4D','#0E5066','#136480','#127899','1A8BB3',
'#222130','#464D57','#D4E8D3','#FFFCFB','ED8917',
'#B33600','#FF8A00','#FFC887','#CC5400','B31E00',
'#012530','#28544B','#ACBD86','#FFD6A0','FF302C',
'#2E95A3','#50B8B4','#C6FFFA','#E2FFA8','D6E055',
'#112F41','#068587','#4FB99F','#F2B134','ED553B',
'#202B30','#4E7178','#4FA9B8','#74C0CF','F1F7E2',
'#302B2F','#696153','#FFA600','#9BB58F','FFD596',
'#458C6B','#F2D8A7','#D9A86C','#D94436','A62424',
'#22475E','#75B08A','#F0E797','#FF9D84','FF5460',
'#FFAA5C','#DA727E','#AC6C82','#685C79','455C7B',
'#686E75','#9BAAC1','#82787B','#E4F1DB','AAC19B',
'#F0C755','#E2AD3B','#BF5C00','#901811','5C110F',
'#FFFBDC','#BFBCA5','#7F7D6E','#3F3E37','E5E2C6',
'#BEBEBE','#F1E4D8','#594735','#94C7BA','D8F1E4',
'#1B1E26','#F2EFBD','#B6D051','#70A99A','2F6D7A',
'#F7E4A2','#A7BD5B','#DC574E','#8DC7B8','ED9355',
'#70E8CB','#FFE9C7','#FF5B5B','#545454','2D2D2F',
'#17111A','#321433','#660C47','#B33467','CCBB51',
'#2B2E2E','#595855','#A2ABA5','#CAE6E8','313F54',
'#023B47','#295E52','#F2E085','#FCAB55','EE7F38',
'#302C29','#D1D1BC','#A7C4BB','#6C8C84','466964',
'#212629','#067778','#49B8A8','#85EDB6','D9E5CD',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF4949',
'#2C3E50','#FC4349','#6DBCDB','#D7DADB','FFFFFF',
'#35262D','#FFFBFF','#E8ECED','#A4B7BB','76A0B0',
'#61E8D2','#FCEEB9','#302F25','#704623','BBE687',
'#E1E6B9','#C4D7A4','#ABC8A4','#375D3B','183128',
'#C98B2F','#803C27','#C56520','#E1B41B','807916',
'#A3D9B0','#93BF9E','#F2F0D5','#8C8474','40362E',
'#524656','#CF4747','#EA7A58','#E4DCCB','A6C4BC',
'#5C2849','#A73E5C','#EC4863','#FFDA66','1FCECB',
'#0EEAFF','#15A9FA','#1B76FF','#1C3FFD','2C1DFF',
'#010000','#393845','#9B96A3','#5C0009','940315',
'#468071','#FFE87A','#FFCA53','#FF893B','E62738',
'#404040','#024959','#037E8C','#F2EFDC','F24C27',
'#FF765E','#C2AE8B','#FCCF65','#FFE5C6','B7BDC4',
'#003647','#00717D','#F2D8A7','#A4A66A','515932',
'#FAFAC0','#C4BE90','#8C644C','#594D37','293033',
'#2B3A42','#3F5765','#BDD4DE','#EFEFEF','E74C3C',
'#3B3B3B','#A8877E','#FFA49D','#FF7474','FF476C',
'#0A3A4A','#196674','#33A6B2','#9AC836','D0E64B',
'#FFA340','#38001C','#571133','#017A74','00C2BA',
'#DCEBDD','#A0D5D6','#789AA1','#304345','AD9A27',
'#588C7E','#F2E394','#F2AE72','#D96459','8C4646',
'#F0E6B1','#B5D6AA','#99A37A','#70584B','3D3536',
'#2F400D','#8CBF26','#A8CA65','#E8E5B0','419184',
'#010712','#13171F','#1C1F26','#24262D','961227',
'#403F33','#6E755F','#AFC2AA','#FFDEA1','E64C10',
'#C74029','#FAE8CD','#128085','#385052','F0AD44',
'#CFF09E','#A8DBA8','#79BD9A','#3B8686','0B486B',
'#E0401C','#E6B051','#272F30','#F7EDB7','9E2B20',
'#FFE2C5','#FFEEDD','#FFDDAA','#FFC484','FFDD99',
'#FFFFE4','#F2E5BD','#B9BF8E','#A69F7C','8C6865',
'#5C8A2D','#AFD687','#FFFFFF','#00C3A9','008798',
'#4F3130','#FF1F3D','#5BE3E3','#FDFFF1','8B9698',
'#D23600','#D95100','#DE6D00','#EE8900','FCA600',
'#FFFFFA','#A1A194','#5B605F','#464646','FF6600',
'#F34A53','#FAE3B4','#AAC789','#437356','1E4147',
'#2A7A8C','#176273','#063540','#E6D9CF','403D3A',
'#21455B','#567D8C','#A59E8C','#8C8372','F2F2F2',
'#012340','#026873','#83A603','#BBBF45','F2F0CE',
'#FDFF98','#A7DB9E','#211426','#6B073B','DA8C25',
'#002F36','#142426','#D1B748','#EDDB43','FFFD84',
'#420000','#600000','#790000','#931111','BF1616',
'#3C989E','#5DB5A4','#F4CDA5','#F57A82','ED5276',
'#23A38F','#B7C11E','#EFF1C2','#F0563D','2E313D',
'#F5ECD9','#2BACB5','#B4CCB9','#E84D5B','3B3B3B',
'#A5EB3C','#60C21E','#159E31','#53DB50','C5FFCB',
'#263138','#406155','#7C9C71','#DBC297','FF5755',
'#0A111F','#263248','#7E8AA2','#E3E3E3','C73226',
'#003B59','#00996D','#A5D900','#F2E926','FF930E',
'#00A19A','#04BF9D','#F2E85C','#F53D54','404040',
'#324152','#47535E','#796466','#C1836A','DEA677',
'#036F73','#84CDC2','#FEF2D8','#F18C79','EF504F',
'#174040','#888C65','#D9CA9C','#D98162','A65858',
'#56797F','#87A0A4','#FCFBDC','#F2DDB6','A6937C',
'#A8BAA9','#FFF5CF','#DBCDAD','#B39C7D','806854',
'#60655F','#AB9675','#FFE0C9','#D4CCBA','CF8442',
'#BDDFB3','#009D57','#2C372E','#0F2925','465F3F',
'#3E3947','#735360','#D68684','#F1B0B0','EBD0C4',
'#0A7B83','#2AA876','#FFD265','#F19C65','CE4D45',
'#FFFFFF','#F4921E','#858585','#C5D2DB','3E6B85',
'#11151E','#212426','#727564','#B9AA81','690C07',
'#000000','#910000','#CBB370','#FFFBF1','21786C',
'#F78F00','#C43911','#75003C','#37154A','0F2459',
'#003354','#91BED4','#D9E8F5','#FFFFFF','F26101',
'#3DA8A4','#7ACCBE','#FFFFF7','#FF99A1','FF5879',
'#64C733','#F0F0F0','#3E879E','#57524D','36302B',
'#343844','#2AB69D','#E65848','#FDC536','FCF2D7',
'#E34517','#F5FF53','#B4E85E','#00BD72','0B4239',
'#A84B3A','#FF9F67','#233138','#FFF7F5','4C646B',
'#59535E','#FAEEFF','#F1BAF3','#5D4970','372049',
'#FF6F22','#D9984F','#FFE8A9','#3E4237','32948A',
'#5D7370','#7FA6A1','#B8D9B8','#D6EDBD','FFF5BC',
'#FFBE00','#FFDC00','#FFD10F','#FFDE20','E8CA00',
'#003840','#005A5B','#007369','#008C72','02A676',
'#E1E6FA','#C4D7ED','#ABC8E2','#375D81','183152',
'#BA2F1D','#FFF8A4','#F5E67F','#264A59','1E2C30',
'#222526','#FFBB6E','#F28D00','#D94F00','80203B',
'#EBD096','#D1B882','#5D8A66','#1A6566','21445B',
'#F00807','#5F6273','#A4ABBF','#CCC9D1','E2E1E9',
'#DFE0AF','#A4BAA2','#569492','#41505E','383245',
'#152737','#2B4E69','#799AA5','#FFFFF0','682321',
'#C44C51','#FFB6B8','#FFEFB6','#A2B5BF','5F8CA3',
'#5ADED4','#4DAAAB','#26596A','#163342','6C98A1',
'#FF5B2B','#B1221C','#34393E','#8CC6D7','FFDA8C',
'#3D4D4D','#99992E','#E6E666','#F2FFBF','800033',
'#242424','#437346','#97D95C','#D9FF77','E9EB9B',
'#FFEBB0','#FFB05A','#F84322','#C33A1A','9F3818',
'#4D2B2F','#E57152','#E8DE67','#FFEFC3','C0CCAB',
'#A82221','#DB5E31','#EDA23E','#F2CB67','BFB840',
'#3B3140','#BFB8A3','#F2E0C9','#F2B9AC','D97E7E',
'#43464D','#9197A6','#D3DCF2','#7690CF','48577D',
'#EFDFBB','#9EBEA6','#335D6A','#D64F2A','7A8A7F',
'#000001','#313634','#C7CECF','#5C0402','941515',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF5A49',
'#F5F4E1','#D6C9B5','#B4AA97','#D44917','82877A',
'#19162B','#1C425C','#6ABDC4','#F0E4C5','D6C28F',
'#00132B','#7F9DB0','#C5E2ED','#FFFFFF','F95900',
'#1F3642','#6D968D','#B6CCB8','#FFE2B3','56493F',
'#08A689','#82BF56','#C7D93D','#E9F2A0','F2F2F2',
'#DE3961','#A4E670','#FFFFDC','#B3EECC','00ADA7',
'#849972','#D9D094','#A6A23E','#4F2F1D','8F5145',
'#F41C54','#FF9F00','#FBD506','#A8BF12','00AAB5',
'#00585F','#009393','#F5F3DC','#454445','FF5828',
'#FF6138','#FFFF9D','#BEEB9F','#79BD8F','00A388',
'#140B04','#332312','#B59D75','#E3D2B4','FFF7EA',
'#ED3B3B','#171F26','#77B59C','#F2E7B1','635656',
'#46594B','#A6977C','#D9B384','#734F30','260B01',
'#CCB8A3','#FF8FB1','#FFF5EA','#4E382F','B29882',
'#B70000','#FFFFFF','#FFCA3D','#94C4F4','0092B3',
'#053B44','#06736C','#A53539','#B9543C','EAD075',
'#E8C1B9','#FFB3AB','#FFCAB8','#E8B69C','FFCEAB',
'#E7F2DF','#69043B','#59023B','#231E2D','161726',
'#E82B1E','#E5DEAF','#A0B688','#557A66','453625',
'#F1E6D4','#BA3D49','#791F33','#9F9694','E3E1DC',
'#CED59F','#F1EDC0','#B1BEA4','#647168','282828',
'#2C3E50','#E74C3C','#ECF0F1','#3498DB','646464',
'#DE7047','#FFDE8D','#FFFFFF','#CDDE47','528540',
'#8EAB99','#40232B','#D95829','#D97338','DEC085',
'#E9662C','#EBAF3C','#00AC65','#068894','2B2B2B',
'#46483C','#A0AA8F','#EBE3CB','#FFFFFF','F26101',
'#170F0E','#290418','#505217','#FFD372','FFF1AF',
'#263545','#C4273C','#D7DADB','#6DBCDB','FFFFFF',
'#DCFAC0','#B1E1AE','#85C79C','#56AE8B','00968B',
'#075807','#097609','#70AF1A','#B9D40B','E5EB0B',
'#521000','#712800','#744E1D','#879666','F1D98C',
'#261F26','#3F3B40','#6C7367','#BFBF8A','F2E086',
'#2C3E50','#FC4349','#D7DADB','#6DBCDB','FFFFFF',
'#506D7D','#94CCB9','#FFECA7','#FFB170','F07D65',
'#3F4036','#8DA681','#F2E1C2','#BF2806','8C1D04',
'#990700','#CC542E','#FF964F','#FFCB7C','787730',
'#195073','#7F8C1F','#EE913F','#F2E5BD','9FD7C7',
'#1B3E59','#F2F0F0','#FFAC00','#BF0404','730202',
'#EA6045','#F8CA4D','#F5E5C0','#3F5666','2F3440',
'#F95759','#FDA099','#FFFFFF','#D9F3CB','8AC2B0',
'#265573','#386D73','#81A68A','#9FBF8F','D4D9B0',
'#E1DA36','#FFEA1B','#6FE4DA','#1DB0BC','007BBC',
'#013859','#185E65','#F9CC7F','#F15C25','9E1617',
'#36CC7C','#D6FFBE','#94D794','#228765','77A668',
'#94201F','#D4421F','#478A80','#D9E061','F08835',
'#F16233','#00B5B5','#F0F0F0','#3E4651','5C6D7E',
'#2E806C','#76CC99','#E0FFED','#FF5F3A','D2413C',
'#00393B','#00766C','#44A18E','#E5EDB6','F6695B',
'#734854','#F2F2E9','#D9D7C5','#A69580','736766',
'#03497E','#0596D5','#9DEBFC','#8D7754','FEB228',
'#F0E14C','#FFBB20','#FA7B12','#E85305','59CC0D',
'#FE4365','#FC9D9A','#F9CDAD','#C8C8A9','83AF9B',
'#00557C','#186D94','#3488AD','#81C1DC','BBE5F3',
'#DEE8D7','#918773','#420A1A','#240001','4D493A',
'#FFFFFF','#CAC535','#97AF25','#158471','41342C',
'#041F3D','#0B2E41','#165751','#448C61','9AC16D',
'#FA8C01','#FF6405','#577700','#082400','A0A600',
'#78C0F9','#FFDDCE','#FFFFFF','#FFDBE6','FE86A4',
'#351330','#CC2A41','#E7CAA4','#759A8A','524549',
'#02151A','#043A47','#087891','#C8C8C8','B31D14',
'#F34A53','#FAE3B4','#AAC789','#437356','1E4147',
'#58838C','#DAD7C7','#BF996B','#BF5841','A61C1C',
'#556354','#E68F0D','#8C948A','#495450','42423F',
'#323640','#5B6470','#8C94A1','#BDC7D6','DFE2FF',
'#FF0000','#FF950B','#2FA88C','#DEEB00','4B2C04',
'#0F3D48','#174C5B','#366774','#ECECE7','E96151',
'#3DBB7E','#A3CD39','#FBAC1D','#F96C1E','EE4036',
'#23363B','#A44F3F','#F8983D','#8D9151','BBC946',
'#4B5657','#969481','#D2C9B0','#F4E3C1','B6B835',
'#E8980C','#B1F543','#F2FF00','#FF5E00','59BBAB',
'#849696','#FEFFFB','#232D33','#17384D','FF972C',
'#555555','#7BB38E','#F4F1D7','#F8AB65','F15C4C',
'#1D3C42','#67BFAD','#F2EC99','#F2C48D','F25050',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF4949',
'#B8E1F2','#249AA7','#ABD25E','#F8C830','F1594A',
'#FDEDD0','#BCF1ED','#FF634D','#FD795B','FFF0AA',
'#FFFFFF','#E5E1D1','#52616D','#2C343B','C44741',
'#FFFFF1','#D5FF9B','#8FB87F','#5A7B6C','374E5A',
'#010340','#0E1E8C','#0003C7','#1510F0','1441F7',
'#002A4A','#17607D','#FFF1CE','#FF9311','E33200',
'#871E31','#CCC097','#9E9D7B','#687061','262626',
'#F16663','#F48D6C','#F2E07B','#8ABE9B','4A6D8B',
'#001F11','#204709','#0C8558','#FFD96A','FF4533',
'#1D1626','#F2E0BD','#BFAA8F','#8C786C','594C4C',
'#685D47','#913420','#1E2729','#C1D9C5','FEEFB1',
'#1D7561','#FC8448','#FF4138','#A8282B','38141B',
'#BF0633','#FF484E','#FF9273','#D1D0B4','E5ECED',
'#8E9E63','#E6DBB0','#F5EED7','#C4BCA0','176573',
'#665446','#809994','#AECCB6','#DEF2C4','E6683F',
'#3D0D26','#660A3E','#891C56','#B0276F','C93482',
'#082136','#00294D','#004B8D','#0068C4','2998FF',
'#3C4631','#9A746F','#F8A2AB','#F1C6B3','EAE9C0',
'#FF534E','#FFD7AC','#BED194','#499989','176785',
'#006D80','#BDA44D','#3C2000','#84CECC','78A419',
'#352C2B','#3C555C','#9E9657','#FFEBCD','CD5510',
'#2C3E50','#FC4349','#6DBCDB','#D7DADB','FFFFFF',
'#523631','#D1BE91','#605E3A','#4D462F','592F39',
'#18293B','#5B5A56','#F2DEA0','#D0B580','FFFBFF',
'#C8DBB6','#ECEBB7','#CCC68A','#B8B165','827A5D ',
'#7DA88C','#EBE9A0','#BED24B','#859132','35323C',
'#E8574C','#F27B29','#E6A51B','#D9CC3C','399977',
'#324032','#B7C22C','#FFFFE1','#22A8B5','2A3F42',
'#B3A589','#FFB896','#FFF9B1','#9AB385','11929E',
'#272433','#343F4F','#3D6066','#77994D','B2D249',
'#250701','#6D4320','#B0925F','#E7DEC0','82ABB8',
'#023550','#028A9E','#04BFBF','#EFEFEF','FF530D',
'#594732','#40342A','#7A422E','#D4CA9A','EDE5AE',
'#013C4D','#BA5B22','#DB913C','#F0B650','FAD46B',
'#143840','#5C6B63','#A69E89','#E0C297','D96523',
'#3FB8AF','#7FC7AF','#DAD8A7','#FFB38B','FF3F34',
'#CA3995','#F58220','#FFDF05','#BED73D','61BC46',
'#FFE1D0','#FFBFB4','#FF837E','#FF4242','BF1616',
'#C4EEFF','#7BA32D','#094201','#A41717','C48726',
'#001325','#187072','#90BD90','#D7D8A2','F2E4C2',
'#1A4F63','#068587','#6FB07F','#FCB03C','FC5B3F',
'#97B350','#333230','#736D61','#BAAB90','FFE5BA',
'#403D33','#807966','#CCC2A3','#8C0000','590000',
'#5F8A42','#86AD59','#F6FAA1','#F28410','D66011',
'#BF355D','#ED8168','#FAB66A','#F2DC86','83BFA1',
'#E1F03E','#FFBA14','#DB3A0F','#A1003D','630024',
'#212226','#45433F','#687067','#BDBB99','F0EAC3',
'#FE4365','#FC9D9A','#F9CDAD','#C8C8A9','83AF9B',
'#293B47','#5F7A87','#FFFFFF','#CBFF48','00ADA9',
'#282A33','#697371','#FFE7A6','#F5BA52','FA8000',
'#0C304A','#2B79A1','#F3F4F1','#85A71E','BFD841',
'#008B83','#4DAE83','#A0AE79','#FFE499','FF665E',
'#5D7359','#E0D697','#D6AA5C','#8C5430','661C0E',
'#324452','#97BDBF','#F2DFBB','#F28705','BF3604',
'#EEEFB9','#6ACFAE','#369C93','#232928','B03831',
'#332F45','#015770','#2A8782','#9FD6AE','FFFED2',
'#2B2830','#5C504F','#ABAB8E','#D9D7A3','C7BE88',
'#DC941B','#EDC266','#B6952C','#E1D3A6','E9A119',
'#00305A','#00448D','#0074D9','#4192D9','7ABAF2',
'#344459','#485F73','#5DA6A6','#A9D9CB','F2EAD0',
'#060719','#4D1B2F','#9E332E','#EB6528','FC9D1C',
'#96CEB4','#FFEEAD','#FF6F69','#FFCC5C','AAD8B0',
'#05F2F2','#04BFBF','#EEF1D9','#A60201','7E100E',
'#E6F1F5','#636769','#AAB3B6','#6E7476','4B4E50',
'#DA0734','#F1A20D','#4AABB1','#FCF3E7','3F1833',
'#202D44','#FC4349','#6DBCDB','#D7DADB','FFFFFF',
'#CC3B37','#398899','#FFFCE8','#FF857F','CCC1A3',
'#5DBEA9','#EFEDDF','#EF7247','#4E3F35','D1CBBA',
'#FFC62D','#E49400','#DD5200','#EFE38A','91B166',
'#B67D14','#F2921F','#F0B23E','#A62409','441208',
'#C71B1B','#D6BA8A','#017467','#E08F23','0B0D0C',
'#474143','#A69E9D','#E7E2DA','#FFFFFF','E7E8E7',
'#435772','#2DA4A8','#FEAA3A','#FD6041','CF2257',
'#6DD19D','#99E89D','#D0E8A1','#FFF9C0','D40049',
'#FAF1D5','#DEC9AC','#CCA18B','#11282D','A5C4BB',
'#000000','#141414','#1C1919','#1A1716','24201F',
'#D5D8DD','#5CA2BE','#135487','#2A4353','989DA4',
'#73161E','#BF0F30','#BFB093','#037F8C','0A2140',
'#195962','#F56F6C','#FFFFFF','#252932','191C21',
'#F8EFB6','#FEBAC5','#6CD1EA','#FACFD7','C2EAE9',
'#91D6BC','#768C6A','#755F31','#B37215','FFBA4B',
'#F2E6BB','#DD4225','#202724','#63BD99','F8FDD8',
'#762B1B','#807227','#CCBF7A','#FFEF98','60B0A1',
'#707864','#C1D74E','#F5FF7C','#DFE6B4','A6B89C',
'#FFF3D2','#97B48F','#E87657','#FF9B6F','E8D495',
'#33262E','#733230','#CC5539','#E6D27F','86A677',
'#122430','#273E45','#FFFCE2','#EBD2B5','E63531',
'#30394F','#FF434C','#6ACEEB','#EDE8DF','FFFBED',
'#0A3A4A','#196A73','#32A6A6','#A1BF36','C8D94A',
'#FFF7CC','#CCC28F','#70995C','#33664D','142933',
'#43464D','#9197A6','#D3DCF2','#7690CF','48577D',
'#DFE0AF','#A4BAA2','#569492','#41505E','383245',
'#B52841','#FFC051','#FF8939','#E85F4D','590051',
'#473C35','#A36D5C','#9C968B','#D9CEAD','8A866A',
'#DB4C39','#2D3638','#109489','#44D487','D0DB86',
'#6F8787','#AEC2AE','#E6DFAE','#B0B57B','888F51',
'#C8385A','#FFCF48','#ECEABE','#1FCECB','1CA9C9',
'#42282E','#75A48B','#D9CFB0','#DC9B74','D6665A',
'#362F2D','#4C4C4C','#94B73E','#B5C0AF','FAFDF2',
'#98293A','#B14A58','#C86C6B','#DE9D76','EFC77F',
'#C1D301','#76AB01','#0E6A00','#083500','042200',
'#453F22','#7A6B26','#CCAD5C','#A1191F','4E1716',
'#541E32','#8E3557','#88A33E','#C2BD86','F7F2B2',
'#2B1B2E','#54344D','#FFFFD6','#B89E95','6E444F',
'#6EC1A5','#9FBEA6','#F5D3A3','#FF9F88','FB7878',
'#2F252C','#D3CCB2','#99AD93','#6E6751','5C3122',
'#BE333F','#F2E9CE','#C8C5B1','#939F88','307360',
'#F0F1F2','#232625','#647362','#B3D929','D2D9B8',
'#FA2B31','#FFBF1F','#FFF146','#ABE319','00C481',
'#09455C','#527E7C','#F5FFCC','#E0EB6E','C4D224',
'#F2DA91','#F2B950','#F29D35','#D96704','BF4904',
'#A2CFA5','#E0E7AB','#F5974E','#E96B56','D24344',
'#150033','#310D42','#5C2445','#AB6946','FFCE4C',
'#23A38F','#B7C11E','#EFF1C2','#F0563D','2E313D',
'#FF2468','#E0D4B1','#FFFFE3','#00A5A6','005B63',
'#65A683','#218777','#3F585F','#47384D','F53357',
'#000623','#28475C','#4A6C74','#8BA693','F0E3C0',
'#E65322','#D19552','#B8BF73','#B6DB83','FFF991',
'#112F41','#068587','#6FB07F','#FCB03C','FC5B3F',
'#C89B41','#A16B2B','#77312B','#1C2331','152C52',
'#C24366','#D9C099','#FFF8D8','#A8E0BA','00ADA7',
'#CC0000','#006600','#FFFFEC','#9C9178','6C644F',
'#3D0319','#720435','#C1140E','#FC5008','32241B',
'#CFC7A4','#5A9E94','#005275','#002344','A38650',
'#FFEBC3','#CC3A00','#FF3600','#FF851B','800C00',
'#EFC164','#F3835D','#F35955','#286275','00434C',
'#E9F29D','#B7C29D','#878E8F','#67617A','51456B',
'#445859','#03A696','#49C4BE','#F1F2E4','FF7746',
'#FA726C','#FFD794','#BAD174','#3BA686','5F6F8C',
'#4D2B1F','#635D61','#7992A2','#97BFD5','BFDCF5',
'#CC4D00','#E6CF73','#668059','#264D4D','00CCB3',
'#4385F5','#DC4437','#FCBE1F','#109D59','FFFFFF',
'#271F2E','#A4A680','#F2EBC9','#D9B166','A66B38',
'#0B2C3C','#FF6666','#DADFE1','#FFFFFF','444444',
'#CFF09E','#A8DBA8','#79BD9A','#3B8686','0B486B',
'#302B26','#A6B827','#EDE9DD','#98D3D4','594E7A',
'#4B0505','#720707','#BFB694','#004659','00292B',
'#B52C38','#EBD1B0','#536682','#D9964B','DE6846',
'#F2F1DF','#F2B705','#F2C84B','#BF820F','734002',
'#26140C','#3D2216','#784E3D','#AB8574','D6BCB1',
'#26221D','#8C2C0F','#E6E5B8','#BFB38D','402D1F',
'#1F8181','#F2BC79','#F28972','#BF1B39','730240',
'#002635','#013440','#AB1A25','#D97925','EFE7BE',
'#8EC447','#FFFFFF','#96D3D4','#636466','2D2D2E',
'#2D1E1E','#4B3C37','#96A576','#CDE196','FFFFBE',
'#F06060','#FA987D','#F7F2CB','#72CCA7','10A296',
'#1D8281','#44BF87','#FBD258','#F29A3F','DB634F',
'#DEDE91','#EF9950','#F34E52','#C91452','492449',
'#6D8EAD','#1F3447','#1A0B07','#362416','CFCDB4',
'#00CD73','#008148','#2D9668','#3ECD8E','004E2C',
'#3D8080','#628282','#858383','#A38282','C28080',
'#475159','#839795','#B2BDB7','#CCC9C0','F2F2F2',
'#0E6870','#C6B599','#C65453','#FFDDB4','EDAA7D',
'#CEF0B7','#A8DBA8','#79BD9A','#3B8686','0B486B',
'#292C44','#FF5349','#F0F0F1','#18CDCA','4F80E1',
'#272A2B','#383737','#473B39','#692B28','940500',
'#D6C274','#DB9E46','#25706B','#3D2423','AB362E',
'#FFA68F','#FF4867','#FFF9C8','#B5EBB9','18B29D',
'#A1A16A','#727D59','#366353','#133C40','03212E',
'#D45354','#A9DC3A','#2FCAD8','#818B85','CDCDC1',
'#F14B6A','#3D3C3E','#22BDAF','#BAD7D4','F4F4F4',
'#FFE2C5','#FFEEDD','#FFDDAA','#FFC484','FFDD99',
'#9FFF4A','#1ABF93','#087363','#004040','2F1933',
'#FFDB97','#B28F4E','#FFFDFB','#466CB2','97BBFF',
'#991C00','#E09A25','#FFFCDB','#008B83','262B30',
'#44281A','#00ACAE','#F5EFD5','#F37606','EE4717',
'#FF5952','#FCEEC9','#96D6D9','#4FAAC9','176075',
'#5C4B51','#8CBEB2','#F2EBBF','#A5C88F','EF847B',
'#105F73','#F7F3B2','#C6CC33','#F28322','CC5404',
'#137072','#56B292','#B7F5AB','#FBFFC0','BF223D',
'#E3F23E','#6C821C','#A6A53F','#E0E0AC','33302E',
'#00215E','#003CAA','#1967F7','#5E4000','AA7400',
'#273A3D','#54695C','#AD9970','#FFBF87','FF8F60',
'#FFAA00','#C2B93E','#808F5D','#576157','302F30',
'#BE1405','#F2DCAC','#AABEAA','#736E41','413C2D',
'#6B1229','#C76A61','#FAB99A','#F7D9B5','CCB1A7',
'#2D9993','#58B3A3','#83BFA3','#B0D9A8','FFFCB6',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF5A49',
'#F30B55','#010326','#012840','#54717F','F2E6CE',
'#2A3411','#73662C','#BC9847','#FFDFB2','6B0031',
'#637D74','#403D3A','#8C3B3B','#AB6937','D4A960',
'#010A26','#011640','#B6D6F2','#FFFFFF','E83338',
'#924847','#EB986C','#E4C678','#9C7885','372C2C',
'#022440','#3F95AA','#4EC6DE','#EAE2DF','F7572F',
'#2B1D2E','#323657','#076473','#54B087','D6F567',
'#052229','#004043','#BCC373','#E3FF55','D0D90C',
'#4C514A','#907A62','#879796','#755854','B09880',
'#1D2939','#1CAF9A','#FFFFFF','#EE4F4B','D1DC48',
'#004B67','#41CCB4','#FFEA95','#FF7C5D','C70151',
'#C0272D','#FCFBE7','#9FD3DA','#008C9A','05484F',
'#213130','#FF5E3D','#C9C83E','#FDFFF1','559398',
'#B1E4FC','#366D78','#39D5F1','#FFFFFF','D9FF03',
'#DECE6C','#FCF9B6','#BFE3B5','#5D826E','262E2B',
'#520A17','#668F91','#F5E6AC','#AB8E5B','52301C',
'#2D3032','#DD5F18','#FBA922','#F7F7F7','404333',
'#0C2538','#2B434F','#638270','#BCC98E','EDE059',
'#E85066','#F28E76','#E6CEB0','#5A8C81','382837',
'#BF2633','#A6242F','#D9CEAD','#C0B18F','011C26',
'#002A4A','#17607D','#FFF1CE','#FF9311','E33200',
'#0A8B91','#485956','#C4B98F','#FFF9BC','EEDF2E',
'#B89A7B','#9BBAAC','#F2D649','#D95D50','DBDBDB',
'#BD7938','#8D4421','#643001','#532700','3A1C00',
'#E1E6FA','#C4D7ED','#ABC8E2','#375D81','183152',
'#2E4259','#F7483B','#ECF0F1','#03C8FA','737373',
'#364656','#5D6B74','#94A4A5','#F2F5E9','FF8C31',
'#3E5916','#93A605','#F28705','#F25C05','E5EFFA',
'#248077','#74AD8D','#C82754','#F7BB21','F9E2B7',
'#20736A','#8BD9CA','#B1D95B','#93A651','403E34',
'#D74B4B','#DCDDD8','#475F77','#354B5E','FFFFFF',
'#252F33','#415C4F','#869C80','#93C2CC','CEEAEE',
'#012840','#79C7D9','#9BF2EA','#497358','9DBF8E',
'#EE7E94','#F8B4C4','#C7CAC9','#D8505C','41424',
'#282828','#505050','#FFFFFF','#2DCEDB','F20000',
'#004358','#1F8A70','#BEDB39','#FF5347','FD7400',
'#470C3B','#802F56','#C0576F','#E38679','FFBD83',
'#573328','#B05A3A','#FF8548','#29332E','0F1B1C',
'#461F2D','#E1FFBB','#BAD47F','#849C23','52533F',
'#333A40','#4C5E5E','#ADD0E5','#CDE4FF','729EBF',
'#DE5605','#F7A035','#B1DEB5','#EFECCA','65ABA6',
'#76D6D2','#F9E270','#EF6F56','#F4EED8','596B56',
'#403E3F','#F2F2F2','#D9D9D9','#9DAABB','8C8C8C',
'#059E9A','#F4F2ED','#F5A243','#DB3E3B','585857',
'#FFBF41','#EE8943','#C02221','#FFF4D3','249CA9',
'#024E76','#39A6B2','#FCE138','#F5B824','F08106',
'#FF0067','#FF3D6A','#E7FF04','#9CFF00','56FF00',
'#003540','#0D3F40','#487360','#8FA671','F2D795',
'#FF493C','#FFFFFF','#B3ECEF','#31C4F5','ADEB41',
'#244358','#4A8B87','#7CBCAE','#F0D4AF','C5252B',
'#EA5930','#F8AF1E','#F5E5C0','#097380','372560',
'#A1DBB2','#FEE5AD','#FACA66','#F7A541','F45D4C',
'#2C4A47','#6C9A7F','#BB523D','#C89D11','81810B',
'#F0F1F2','#232625','#647362','#FF5629','D2D9B8',
'#7C9B5F','#B8D197','#E3FFF3','#9BDEC7','568F84',
'#E54E45','#DBC390','#F2F2EF','#13A3A5','403833',
'#77A7FB','#E57368','#FBCB43','#34B67A','FFFFFF',
'#001A2E','#8F0000','#FFFFFF','#8A874B','41594F',
'#312F40','#49A69C','#EFEAC5','#E89063','BF5656',
'#047C8C','#018B8D','#F3BF81','#F49B78','F1706D',
'#00303E','#7096AD','#C1D1DE','#FFF9EF','EC4911',
'#2D6891','#70A0BF','#F5EEDC','#DC4C1A','F0986C',
'#040002','#3D1309','#E8B96A','#BC5D15','5C0F00',
'#8B929C','#5E6070','#514454','#3B313D','FF2479',
'#142D58','#447F6E','#E1B65B','#C8782A','9E3E17',
'#22104D','#2D1E5E','#483A85','#7067AB','A49CFA',
'#919C86','#9E373E','#2B2E36','#D1B993','C45A3B',
'#332F45','#015770','#2A8782','#9FD6AE','FFFED2',
'#37C78F','#FEE293','#FF4D38','#CC2249','380C2A',
'#47282C','#8C8468','#C9B37F','#DBDAB7','C4C49C',
'#14191A','#2D2B21','#A69055','#CCB287','FFB88C',
'#F5E3CD','#696158','#B6A898','#877D71','504A43',
'#005151','#009393','#F56200','#454445','969692',
'#D95F47','#FFF2C1','#80A894','#106153','072C36',
'#9E352C','#E6E8A9','#93C28C','#2E5A5C','2B2623',
'#03013A','#334A94','#6B9EDF','#83C3F2','99E6FF',
'#372A26','#4D4D4D','#6DA0A7','#9ED5A8','C7F5FF',
'#03658C','#022E40','#F2B705','#F28705','F25C05',
'#FF3B16','#E87826','#E8BA4A','#80A272','003045',
'#00748E','#E3DFBB','#F4BA4D','#E3753C','DA3B3A',
'#25401E','#56732C','#84A63C','#B8D943','EAF2AC',
'#449BB5','#043D5D','#EB5055','#68C39F','FFFCF5',
'#108F97','#FF8B6B','#FFE39F','#16866D','103636',
'#1A4F63','#068F86','#6FD57F','#FCB03C','FC5B3F',
'#381C19','#472E29','#948658','#F0E99A','362E29',
'#D7E8F7','#BBD0E3','#9CB7CF','#6A8BAB','375D81',
'#0F1C28','#136972','#67BFA7','#F3CF5B','F07444',
'#FFFFFF','#4EA9A0','#969514','#FE9C03','FCDE8E',
'#2F2D30','#656566','#65537A','#51386E','2A2333',
'#4C2916','#F05A28','#FBAF3F','#38B449','FFFFFF',
'#132537','#006C80','#EBCAB8','#FE8315','FA3113',
'#ECEEE1','#A8DACF','#F05B4F','#D8403A','221E1F',
'#00305A','#004B8C','#0074D9','#4192D9','7ABAF2',
'#72CF3F','#85FF00','#23E000','#2FB81B','00FF1C',
'#45CEEF','#FFF5A5','#FFD4DA','#99D2E4','D8CAB4',
'#FF5B00','#A1716C','#728296','#439AAB','00CABD',
'#EB6C2D','#D9C8A2','#939C80','#496158','232F38',
'#D94214','#FFF2C1','#80A894','#52736B','093844',
'#4D1B2F','#9E332E','#EB6528','#FC9D1C','FFCA50',
'#FFEEB0','#9AE8A4','#C7C12D','#F76245','ED1C43',
'#FFFAED','#D4DBFF','#879AC9','#242942','FF8800',
'#022840','#013440','#517360','#9DA67C','F2DC99',
'#331A0F','#519994','#BA4B3C','#EEDDAA','789F63',
'#577867','#EDCE82','#D68644','#AB3229','662845',
'#435A66','#88A6AF','#F5F2EB','#D9CDB8','424342',
'#FF8840','#958D4F','#737B55','#595540','513E38',
'#9D805A','#EBC99D','#FFE6C5','#9DCEEA','4B809E',
'#272D40','#364659','#55736D','#9DBF8E','D0D991',
'#23A38F','#B7C11E','#EFF1C2','#F0563D','2E313D',
'#98C000','#3D4C53','#EA2E49','#FFE11A','0CDBE8',
'#A20E30','#E93C4F','#DCDCD4','#ADBCC3','2D4255',
'#1C2640','#263357','#384C80','#4E6AB3','5979CD',
'#D94214','#FFF2C1','#80A894','#52736B','093844',
'#3B596A','#427676','#3F9A82','#A1CD73','ECDB60',
'#1E1E1F','#424143','#67666A','#807F83','CBC9CF',
'#E04946','#3BA686','#B6D15D','#FFD495','FA847E',
'#FFEBB0','#FFB05A','#F84322','#C33A1A','9F3818',
'#FFA136','#FF814A','#E6635A','#785D6B','534557',
'#CDCF91','#EBEACC','#D6D5B8','#6D7D80','41545E',
'#011526','#011C40','#4E8DA6','#F2EA79','F2B33D',
'#353230','#3F4E51','#7B8F70','#99B2BE','F6F4EA',
'#063559','#0D8C7F','#8FBF4D','#F2D13E','D95929',
'#158000','#199900','#20BF00','#24D900','29FF00',
'#0B0D0E','#137074','#7EB7A3','#F1DDBB','EC6766',
'#02151A','#043A47','#087891','#C8C8C8','B31D14',
'#59361F','#5C992E','#A3CC52','#E6E673','FF5933',
'#FE4365','#FC9D9A','#F9CDAD','#C8C8A9','83AF9B',
'#4B1E18','#F9E5C2','#BBB082','#829993','4F5D4E',
'#032843','#1F595B','#508C6D','#71A670','A6DB89',
'#191724','#4C4547','#8C594E','#D18952','FDB157',
'#191919','#182828','#60702D','#AAB232','E6FA87',
'#212A3F','#434F5B','#F2F2F2','#8AB839','2E2E2E',
'#004158','#026675','#038B8B','#F1EEC9','F09979',
'#023059','#3F7EA6','#F2F2F2','#D99E32','BF5E0A',
'#F21E52','#FFFFFF','#3D3B42','#0C6F73','63CFD4',
'#452743','#E7635E','#F8E9A8','#89E0AD','00928C',
'#FAAD63','#D1714D','#785E48','#39403B','3D1C24',
'#4C0016','#FFF7EB','#DCCEA7','#A17345','104F53',
'#BF2431','#F24150','#2A4557','#3B848C','EFF2E4',
'#3B3013','#8F6031','#E88833','#9C0C0A','FDF3C1',
'#1E2422','#88BEB1','#FF006D','#DAFFFF','718A94',
'#F1F4F7','#AF9F7B','#775E43','#40413C','251C17',
'#00182E','#0C6BA1','#D4D6D4','#FFFDEB','FF7500',
'#FFAB4A','#CCBAAB','#1E2129','#3D5E6E','47A3A3',
'#66B3A7','#C0D4B6','#EEF0BD','#F0563D','2C2F3B',
'#332525','#907465','#EDC5B5','#878C6D','63674A',
'#F04C16','#DBDBD0','#EDBD1F','#4CB09C','313B4A',
'#2B211D','#611C26','#C5003E','#8EB7A8','F1E4B7',
'#1A1F2B','#30395C','#4A6491','#85A5CC','D0E4F2',
'#03497E','#0596D5','#9DEBFC','#999999','FE4B28',
'#2F4159','#465E73','#88A649','#F2ECE4','D98841',
'#323A46','#22282F','#EB4A33','#FFFFFF','E9F0F5',
'#2C3E50','#FC4349','#6DBCDB','#D7DADB','FFFFFF',
'#F29727','#E05723','#B0382F','#982E4B','713045',
'#4D584A','#465943','#428552','#3E754E','4C694B',
'#47191C','#59574B','#829690','#B5B09A','E1E3CB',
'#1D5123','#B1C661','#FFDA68','#FE9257','F64448',
'#59323C','#260126','#F2EEB3','#BFAF80','8C6954',
'#4E0805','#9E0522','#FFF4D4','#B8C591','447622',
'#424862','#FB9A63','#BFC4D5','#F6FBF4','FEBC98',
'#FF2468','#E0D4B1','#FFFFE3','#00A5A6','005B63',
'#1C2F40','#4C6173','#8094A6','#D9D1BA','F2E9D8',
'#DFD7B7','#EB7707','#5C5445','#3B2323','9CBFC7',
'#262E3B','#9C8878','#CFCAAA','#FBF8FF','992435',
'#FFBC67','#DA727E','#AC6C82','#685C79','455C7B',
'#404A69','#516C8A','#8AC0DE','#FFFFFF','FFAC00',
'#485B61','#4B8C74','#74C476','#A4E66D','CFFC83',
'#A31180','#C42795','#DE52B4','#EA88CE','FFBFE5',
'#E64D2E','#FFF5F1','#7893AD','#576B9C','2D2A52',
'#BF0436','#8C0327','#590219','#F2CBA1','8C674C',
'#CF5B6F','#FFF8C8','#CAD9B1','#8FB3A0','648991',
'#341D44','#744D90','#BB8CDD','#3E4417','88904D',
'#00293E','#003D4E','#006269','#00918F','00BAB5',
'#43212E','#D9666F','#F2D57E','#A9A688','516057',
'#2A3B30','#ABFFD1','#EBFFF5','#9DFEFF','273B40',
'#A63343','#E65159','#F5E9DB','#F4F7CF','BAD984',
'#1BA68C','#54BFAC','#F2EDA7','#F2E530','D94625',
'#1A2A40','#3F7369','#F2DEA0','#CE5251','EA895E',
'#1E9382','#70A758','#EFF1C2','#F0563D','2E313D',
'#A991E8','#FFB4BB','#ACF7FF','#A2E891','FFEDAE',
'#225B66','#17A3A5','#8DBF67','#FCCB5F','FC6E59',
'#282624','#BFB7AA','#403D39','#807A71','ABA398',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF4949',
'#440008','#605521','#988432','#D9A54E','9E3711',
'#649670','#36291E','#69AD6C','#92E67C','C5FF84',
'#42342C','#738076','#B2B39B','#DFE5E1','294359',
'#1A3838','#3F7A51','#82A352','#D1C062','FFBE59',
'#7D8C22','#B3BF67','#F2E49B','#D9DFF4','6791BF',
'#8A7D6D','#2D2D38','#E86E48','#FFFFE8','9CC9C9',
'#CFC949','#FFF5BF','#A9E6C4','#6AB39F','665841',
'#A1172D','#FDFFBA','#A7DB9E','#275C57','1F1B19',
'#FF6C0D','#F29E00','#E6C10F','#44996F','216273',
'#2C3E50','#FA4248','#D7DADB','#6DBCDB','FFFFFF',
'#627369','#99B397','#E2F2C6','#91CCAD','376266',
'#04496E','#66CAFF','#A3FC7E','#70D44A','2C6B0F',
'#1BA68C','#97BF3F','#F2ECD8','#F2B035','F2522E',
'#A2D9B1','#7CBF9E','#F2F1B9','#8C8575','193741',
'#024959','#037E8C','#F2EFDC','#E74C30','363636',
'#212625','#9CA6A2','#D0D9D6','#BF0404','C2C6AF',
'#00FFFF','#00FF00','#FFFF00','#FF5100','FF007C',
'#212629','#CDCF19','#FFF77D','#96C4AB','CF2A56',
'#CFF9FF','#BFC7BB','#787051','#332730','57324F',
'#98CACB','#FDEFBE','#F0542B','#736E5B','ABA68E',
'#F2F1EB','#BFB9A4','#262222','#802A30','8C0303',
'#65356B','#AB434F','#C76347','#FFA24C','519183',
'#78BF82','#A4D17C','#CFD96C','#EBD464','FFD970',
'#806265','#FFA256','#F7DD77','#E0D054','ABA73C',
'#8F323C','#123943','#80BDDB','#4189AB','C98127',
'#683820','#8C9A89','#E7D6A2','#BEAA65','9A8234',
'#021B21','#032C36','#065F73','#E8DFD6','FF2A1D',
'#2D6C73','#3FA693','#B4D9CB','#9ABF49','C6D93B',
'#141F26','#2B4040','#405950','#A69E86','F2D9BB',
'#4A8279','#003330','#610400','#003B06','02730F',
'#69B5E1','#D4E4F5','#EAF2F8','#BEDBED','000000',
'#893660','#EF7261','#68D693','#A0D7E2','299CA8',
'#073A59','#2D9AA6','#F2E2DC','#F23322','A61B1B',
'#2A3A48','#3E6372','#B2D4DC','#FAFAFF','FF6900',
'#F3BD8D','#F1A280','#BE6D6B','#704A5B','3E263C',
'#1C2742','#3C91C7','#5A9ABE','#95C5DE','E0EEFB',
'#426261','#465A59','#577573','#739A97','9AC1C0',
'#002A4A','#17607D','#FFF1CE','#FF9311','D64700',
'#589373','#BFBD99','#F2D6B3','#C2512F','241E1E',
'#1F518B','#1488C8','#F7E041','#E2413E','B5292A',
'#549494','#E85649','#232C2E','#E6E8D2','706558',
'#392133','#FFECBE','#D9D098','#C4AB6D','AB7D3A',
'#F0F0F0','#1C1C1C','#A2FDF5','#1CCDC7','27EDDF',
'#011526','#025959','#027353','#03A678','03A696',
'#004358','#1F8A70','#BEDB39','#FFE11A','FD7400',
'#37465D','#F2F2F2','#9DC02E','#779324','051A37',
'#580022','#AA2C30','#FFBE8D','#487B80','011D24',
'#F9F9F9','#03A678','#E9EDEB','#F44647','00707F',
'#800000','#BF0000','#E2D6C2','#F6EDD8','FFFFFF',
'#F7F6AF','#1B2124','#D62822','#97D6A6','468263',
'#432852','#992255','#FF3D4C','#28656E','00968F',
'#444344','#52BBB2','#2B344D','#EE5555','F8F7EE',
'#45334A','#796B7D','#CCC4B0','#FFF1B5','FFA3A3',
'#5A4B53','#9C3C58','#DE2B5B','#D86A41','D2A825',
'#14151C','#0C242B','#297059','#84D66E','D1FB7A',
'#272D40','#364659','#55736D','#9DBF8E','D0D991',
'#23A38F','#B7C11E','#EFF1C2','#F0563D','2E313D',
'#2E064D','#80176B','#B356A1','#59580B','FFFF00',
'#CC3333','#FF9D33','#F7F7F0','#3EBBA7','00747A',
'#5C4B51','#8CBEB2','#F2EBBF','#F3B562','BD6060',
'#0D3E58','#1C848C','#19C0C2','#F3EDD6','DA6260',
'#022629','#2A5945','#FAFFED','#E6DCC0','B3371C',
'#F4FAC7','#7BAD8D','#FFB159','#F77F45','C2454E',
'#A2C1C6','#86B1B7','#AECBAD','#CFDCB0','D6E1D1',
'#B0DAFF','#325B80','#64B7FF','#586D80','5092CC',
'#0F808C','#6C8C26','#F2A71B','#F26A1B','D91818',
'#FFBC6C','#FE9F6C','#BD716E','#74495F','3B2C4D',
'#FF4D41','#F2931F','#E6CA21','#91B321','1E8C65',
'#302821','#453629','#5C4837','#8A735F','BDA895',
'#415457','#5F7B7F','#9ACCAF','#E6EBC4','F9F7C8',
'#474143','#A69E9D','#E7E2DA','#FFFFFF','E7E8E7',
'#805939','#BD9962','#E6CD7D','#578072','2D4B4D',
'#03588C','#1763A6','#419CA6','#54BF83','8DBF41',
'#00CCFF','#A1FCFF','#040438','#004878','C9FAFF',
'#534C64','#B7DECF','#F0F3D7','#7E858C','D96557',
'#7F7364','#CBB08E','#CBC1B7','#789DCB','646F7F',
'#5C2849','#A73E5C','#EC7263','#FE9551','FFD285',
'#FF0012','#FF7D00','#FFD900','#5BE300','0084B0',
'#F24C32','#F29471','#FCDFA6','#36B898','3D7585',
'#083157','#0A6C87','#459C97','#92CCA5','C9F0B1',
'#DC941B','#EDC266','#B6952C','#E1D3A6','E9A119',
'#323836','#BAD1B5','#DBE8CF','#F0F7E8','FFFEF5',
'#081724','#589494','#8EBBB4','#D0DCD0','F5EED2',
'#50781C','#9CAD1C','#EAF7E6','#40A5DE','0B5191',
'#537F79','#78A68F','#CBD49C','#FED457','CB252A',
'#F23C13','#CBAB78','#FFFFFF','#898373','1F1C17',
'#450003','#5C0002','#94090D','#D40D12','FFED75',
'#0770A2','#82D9F7','#FEFEFE','#AEC844','F36622',
'#30394F','#FF434C','#6ACEEB','#EDE8DF','0E6569',
'#FF6B6B','#556270','#C7F464','#4ECDC4','EDC8BB',
'#D9B500','#FFED9C','#BFCC85','#748F74','454545',
'#452E32','#A34B1B','#B5A187','#EDDF9A','A7CC31',
'#2C2B33','#596664','#909980','#CCC08D','FF8A00',
'#C21F1F','#FFFFFC','#E34446','#FFFFDB','E36D6F',
'#282828','#00AAB5','#C1C923','#F41C54','F5F0F0',
'#3A3F40','#202627','#151B1E','#EFF4FF','41444D',
'#DEBB73','#4D0017','#010000','#4D0F30','9A002F',
'#EB9328','#FFA754','#FFD699','#FFF5DC','4FA6B3',
'#025E73','#037F8C','#D9D59A','#D9BD6A','590202',
'#636266','#E0CEA4','#E8A579','#7D6855','42403E',
'#FF0000','#FF4000','#FF7F00','#FFBF00','FFFF00',
'#FFFFFF','#74ADA6','#1E5E6F','#241B1F','68A81E',
'#5A0532','#FF6745','#FFC861','#9DAE64','27404A',
'#ACCBBC','#467847','#E8E4C1','#A60303','730202',
'#5C4B51','#8CBEB2','#F2EBBF','#F3B562','F06060',
'#0D2557','#93A8C9','#FFFFFF','#F5DED5','558D96',
'#F53C4A','#565157','#10CFC8','#F2EEE7','F5D662',
'#FFD97B','#E65029','#A60027','#660033','191C26',
'#595408','#A6800D','#A66D03','#A63F03','730C02',
'#2E031F','#590424','#8C072B','#BF0A2B','DEEFC5',
'#E0C882','#A6874E','#BFA169','#D9B779','F2D399',
'#D88681','#A67673','#746566','#535A5D','324F54',
'#FC297D','#FB607A','#FDA286','#FDC188','FEE78A',
'#FFECA1','#B3B27F','#4C5E52','#2F3436','FFBE2C',
'#D93312','#B3AB82','#45735F','#394D47','2C3233',
'#324143','#6595A3','#C8E3E8','#FCFFED','B6C28B',
'#477984','#FEF5EB','#C03C44','#EEAA4D','313E4A',
'#334D5C','#45B29D','#EFC94C','#E27A3F','DF4949',
'#630B11','#33322F','#2A2927','#1E1D1C','000000',
'#D94214','#FFF2C1','#80A894','#52736B','093844',
'#051E21','#00302D','#856434','#F28C28','FFAD4E',
'#D7DADD','#DDDEE3','#E1E1E9','#EDEFF4','F2F3F8',
'#BF495E','#41A693','#F2EC9B','#D9CF48','D9583B',
'#067072','#14A589','#DECFA6','#BAAE8C','F94B06',
'#423A38','#47B8C8','#E7EEE2','#BDB9B1','D7503E',
'#730324','#DFE3E6','#B4C4D4','#8BA2BD','456382',
'#537374','#F9BD7F','#EBD7A5','#ADC9A5','5C9E99',
'#88B59E','#B6DEC8','#39464D','#C04229','ABD1AB',
'#11A7FC','#95D127','#F2E415','#FF8638','EE3551',
'#212640','#5D718C','#4B95A6','#60BFBF','EFF2D8',
'#D8A64D','#9B5422','#351411','#5B0D0D','991C11',
'#53324F','#668D6E','#F2E0A0','#F19B7A','F0756E',
'#DFE0AF','#A4BAA2','#569492','#41505E','383245',
'#7BBADE','#93DE7F','#FFED5D','#F29E4A','FF7050',
'#133800','#1B4F1B','#398133','#5C9548','93E036',
'#D9D7AD','#91A685','#FF6A00','#37485C','1C232E',
'#008767','#FFB27A','#FF6145','#AB2141','5E1638',
'#727B7F','#CCEAEA','#7A7556','#2E2125','44CACC',
'#FFFFED','#FF2C38','#FF9A3A','#FFF040','67D9FF',
'#007148','#60A859','#9BDA6A','#C7F774','F9FFEF',
'#092740','#45698B','#90B0CC','#F1FAFF','8FD36F',
'#E2FFA0','#7D8076','#FAFFED','#C2CCBE','8F7D70',
'#00736A','#00BC9F','#F1EEC7','#FEA301','F2561A',
'#26282E','#AD5138','#F7F7F7','#DDDAE0','8594AE',
'#1A191F','#35352F','#484042','#4E5252','E64D38',
'#49454A','#E69B02','#FAF4C6','#B1D631','324052',
'#5F1A2B','#1D2834','#6F8B78','#E4D49E','C96466',
'#012D3D','#38AD9E','#FFEB9E','#FF6867','D0DBED',
'#0D1F36','#104954','#1E9C89','#38CC85','60EB7B',
'#8C4E03','#9FA66A','#F2EC94','#F23005','8B0F03',
'#000001','#20201F','#E2E2E4','#590402','B80000',
'#344059','#465973','#F2D272','#A69460','595139',
'#33454C','#608F85','#B6E5CB','#8BAF95','54584E',
'#FBFEF6','#B7BFA4','#687F70','#1A3841','BF3847',
'#D7E836','#86FFC7','#FFB048','#E8366C','593BFF',
'#34A9FF','#5982DB','#665EB8','#684682','632E62',
'#004056','#2C858D','#74CEB7','#C9FFD5','FFFFCB',
'#BFB978','#84945C','#516967','#4D3130','281B24',
'#103B73','#20638C','#3786A6','#4EABBF','EBEFF2',
'#9FB1BF','#1D2D63','#1C5357','#1F6E56','196331',
'#FFEBBA','#C3BD91','#88947B','#4C3F3F','2A2727',
'#347373','#4EA6A6','#91D9D9','#FFFFFD','F2E205',
'#828948','#EFDFC2','#006971','#DC533E','840000',
'#000137','#29003F','#79003D','#D04D14','F89801',
'#370005','#4B0005','#5F0005','#730005','870005',
'#C3AE8D','#F25260','#2D5F73','#6BADC9','8FCED6',
'#9E1B36','#F7EDBA','#E69B3D','#EB3355','3D241D',
'#1D8281','#44BF87','#FBD258','#F29A3F','DB634F',
'#035C75','#1B808C','#31A6A8','#F3F1BC','F3AD14',
'#FF7500','#665130','#EBB643','#CEDAA8','668E84',
'#384D3A','#3E6653','#728053','#A68357','D97C71',
'#012326','#17455C','#E1CAAB','#FE8333','FA4913',
'#1A2944','#2DA7C7','#56ACBA','#98C4C9','CBD5D2',
'#BF3542','#CDC5BA','#EBE3D6','#3C3C3C','2E2E2E',
'#231921','#695F74','#BEB4CB','#EBEBF0','D2DCEB',
'#34373F','#686C75','#F3E9D0','#BEB7A7','8E867C',
'#661510','#D9351A','#F2C76F','#BF9727','204D3F',
'#3CFFEE','#24AABC','#356781','#2C3D51','1C1F24',
'#DA3537','#FFFCC4','#00585F','#6A6A61','2A2C2B',
'#AE3135','#D1AF87','#8C826B','#3D3C33','F2F0CE',
'#FF0894','#FF5E9F','#FF91A7','#FFB5CA','F5F0BA',
'#99878D','#323232','#646464','#7E4A5C','372129',
'#3FB8AF','#7FC7AF','#DAD8A7','#FFB38B','FF3F34',
'#402B3C','#6AA6A6','#D9CCA7','#F2B263','F26835',
'#6AA690','#F2BC1B','#F2DC99','#F29057','BF1F1F',
'#F4FAC7','#7BAD8D','#FFB158','#F77F45','C2454E',
'#E5533C','#F5E346','#93D06D','#50AC6A','227864',
'#39588A','#A9BDD7','#FFFFFF','#FFEADD','FFD0BB',
'#B0B595','#615F4F','#828567','#91A380','EAFFCD',
'#00427F','#0066BD','#66B5CC','#F0E4C5','D6C28F',
'#FF6313','#F9E4B3','#C29689','#74474B','45232E',
'#00585F','#009393','#FFFCC4','#C7C49B','EB0A00',
'#091840','#44A2FF','#F7F7EA','#B3CC63','4C6620',
'#5CBBE3','#FCF1BC','#5C8182','#383A47','B4F257',
'#9E9E9E','#E5E1D1','#E0393D','#253746','425563',
'#4D9453','#FFFFB1','#ADDE4E','#FF9D27','A62A16',
'#B70046','#FF850B','#FFEBC5','#109679','675A4C',
'#363636','#0599B0','#A4BD0A','#FFA615','FF2E00',
'#7D8077','#BBBFB2','#FAFFED','#E82A33','E3DEBC',
'#FD9F44','#FC5C65','#007269','#03A679','FAF0B9',
'#134B57','#81A489','#F1D8B5','#F2A054','C04D31',
'#946E49','#394042','#EDDBAC','#872A0C','BA8E3A',
'#404040','#024959','#037E8C','#FFFFFF','F24C27',
'#2A3342','#163C6E','#4E5F61','#E6A015','EDE7BE',
'#445060','#829AB5','#849E91','#C14543','D6D5D1',
'#8A9126','#B7BF5E','#FFE9C4','#F5B776','F58E45',
'#9B2D1E','#3C3A28','#78A080','#9BCD9E','FFFFAE',
'#FF6138','#FFFF9D','#BEEB9F','#79BD8F','00A388',
'#990000','#FF6600','#FF9900','#996633','CC9966',
'#DCE6DA','#B8CCBB','#98B3A5','#7A9994','62858C',
'#0B1C29','#3B7C8F','#73A5A3','#98C1B7','F0EBD2',
'#F6CB51','#E25942','#13A89E','#3F4953','F2E7DA',
'#282F36','#FFFEFC','#BDA21D','#BFBC5B','D2E098',
'#8C182D','#DE7140','#FCB95A','#FAE285','6A7349',
'#6B9100','#FFE433','#FF841F','#E03D19','A6001C',
'#FFEAA7','#D9D697','#9FC49F','#718C6A','543122',
'#CFF09E','#A8DBA8','#79BD9A','#3B8686','0B486B',
'#0C2233','#065471','#0A91AB','#FFC045','F2F2F2',
'#BEE8E0','#373C40','#2E2621','#73320B','FF5E00',
'#1B2C35','#A3BFC6','#FF005D','#222A30','293A42',
'#FF8400','#3B4044','#494948','#E6E1D8','F7F2E9',
'#6A482D','#518C86','#F6BF3D','#EF7C27','BF2424',
'#261C2B','#292B39','#226468','#608D80','829D8F',
'#B2AD9A','#110E00','#363226','#A9A695','ECE9D8',
'#1B1B26','#26394D','#286480','#13B3BF','A3FF57',
'#F2C2A7','#F5E5C5','#593D28','#422C21','93DEDB',
'#001028','#033140','#1E5A5B','#7BA78C','EBEDC6',
'#544E6E','#808CB0','#ABD1D9','#D9FFF7','DDF556',
'#323A45','#596677','#758194','#FFFFFF','E74C3C',
'#45291A','#AB926D','#DBD1BC','#4999C3','5FCBEC',
'#6B151D','#2E1615','#A8553A','#DB8F5A','F2C18E',
'#000623','#28475C','#4A6C74','#8BA693','F0E3B1',
'#60807B','#81B37A','#BCCC5F','#FFEE65','E64964',
'#FFFFFA','#A1A194','#5B605F','#464646','FF6600',
'#1E1B17','#577270','#9C9A79','#C7BDA1','580E0C',
'#452F27','#5E504A','#6B6865','#9BBAB2','B0FFED',
'#1B5257','#F7F6C3','#F28159','#CC5850','4F1C2E',
'#FAA51B','#BF511F','#2C445E','#2F6D82','5EE4EB',
'#BF3952','#59364A','#556D73','#D9D1A9','D95F5F',
'#024959','#037E8C','#F2EFDC','#E74C30','363636',
'#221A26','#544759','#A197A6','#F27405','D93D04',
'#C4A44A','#E6D399','#9AB8A9','#7C8A7F','4E4B44',
'#FFFEC8','#B1BF99','#5B604D','#39382B','26181E',
'#4E3C51','#21A68D','#3BBF9A','#F2E8B6','F25749',
'#102144','#1B325E','#254580','#3C63B0','5D8AEA',
'#2A3A48','#3E6372','#B2D4DC','#FAFAFF','FF4B00',
'#FFF1BF','#F20058','#FFAEAC','#000001','7D7A96',
'#FDFFC6','#F2F096','#FF0080','#DE0049','521218',
'#5B0E00','#FBB500','#FBD864','#807D1A','59233C',
'#1E1E1F','#424143','#67666A','#807F83','CBC9CF',
'#3C3658','#3EC8B7','#7CD0B4','#B9D8B1','F7E0AE',
'#FFFFFF','#99B75F','#D5DD98','#EBF4DB','D8D8D8',
'#248A8A','#C9FA58','#F9E555','#FAAC38','F2572A',
'#086B63','#77A490','#E2D8C1','#BFAE95','7C7159',
'#5C4B51','#8CBEB2','#F2EBBF','#A5C88F','EF847B',
'#17162F','#89346D','#C76058','#FFB248','E8C475',
'#6E8F4A','#65D9C5','#F2E7B6','#EDA430','AB3E2C',
'#30394F','#FF434C','#6ACEEB','#EDE8DF','0E6569',
'#8E1B13','#F9E4B3','#849689','#46464A','29232E',
'#686B30','#AB9A52','#E8BA67','#D68F4F','BA512E',
'#E54E45','#DBC390','#F2F2EF','#13A3A5','403833',
'#65BA99','#59A386','#F1DDBB','#D6C4A6','E74C3C',
'#A6FFBC','#4ACFAF','#00A995','#006161','003D4C',
'#33271E','#8B7653','#C8D9A0','#FDEE9D','233331',
'#048789','#503D2E','#D44D27','#E2A72E','EFEBC8',
'#E5FF1E','#A9D943','#75A660','#698070','494D4B',
'#2DEBA2','#91F57F','#EBAA69','#E70049','2B0027',
'#990000','#336699','#DDDDDD','#999999','333333',
'#F13A4B','#3D3C3E','#22BDAF','#F4F4F4','D7D7D7',
'#F53A59','#001D2D','#15A88C','#B7D9C8','F3F5F4',];

outArrayPalette.set(colors);

};

Ops.Array.PaletteLibrary.prototype = new CABLES.Op();
CABLES.OPS["a96020ac-0832-478e-bbb7-d6246d0eeedf"]={f:Ops.Array.PaletteLibrary,objName:"Ops.Array.PaletteLibrary"};




// **************************************************************
// 
// Ops.Array.ParseArray_v2
// 
// **************************************************************

Ops.Array.ParseArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const text = op.inStringEditor("text", "1,2,3"),
    separator = op.inString("separator", ","),
    toNumber = op.inValueBool("Numbers", true),
    trim = op.inValueBool("Trim", true),
    splitNewLines = op.inBool("Split Lines", false),
    parsed = op.outTrigger("Parsed"),
    arr = op.outArray("array"),
    len = op.outNumber("length");

text.setUiAttribs({ "ignoreBigPort": true });

text.onChange = separator.onChange = toNumber.onChange = trim.onChange = parse;

splitNewLines.onChange = () =>
{
    separator.setUiAttribs({ "greyout": splitNewLines.get() });
    parse();
};

parse();

function parse()
{
    if (!text.get())
    {
        arr.set(null);
        arr.set([]);
        len.set(0);
        return;
    }

    let textInput = text.get();
    if (trim.get() && textInput)
    {
        textInput = textInput.replace(/^\s+|\s+$/g, "");
        textInput = textInput.trim();
    }

    let r;
    let sep = separator.get();
    if (separator.get() === "\\n") sep = "\n";
    if (splitNewLines.get()) r = textInput.split("\n");
    else r = textInput.split(sep);

    if (r[r.length - 1] === "") r.length -= 1;

    len.set(r.length);

    if (trim.get())
    {
        for (let i = 0; i < r.length; i++)
        {
            r[i] = r[i].replace(/^\s+|\s+$/g, "");
            r[i] = r[i].trim();
        }
    }

    op.setUiError("notnum", null);
    if (toNumber.get())
    {
        let hasStrings = false;
        for (let i = 0; i < r.length; i++)
        {
            r[i] = Number(r[i]);
            if (!CABLES.UTILS.isNumeric(r[i]))
            {
                hasStrings = true;
            }
        }
        if (hasStrings)
        {
            op.setUiError("notnum", "Parse Error / Not all values numerical!");
        }
    }

    arr.set(null);
    arr.set(r);
    parsed.trigger();
}


};

Ops.Array.ParseArray_v2.prototype = new CABLES.Op();
CABLES.OPS["c974de41-4ce4-4432-b94d-724741109c71"]={f:Ops.Array.ParseArray_v2,objName:"Ops.Array.ParseArray_v2"};




// **************************************************************
// 
// Ops.Array.PerlinArray
// 
// **************************************************************

Ops.Array.PerlinArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArrayX = op.inArray("Array in X"),
    inTimeArray = op.inArray("Array time"),
    inTime = op.inFloat("Time in Y", 0),
    seed = op.inFloatSlider("Seed 0-1", 0.0),
    inFrequency = op.inFloat("Frequency", 10),
    outArray = op.outArray("Array out"),
    outArrayLength = op.outNumber("Array length out");

let showingError = false;

let newArr = [];
outArray.set(newArr);

seed.set(Math.random());

inArrayX.onChange = inTimeArray.onChange = inTime.onChange = inFrequency.onChange = update;

seed.onChange = function ()
{
    Math.randomSeed = seed.get();
    noise.seed(Math.seededRandom());
    update();
};

function update()
{
    let arr = inArrayX.get();
    let arrTime = inTimeArray.get();

    let time = inTime.get();
    let mult = inFrequency.get();

    if (arrTime)
    {
        if (!arr || !arrTime)
        {
            outArray.set(null);
            return;
        }
        if (arr.length != arrTime.length)
        {
            if (!showingError)
            {
                op.uiAttr({ "error": "Arrays do not have the same length !" });
                outArrayLength.set(0);
                showingError = true;
            }
            outArray.set(null);
            return;
        }
        if (showingError)
        {
            showingError = false;
            op.uiAttr({ "error": null });
        }

        if (newArr.length != arr.length)newArr.length = arr.length;

        for (var i = 0; i < arr.length; i++)
        {
            newArr[i] = noise.perlin2(arr[i] * mult, arrTime[i] + time);
        }
    }
    else if (!arrTime)
    {
        if (!arr)
        {
            outArray.set(null);
            return;
        }

        if (newArr.length != arr.length)newArr.length = arr.length;

        for (var i = 0; i < arr.length; i++)
        {
            newArr[i] = noise.perlin2(arr[i] * mult, time);
        }
    }

    outArray.set(null);
    outArray.set(newArr);
    outArrayLength.set(newArr.length);
}


};

Ops.Array.PerlinArray.prototype = new CABLES.Op();
CABLES.OPS["ed55556e-f319-47cc-bce6-ea015b45650b"]={f:Ops.Array.PerlinArray,objName:"Ops.Array.PerlinArray"};




// **************************************************************
// 
// Ops.Array.Phyllotaxis
// 
// **************************************************************

Ops.Array.Phyllotaxis = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exec=op.inTrigger("Render");
const inNum=op.inValueInt("Num",400);
const inC=op.inValue("Scale",0.1);
const inI=op.inValue("Param",100);

const outArr=op.outArray("Coordinates");

const arr=[];

inNum.onChange=update;
inC.onChange=update;
inI.onChange=update;

function update()
{
    arr.length=Math.floor(inNum.get()*3);

    var n=inNum.get();
    var c=inC.get();
    
    var ii=inI.get();
    
    for (var i = 0; i < n; i++)
    {
        var a = i * ii;
        var r = c * Math.sqrt(i);
        var x = r * Math.cos(a);
        var y = r * Math.sin(a);
        var hu = i/3.0 % 360;
        
        arr[i*3+0]=x;
        arr[i*3+1]=y;
        arr[i*3+2]=0;
    }
    outArr.set(null);
    outArr.set(arr);
}

update();

};

Ops.Array.Phyllotaxis.prototype = new CABLES.Op();
CABLES.OPS["312b5220-c0f9-4003-9072-e400f216251a"]={f:Ops.Array.Phyllotaxis,objName:"Ops.Array.Phyllotaxis"};




// **************************************************************
// 
// Ops.Array.PointArray.CircularPoints
// 
// **************************************************************

Ops.Array.PointArray.CircularPoints = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    radius = op.inValue("Radius", 1),
    segments = op.inValue("Round Segments", 40),
    percent = op.inFloat("Rounds", 1),
    inRoundOffset = op.inFloat("Radius Add Round", 0.1),
    inPointRadOffset = op.inFloat("Radius Add Point", 0.1),
    inOffset = op.inFloat("Offset", 0),
    inPointOffset = op.inFloat("Point Offset XY", 0.1),
    inPointOffsetZ = op.inFloat("Point Offset Z", 0.1),
    inOffsetRot = op.inFloat("Offset Rotation"),
    outArr = op.outArray("Points", 3),
    outRotArr = op.outArray("Rotation", 3),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array lengths");

inOffset.onChange =
    inOffsetRot.onChange =
    inPointRadOffset.onChange =
    inPointOffset.onChange =
    radius.onChange =
    inPointOffsetZ.onChange =
    inRoundOffset.onChange =
    percent.onChange =
    segments.onChange = calcArray;

function calcArray()
{
    const segs = Math.max(3, Math.floor(segments.get()));
    const points = [];
    const rots = [];

    const roundOffset = inRoundOffset.get();

    let count = 0;
    const offsetRot = inOffsetRot.get();
    const r = radius.get();
    const pointOff = inPointRadOffset.get() / 100;
    const roundOff = inRoundOffset.get();
    const offZ = inPointOffsetZ.get();
    let progressOffset = 0.0;

    for (let i = 0; i < segs * percent.get(); i++)
    {
        progressOffset = i * inPointOffset.get() + inOffset.get();
        const radiusOff = Math.floor(i / segs) * roundOff;

        let degInRad = (360 / segs) * (i + progressOffset) * CGL.DEG2RAD;
        let posx = Math.cos(degInRad) * (r + radiusOff + pointOff * i);
        let posy = Math.sin(degInRad) * (r + radiusOff + pointOff * i);

        rots.push(0, 0, degInRad * CGL.RAD2DEG - offsetRot);

        points.push(posx, posy, i * offZ);
    }

    outArr.set(null);
    outArr.set(points);

    outRotArr.set(null);
    outRotArr.set(rots);

    outTotalPoints.set(points.length / 3);
    outArrayLength.set(points.length);
}

calcArray();


};

Ops.Array.PointArray.CircularPoints.prototype = new CABLES.Op();
CABLES.OPS["5d2de367-c2b8-4702-abf0-b16bbeb22f37"]={f:Ops.Array.PointArray.CircularPoints,objName:"Ops.Array.PointArray.CircularPoints"};




// **************************************************************
// 
// Ops.Array.PointArray.FillPointArrayDuplicates
// 
// **************************************************************

Ops.Array.PointArray.FillPointArrayDuplicates = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inNumPoints = op.inValueInt("Num Elements", 1000),
    inCalc = op.inTriggerButton("Calculate"),
    outArr = op.outArray("Result");
op.toWorkPortsNeedToBeLinked(inArr);

let arr = [];

inCalc.onTriggered = function ()
{
    let num = inNumPoints.get();

    arr.length = num * 3;

    let oldArr = inArr.get();
    if (!oldArr)
    {
        outArr.set(null);
        return;
    }
    let numOld = oldArr.length;

    let i = 0;
    for (i = 0; i < numOld; i++)
    {
        arr[i] = oldArr[i];
    }

    Math.randomSeed = 5711;

    while (i < (num - 1) * 3)
    {
        let ind = Math.floor(Math.seededRandom() * (numOld / 3)) * 3;

        arr[i + 0] = oldArr[ind + 0];
        arr[i + 1] = oldArr[ind + 1];
        arr[i + 2] = oldArr[ind + 2];
        i += 3;
    }

    outArr.set(null);
    outArr.set(arr);
};


};

Ops.Array.PointArray.FillPointArrayDuplicates.prototype = new CABLES.Op();
CABLES.OPS["dae7416d-b130-487e-bdd3-ca5a18278d47"]={f:Ops.Array.PointArray.FillPointArrayDuplicates,objName:"Ops.Array.PointArray.FillPointArrayDuplicates"};




// **************************************************************
// 
// Ops.Array.PointArray.RedistributeSplinePoints
// 
// **************************************************************

Ops.Array.PointArray.RedistributeSplinePoints = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array3x"),
    num = op.inValueInt("Num Points", 100),
    inExec = op.inTriggerButton("Calculate"),
    inNormalized = op.inValueBool("Normalized"),
    result = op.outArray("Result"),
    outSplineLength = op.outNumber("Spline Length");

const
    animX = new CABLES.Anim(),
    animY = new CABLES.Anim(),
    animZ = new CABLES.Anim();

let needsMapping = true;
let newArray = [];
let totalSplineLength = 0;

function dist(x1, y1, z1, x2, y2, z2)
{
    let xd = x1 - x2;
    let yd = y1 - y2;
    let zd = z1 - z2;
    return Math.sqrt(xd * xd + yd * yd + zd * zd);
}

function splineLength(arr)
{
    let l = 0;
    for (let i = 3; i < arr.length; i += 3)
    {
        l += dist(arr[i - 3], arr[i - 2], arr[i - 1], arr[i + 0], arr[i + 1], arr[i + 2]);
    }

    return l;
}

function mapArrays()
{
    animX.clear();
    animY.clear();
    animZ.clear();
    let arr = inArr.get();
    if (!arr)
    {
        result.set([]);
        return;
    }
    totalSplineLength = splineLength(arr);
    outSplineLength.set(totalSplineLength);

    let distPos = 0;

    for (let i = 0; i < arr.length; i += 3)
    {
        let p = i / (arr.length - 3);
        if (i > 0)
        {
            distPos += dist(arr[i - 3], arr[i - 2], arr[i - 1], arr[i + 0], arr[i + 1], arr[i + 2]);
        }

        animX.setValue(distPos, arr[i + 0]);
        animY.setValue(distPos, arr[i + 1]);
        animZ.setValue(distPos, arr[i + 2]);
    }

    needsMapping = false;
}

function buildResultArray()
{
    let n = Math.max(0, num.get());
    if (n === 0)
    {
        result.set([]);
        return;
    }

    newArray.length = n * 3;

    for (let i = 0; i < n; i++)
    {
        newArray[i * 3 + 0] = animX.getValue(i / n * totalSplineLength);
        newArray[i * 3 + 1] = animY.getValue(i / n * totalSplineLength);
        newArray[i * 3 + 2] = animZ.getValue(i / n * totalSplineLength);
    }

    result.set(null);
    result.set(newArray);
}

inArr.onChange = function ()
{
    needsMapping = true;
};

inExec.onTriggered = function ()
{
    if (needsMapping)mapArrays();
    buildResultArray();
};


};

Ops.Array.PointArray.RedistributeSplinePoints.prototype = new CABLES.Op();
CABLES.OPS["f17bae71-6047-49ea-af17-f7690e6e4d36"]={f:Ops.Array.PointArray.RedistributeSplinePoints,objName:"Ops.Array.PointArray.RedistributeSplinePoints"};




// **************************************************************
// 
// Ops.Array.RandomArrays
// 
// **************************************************************

Ops.Array.RandomArrays = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const numValues = op.inValueInt("Num Values", 100);
const inModeSwitch = op.inSwitch("Mode", ["A", "AB", "ABC", "ABCD"], "A");
const inSeed = op.inValueFloat("Random Seed ", 0);
const inInteger = op.inBool("Integer", false);
const outValues = op.outArray("Array Out");

const letters = ["A", "B", "C", "D"];

const inArray = letters.map(function (value)
{
    return {
        "min": op.inValueFloat("Min " + value, -1),
        "max": op.inValueFloat("Max " + value, 1),
    };
});

for (let i = 0; i < inArray.length; i += 1)
{
    const portObj = inArray[i];
    const keys = Object.keys(portObj);

    op.setPortGroup("Value Range " + letters[i], keys.map(function (key) { return portObj[key]; }));

    if (i > 0) keys.forEach(function (key) { portObj[key].setUiAttribs({ "greyout": true }); });
}


inModeSwitch.onChange = function ()
{
    const mode = inModeSwitch.get();
    const modes = inModeSwitch.uiAttribs.values;

    outValues.setUiAttribs({ "stride": inModeSwitch.get().length });

    const index = modes.indexOf(mode);

    inArray.forEach(function (portObj, i)
    {
        const keys = Object.keys(portObj);
        keys.forEach(function (key, j)
        {
            if (i <= index) portObj[key].setUiAttribs({ "greyout": false });
            else portObj[key].setUiAttribs({ "greyout": true });
        });
    });
    init();
};

const outTotalPoints = op.outNumber("Chunks Amount");
const outArrayLength = op.outNumber("Array length");

outValues.ignoreValueSerialize = true;

numValues.onChange = inSeed.onChange = inInteger.onChange = init;

const minMaxArray = [];

init();

function init()
{
    const arr = [];
    const mode = inModeSwitch.get();
    const modes = inModeSwitch.uiAttribs.values;
    const index = modes.indexOf(mode);

    Math.randomSeed = inSeed.get();

    const dimension = index + 1;
    const length = Math.floor(Math.abs(numValues.get() * dimension));

    arr.length = length;
    const tupleLength = length / dimension;
    const isInteger = inInteger.get();

    // optimization: we only need to fetch the max min for each component once
    for (let i = 0; i < dimension; i += 1)
    {
        const portObj = inArray[i];
        const max = portObj.max.get();
        const min = portObj.min.get();
        minMaxArray[i] = [min, max];
    }

    for (let j = 0; j < tupleLength; j += 1)
    {
        for (let k = 0; k < dimension; k += 1)
        {
            const min = minMaxArray[k][0];
            const max = minMaxArray[k][1];
            const index = j * dimension + k;

            if (isInteger) arr[index] = Math.floor(Math.seededRandom() * ((max + 1) - min) + min);
            else arr[index] = Math.seededRandom() * (max - min) + min;
        }
    }

    outValues.set(null);

    outValues.set(arr);
    outTotalPoints.set(arr.length / dimension);
    outArrayLength.set(arr.length);
}

// assign change handler
inArray.forEach(function (obj)
{
    Object.keys(obj).forEach(function (key)
    {
        const x = obj[key];
        x.onChange = init;
    });
});


};

Ops.Array.RandomArrays.prototype = new CABLES.Op();
CABLES.OPS["8a9fa2c6-c229-49a9-9dc8-247001539217"]={f:Ops.Array.RandomArrays,objName:"Ops.Array.RandomArrays"};




// **************************************************************
// 
// Ops.Array.RandomNumbersArray3_v2
// 
// **************************************************************

Ops.Array.RandomNumbersArray3_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    numValues = op.inValueInt("numValues", 100),
    min = op.inValueFloat("Min", -1),
    max = op.inValueFloat("Max", 1),
    seed = op.inValueFloat("random seed"),
    closed = op.inValueBool("Last == First"),
    inInteger = op.inValueBool("Integer", false),
    values = op.outArray("values", null, 3),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length");

op.setPortGroup("Value Range", [min, max]);
op.setPortGroup("", [seed, closed]);

values.ignoreValueSerialize = true;

closed.onChange =
    max.onChange =
    min.onChange =
    numValues.onChange =
    seed.onChange =
    inInteger.onChange = init;

const arr = [];
init();

function init()
{
    Math.randomSeed = seed.get();

    const isInteger = inInteger.get();

    const arrLength = arr.length = Math.max(0, Math.floor(Math.abs((numValues.get() || 0) * 3)));

    if (arrLength === 0)
    {
        values.set(null);
        outTotalPoints.set(0);
        outArrayLength.set(0);
        return;
    }

    const minIn = min.get();
    const maxIn = max.get();

    for (let i = 0; i < arrLength; i += 3)
    {
        if (!isInteger)
        {
            arr[i + 0] = Math.seededRandom() * (maxIn - minIn) + minIn;
            arr[i + 1] = Math.seededRandom() * (maxIn - minIn) + minIn;
            arr[i + 2] = Math.seededRandom() * (maxIn - minIn) + minIn;
        }
        else
        {
            arr[i + 0] = Math.floor(Math.seededRandom() * ((maxIn - minIn) + 1) + minIn);
            arr[i + 1] = Math.floor(Math.seededRandom() * ((maxIn - minIn) + 1) + minIn);
            arr[i + 2] = Math.floor(Math.seededRandom() * ((maxIn - minIn) + 1) + minIn);
        }
    }

    if (closed.get() && arrLength > 3)
    {
        arr[arrLength - 3 + 0] = arr[0];
        arr[arrLength - 3 + 1] = arr[1];
        arr[arrLength - 3 + 2] = arr[2];
    }

    values.set(null);
    values.set(arr);
    outTotalPoints.set(arrLength / 3);
    outArrayLength.set(arrLength);
}


};

Ops.Array.RandomNumbersArray3_v2.prototype = new CABLES.Op();
CABLES.OPS["45b2113a-1ca0-41d8-8d90-db3e394b669c"]={f:Ops.Array.RandomNumbersArray3_v2,objName:"Ops.Array.RandomNumbersArray3_v2"};




// **************************************************************
// 
// Ops.Array.RandomNumbersArray4_v2
// 
// **************************************************************

Ops.Array.RandomNumbersArray4_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    numValues = op.inValueInt("numValues", 100),
    min = op.inValueFloat("Min", 0),
    max = op.inValueFloat("Max", 1),
    seed = op.inValueFloat("random seed"),
    closed = op.inValueBool("Last == First"),
    inInteger = op.inValueBool("Integer", false),
    values = op.outArray("values", null, 4),
    outTotalPoints = op.outNumber("Tuple Amount"),
    outArrayLength = op.outNumber("Array length");

op.setPortGroup("Value Range", [min, max]);
op.setPortGroup("", [seed, closed]);

values.ignoreValueSerialize = true;

closed.onChange = max.onChange =
    min.onChange =
    numValues.onChange =
    seed.onChange =
    values.onLinkChanged =
    inInteger.onChange = init;

let arr = [];
init();

function init()
{
    Math.randomSeed = seed.get();

    let isInteger = inInteger.get();

    let arrLength = arr.length = Math.floor(Math.abs(numValues.get() * 4));
    if (arrLength === 0)
    {
        values.set(null);
        outTotalPoints.set(0);
        outArrayLength.set(0);
        return;
    }

    let minIn = min.get();
    let maxIn = max.get();

    for (let i = 0; i < arrLength; i += 4)
    {
        if (!isInteger)
        {
            arr[i + 0] = Math.seededRandom() * (maxIn - minIn) + minIn;
            arr[i + 1] = Math.seededRandom() * (maxIn - minIn) + minIn;
            arr[i + 2] = Math.seededRandom() * (maxIn - minIn) + minIn;
            arr[i + 3] = Math.seededRandom() * (maxIn - minIn) + minIn;
        }
        else
        {
            arr[i + 0] = Math.floor(Math.seededRandom() * ((maxIn - minIn) + 1) + minIn);
            arr[i + 1] = Math.floor(Math.seededRandom() * ((maxIn - minIn) + 1) + minIn);
            arr[i + 2] = Math.floor(Math.seededRandom() * ((maxIn - minIn) + 1) + minIn);
            arr[i + 3] = Math.floor(Math.seededRandom() * ((maxIn - minIn) + 1) + minIn);
        }
    }

    if (closed.get() && arrLength > 4)
    {
        arr[arrLength - 4 + 0] = arr[0];
        arr[arrLength - 4 + 1] = arr[1];
        arr[arrLength - 4 + 2] = arr[2];
        arr[arrLength - 4 + 3] = arr[2];
    }

    values.set(null);
    values.set(arr);
    outTotalPoints.set(arrLength / 4);
    outArrayLength.set(arrLength);
}


};

Ops.Array.RandomNumbersArray4_v2.prototype = new CABLES.Op();
CABLES.OPS["23c28491-06d3-4ea8-9e0d-c615b0783817"]={f:Ops.Array.RandomNumbersArray4_v2,objName:"Ops.Array.RandomNumbersArray4_v2"};




// **************************************************************
// 
// Ops.Array.RandomNumbersArray_v3
// 
// **************************************************************

Ops.Array.RandomNumbersArray_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    numValues = op.inValueInt("numValues", 10),
    min = op.inValueFloat("Min", 0),
    max = op.inValueFloat("Max", 1),
    seed = op.inValueFloat("random seed"),
    values = op.outArray("values", 100),
    outArrayLength = op.outNumber("Array length"),
    inInteger = op.inValueBool("Integer", false);

values.ignoreValueSerialize = true;
op.setPortGroup("Value Range", [min, max]);
op.setPortGroup("", [seed]);

max.onChange =
    min.onChange =
    numValues.onChange =
    seed.onChange =
    values.onLinkChanged =
    inInteger.onChange = init;

let arr = [];
init();

function init()
{
    Math.randomSeed = seed.get();
    let isInteger = inInteger.get();

    let arrLength = arr.length = Math.max(0, Math.abs(parseInt(numValues.get() || 0)));

    let minIn = min.get();
    let maxIn = max.get();

    if (arrLength === 0)
    {
        values.set(null);
        outArrayLength.set(0);
        return;
    }
    if (!isInteger)
    {
        for (var i = 0; i < arrLength; i++)
        {
            arr[i] = Math.seededRandom() * (maxIn - minIn) + minIn;
        }
    }
    else
    {
        for (var i = 0; i < arrLength; i++)
        {
            arr[i] = Math.floor(Math.seededRandom() * ((maxIn - minIn) + 1) + minIn);
        }
    }

    values.set(null);
    values.set(arr);
    outArrayLength.set(arrLength);
}


};

Ops.Array.RandomNumbersArray_v3.prototype = new CABLES.Op();
CABLES.OPS["e8609213-0803-4338-ab20-f95d0d65a110"]={f:Ops.Array.RandomNumbersArray_v3,objName:"Ops.Array.RandomNumbersArray_v3"};




// **************************************************************
// 
// Ops.Array.RandomWordsArray
// 
// **************************************************************

Ops.Array.RandomWordsArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let arr = ["apple", "baby", "back", "ball", "bear", "bed", "bell", "bird",
    "birthday", "boat", "box", "boy", "bread", "brother", "cake", "car",
    "cables", "cat", "chair", "chicken", "children", "Christmas", "coat", "corn",
    "cow", "day", "dog", "doll", "door", "duck", "egg", "eye", "farm", "farmer",
    "father", "feet", "fire", "fish", "floor", "flower", "game", "garden", "girl",
    "good-bye", "grass", "ground", "hand", "head", "hill", "home", "horse", "house",
    "kitty", "leg", "letter", "man", "men", "milk", "money", "morning", "mother",
    "name", "nest", "night", "paper", "party", "picture", "pig", "rabbit", "rain",
    "ring", "robin", "Santa Claus", "school", "seed", "sheep", "shoe", "sister",
    "snow", "song", "squirrel", "stick", "street", "sun", "table", "thing", "time",
    "top", "toy", "tree", "watch", "water", "way", "wind", "window", "wood"];

arr = CABLES.shuffleArray(arr);

let values = op.outArray("Words", arr);


};

Ops.Array.RandomWordsArray.prototype = new CABLES.Op();
CABLES.OPS["98057c3a-f6ec-48a6-8e8a-4b8316a0dcf1"]={f:Ops.Array.RandomWordsArray,objName:"Ops.Array.RandomWordsArray"};




// **************************************************************
// 
// Ops.Array.ReduceArray3_v3
// 
// **************************************************************

Ops.Array.ReduceArray3_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    arr = op.inArray("Array"),
    inMeth = op.inSwitch("Remove", ["Xth Item", "Random", "Duplicates"], "Xth Item"),
    num = op.inValueInt("Every xth Item", 2),
    inThresh = op.inFloatSlider("Threshold", 0.5),
    inSeed = op.inFloat("Seed", 1),
    outArr = op.outArray("Result Array");

num.onChange =
    inThresh.onChange =
    inSeed.onChange =
    arr.onChange = update;

const newArray = [];

let updateMethod = updateXth;

inMeth.onChange = () =>
{
    if (inMeth.get() == "Xth Item")updateMethod = updateXth;
    if (inMeth.get() == "Random")updateMethod = updateRandom;
    if (inMeth.get() == "Duplicates")updateMethod = updateDupes;

    update();
};

function update()
{
    const theArray = arr.get();
    if (!theArray) return;

    let newArray = updateMethod(theArray);

    outArr.set(null);
    outArr.set(newArray);
}

function updateDupes(theArray)
{
    const noDupesArr = [];

    for (let i = 0; i < theArray.length; i += 3)
    {
        let found = false;
        for (let j = 0; j < noDupesArr.length; j += 3)
        {
            if (
                theArray[i] == noDupesArr[j] &&
                theArray[i + 1] == noDupesArr[j + 1] &&
                theArray[i + 2] == noDupesArr[j + 2]
            )
            {
                found = true;
                break;
            }
        }

        if (!found)
        {
            noDupesArr.push(theArray[i], theArray[i + 1], theArray[i + 2]);
        }
    }
    return noDupesArr;
}

function updateRandom(theArray)
{
    Math.randomSeed = inSeed.get();

    const newArray = [];

    const thresh = inThresh.get();

    for (let i = 0; i < theArray.length; i += 3)
    {
        if (Math.seededRandom() > thresh)
            newArray.push(theArray[i + 0], theArray[i + 1], theArray[i + 2]);
    }

    return newArray;
}

function updateXth(theArray)
{
    const step = Math.max(0, Math.floor(num.get()));
    const newArray = [];

    if (step === 0)
    {
        outArr.set(null);
        outArr.set([]);
        return;
    }

    for (let i = 0; i < theArray.length; i += step * 3)
        newArray.push(theArray[i + 0], theArray[i + 1], theArray[i + 2]);

    return newArray;
}


};

Ops.Array.ReduceArray3_v3.prototype = new CABLES.Op();
CABLES.OPS["5ba30060-2e42-4441-8b15-49279dc3bb67"]={f:Ops.Array.ReduceArray3_v3,objName:"Ops.Array.ReduceArray3_v3"};




// **************************************************************
// 
// Ops.Array.ReverseArray3
// 
// **************************************************************

Ops.Array.ReverseArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
let inArrPort = op.inArray("Array");

// outputs
let outArrayPort = op.outArray("Reversed Array", []);

// change listeners
inArrPort.onChange = function ()
{
    let inArr = inArrPort.get();
    let reversedArr = [];
    if (inArr && inArr.length >= 3)
    {
        // in case the array is not dividable by 3, get rid of the rest
        // e.g. length = 31 -> ignore the last value
        //      length = 30 -> perfect fit for [x, y, z, ...]
        let iStart = (Math.floor(inArr.length / 3) * 3) - 3;
        for (let i = iStart; i >= 0; i -= 3)
        {
            reversedArr.push(inArr[i], inArr[i + 1], inArr[i + 2]);
        }
    }

    outArrayPort.set(null);
    outArrayPort.set(reversedArr);
};


};

Ops.Array.ReverseArray3.prototype = new CABLES.Op();
CABLES.OPS["5b0feea0-06ee-4e9d-befb-41793ab4fa2c"]={f:Ops.Array.ReverseArray3,objName:"Ops.Array.ReverseArray3"};




// **************************************************************
// 
// Ops.Array.RingBuffer
// 
// **************************************************************

Ops.Array.RingBuffer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let DEFAULT_LENGTH = 10;

const
    inVal = op.inValue("Value"),
    inWrite = op.inTriggerButton("Write"),
    inNum = op.inValueInt("Length", DEFAULT_LENGTH),
    inReset = op.inTriggerButton("Reset Index"),
    outArr = op.outArray("Result"),
    outIndex = op.outNumber("Index");

let index = 0;
let arr = [];
inNum.onChange = updateLength;
updateLength();

function updateLength()
{
    arr.length = Math.floor(inNum.get());
    for (let i = 0; i < arr.length; i++) arr[i] = 0;
    outArr.set(null);
    outArr.set(arr);
}

inWrite.onTriggered = function ()
{
    index = Math.floor(index % inNum.get());
    arr[index] = inVal.get();
    outIndex.set(index);
    outArr.set(null);
    outArr.set(arr);
    index++;
};

inReset.onTriggered = function ()
{
    index = 0;
};


};

Ops.Array.RingBuffer.prototype = new CABLES.Op();
CABLES.OPS["38b77ea5-b44b-48b3-9433-09a83753a209"]={f:Ops.Array.RingBuffer,objName:"Ops.Array.RingBuffer"};




// **************************************************************
// 
// Ops.Array.RotateArray
// 
// **************************************************************

Ops.Array.RotateArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArray = op.inArray("Array in");
const count = op.inValueInt("Rotate amount", 0);
const outArray = op.outArray("ArrayOut");

let newArr = [];
outArray.set(newArr);

count.onChange =
inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    let rotateIndex = -count.get();

    newArr = rotate(inArray.get(), rotateIndex, 0);
    outArray.set(null);
    outArray.set(newArr);
};

// https://gist.github.com/aubergene/7ecfe624199e68f60258
function rotate(array, n, guard)
{
    let head, tail;
    n = (n === null) || guard ? 1 : n;
    n %= array.length;
    tail = array.slice(n);

    head = array.slice(0, n);
    return tail.concat(head);
}


};

Ops.Array.RotateArray.prototype = new CABLES.Op();
CABLES.OPS["e435d07b-8545-4469-befb-868510adcb76"]={f:Ops.Array.RotateArray,objName:"Ops.Array.RotateArray"};




// **************************************************************
// 
// Ops.Array.RouteArray
// 
// **************************************************************

Ops.Array.RouteArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

const
    NUM_PORTS = 10,
    DEFAULT_ARRAY_DEFAULT = [],
    indexPort = op.inInt('index'),
    arrayPort = op.inArray('array in'),
    defaultArrayPort = op.inArray('default array', DEFAULT_ARRAY_DEFAULT),
    arrayPorts = createOutPorts(DEFAULT_ARRAY_DEFAULT);

indexPort.onChange = arrayPort.onChange = defaultArrayPort.onChange = update;

setDefaultValues();
update();

function createOutPorts()
{
    var arr = [];
    for(var i=0; i<NUM_PORTS; i++)
    {
        var port = op.outArray('Index ' + i + ' array');
        arr.push(port);
    }
    defaultArrayPort.set(null);
    return arr;
};

function setDefaultValues()
{
    var defaultValue = defaultArrayPort.get();

    arrayPorts.forEach(port => port.set(null));
    if(defaultArrayPort.get())
    {
        arrayPorts.forEach(port => port.set(defaultValue));
    }
};

function update()
{
    setDefaultValues();
    var index = indexPort.get();
    var value = arrayPort.get();

    index = Math.floor(index);
    index = clamp(index, 0, NUM_PORTS-1);
    arrayPorts[index].set(value);
};

function clamp(value, min, max)
{
  return Math.min(Math.max(value, min), max);
};


};

Ops.Array.RouteArray.prototype = new CABLES.Op();
CABLES.OPS["6597c011-7b2a-4d7c-93f5-40fcc2047cfe"]={f:Ops.Array.RouteArray,objName:"Ops.Array.RouteArray"};




// **************************************************************
// 
// Ops.Array.SetNumberArray
// 
// **************************************************************

Ops.Array.SetNumberArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTriggerButton("exe"),
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    value = op.inValueFloat("value"),
    values = op.outArray("values");

exe.onTriggered = update;

let newArr = [];

function update()
{
    let arr = array.get();

    if (!Array.isArray(arr))
    {
        values.set(null);
        return;
    }

    newArr.length = arr.length;
    for (let i = 0; i < arr.length; i++)newArr[i] = arr[i];

    newArr[Math.floor(index.get())] = value.get();

    values.set(null);
    values.set(newArr);
}


};

Ops.Array.SetNumberArray.prototype = new CABLES.Op();
CABLES.OPS["ed39fd33-1b8d-4d04-a44d-4a22e4477a0a"]={f:Ops.Array.SetNumberArray,objName:"Ops.Array.SetNumberArray"};




// **************************************************************
// 
// Ops.Array.SetNumbersArray3
// 
// **************************************************************

Ops.Array.SetNumbersArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTriggerButton("exe"),
    array = op.inArray("array"),
    index = op.inValueInt("index"),
    value1 = op.inValueFloat("Value 1"),
    value2 = op.inValueFloat("Value 2"),
    value3 = op.inValueFloat("Value 3"),
    values = op.outArray("values");

let newArr = [];

function update()
{
    let arr = array.get();
    if (!arr) return;

    newArr.length = arr.length;
    for (let i = 0; i < arr.length; i++) newArr[i] = arr[i];

    const idx = 3 * Math.abs(Math.floor(index.get()));
    newArr[idx + 0] = value1.get();
    newArr[idx + 1] = value2.get();
    newArr[idx + 2] = value3.get();

    values.set(null);
    values.set(newArr);
}

exe.onTriggered = update;


};

Ops.Array.SetNumbersArray3.prototype = new CABLES.Op();
CABLES.OPS["c3b2d0c9-0aa5-4605-948a-a53784fa8f1a"]={f:Ops.Array.SetNumbersArray3,objName:"Ops.Array.SetNumbersArray3"};




// **************************************************************
// 
// Ops.Array.ShuffleArray3_v2
// 
// **************************************************************

Ops.Array.ShuffleArray3_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array3"),
    inSeed = op.inFloat("Seed", 1),
    outArr = op.outArray("Result");

const newArr = [];
const rndArr = [];
inArr.onChange = update;
inSeed.onChange = update;

function fisherYatesShuffle(array)
{
    let i = 0;
    let j = 0;
    let temp = null;

    for (i = array.length - 1; i >= 0; i -= 1)
    {
        j = Math.floor(Math.seededRandom() * (i + 1));
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

function update()
{
    const arr = inArr.get();

    if (!arr || arr.length % 3 !== 0) return;
    if (arr.length != newArr.length) newArr.length = arr.length;

    let i = 0;
    let j = 0;
    const temp = null;
    Math.randomSeed = inSeed.get() + 1;

    for (i = 0; i < arr.length; i += 3) rndArr[i / 3] = i;

    for (let i = 0; i < 4; i++) fisherYatesShuffle(rndArr);

    for (i = 0; i < arr.length; i += 3)
    {
        j = rndArr[i / 3];

        newArr[i + 0] = arr[j + 0];
        newArr[i + 1] = arr[j + 1];
        newArr[i + 2] = arr[j + 2];
    }

    outArr.set(null);
    outArr.set(newArr);
}


};

Ops.Array.ShuffleArray3_v2.prototype = new CABLES.Op();
CABLES.OPS["147f0224-3241-423d-927c-14306134befa"]={f:Ops.Array.ShuffleArray3_v2,objName:"Ops.Array.ShuffleArray3_v2"};




// **************************************************************
// 
// Ops.Array.ShuffleArray_v2
// 
// **************************************************************

Ops.Array.ShuffleArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array3"),
    inSeed = op.inFloat("Seed", 1),
    outArr = op.outArray("Result");

let newArr = [];
let rndArr = [];
inArr.onChange = update;
inSeed.onChange = update;

function fisherYatesShuffle(array)
{
    let i = 0;
    let j = 0;
    let temp = null;

    for (i = array.length - 1; i > 0; i -= 1)
    {
        j = Math.floor(Math.seededRandom() * (i + 1));
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

function update()
{
    const arr = inArr.get();

    if (!arr)
    {
        outArr.set(null);
        return;
    }
    if (arr.length != newArr.length)
    {
        rndArr.length =
        newArr.length = arr.length;
    }

    let j = 0;
    let temp = null;
    Math.randomSeed = inSeed.get();

    for (let i = 0; i < arr.length; i++)
    {
        rndArr[i] = i;
    }

    fisherYatesShuffle(rndArr);

    for (let i = 0; i < arr.length; i++)
    {
        j = rndArr[i];
        newArr[i] = arr[j];
    }

    outArr.set(null);
    outArr.set(newArr);
}


};

Ops.Array.ShuffleArray_v2.prototype = new CABLES.Op();
CABLES.OPS["ea752da3-79f4-4674-95bf-722634365f53"]={f:Ops.Array.ShuffleArray_v2,objName:"Ops.Array.ShuffleArray_v2"};




// **************************************************************
// 
// Ops.Array.SimplexArray
// 
// **************************************************************

Ops.Array.SimplexArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArrayX = op.inArray("Array in X "),
    inTimeArray = op.inArray("Array time"),
    inTime = op.inFloat("Time in Y", 0),
    seed = op.inFloatSlider("Seed 0-1", 0.5),
    inFrequency = op.inFloat("Frequency", 10),
    outArray = op.outArray("Array out"),
    outArrayLength = op.outNumber("Array length out");

let showingError = false;

let newArr = [];
outArray.set(newArr);

seed.set(Math.random());

inArrayX.onChange = inTime.onChange = inFrequency.onChange = update;

seed.onChange = function ()
{
    Math.randomSeed = seed.get();
    noise.seed(Math.seededRandom());
    update();
};
function update()
{
    let arr = inArrayX.get();
    let arrTime = inTimeArray.get();

    let time = inTime.get();
    let mult = inFrequency.get();

    if (arrTime)
    {
        if (!arr || !arrTime)
        {
            outArray.set(null);
            return;
        }
        if (arr.length != arrTime.length)
        {
            if (!showingError)
            {
                op.uiAttr({ "error": "Arrays do not have the same length !" });
                outArrayLength.set(0);
                showingError = true;
            }
            outArray.set(null);
            return;
        }
        if (showingError)
        {
            showingError = false;
            op.uiAttr({ "error": null });
        }

        if (newArr.length != arr.length)newArr.length = arr.length;

        for (var i = 0; i < arr.length; i++)
        {
            newArr[i] = noise.simplex2(arr[i] * mult, arrTime[i] + time);
        }
    }
    else if (!arrTime)
    {
        if (!arr)
        {
            outArray.set(null);
            return;
        }

        if (newArr.length != arr.length)newArr.length = arr.length;

        for (var i = 0; i < arr.length; i++)
        {
            newArr[i] = noise.simplex2(arr[i] * mult, time);
        }
    }

    outArray.set(null);
    outArray.set(newArr);
    outArrayLength.set(newArr.length);
}


};

Ops.Array.SimplexArray.prototype = new CABLES.Op();
CABLES.OPS["094af2fe-c511-4c89-b384-4cc7c4c7b626"]={f:Ops.Array.SimplexArray,objName:"Ops.Array.SimplexArray"};




// **************************************************************
// 
// Ops.Array.SmoothArray
// 
// **************************************************************

Ops.Array.SmoothArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// look at http://sol.gfxile.net/interpolation/
const exec = op.inTrigger("Execute"),
    inArray = op.inArray("Array In"),
    inModeBool = op.inBool("Separate inc/dec", false),
    incFactor = op.inValue("Inc factor", 4),
    decFactor = op.inValue("Dec factor", 4),
    next = op.outTrigger("Next"),
    outArray = op.outArray("Array Out");

let goal = [];
let reset = false;
let lastTrigger = 0;

let newArr = [];
outArray.set(newArr);

let divisorUp;
let divisorDown;

let selectedMode = false;

onFilterChange();
getDivisors();
function onFilterChange()
{
    selectedMode = inModeBool.get();

    if (!selectedMode)
    {
        decFactor.setUiAttribs({ "greyout": true });
        incFactor.setUiAttribs({ "title": "Inc/Dec factor" });
    }
    else
    {
        decFactor.setUiAttribs({ "greyout": false });
        incFactor.setUiAttribs({ "title": "Inc factor" });
    }

    getDivisors();
    update();
}

function getDivisors()
{
    divisorUp = incFactor.get();

    if (selectedMode == false) divisorDown = incFactor.get();
    else divisorDown = decFactor.get();

    if (divisorUp <= 0 || divisorUp != divisorUp)divisorUp = 0.0001;
    if (divisorDown <= 0 || divisorDown != divisorDown)divisorDown = 0.0001;
    if (divisorUp <= 1.0) divisorUp = 1.0;
    if (divisorDown <= 1.0) divisorDown = 1.0;
}

inArray.onLinkChanged = () =>
{
    if (inArray) inArray.copyLinkedUiAttrib("stride", outArray);
};

inArray.onChange = function ()
{
    let arr = inArray.get();
    if (!arr) return;

    for (let i = 0; i < arr.length; i++)
    {
        goal[i] = arr[i] || 0;
    }
};

let oldVal = 0;

function update()
{
    let arr = inArray.get();
    if (!arr) return;

    if (newArr.length != arr.length)
    {
        newArr.length = arr.length || 0;
        reset = true;
    }

    let tm = 1;
    if (CABLES.now() - lastTrigger > 500 || lastTrigger === 0)reset = true;
    else tm = (CABLES.now() - lastTrigger) / 17;
    lastTrigger = CABLES.now();

    if (reset)
    {
        for (var i = 0; i < arr.length; i++)
        {
            newArr[i] = arr[i];
        }
        reset = false;
    }

    for (var i = 0; i < arr.length; i++)
    {
        let val = newArr[i];

        let diff = goal[i] - val;

        if (diff >= 0)
            val += (diff) / (divisorDown * tm);
        else
            val += (diff) / (divisorUp * tm);

        if (val > 0 && val < 0.000000001)val = 0;
        if (!val) val = 0;

        if (newArr[i] != val)
        {
            newArr[i] = val;
            oldVal = val;
        }
    }
    outArray.set(null);
    outArray.set(newArr);

    next.trigger();
}

exec.onTriggered = function ()
{
    update();
};

incFactor.onChange = decFactor.onChange = getDivisors;
inModeBool.onChange = onFilterChange;
update();


};

Ops.Array.SmoothArray.prototype = new CABLES.Op();
CABLES.OPS["8fd2ed9b-02e5-4349-b7bc-6665ca240ffa"]={f:Ops.Array.SmoothArray,objName:"Ops.Array.SmoothArray"};




// **************************************************************
// 
// Ops.Array.SortArray
// 
// **************************************************************

Ops.Array.SortArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const arrayIn = op.inArray("Array to sort"),
    sortMode = op.inSwitch("Sorting mode", ["Sort ascending", "Sort descending"], "Sort ascending"),
    arrayOut = op.outArray("Sorted array");
let arrOut = [];

arrayIn.onChange = sortMode.onChange = update;
update();

function update()
{
    let arrIn = arrayIn.get();

    arrOut.length = 0;

    if (!arrIn)
    {
        arrayOut.set(null);
        return;
    }

    arrOut.length = arrIn.length;

    let i;
    for (i = 0; i < arrIn.length; i++)
    {
        arrOut[i] = arrIn[i];
    }

    if (sortMode.get() === "Sort ascending")
    {
        arrOut.sort(function (a, b) { return a - b; });
    }
    else
    {
        arrOut.sort(function (a, b) { return b - a; });
    }

    arrayOut.set(null);
    arrayOut.set(arrOut);
}


};

Ops.Array.SortArray.prototype = new CABLES.Op();
CABLES.OPS["9ab49d2c-b4e4-4fc2-9e6e-8e664e094369"]={f:Ops.Array.SortArray,objName:"Ops.Array.SortArray"};




// **************************************************************
// 
// Ops.Array.SortArray3
// 
// **************************************************************

Ops.Array.SortArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inArr = op.inArray("Array");
let what = op.inValueSelect("What", ["None", "X", "Y", "Z", "XYZ"]);
what.set("X");
let outArr = op.outArray("Result");

let comparator = compareX;
let arrArr = [];

op.toWorkPortsNeedToBeLinked(inArr);

function compareX(a, b) { return a[0] - b[0]; }

function compareY(a, b) { return a[1] - b[1]; }

// function compareZ(a, b){ return b[2]-a[2]; }
function compareZ(a, b) { return a[2] - b[2]; }

function compareXYZ(a, b) { return (a[0] + a[1] + a[2]) - (b[0] + b[1] + b[2]); }

function sliceArray()
{
    let size = 3;
    arrArr.length = 0;
    let bigarray = inArr.get();
    for (let i = 0; i < bigarray.length; i += size)
    {
        arrArr.push(bigarray.slice(i, i + size));
    }
}

inArr.onChange = recalc;

function recalc()
{
    if (!Array.isArray(inArr.get()))
    {
        outArr.set(null);
        return;
    }
    if (!comparator)
    {
        outArr.set(null);
        outArr.set(inArr.get());
        return;
    }

    let start = performance.now();

    sliceArray();

    arrArr.sort(comparator);
    outArr.set(null);

    if (arrArr.flat)arrArr = arrArr.flat();
    else arrArr = [].concat.apply([], arrArr);

    outArr.set(null);
    outArr.set(arrArr);
}

what.onChange = function ()
{
    // if(what.get()=='None')comparator=null;
    if (what.get() == "X")comparator = compareX;
    if (what.get() == "Y")comparator = compareY;
    if (what.get() == "Z")comparator = compareZ;
    if (what.get() == "XYZ")comparator = compareXYZ;
    recalc();
};


};

Ops.Array.SortArray3.prototype = new CABLES.Op();
CABLES.OPS["b0fbc366-09a8-4695-87b3-5946210bf722"]={f:Ops.Array.SortArray3,objName:"Ops.Array.SortArray3"};




// **************************************************************
// 
// Ops.Array.SortArray3ByDistance
// 
// **************************************************************

Ops.Array.SortArray3ByDistance = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    outArr = op.outArray("Result");

function dist(x1, y1, z1, x2, y2, z2)
{
    let xd = x2 - x1;
    let yd = y2 - y1;
    let zd = z2 - z1;
    return Math.abs(Math.sqrt(xd * xd + yd * yd + zd * zd));
}

inArr.onChange = function ()
{
    if (!inArr.get()) return;

    let arr = inArr.get();

    if (arr.length == 0) return;

    let data = [];
    let i = 0;
    for (i = 0; i < arr.length; i += 3)
    {
        data[i / 3] = {
            "x": arr[i + 0],
            "y": arr[i + 1],
            "z": arr[i + 2],
            "found": false,
            "pos": 0
        };
    }

    let lastPoint = data[0];
    data[0].found = true;

    for (i = 0; i < data.length; i++)
    {
        let smallest = null;
        let smallDist = 999999999;

        for (let j = 0; j < data.length; j++)
        {
            let d = dist(
                lastPoint.x, lastPoint.y, lastPoint.z,
                data[j].x, data[j].y, data[j].z
            );

            if (d < smallDist && !data[j].found)
            {
                smallDist = d;
                smallest = data[j];
            }
        }

        if (smallest)
        {
            smallest.pos = i;
            smallest.found = true;
            lastPoint = smallest;
        }
    }

    data.sort(function (a, b)
    {
        return a.pos - b.pos;
    });

    let outArray = [];
    for (i = 0; i < data.length; i++)
    {
        outArray[i * 3 + 0] = data[i].x;
        outArray[i * 3 + 1] = data[i].y;
        outArray[i * 3 + 2] = data[i].z;
    }
    outArr.set(outArray);
};


};

Ops.Array.SortArray3ByDistance.prototype = new CABLES.Op();
CABLES.OPS["d67e094b-0206-4ab6-b97f-98a1242b334c"]={f:Ops.Array.SortArray3ByDistance,objName:"Ops.Array.SortArray3ByDistance"};




// **************************************************************
// 
// Ops.Array.SortArrayObjectsByKey
// 
// **************************************************************

Ops.Array.SortArrayObjectsByKey = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const arrayIn = op.inArray('Array to sort');
const propIn = op.inString('Sort property');
const sortMode = op.inSwitch('Sorting mode', ['Sort ascending', 'Sort descending'], 'Sort ascending');
const arrayOut = op.outArray('Sorted array');

let arrOut = [];

arrayIn.onChange = propIn.onChange = sortMode.onChange = update;

update();

function update() {
  const path = propIn.get();

  if (!arrayIn.get() || !path) {
    arrayOut.set(null);
    return;
  }

  arrOut = arrayIn.get();

  if (sortMode.get() === 'Sort ascending') {
    arrOut.sort(function(a, b) {
      const properties = Array.isArray(path) ? path : path.split('.');
      const propA = properties.reduce((prev, curr) => prev && prev[curr], a);
      const propB = properties.reduce((prev, curr) => prev && prev[curr], b);
      if (propA < propB) {
        return -1;
      } else if ( propA > propB) {
        return 1;
      } else {
        return 0;
      }
    });
  } else {
    arrOut.sort(function(a, b) {
      const properties = Array.isArray(path) ? path : path.split('.');
      const propA = properties.reduce((prev, curr) => prev && prev[curr], a);
      const propB = properties.reduce((prev, curr) => prev && prev[curr], b);
      if (propA < propB) {
        return 1;
      } else if ( propA > propB) {
        return -1;
      } else {
        return 0;
      }
    });
  }

  arrayOut.set(null);
  arrayOut.set(arrOut);
}


};

Ops.Array.SortArrayObjectsByKey.prototype = new CABLES.Op();
CABLES.OPS["6a5a6674-9247-47ea-b9e1-0438ca07529a"]={f:Ops.Array.SortArrayObjectsByKey,objName:"Ops.Array.SortArrayObjectsByKey"};




// **************************************************************
// 
// Ops.Array.SortArrayWithIndices
// 
// **************************************************************

Ops.Array.SortArrayWithIndices = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    arrayIn = op.inArray("Array to sort"),
    sortMode = op.inSwitch("Sorting mode", ["Ascending", "Descending"], "Ascending"),
    arrayOut = op.outArray("Sorted array"),
    arrayOutIdx = op.outArray("Sorted Indices");

let arrOut = [];
let indices = [];

arrayIn.onChange = sortMode.onChange = update;
update();

function update()
{
    let arrIn = arrayIn.get();

    arrOut.length = 0;

    if (!arrIn)
    {
        arrayOut.set(null);
        return;
    }

    arrOut.length = arrIn.length;
    indices.length = arrIn.length;

    for (let i = 0; i < arrIn.length; ++i) indices[i] = i;

    for (let i = 0; i < arrIn.length; i++)
    {
        arrOut[i] = arrIn[i];
    }

    if (sortMode.get() === "Sort ascending")
    {
        indices.sort(function (a, b) { return arrOut[a] < arrOut[b] ? -1 : arrOut[a] > arrOut[b] ? 1 : 0; });

        // arrOut.sort(function (a, b) { return a - b; });
    }
    else
    {
        indices.sort(function (a, b) { return arrOut[a] > arrOut[b] ? -1 : arrOut[a] < arrOut[b] ? 1 : 0; });
    }

    arrayOut.set(null);
    arrayOut.set(arrOut);
    arrayOutIdx.set(null);
    arrayOutIdx.set(indices);
}


};

Ops.Array.SortArrayWithIndices.prototype = new CABLES.Op();
CABLES.OPS["83f78f91-027b-4251-9cd9-70ac676059ff"]={f:Ops.Array.SortArrayWithIndices,objName:"Ops.Array.SortArrayWithIndices"};




// **************************************************************
// 
// Ops.Array.SplineLengthArray3
// 
// **************************************************************

Ops.Array.SplineLengthArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array3x"),
    inCalc = op.inTriggerButton("Calculate"),
    outValue = op.outNumber("Length");

let needsCalc = true;

inArr.onChange = function ()
{
    needsCalc = true;
};

inCalc.onTriggered = function ()
{
    if (needsCalc)
    {
        needsCalc = false;
        let arr = inArr.get();
        if (!arr || arr.length < 3)
        {
            outValue.set(0);
            return;
        }

        let l = 0;
        for (let i = 3; i < arr.length; i += 3)
        {
        	let xd = arr[i - 3] - arr[i + 0];
        	let yd = arr[i - 2] - arr[i + 1];
        	let zd = arr[i - 1] - arr[i + 2];
            l += Math.sqrt(xd * xd + yd * yd + zd * zd);
        }

        if (l != l)l = 0;
        outValue.set(l);
    }
};


};

Ops.Array.SplineLengthArray3.prototype = new CABLES.Op();
CABLES.OPS["894db700-f220-427d-99fe-553db0a60034"]={f:Ops.Array.SplineLengthArray3,objName:"Ops.Array.SplineLengthArray3"};




// **************************************************************
// 
// Ops.Array.SplinePositionAtDistanceArray3
// 
// **************************************************************

Ops.Array.SplinePositionAtDistanceArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTriggerButton("Calculate"),
    inArr = op.inArray("Array3x"),
    inDist = op.inValue("Distance"),
    inNormalized = op.inValueBool("Normalized"),

    outNext = op.outTrigger("Next"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z"),

    outSplineLength = op.outNumber("Spline Length");

let animX = new CABLES.Anim();
let animY = new CABLES.Anim();
let animZ = new CABLES.Anim();

let needsMapping = true;

function dist(x1, y1, z1, x2, y2, z2)
{
    let xd = x1 - x2;
    let yd = y1 - y2;
    let zd = z1 - z2;
    return Math.sqrt(xd * xd + yd * yd + zd * zd);
}

function splineLength(arr)
{
    let l = 0;
    for (let i = 3; i < arr.length; i += 3)
    {
        l += dist(arr[i - 3], arr[i - 2], arr[i - 1], arr[i + 0], arr[i + 1], arr[i + 2]);
    }

    outSplineLength.set(l);
    return l;
}

function mapArrays()
{
    animX.clear();
    animY.clear();
    animZ.clear();
    let arr = inArr.get();
    let sl = splineLength(arr);

    let distPos = 0;

    for (let i = 0; i < arr.length; i += 3)
    {
        let p = i / (arr.length - 3);
        if (i > 0)
        {
            distPos += dist(arr[i - 3], arr[i - 2], arr[i - 1], arr[i + 0], arr[i + 1], arr[i + 2]);
        }

        animX.setValue(distPos, arr[i + 0]);
        animY.setValue(distPos, arr[i + 1]);
        animZ.setValue(distPos, arr[i + 2]);
    }

    needsMapping = false;
}

inArr.onChange = function ()
{
    needsMapping = true;
};

inExec.onTriggered = function ()
{
    if (needsMapping)mapArrays();

    let d = inDist.get();
    if (inNormalized.get())d *= outSplineLength.get();

    outX.set(animX.getValue(d));
    outY.set(animY.getValue(d));
    outZ.set(animZ.getValue(d));

    outNext.trigger();
};


};

Ops.Array.SplinePositionAtDistanceArray3.prototype = new CABLES.Op();
CABLES.OPS["02100bb5-fe07-4c1b-8792-67f9add7afff"]={f:Ops.Array.SplinePositionAtDistanceArray3,objName:"Ops.Array.SplinePositionAtDistanceArray3"};




// **************************************************************
// 
// Ops.Array.SplinesToLineStripArray
// 
// **************************************************************

Ops.Array.SplinesToLineStripArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArrays = op.inArray("Array"),
    outArr = op.outArray("Result");

inArrays.onChange = function ()
{
    let inArr = inArrays.get();

    let arr = [];

    if (!inArr) return;

    for (let i = 0; i < inArr.length; i++)
    {
        let pointArray = inArr[i];

        for (let j = 3; j < pointArray.length - 3; j += 3)
        {
            arr.push(pointArray[j - 3]);
            arr.push(pointArray[j - 2]);
            arr.push(pointArray[j - 1]);
            arr.push(pointArray[j + 0]);
            arr.push(pointArray[j + 1]);
            arr.push(pointArray[j + 2]);
        }
    }

    outArr.set(null);
    outArr.set(arr);
};


};

Ops.Array.SplinesToLineStripArray.prototype = new CABLES.Op();
CABLES.OPS["0877ac11-4ebc-484c-aa10-276040756d0a"]={f:Ops.Array.SplinesToLineStripArray,objName:"Ops.Array.SplinesToLineStripArray"};




// **************************************************************
// 
// Ops.Array.StringToCharArray
// 
// **************************************************************

Ops.Array.StringToCharArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    strIn = op.inString("String", "test"),
    convertToNumbersBool = op.inBool("Convert to numbers", false),
    arrOut = op.outArray("Array out");

const arr = [];

function update()
{
    const str = strIn.get();
    if (str !== undefined && str !== null)
    {
        const strLength = str.length;

        arr.length = 0;
        arr.length = strLength;
        if (convertToNumbersBool.get())
        {
            for (let i = 0; i < strLength; i++)
            {
                arr[i] = str.charCodeAt(i);
            }
        }
        else
        {
            for (let i = 0; i < strLength; i++)
            {
                arr[i] = str.charAt(i);
            }
        }

        op.setUiError("null", null);
        arrOut.set(null);
        arrOut.set(arr);
    }
    else
    {
        op.setUiError("null", "input is not of type string");
        arrOut.set(null);
    }
}

update();
strIn.onChange = convertToNumbersBool.onChange = update;


};

Ops.Array.StringToCharArray.prototype = new CABLES.Op();
CABLES.OPS["02ca1ecb-b087-4000-90f9-de96dca2f459"]={f:Ops.Array.StringToCharArray,objName:"Ops.Array.StringToCharArray"};




// **************************************************************
// 
// Ops.Array.SubdivideArray1
// 
// **************************************************************

Ops.Array.SubdivideArray1 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inArr = op.inArray("Points");
let subDivs = op.inInt("Num Subdivs", 5);
let bezier = op.inValueBool("Smooth", true);
let bezierEndPoints = op.inValueBool("Bezier Start/End Points", true);

let result = op.outArray("Result");

op.toWorkPortsNeedToBeLinked(inArr);

subDivs.onChange = calc;
bezier.onChange = calc;
inArr.onChange = calc;
bezierEndPoints.onChange = calc;

function ip(x0, x1, x2, t)// Bezier
{
    let r = (x0 * (1 - t) * (1 - t) + 2 * x1 * (1 - t) * t + x2 * t * t);
    return r;
}

let arr = [];

function calc()
{
    if (!inArr.get())
    {
        result.set(null);
        return;
    }
    const subd = Math.floor(subDivs.get());
    let inPoints = inArr.get();

    if (inPoints.length < 3) return;

    let i = 0;
    let j = 0;
    let k = 0;
    let count = 0;

    if (subd > 0 && !bezier.get())
    {
        const newLen = (inPoints.length - 1) * subd;
        if (newLen != arr.length)
        {
            arr.length = newLen;
        }

        count = 0;
        for (i = 0; i < inPoints.length - 1; i++)
        {
            for (j = 0; j < subd; j++)
            {
                arr[count] =
                        inPoints[i] + (inPoints[i + 1] - inPoints[i]) * j / subd;
                count++;
            }
        }
    }
    else
    if (subd > 0 && bezier.get())
    {
        let newLen = (inPoints.length - 6) * (subd - 1);
        if (bezierEndPoints.get())newLen += 6;

        if (newLen != arr.length) arr.length = Math.floor(Math.abs(newLen));
        count = 0;

        if (bezierEndPoints.get())
        {
            arr[0] = inPoints[0];
            count = 1;
        }

        for (i = 1; i < inPoints.length - 1; i++)
        {
            for (j = 0; j < subd; j++)
            {
                let p = ip(
                    (inPoints[i - 1] + inPoints[i]) / 2,
                    inPoints[i + 0],
                    (inPoints[i + 1] + inPoints[i]) / 2,
                    j / subd
                );
                arr[count] = p;
                count++;
            }
        }

        if (bezierEndPoints.get())
        {
            arr[count] = inPoints[inPoints.length - 1];
        }
    }
    result.set(null);
    result.set(arr);
}


};

Ops.Array.SubdivideArray1.prototype = new CABLES.Op();
CABLES.OPS["fa10c94d-d14e-41d3-b690-26d7cac5f146"]={f:Ops.Array.SubdivideArray1,objName:"Ops.Array.SubdivideArray1"};




// **************************************************************
// 
// Ops.Array.SubdivideArray3_v2
// 
// **************************************************************

Ops.Array.SubdivideArray3_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Points"),
    subDivs = op.inInt("Num Subdivs", 5),
    bezier = op.inValueBool("Smooth", true),
    inLoop = op.inValueBool("Loop", false),
    bezierEndPoints = op.inValueBool("Bezier Start/End Points", true),
    result = op.outArray("Result");

op.toWorkPortsNeedToBeLinked(inArr);

let arr = [];

subDivs.onChange =
    inLoop.onChange =
    bezier.onChange =
    inArr.onChange =
    bezierEndPoints.onChange = calc;

function ip(x0, x1, x2, t)// Bezier
{
    const r = (x0 * (1 - t) * (1 - t) + 2 * x1 * (1 - t) * t + x2 * t * t);
    return r;
}

function calc()
{
    inLoop.setUiAttribs({ "greyout": !bezier.get() });
    bezierEndPoints.setUiAttribs({ "greyout": !bezier.get() });

    if (!inArr.get())
    {
        result.set(null);
        return;
    }
    const subd = Math.floor(subDivs.get());
    const inPoints = inArr.get();

    if (inPoints.length < 3) return;

    let i = 0;
    let j = 0;
    let k = 0;
    let count = 0;

    if (subd > 0 && !bezier.get())
    {
        const newLen = (inPoints.length - 3) * subd + 3;
        if (newLen != arr.length)
        {
            arr.length = newLen;
        }

        count = 0;
        for (i = 0; i < inPoints.length - 3; i += 3)
        {
            for (j = 0; j < subd; j++)
            {
                for (k = 0; k < 3; k++)
                {
                    arr[count] =
                        inPoints[i + k] + (inPoints[i + k + 3] - inPoints[i + k]) * j / subd;
                    count++;
                }
            }
        }
        arr[newLen - 3] = inPoints[inPoints.length - 3];
        arr[newLen - 2] = inPoints[inPoints.length - 2];
        arr[newLen - 1] = inPoints[inPoints.length - 1];
    }
    else
    if (subd > 0 && bezier.get())
    {
        let newLen = (inPoints.length - 6) * (subd - 1);
        if (bezierEndPoints.get())newLen += 6;

        if (newLen != arr.length) arr.length = Math.floor(Math.abs(newLen));
        count = 0;

        if (bezierEndPoints.get())
        {
            arr[0] = inPoints[0];
            arr[1] = inPoints[1];
            arr[2] = inPoints[2];
            count = 3;
        }

        const doLoop = inLoop.get();

        function idx(i)
        {
            if (doLoop) return i % (inPoints.length - 3);
            else return i;
        }

        let endi = inPoints.length - 3;
        if (doLoop)endi = inPoints.length;

        for (i = 3; i < endi; i += 3)
        {
            for (j = 0; j < subd; j++)
            {
                for (k = 0; k < 3; k++)
                {
                    const p = ip(
                        (inPoints[idx(i + k - 3)] + inPoints[idx(i + k)]) / 2,
                        inPoints[idx(i + k + 0)],
                        (inPoints[idx(i + k + 3)] + inPoints[idx(i + k + 0)]) / 2,
                        j / subd
                    );
                    arr[count] = p;
                    count++;
                }
            }
        }

        if (doLoop)
        {
            arr[count + 0] = arr[0];
            arr[count + 1] = arr[1];
            arr[count + 2] = arr[2];
            count++; count++; count++;
        }

        if (bezierEndPoints.get())
        {
            arr[count - 0] = inPoints[inPoints.length - 3];
            arr[count + 1] = inPoints[inPoints.length - 2];
            arr[count + 2] = inPoints[inPoints.length - 1];
        }
    }
    if (subd == 0)
    {
        arr = Array.from(inPoints);
    }

    result.set(null);
    result.set(arr);
}


};

Ops.Array.SubdivideArray3_v2.prototype = new CABLES.Op();
CABLES.OPS["d8bb5727-35e4-4e2a-999b-112ebc659720"]={f:Ops.Array.SubdivideArray3_v2,objName:"Ops.Array.SubdivideArray3_v2"};




// **************************************************************
// 
// Ops.Array.SwitchArray
// 
// **************************************************************

Ops.Array.SwitchArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let idx = op.inValueInt("Index");
let valuePorts = [];
let result = op.outArray("Result");

idx.onChange = update;

for (let i = 0; i < 10; i++)
{
    let p = op.inArray("Array " + i);
    valuePorts.push(p);
    p.onChange = update;
}

function update()
{
    if (idx.get() >= 0 && valuePorts[idx.get()])
    {
        result.set(valuePorts[idx.get()].get());
    }
}


};

Ops.Array.SwitchArray.prototype = new CABLES.Op();
CABLES.OPS["3fab881c-c2cf-42a0-9c42-2d8edfd93f57"]={f:Ops.Array.SwitchArray,objName:"Ops.Array.SwitchArray"};




// **************************************************************
// 
// Ops.Array.SwitchArrayOnTrigger
// 
// **************************************************************

Ops.Array.SwitchArrayOnTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let N_PORTS = 8;

// input ports
const
    inTrigger1 = op.inTriggerButton("Trigger 1"),
    inArray1 = op.inArray("Array 1"),
    inTrigger2 = op.inTriggerButton("Trigger 2"),
    inArray2 = op.inArray("Array 2"),
    inTrigger3 = op.inTriggerButton("Trigger 3"),
    inArray3 = op.inArray("Array 3"),
    inTrigger4 = op.inTriggerButton("Trigger 4"),
    inArray4 = op.inArray("Array 4"),
    inTrigger5 = op.inTriggerButton("Trigger 5"),
    inArray5 = op.inArray("Array 5"),
    inTrigger6 = op.inTriggerButton("Trigger 6"),
    inArray6 = op.inArray("Array 6"),
    inTrigger7 = op.inTriggerButton("Trigger 7"),
    inArray7 = op.inArray("Array 7"),
    inTrigger8 = op.inTriggerButton("Trigger 8"),
    inArray8 = op.inArray("Array 8");

// output ports
let outArray = op.outArray("Out Array");

// change listeners
inTrigger1.onTriggered = function ()
{
    outArray.set(inArray1.get());
};
inTrigger2.onTriggered = function ()
{
    outArray.set(inArray2.get());
};
inTrigger3.onTriggered = function ()
{
    outArray.set(inArray3.get());
};
inTrigger4.onTriggered = function ()
{
    outArray.set(inArray4.get());
};
inTrigger5.onTriggered = function ()
{
    outArray.set(inArray5.get());
};
inTrigger6.onTriggered = function ()
{
    outArray.set(inArray6.get());
};
inTrigger7.onTriggered = function ()
{
    outArray.set(inArray7.get());
};
inTrigger8.onTriggered = function ()
{
    outArray.set(inArray8.get());
};


};

Ops.Array.SwitchArrayOnTrigger.prototype = new CABLES.Op();
CABLES.OPS["08e0cc91-8fda-48c1-a98e-2bf7265d6683"]={f:Ops.Array.SwitchArrayOnTrigger,objName:"Ops.Array.SwitchArrayOnTrigger"};




// **************************************************************
// 
// Ops.Array.TextureBufferArray
// 
// **************************************************************

Ops.Array.TextureBufferArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inExec = op.inTrigger("Write");

const inTexture = op.inTexture("Texture");
const inNum = op.inValueInt("Num", 8);

const outArr = op.outArray("Result");

const inSort = op.inValueBool("Order");
const inClear = op.inValueBool("Clear", true);

const cgl = op.patch.cgl;
const frameBuf = cgl.gl.createFramebuffer();
const renderbuffer = cgl.gl.createRenderbuffer();
let index = 0;
const textures = [];
let quadMesh = null;
let inited = false;
const sorted = [];

inNum.onChange = init;

const bgFrag = ""
    .endl() + "UNI float a;"
    .endl() + "UNI sampler2D tex;"
    .endl() + "IN vec2 texCoord;"
    .endl() + "void main()"
    .endl() + "{"
    .endl() + "   vec4 col=texture2D(tex,texCoord);"
    .endl() + "   outColor= col;"
    .endl() + "}";
const bgShader = new CGL.Shader(cgl, "imgcompose bg");
bgShader.setSource(bgShader.getDefaultVertexShader(), bgFrag);
const textureUniform = new CGL.Uniform(bgShader, "t", "tex", 0);

inExec.onTriggered = render;

function init()
{
    if (inNum.get() == 0) return;
    for (let i = 0; i < textures.length; i++)
    {
        textures[i].delete();
    }

    if (!inTexture.get()) return;
    textures.length = inNum.get();
    sorted.length = inNum.get();

    // op.log(inTexture.get());

    for (let i = 0; i < inNum.get(); i++)
    {
        textures[i] = inTexture.get().clone();
        // textures[i].updateMipMap();
    }

    // cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, null);

    // cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);
    cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);
    cgl.gl.framebufferTexture2D(cgl.gl.FRAMEBUFFER, cgl.gl.COLOR_ATTACHMENT0, cgl.gl.TEXTURE_2D, textures[0].tex, 0);

    // cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, renderbuffer);

    // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, null);
    // cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, null);
    cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, null);

    // textures[0].updateMipMap();

    inited = true;
}

function createMesh()
{
    const geom = new CGL.Geometry("textureEffect rect");

    geom.vertices = [
        1.0, 1.0, 0.0,
        -1.0, 1.0, 0.0,
        1.0, -1.0, 0.0,
        -1.0, -1.0, 0.0
    ];

    geom.texCoords = [
        1.0, 1.0,
        0.0, 1.0,
        1.0, 0.0,
        0.0, 0.0
    ];

    geom.verticesIndices = [
        0, 1, 2,
        2, 1, 3
    ];

    quadMesh = new CGL.Mesh(cgl, geom);
}

function render()
{
    if (!inTexture.get())
    {
        op.log("no tex 1");
        return;
    }

    if (!inTexture.get().tex)
    {
        op.log("no tex 2");
        return;
    }

    if (!quadMesh)createMesh();
    if (!inited || !frameBuf)init();
    if (!textures[0] || textures.length == 0)
    {
        op.log("no tex");
        return;
    }

    if (!textures[0].compareSettings(inTexture.get()))init();
    // if(inTexture.get().width!=textures[0].width)init();
    // if(inTexture.get().height!=textures[0].height)init();

    index %= inNum.get();

    cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);
    cgl.gl.framebufferTexture2D(cgl.gl.FRAMEBUFFER, cgl.gl.COLOR_ATTACHMENT0, cgl.gl.TEXTURE_2D, textures[index].tex, 0);
    cgl.pushGlFrameBuffer(frameBuf);

    cgl.pushDepthTest(false);

    if (inClear.get())
    {
        cgl.gl.clearColor(0, 0, 0, 1);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
    }

    cgl.pushModelMatrix();

    cgl.pushPMatrix();
    cgl.gl.viewport(0, 0, inTexture.get().width, inTexture.get().height);
    mat4.perspective(cgl.pMatrix, 45, inTexture.get().width / inTexture.get().height, 0.1, 1100.0);

    cgl.pushPMatrix();
    mat4.identity(cgl.pMatrix);

    cgl.pushViewMatrix();
    mat4.identity(cgl.vMatrix);

    cgl.pushModelMatrix();
    mat4.identity(cgl.mMatrix);

    // here be rendering

    cgl.pushShader(bgShader);
    // cgl.currentTextureEffect.bind();

    cgl.setTexture(0, inTexture.get().tex);
    // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D,  );

    quadMesh.render(cgl.getShader());

    cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, cgl.popGlFrameBuffer());

    cgl.popShader();

    cgl.popDepthTest();
    cgl.popModelMatrix();

    cgl.popPMatrix();
    cgl.popModelMatrix();
    cgl.popViewMatrix();

    cgl.popPMatrix();
    cgl.resetViewPort();

    op.patch.cgl.gl.bindTexture(op.patch.cgl.gl.TEXTURE_2D, textures[index].tex);
    // this._colorTextures[i].updateMipMap();
    textures[index].updateMipMap();
    op.patch.cgl.gl.bindTexture(op.patch.cgl.gl.TEXTURE_2D, null);

    if (inSort.get())
    {
        for (let i = 0; i < textures.length; i++)
        {
            sorted[textures.length - i - 1] = textures[(index + i + 1) % inNum.get()];
        }

        outArr.set(null);
        outArr.set(sorted);
    }
    else
    {
        outArr.set(null);
        outArr.set(textures);
    }
    index++;
}


};

Ops.Array.TextureBufferArray.prototype = new CABLES.Op();
CABLES.OPS["04dc13d2-e339-4e1d-82c5-9c9ff1b175b8"]={f:Ops.Array.TextureBufferArray,objName:"Ops.Array.TextureBufferArray"};




// **************************************************************
// 
// Ops.Array.TransformArray3
// 
// **************************************************************

Ops.Array.TransformArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTriggerButton("Transform"),
    inArr = op.inArray("Array", 3),
    transX = op.inFloat("Translate X"),
    transY = op.inFloat("Translate Y"),
    transZ = op.inFloat("Translate Z"),
    scaleX = op.inFloat("Scale X", 1),
    scaleY = op.inFloat("Scale Y", 1),
    scaleZ = op.inFloat("Scale Z", 1),
    rotX = op.inFloat("Rotation X"),
    rotY = op.inFloat("Rotation Y"),
    rotZ = op.inFloat("Rotation Z"),
    next = op.outTrigger("Next"),
    outArr = op.outArray("Result", 3);

op.setPortGroup("Translation", [transX, transY, transZ]);
op.setPortGroup("Scale", [scaleX, scaleY, scaleZ]);
op.setPortGroup("Rotation", [rotX, rotY, rotZ]);

let resultArr = [];
let needsCalc = true;

let rotVec = vec3.create();
let emptyVec = vec3.create();
let transVec = vec3.create();
let centerVec = vec3.create();

inExec.onTriggered = doTransform;

inArr.onChange =
transX.onChange = transY.onChange = transZ.onChange =
scaleX.onChange = scaleY.onChange = scaleZ.onChange =
rotX.onChange = rotY.onChange = rotZ.onChange = calcLater;

function calcLater()
{
    needsCalc = true;
}

function doTransform()
{
    let arr = inArr.get();
    if (!arr)
    {
        outArr.set(null);
        return;
    }
    if (needsCalc)
    {
        resultArr.length = arr.length;

        const nrotx = rotX.get();
        const nroty = rotY.get();
        const nrotz = rotZ.get();
        const scx = scaleX.get();
        const scy = scaleY.get();
        const scz = scaleZ.get();
        const transx = transX.get();
        const transy = transY.get();
        const transz = transZ.get();
        const doRot = nrotx || nroty || nrotz;

        for (let i = 0; i < arr.length; i += 3)
        {
            resultArr[i + 0] = arr[i + 0] * scx;
            resultArr[i + 1] = arr[i + 1] * scy;
            resultArr[i + 2] = arr[i + 2] * scz;

            resultArr[i + 0] = resultArr[i + 0] + transx;
            resultArr[i + 1] = resultArr[i + 1] + transy;
            resultArr[i + 2] = resultArr[i + 2] + transz;

            if (doRot)
            {
                vec3.set(rotVec,
                    resultArr[i + 0],
                    resultArr[i + 1],
                    resultArr[i + 2]);

                if (nrotx != 0) vec3.rotateX(rotVec, rotVec, transVec, nrotx * CGL.DEG2RAD);
                if (nroty != 0) vec3.rotateY(rotVec, rotVec, transVec, nroty * CGL.DEG2RAD);
                if (nrotz != 0) vec3.rotateZ(rotVec, rotVec, transVec, nrotz * CGL.DEG2RAD);

                resultArr[i + 0] = rotVec[0];
                resultArr[i + 1] = rotVec[1];
                resultArr[i + 2] = rotVec[2];
            }
        }

        needsCalc = false;
        outArr.set(null);
        outArr.set(resultArr);
    }
    next.trigger();
}


};

Ops.Array.TransformArray3.prototype = new CABLES.Op();
CABLES.OPS["b18040d6-13d7-4f55-950f-3f95cafa4e90"]={f:Ops.Array.TransformArray3,objName:"Ops.Array.TransformArray3"};




// **************************************************************
// 
// Ops.Array.WeaveArrays
// 
// **************************************************************

Ops.Array.WeaveArrays = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
let inPort1 = op.inArray("Array 1");
let inPort2 = op.inArray("Array 2");
let chunkSizePort = op.inValue("Chunk Size", 1);

// outputs
let outPort = op.outArray("Combined Array");

// change listeners
inPort1.onChange = update;
inPort2.onChange = update;
chunkSizePort.onChange = update;

// functions

function update()
{
    let newArr = [];
    let arr1 = inPort1.get();
    let arr2 = inPort2.get();

    let chunkSize = chunkSizePort.get();
    if (chunkSize < 1)
    {
        chunkSize = 1;
        // TODO: Show warning in gui!?
    }
    // array 2 is empty -> just use array 1
    if (arr1 && !arr2)
    {
        newArr = arr1.slice(0);
    }
    // array 1 is empty -> just use array 2
    if (!arr1 && arr2) // normally else if
    {
        newArr = arr2.slice(0);
    }

    // array 1 and 2 are not empty -> combine them
    else if (arr1 && arr2)
    {
        for (let i = 0; i < Math.max(arr1.length, arr2.length); i += chunkSize)
        {
            for (let j = 0; j < chunkSize && j + i < arr1.length; j++)
            {
                newArr.push(arr1[i + j]);
            }
            for (let k = 0; k < chunkSize && k + i < arr2.length; k++)
            {
                newArr.push(arr2[i + k]);
            }
        }
    }
    outPort.set(null);
    outPort.set(newArr);
}


};

Ops.Array.WeaveArrays.prototype = new CABLES.Op();
CABLES.OPS["ad6d77b7-d81d-4115-a2f2-5160adaaef3a"]={f:Ops.Array.WeaveArrays,objName:"Ops.Array.WeaveArrays"};




// **************************************************************
// 
// Ops.Arrays.ArrayToArrays
// 
// **************************************************************

Ops.Arrays.ArrayToArrays = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inStride = op.inInt("Stride", 6),
    outArr = op.outArray("Result");

inArr.onChange = () =>
{
    const stride = inStride.get();
    const result = [];
    const arr = inArr.get();
    if (!arr) return outArr.set(null);

    let count = 0;
    for (let i = 0; i < arr.length; i += stride)
    {
        const newArr = [];
        for (let j = 0; j < stride; j++)
        {
            newArr[j] = arr[i + j] || 0;
        }
        result[count] = newArr;
        count++;
    }

    outArr.set(null);
    outArr.set(result);
};


};

Ops.Arrays.ArrayToArrays.prototype = new CABLES.Op();
CABLES.OPS["037a9886-c185-4ab2-8c7e-b9f85b1e678c"]={f:Ops.Arrays.ArrayToArrays,objName:"Ops.Arrays.ArrayToArrays"};




// **************************************************************
// 
// Ops.Audio.BpmTap
// 
// **************************************************************

Ops.Audio.BpmTap = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const DEFAULT_BPM = 127;

const exe = op.inTrigger("exe");
const tap = op.inTriggerButton("tap");
const sync = op.inTriggerButton("sync");
const nudgeLeft = op.inTriggerButton("nudgeLeft");
const nudgeRight = op.inTriggerButton("nudgeRight");

const beat = op.outTrigger("beat");
// const bpm = this.addOutPort(new CABLES.Port(this, "Bpm", CABLES.OP_PORT_TYPE_VALUE, { "display": "editor" }),0);
const bpm = op.outNumber("Bpm", DEFAULT_BPM);
const outStates = op.outArray("States");
const beatNum = op.outNumber("Beat Index");

const DEFAULT_MILLIS = bpmToMillis(DEFAULT_BPM);
const NUDGE_VALUE = 0.5; // to add / substract from avg bpm

let lastFlash = -1;
let lastTap = -1;

const taps = [];

let avgBpm = DEFAULT_BPM;
let avgMillis = getAvgMillis();

let beatCounter = 1; // [1, 2, 3, 4]
const states = [1, 0, 0, 0];

exe.onTriggered = function ()
{
    if (op.patch.freeTimer.get() * 1000 < lastFlash)
    {
        lastFlash = op.patch.freeTimer.get() * 1000;
    }

    if (op.patch.freeTimer.get() * 1000 > lastFlash + avgMillis)
    {
        beat.trigger();
        incrementState();
        outStates.set(null);
        outStates.set(states);

        if (taps.length > 0) bpm.set(millisToBpm(avgMillis));
        lastFlash = op.patch.freeTimer.get() * 1000;
    }
};

function incrementState()
{
    beatCounter++;
    if (beatCounter > 4)
    {
        beatCounter = 1;
    }
    for (let i = 0; i < 4; i++)
    {
        states[i] = 0;
    }
    states[beatCounter - 1] = 1;

    beatNum.set(beatCounter - 1);
}

function tapPressed()
{
    // start new tap session
    if (op.patch.freeTimer.get() * 1000 - lastTap > 1000)
    {
        taps.length = 0;
        beatCounter = 0;
    }
    else
    {
        taps.push(op.patch.freeTimer.get() * 1000 - lastTap);
    }
    lastTap = op.patch.freeTimer.get() * 1000;
    avgMillis = getAvgMillis();
}

function millisToBpm(millis)
{
    return Number(60 * 1000 / millis).toFixed(2);
}

function bpmToMillis(bpms)
{
    return 60 * 1000 / bpms;
}

function getAvgMillis()
{
    if (taps.length >= 1)
    {
        let sum = 0.0;
        for (let i = 0; i < taps.length; i++)
        {
            sum += taps[i];
        }
        return sum / taps.length;
    }
    else
    {
        return DEFAULT_MILLIS;
    }
}

function syncPressed()
{
    // on next execute everything will be reset to first beat
    lastFlash = -1;
    beatCounter = 0;
}

function nudgeLeftPressed()
{
    avgBpm += NUDGE_VALUE;
    avgMillis = bpmToMillis(avgBpm);
}

function nudgeRightPressed()
{
    avgBpm -= NUDGE_VALUE;
    avgMillis = bpmToMillis(avgBpm);
}

tap.onTriggered = tapPressed;
sync.onTriggered = syncPressed;
nudgeLeft.onTriggered = nudgeLeftPressed;
nudgeRight.onTriggered = nudgeRightPressed;


};

Ops.Audio.BpmTap.prototype = new CABLES.Op();
CABLES.OPS["86096ee6-08f7-4463-b7c3-41cf7bc80de7"]={f:Ops.Audio.BpmTap,objName:"Ops.Audio.BpmTap"};




// **************************************************************
// 
// Ops.Audio.MidiJson
// 
// **************************************************************

Ops.Audio.MidiJson = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj = op.inObject("MidiJson"),
    inTime = op.inValue("Time"),
    outBeat = op.outNumber("Beat"),
    outTrackNames = op.outArray("Track Names"),
    outNames = op.outArray("Names"),
    outProgress = op.outArray("Progress"),
    outVelocity = op.outArray("Velocity"),
    outNumTracks = op.outNumber("Num Tracks"),
    outBPM = op.outNumber("BPM"),
    outData = op.outObject("Data");

let midi = null;
let arrNames = [];
let arrProgress = [];
let arrVelocity = [];
let bpm = 0;

inObj.onChange = function ()
{
    midi = null;
    outNumTracks.set(0);

    midi = inObj.get();
    if (!midi) return;
    if (!midi.tracks) return;

    outNumTracks.set(midi.tracks.length);

    let arrTrackNames = [];
    for (let i = 0; i < midi.tracks.length; i++)
    {
        arrTrackNames[i] = midi.tracks[i].name || "?";
    }

    outTrackNames.set(null);
    outTrackNames.set(arrTrackNames);

    arrNames.length = midi.tracks.length;

    bpm = midi.header.bpm;
    outBPM.set(midi.header.bpm);

    for (let t = 0; t < midi.tracks.length; t++)
    {
        for (let n = 0; n < midi.tracks[t].notes.length; n++)
        {
            let note = midi.tracks[t].notes[n];
            note.timeEnd = note.time + note.duration;
        }
    }
};

inTime.onChange = function ()
{
    if (!midi) return;
    if (!midi.tracks) return;

    let time = inTime.get();
    outNames.set(null);
    outProgress.set(null);
    outVelocity.set(null);
    outData.set(null);

    let beat = Math.round(inTime.get() / 60 * (bpm));

    for (let t = 0; t < midi.tracks.length; t++)
    {
        arrNames[t] = "";
        arrProgress[t] = 0;
        arrVelocity[t] = 0;

        for (let n = 0; n < midi.tracks[t].notes.length; n++)
        {
            let note = midi.tracks[t].notes[n];

            if (
                time > note.time &&
                time < note.timeEnd)
            {
                arrProgress[t] = (time - note.time) / (note.duration);
                arrNames[t] = note.name;
                arrVelocity[t] = note.velocity;

                const data =
                {
                    "beat": 0,
                    "names": arrNames,
                    "progress": arrProgress,
                    "velocity": arrVelocity,
                    "midi": note.midi,
                    "beat": beat

                };

                outData.set(data);
            }
        }
    }

    outNames.set(arrNames);
    outNames.setUiAttribs({ "stride": arrNames.length });
    outProgress.set(arrProgress);
    outVelocity.set(arrVelocity);

    outBeat.set(beat);
};


};

Ops.Audio.MidiJson.prototype = new CABLES.Op();
CABLES.OPS["695aef03-8ab0-48a1-b3ee-2c6c01a21640"]={f:Ops.Audio.MidiJson,objName:"Ops.Audio.MidiJson"};




// **************************************************************
// 
// Ops.Audio.MidiJsonNote_v2
// 
// **************************************************************

Ops.Audio.MidiJsonNote_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inData = op.inObject("Data"),
    // inFilter = op.inSwitch("Filter", ["Note Name", "Midi"], "Note Name"),
    inNote = op.inString("Note"),
    // inNoteMidi = op.inInt("Midi"),
    inChannel = op.inValueString("Channel", -1),
    inStartBeat = op.inValueInt("Beat Start", 0),
    inEndBeat = op.inValueInt("Beat End", 0),

    outCount = op.outNumber("Count"),
    outProgress = op.outNumber("Progress"),
    outTimeSince = op.outNumber("Time since last"),
    outTrigger = op.outTrigger("Trigger"),
    outReset = op.outTrigger("Reseted");

let lastBeat = 0;
let counter = 0;
let oldNames = null;
let oldProgress = null;
let lastHit = 0;
let notfound = true;
// let NoteOrMidi = true;
// inFilter.onChange = updateUi;
// updateUi();

// function updateUi()
// {
//     inNote.setUiAttribs({ "greyout": inFilter.get() != "Note Name" });
//     inNoteMidi.setUiAttribs({ "greyout": inFilter.get() != "Midi" });

//     NoteOrMidi = inFilter.get() == "Note Name";
// }

inNote.onChange = () =>
{
    op.setUiAttrib({ "extendTitle": "" + inNote.get() });
};

inData.onChange = function ()
{
    const data = inData.get();
    if (!data) return;
    const beat = data.beat;

    if (inStartBeat.get() != inEndBeat.get())
    {
        if (beat < inStartBeat.get()) return;
        if (beat > inEndBeat.get()) return;
    }

    const names = data.names;
    const progress = data.progress;
    if (!names) return;
    if (!progress) return;

    if (beat < lastBeat)
    {
        counter = 0;
        lastHit = 0;
        notfound = true;
        outTimeSince.set(0);
        outReset.trigger();
    }
    lastBeat = beat;

    const note = inNote.get();

    if (!oldNames)
    {
        oldNames = [];
        oldProgress = [];
        oldNames.length = names.length;
        oldProgress.length = names.length;
    }

    let startChn = 0;
    let endChn = names.length;

    if (inChannel.get() >= 0)
    {
        startChn = inChannel.get();
        endChn = startChn + 1;
    }

    let prog = 0;
    let progCount = 0;

    for (let i = startChn; i < endChn; i++)
    {
        if ((NoteOrMidi && names[i] == note))
        {
            if ((oldNames[i] != note) || notfound) // ( oldNames[i]==note && progress[i]<oldProgress[i])
            {
                counter++;
                lastHit = CABLES.now();
                outTrigger.trigger();
            }

            progCount++;
            prog += progress[i];
            notfound = false;
        }

        oldNames[i] = names[i];
        oldProgress[i] = progress[i];
    }

    if (progCount == 0)notfound = true;
    else outProgress.set((prog / progCount) || 0);

    if (lastHit !== 0) outTimeSince.set((CABLES.now() - lastHit) / 1000);

    outCount.set(counter);
};


};

Ops.Audio.MidiJsonNote_v2.prototype = new CABLES.Op();
CABLES.OPS["979df145-edc2-4014-9d7e-1e66ce1c4b06"]={f:Ops.Audio.MidiJsonNote_v2,objName:"Ops.Audio.MidiJsonNote_v2"};




// **************************************************************
// 
// Ops.Audio.SpeechRecognition
// 
// **************************************************************

Ops.Audio.SpeechRecognition = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inLang = op.inString("Language", "us-US"),
    active = op.inBool("Active", true),
    result = op.outString("Result"),
    confidence = op.outNumber("Confidence"),
    outSupported = op.outBool("Supported", false),
    outResult = op.outTrigger("New Result", ""),
    outActive = op.outBool("Started", false);


active.onChange = startStop;

window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition;

let recognition = null;

inLang.onChange = changeLang;

function startStop()
{
    if (!recognition) return;

    try
    {
        if (active.get() != outActive.get())
        {
            if (active.get()) recognition.start();
            else recognition.abort();
        }
    }
    catch (e)
    {
        op.logError(e);
    }
}


op.init = function ()
{
    startStop();
};

function changeLang()
{
    if (!recognition) return;

    recognition.lang = inLang.get();
    recognition.stop();

    setTimeout(function ()
    {
        try { recognition.start(); }
        catch (e) {}
    }, 500);
}

startAPI();

function startAPI()
{
    if (window.SpeechRecognition)
    {
        outSupported.set(true);

        if (recognition) recognition.abort();

        recognition = new SpeechRecognition();

        recognition.lang = inLang.get();
        recognition.interimResults = false;
        recognition.maxAlternatives = 0;
        recognition.continuous = true;
        SpeechRecognition.interimResults = true;


        recognition.onstart = function () { outActive.set(true); };
        recognition.onstop = function (event) { outActive.set(false); };

        recognition.onresult = function (event) { op.log("recognition result"); };
        recognition.onerror = function (event) { op.log("recognition error", result); };


        recognition.onresult = function (event)
        {
            const idx = event.results.length - 1;

            result.set(event.results[idx][0].transcript);
            confidence.set(event.results[idx][0].confidence);
            op.log("You said: ", event.results[idx][0].transcript);
            outResult.trigger();
        };
    }
}


};

Ops.Audio.SpeechRecognition.prototype = new CABLES.Op();
CABLES.OPS["e7ccd7a9-54e9-4637-b8cb-011708dfc0dd"]={f:Ops.Audio.SpeechRecognition,objName:"Ops.Audio.SpeechRecognition"};




// **************************************************************
// 
// Ops.Boolean.And
// 
// **************************************************************

Ops.Boolean.And = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    bool0 = op.inValueBool("bool 1"),
    bool1 = op.inValueBool("bool 2"),
    result = op.outBoolNum("result");

bool0.onChange =
bool1.onChange = exec;

function exec()
{
    result.set(bool1.get() && bool0.get());
}


};

Ops.Boolean.And.prototype = new CABLES.Op();
CABLES.OPS["c26e6ce0-8047-44bb-9bc8-5a4f911ed8ad"]={f:Ops.Boolean.And,objName:"Ops.Boolean.And"};




// **************************************************************
// 
// Ops.Boolean.BoolToNumber
// 
// **************************************************************

Ops.Boolean.BoolToNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    bool = op.inValueBool("bool"),
    number = op.outNumber("number");

bool.onChange = function ()
{
    if (bool.get()) number.set(1);
    else number.set(0);
};


};

Ops.Boolean.BoolToNumber.prototype = new CABLES.Op();
CABLES.OPS["2591c495-fceb-4f6e-937f-11b190c72ee5"]={f:Ops.Boolean.BoolToNumber,objName:"Ops.Boolean.BoolToNumber"};




// **************************************************************
// 
// Ops.Boolean.BoolToString
// 
// **************************************************************

Ops.Boolean.BoolToString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inBool = op.inBool("Boolean", false),
    inTrue = op.inString("True", "true"),
    inFalse = op.inString("False", "false"),
    result = op.outString("String", "false");

inTrue.onChange =
    inFalse.onChange =
    inBool.onChange = update;

function update()
{
    if (inBool.get()) result.set(inTrue.get());
    else result.set(inFalse.get());
}


};

Ops.Boolean.BoolToString.prototype = new CABLES.Op();
CABLES.OPS["22a734aa-8b08-4db7-929b-393d4704e1d6"]={f:Ops.Boolean.BoolToString,objName:"Ops.Boolean.BoolToString"};




// **************************************************************
// 
// Ops.Boolean.IfFalseThen
// 
// **************************************************************

Ops.Boolean.IfFalseThen = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Exe"),
    boolean = op.inValueBool("Boolean", false),
    triggerThen = op.outTrigger("then"),
    triggerElse = op.outTrigger("else");

boolean.onChange = execBool;
exe.onTriggered = exec;

function execBool()
{
    if (exe.isLinked()) return;
    exec();
}

function exec()
{
    if (!boolean.get()) triggerThen.trigger();
    else triggerElse.trigger();
}


};

Ops.Boolean.IfFalseThen.prototype = new CABLES.Op();
CABLES.OPS["91cf65f1-94ac-423f-a536-af71eed08440"]={f:Ops.Boolean.IfFalseThen,objName:"Ops.Boolean.IfFalseThen"};




// **************************************************************
// 
// Ops.Boolean.IfTrueThen_v2
// 
// **************************************************************

Ops.Boolean.IfTrueThen_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe=op.inTrigger("exe"),
    boolean=op.inValueBool("boolean",false),
    triggerThen=op.outTrigger("then"),
    triggerElse=op.outTrigger("else");

exe.onTriggered=exec;

function exec()
{
    if(boolean.get()) triggerThen.trigger();
    else triggerElse.trigger();
}



};

Ops.Boolean.IfTrueThen_v2.prototype = new CABLES.Op();
CABLES.OPS["9549e2ed-a544-4d33-a672-05c7854ccf5d"]={f:Ops.Boolean.IfTrueThen_v2,objName:"Ops.Boolean.IfTrueThen_v2"};




// **************************************************************
// 
// Ops.Boolean.IsOne
// 
// **************************************************************

Ops.Boolean.IsOne = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inValue("Value"),
    result = op.outBoolNum("Result", false);

val.onChange = function ()
{
    result.set(val.get() == 1);
};


};

Ops.Boolean.IsOne.prototype = new CABLES.Op();
CABLES.OPS["695d35e2-ffe6-498d-9242-12dc4bcb3c2d"]={f:Ops.Boolean.IsOne,objName:"Ops.Boolean.IsOne"};




// **************************************************************
// 
// Ops.Boolean.IsZero
// 
// **************************************************************

Ops.Boolean.IsZero = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inValue("Value"),
    result = op.outBoolNum("Result", true);

val.onChange = function ()
{
    result.set(val.get() == 0);
};


};

Ops.Boolean.IsZero.prototype = new CABLES.Op();
CABLES.OPS["76d37c73-3c32-47bd-8b4a-4229db7e57f1"]={f:Ops.Boolean.IsZero,objName:"Ops.Boolean.IsZero"};




// **************************************************************
// 
// Ops.Boolean.MonoFlop
// 
// **************************************************************

Ops.Boolean.MonoFlop = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    trigger = op.inTriggerButton("Trigger"),
    duration = op.inValue("Duration", 1),
    valueTrue = op.inValue("Value True", 1),
    valueFalse = op.inValue("Value False", 0),
    resetButton = op.inTriggerButton("Reset"),
    outAct = op.outTrigger("Activated"),
    outEnded = op.outTrigger("Ended"),
    result = op.outBoolNum("Result", false);

let lastTimeout = -1;

resetButton.onTriggered = function ()
{
    result.set(valueFalse.get());

    clearTimeout(lastTimeout);
};

trigger.onTriggered = function ()
{
    if (result.get() == valueFalse.get())outAct.trigger();
    result.set(valueTrue.get());

    clearTimeout(lastTimeout);
    lastTimeout = setTimeout(function ()
    {
        result.set(valueFalse.get());
        outEnded.trigger();
    }, duration.get() * 1000);
};


};

Ops.Boolean.MonoFlop.prototype = new CABLES.Op();
CABLES.OPS["3a4b0a78-4172-41c7-8248-95cb0856ecc8"]={f:Ops.Boolean.MonoFlop,objName:"Ops.Boolean.MonoFlop"};




// **************************************************************
// 
// Ops.Boolean.Not
// 
// **************************************************************

Ops.Boolean.Not = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    bool = op.inValueBool("Boolean"),
    outbool = op.outBoolNum("Result");

bool.changeAlways = true;

bool.onChange = function ()
{
    outbool.set((!bool.get()));
};


};

Ops.Boolean.Not.prototype = new CABLES.Op();
CABLES.OPS["6d123c9f-7485-4fd9-a5c2-76e59dcbeb34"]={f:Ops.Boolean.Not,objName:"Ops.Boolean.Not"};




// **************************************************************
// 
// Ops.Boolean.Or
// 
// **************************************************************

Ops.Boolean.Or = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    bool0 = op.inValueBool("bool 1"),
    bool1 = op.inValueBool("bool 2"),
    bool2 = op.inValueBool("bool 3"),
    bool3 = op.inValueBool("bool 4"),
    bool4 = op.inValueBool("bool 5"),
    bool5 = op.inValueBool("bool 6"),
    bool6 = op.inValueBool("bool 7"),
    bool7 = op.inValueBool("bool 8"),
    bool8 = op.inValueBool("bool 9"),
    bool9 = op.inValueBool("bool 10"),
    result = op.outBoolNum("result");

bool0.onChange =
    bool1.onChange =
    bool2.onChange =
    bool3.onChange =
    bool4.onChange =
    bool5.onChange =
    bool6.onChange =
    bool7.onChange =
    bool8.onChange =
    bool9.onChange = exec;

function exec()
{
    result.set(bool0.get() || bool1.get() || bool2.get() || bool3.get() || bool4.get() || bool5.get() || bool6.get() || bool7.get() || bool8.get() || bool9.get());
}


};

Ops.Boolean.Or.prototype = new CABLES.Op();
CABLES.OPS["b3b36238-4592-4e11-afe3-8361c4fd6be5"]={f:Ops.Boolean.Or,objName:"Ops.Boolean.Or"};




// **************************************************************
// 
// Ops.Boolean.OrNumber
// 
// **************************************************************

Ops.Boolean.OrNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNum = op.inFloat("Number", 0),
    inOr = op.inFloat("Or", 1),
    result = op.outNumber("Result");

inNum.onChange =
inOr.onChange = update;
update();

function update()
{
    const n = inNum.get();
    if (!n || n != n)result.set(inOr.get());
    else result.set(inNum.get());
}


};

Ops.Boolean.OrNumber.prototype = new CABLES.Op();
CABLES.OPS["beb3c979-5723-4283-a23a-34f4b5038b49"]={f:Ops.Boolean.OrNumber,objName:"Ops.Boolean.OrNumber"};




// **************************************************************
// 
// Ops.Boolean.ParseBoolean_v2
// 
// **************************************************************

Ops.Boolean.ParseBoolean_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inVal = op.inString("String"),
    result = op.outBoolNum("Result");

inVal.onChange = function ()
{
    let v = inVal.get();
    if (v === "false" || v == false || v === 0 || v == null || v == undefined)result.set(false);
    else result.set(true);
};


};

Ops.Boolean.ParseBoolean_v2.prototype = new CABLES.Op();
CABLES.OPS["b436e831-36f5-4e0c-838e-4a82c4b07ec0"]={f:Ops.Boolean.ParseBoolean_v2,objName:"Ops.Boolean.ParseBoolean_v2"};




// **************************************************************
// 
// Ops.Boolean.RouteBoolean
// 
// **************************************************************

Ops.Boolean.RouteBoolean = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    NUM_PORTS = 10,
    indexPort = op.inInt("Index"),
    valuePort = op.inBool("Boolean in", true),
    defaultBoolPort = op.inBool("Default boolean", false),
    valuePorts = createOutPorts();

indexPort.onChange = valuePort.onChange = defaultBoolPort.onChange = update;

setDefaultValues();
update();

function createOutPorts()
{
    let arr = [];
    for (let i = 0; i < NUM_PORTS; i++)
    {
        let port = op.outBool("Index " + i + " boolean");
        arr.push(port);
    }
    return arr;
}

function setDefaultValues()
{
    let defaultValue = defaultBoolPort.get();
    valuePorts.forEach(port => port.set(defaultValue));
}

function update()
{
    setDefaultValues();
    let index = indexPort.get();
    let value = valuePort.get();
    index = Math.round(index);
    index = CABLES.clamp(index, 0, NUM_PORTS - 1);
    valuePorts[index].set(value);
}


};

Ops.Boolean.RouteBoolean.prototype = new CABLES.Op();
CABLES.OPS["88b3f5ec-0e45-4651-89ca-33173d001ab6"]={f:Ops.Boolean.RouteBoolean,objName:"Ops.Boolean.RouteBoolean"};




// **************************************************************
// 
// Ops.Boolean.ToggleBoolValue
// 
// **************************************************************

Ops.Boolean.ToggleBoolValue = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    bool = op.inValueBool("in bool"),
    outbool = op.outBoolNum("out bool");

bool.changeAlways = true;

bool.onChange = function ()
{
    outbool.set(!(bool.get() == true));
};


};

Ops.Boolean.ToggleBoolValue.prototype = new CABLES.Op();
CABLES.OPS["7b1abd02-3aad-4106-9848-7f4c3cfab6a9"]={f:Ops.Boolean.ToggleBoolValue,objName:"Ops.Boolean.ToggleBoolValue"};




// **************************************************************
// 
// Ops.Boolean.ToggleBool_v2
// 
// **************************************************************

Ops.Boolean.ToggleBool_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    trigger = op.inTriggerButton("trigger"),
    reset = op.inTriggerButton("reset"),
    outBool = op.outBool("result"),
    inDefault = op.inBool("Default", false);

let theBool = false;

op.onLoadedValueSet = () =>
{
    outBool.set(inDefault.get());
};

trigger.onTriggered = function ()
{
    theBool = !theBool;
    outBool.set(theBool);
};

reset.onTriggered = function ()
{
    theBool = inDefault.get();
    outBool.set(theBool);
};


};

Ops.Boolean.ToggleBool_v2.prototype = new CABLES.Op();
CABLES.OPS["4313d9bb-96b6-43bc-9190-6068cfb2593c"]={f:Ops.Boolean.ToggleBool_v2,objName:"Ops.Boolean.ToggleBool_v2"};




// **************************************************************
// 
// Ops.Boolean.TriggerBoolean
// 
// **************************************************************

Ops.Boolean.TriggerBoolean = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTriggerTrue = op.inTriggerButton("True"),
    inTriggerFalse = op.inTriggerButton("false"),
    outResult = op.outBoolNum("Result");

inTriggerTrue.onTriggered = function ()
{
    outResult.set(true);
};

inTriggerFalse.onTriggered = function ()
{
    outResult.set(false);
};


};

Ops.Boolean.TriggerBoolean.prototype = new CABLES.Op();
CABLES.OPS["31f65abe-9d6c-4ba6-a291-ef2de41d2087"]={f:Ops.Boolean.TriggerBoolean,objName:"Ops.Boolean.TriggerBoolean"};




// **************************************************************
// 
// Ops.Boolean.TriggerChangedFalse
// 
// **************************************************************

Ops.Boolean.TriggerChangedFalse = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let val = op.inValueBool("Value", false);
let next = op.outTrigger("Next");

let oldVal = 0;

val.onChange = function ()
{
    let newVal = val.get();
    if (oldVal && !newVal)
    {
        oldVal = false;
        next.trigger();
    }
    else
    {
        oldVal = true;
    }
};


};

Ops.Boolean.TriggerChangedFalse.prototype = new CABLES.Op();
CABLES.OPS["6387bcb0-6091-4199-8ab7-f96ad4aa3c7d"]={f:Ops.Boolean.TriggerChangedFalse,objName:"Ops.Boolean.TriggerChangedFalse"};




// **************************************************************
// 
// Ops.Boolean.TriggerChangedTrue
// 
// **************************************************************

Ops.Boolean.TriggerChangedTrue = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let val = op.inValueBool("Value", false);
let next = op.outTrigger("Next");
let oldVal = 0;

val.onChange = function ()
{
    let newVal = val.get();
    if (!oldVal && newVal)
    {
        oldVal = true;
        next.trigger();
    }
    else
    {
        oldVal = false;
    }
};


};

Ops.Boolean.TriggerChangedTrue.prototype = new CABLES.Op();
CABLES.OPS["385197e1-8b34-4d1c-897f-d1386d99e3b3"]={f:Ops.Boolean.TriggerChangedTrue,objName:"Ops.Boolean.TriggerChangedTrue"};




// **************************************************************
// 
// Ops.Boolean.TriggerOnChangeBoolean
// 
// **************************************************************

Ops.Boolean.TriggerOnChangeBoolean = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inBool = op.inValueBool("Value"),
    outTrue = op.outTrigger("True"),
    outFalse = op.outTrigger("False");

inBool.onChange = function ()
{
    if (inBool.get()) outTrue.trigger();
    else outFalse.trigger();
};


};

Ops.Boolean.TriggerOnChangeBoolean.prototype = new CABLES.Op();
CABLES.OPS["dba19c07-e3c4-4971-a991-c9e6212ca1c8"]={f:Ops.Boolean.TriggerOnChangeBoolean,objName:"Ops.Boolean.TriggerOnChangeBoolean"};




// **************************************************************
// 
// Ops.Browser.BrowserInfo_v3
// 
// **************************************************************

Ops.Browser.BrowserInfo_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    isMobile = op.outBool("Is Mobile", false),
    isTouch = op.outBool("Is Touchscreen", false),
    isIe = op.outBool("Is IE", false),
    isEdge = op.outBool("Is Edge", false),
    isChrome = op.outBool("Is Chrome", false),
    isFirefox = op.outBool("Is Firefox", false),
    isOpera = op.outBool("Is Opera", false),
    isSafari = op.outBool("Is Safari", false),
    isWindows = op.outBool("Is Windows", false),
    isLinux = op.outBool("Is Linux", false),
    isMac = op.outBool("Is Mac", false),
    isIos = op.outBool("Is iOS", false),
    isAndroid = op.outBool("Is Android", false),
    isElectron = op.outBool("Is Electron", false),
    outOS = op.outString("Operating System", ""),
    outBrowserName = op.outString("Browser Name", ""),
    outVersion = op.outString("OS Version", ""),
    outNav = op.outString("Language"),
    outUA = op.outString("User Agent");

op.setPortGroup("Browsers", [isIe, isEdge, isChrome, isFirefox, isOpera, isSafari]);
op.setPortGroup("Operating Systems", [isWindows, isLinux, isMac, isIos, isAndroid, isElectron]);
op.setPortGroup("Textual Information", [outOS, outBrowserName, outNav, outVersion, outUA]);
const pf = platform;

const osFamily = pf.os.family;

const isOperaBool = pf.name === "Opera";
const isSafariBool = pf.name === "Safari";
const isIEBool = pf.name === "IE";
const isEdgeBool = pf.name === "Microsoft Edge";
const isChromeBool = pf.name === "Chrome" || pf.name === "Chrome Mobile";
const isBlinkBool = pf.layout === "Blink";
const isFirefoxBool = pf.name === "Firefox" || pf.name === "Firefox Mobile" || pf.name === "Firefox for iOS";

const isLinuxBool = osFamily === "Linux"
    || osFamily === "Ubuntu"
    || osFamily === "SuSE"
    || osFamily === "Fedora"
    || osFamily === "OpenBSD"
    || osFamily === "Debian"
    || osFamily === "Red Hat";

const isMacBool = osFamily === "Mac" || osFamily === "Macintosh" || osFamily === "Mac OS X" || osFamily === "OS X";
const isWindowsBool = osFamily === "Windows" || osFamily === "Windows 98;";
const isAndroidBool = osFamily === "Android";
const isIosBool = osFamily === "iOS";
const isMobileBool = (osFamily === "webOS" // LG mobile phones
    || osFamily === "Windows Phone"
    || osFamily === "Android"
    || osFamily === "iOS")
    ||
    (pf.name === "Chrome Mobile"
    || pf.name === "Firefox for iOS"
    || pf.name === "Firefox Mobile"
    || pf.name === "IE Mobile"
    || pf.name === "Opera Mobile");
const isElectronBool = pf.name === "Electron";

const isTouchDevice = (
    ("ontouchstart" in window) ||
        (navigator.maxTouchPoints > 0) ||
        (navigator.msMaxTouchPoints > 0));

isMobile.set(isMobileBool);
isTouch.set(isTouchDevice);

isIe.set(isIEBool);
isEdge.set(isEdgeBool);
isChrome.set(isChromeBool);
isFirefox.set(isFirefoxBool);
isOpera.set(isOperaBool);
isSafari.set(isSafariBool);

isMac.set(isMacBool);
isLinux.set(isLinuxBool);
isWindows.set(isWindowsBool);
isIos.set(isIosBool);
isAndroid.set(isAndroidBool);
isElectron.set(isElectronBool);

outNav.set(navigator.language || navigator.userLanguage);
outUA.set(pf.ua);
outVersion.set(pf.os.version);
outOS.set(pf.os.toString());
outBrowserName.set(pf.name);


};

Ops.Browser.BrowserInfo_v3.prototype = new CABLES.Op();
CABLES.OPS["ec3e0121-b2c2-4c31-bbda-a6982080f73f"]={f:Ops.Browser.BrowserInfo_v3,objName:"Ops.Browser.BrowserInfo_v3"};




// **************************************************************
// 
// Ops.Browser.JsMemory
// 
// **************************************************************

Ops.Browser.JsMemory = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Update"),
    outUsed = op.outNumber("Used Heap Size", 0),
    outTotal = op.outNumber("Total Heap Size", 0);

if (performance.memory && performance.memory.usedJSHeapSize)
    inExec.onTriggered = update;

function update()
{
    outUsed.set(performance.memory.usedJSHeapSize / 1024 / 1024);
    outTotal.set(performance.memory.totalJSHeapSize / 1024 / 1024);
}


};

Ops.Browser.JsMemory.prototype = new CABLES.Op();
CABLES.OPS["7176f9c7-1ee8-419e-b58b-178cca9265e7"]={f:Ops.Browser.JsMemory,objName:"Ops.Browser.JsMemory"};




// **************************************************************
// 
// Ops.Browser.WebShare
// 
// **************************************************************

Ops.Browser.WebShare = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inText = op.inString("Text", "check out undev"),
    inUrl = op.inString("URL", "https://undev.studio"),
    inBase64 = op.inString("Base64 File"),
    inDataUrl = op.inString("Data URL"),
    inFileType = op.inString("Filetype", "image/png"),
    inFileName = op.inString("Filename", "screenshot.png"),
    exec = op.inTriggerButton("Share"),
    outStatus = op.outString("Status", "none"),
    outSupport = op.outBoolNum("Supported", !!navigator.share);

op.setPortGroup("File", [inBase64, inDataUrl, inFileType, inFileName]);

if (!navigator.share)
{
    op.setUiError("noShare", "webshare api not supported on this device", 1);
}

exec.onTriggered = () =>
{
    op.setUiError("noShare", null);
    if (!navigator.share)
    {
        op.setUiError("noShare", "webshare api not supported on this device", 1);
        outSupport.set(false);
        return;
    }
    outSupport.set(true);

    const shareData = {};
    shareData.text = inText.get();
    shareData.url = inUrl.get();

    let url = inDataUrl.get();
    if (inBase64.get())
    {
        url = "data:" + inFileType.get() + ";base64," + inBase64.get();
    }

    if (url)
    {
        fetch(url)
            .then((res) => res.blob())
            .then((blob) =>
            {
                shareData.files = [
                    new File(
                        [blob],
                        inFileName.get(),
                        {
                            "type": inFileType.get(),
                            "lastModified": new Date().getTime()
                        }
                    )
                ];
                if (!navigator.canShare(shareData))
                {
                    op.setUiError("noShare", "browser can't share files", 1);
                    op.log("browser cant share files", shareData);
                    delete shareData.files;
                }
                if (!navigator.canShare(shareData))
                {
                    op.setUiError("noShare", "browser can't share data", 1);
                    op.log("browser cant share data", shareData);
                    outStatus.set("error");
                }
                else
                {
                    doShare(shareData);
                }
            });
    }
    else
    {
        doShare(shareData);
    }
};

function doShare(shareData)
{
    navigator.share(shareData)
        .then(() =>
        {
            outStatus.set("success");
        })
        .catch((error) =>
        {
            outStatus.set("error");
            op.setUiError("noShare", "Error sharing", error);
            op.log("Error sharing", error);
        });
}


};

Ops.Browser.WebShare.prototype = new CABLES.Op();
CABLES.OPS["2e24a18f-161a-480c-a86b-4232c59f68c4"]={f:Ops.Browser.WebShare,objName:"Ops.Browser.WebShare"};




// **************************************************************
// 
// Ops.Cables.AssetPathURL
// 
// **************************************************************

Ops.Cables.AssetPathURL = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    fn = op.inString("Filename", ""),
    path = op.outString("Path");

fn.onChange = update;

update();

function update()
{
    let filename = fn.get();

    if (!fn.get())
    {
        path.set("");
        return;
    }

    let patchId = null;
    if (op.storage && op.storage.blueprint && op.storage.blueprint.patchId)
    {
        patchId = op.storage.blueprint.patchId;
    }
    filename = op.patch.getAssetPath(patchId) + filename;
    let url = op.patch.getFilePath(filename);
    path.set(url);
}


};

Ops.Cables.AssetPathURL.prototype = new CABLES.Op();
CABLES.OPS["e502ae39-c87e-4516-9e78-cb71333bcfff"]={f:Ops.Cables.AssetPathURL,objName:"Ops.Cables.AssetPathURL"};




// **************************************************************
// 
// Ops.Cables.CustomOp_v2
// 
// **************************************************************

Ops.Cables.CustomOp_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const defaultCode = "\
// you can use custom javascript code here, it will be bound to the\n\
// scope of the current op, which is available as `op`.\n\
// \n\
// have a look at the documentation at:\n\
// https://docs.cables.gl/dev_hello_op/dev_hello_op.html\n\
\n\
";

const inJS = op.inStringEditor("JavaScript");
inJS.setUiAttribs({ "editorSyntax": "js" });
inJS.set(defaultCode);
const inLib = op.inUrl("Library", [".js"]);

const portsData = op.inString("portsData", "{}");
portsData.setUiAttribs({ "hidePort": true });
portsData.setUiAttribs({ "hideParam": true });
const protectedPorts = [inJS.id, inLib.id, portsData.id];

let wasPasted = false;

op.setUiError("error", null);

const init = function ()
{
    if (op.uiAttribs)
    {
        wasPasted = op.uiAttribs.pasted;
    }
    restorePorts();
    loadLibAndExecute();
    inLib.onChange = inJS.onChange = loadLibAndExecute;
    if (wasPasted) wasPasted = false;
};

op.onLoadedValueSet = init;
op.patch.on("onOpAdd", (newOp, fromDeserizalize) =>
{
    if (op == newOp && !fromDeserizalize)
    {
        init();
    }
});

op.onError = function (ex)
{
    if (op.patch.isEditorMode())
    {
        op.setUiError("error", ex);
        const str = inJS.get();
        const badLines = [];
        let htmlWarning = "";
        const lines = str.match(/^.*((\r\n|\n|\r)|$)/gm);

        let anonLine = "";
        const exLines = ex.stack.split("\n");
        for (let i = 0; i < exLines.length; i++)
        {
            // firefox
            if (exLines[i].includes("Function:"))
            {
                anonLine = exLines[i];
                break;
            }
            // chrome
            if (exLines[i].includes("anonymous"))
            {
                anonLine = exLines[i];
                break;
            }
        }

        let lineFields = anonLine.split(":");
        let errorLine = lineFields[lineFields.length - 2];

        badLines.push(errorLine - 2);

        for (const i in lines)
        {
            const j = parseInt(i, 10) + 1;
            const line = j + ": " + lines[i];

            let isBadLine = false;
            for (const bj in badLines)
                if (badLines[bj] == j) isBadLine = true;

            if (isBadLine) htmlWarning += "<span class=\"error\">";
            htmlWarning += line.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("\"", "&quot;")
                .replaceAll("'", "&#039;");
            if (isBadLine) htmlWarning += "</span>";
        }

        ex.customMessage = htmlWarning;
        ex.stack = "";
        op.patch.emitEvent("exceptionOp", ex, op.name);
    }
};

const getEvalFunction = () =>
{
    op.setUiError("error", null);
    let errorEl = document.getElementById("customop-error-" + op.id);
    if (errorEl)
    {
        errorEl.remove();
    }
    try
    {
        return new Function("op", inJS.get());
    }
    catch (err)
    {
        op.onError(err);
        if (op.patch.isEditorMode())
        {
            errorEl = document.createElement("script");
            errorEl.id = "customop-error-" + op.id;
            errorEl.type = "text/javascript";
            errorEl.innerHTML = inJS.get();
            document.body.appendChild(errorEl);
        }
        else
        {
            op.logError("error creating javascript function", err);
        }
        return null;
    }
};

function loadLibAndExecute()
{
    if (inLib.get())
    {
        let scriptTag = document.getElementById("customop_lib_" + op.id);
        if (scriptTag)
        {
            scriptTag.remove();
        }
        scriptTag = document.createElement("script");
        scriptTag.id = "customlib_" + op.id;
        scriptTag.type = "text/javascript";
        scriptTag.src = op.patch.getFilePath(String(inLib.get()));
        scriptTag.onload = function ()
        {
            op.logVerbose("done loading library", inLib.get());
            execute();
        };
        document.body.appendChild(scriptTag);
    }
    else if (inJS.get() && inJS.get() !== defaultCode)
    {
        execute();
    }
}

const removeInPort = (port) =>
{
    port.removeLinks();
    for (let ipi = 0; ipi < op.portsIn.length; ipi++)
    {
        if (op.portsIn[ipi] == port)
        {
            op.portsIn.splice(ipi, 1);
            return;
        }
    }
};

const removeOutPort = (port) =>
{
    port.removeLinks();
    for (let ipi = 0; ipi < op.portsOut.length; ipi++)
    {
        if (op.portsOut[ipi] == port)
        {
            op.portsOut.splice(ipi, 1);
            return;
        }
    }
};

const execute = () =>
{
    const evalFunction = getEvalFunction();
    if (evalFunction)
    {
        try
        {
            const oldLinksIn = {};
            const oldValuesIn = {};
            const oldLinksOut = {};
            const removeInPorts = [];
            const removeOutPorts = [];
            op.portsIn.forEach((port) =>
            {
                if (!protectedPorts.includes(port.id))
                {
                    oldLinksIn[port.name] = [];
                    oldValuesIn[port.name] = port.get();
                    port.links.forEach((link) =>
                    {
                        const linkInfo = {
                            "op": link.portOut.parent,
                            "portName": link.portOut.name
                        };
                        oldLinksIn[port.name].push(linkInfo);
                    });
                    removeInPorts.push(port);
                }
            });
            op.portsOut.forEach((port) =>
            {
                oldLinksOut[port.name] = [];
                port.links.forEach((link) =>
                {
                    const linkInfo = {
                        "op": link.portIn.parent,
                        "portName": link.portIn.name
                    };
                    oldLinksOut[port.name].push(linkInfo);
                });
                removeOutPorts.push(port);
            });
            removeInPorts.forEach((port) =>
            {
                removeInPort(port);
            });
            removeOutPorts.forEach((port) =>
            {
                removeOutPort(port);
            });
            if (removeOutPorts.length > 0 || removeInPorts.length > 0)
            {
                this.emitEvent("onUiAttribsChange", {});
                this.emitEvent("onPortRemoved", {});
            }
            evalFunction(this);

            op.portsIn.forEach((port) =>
            {
                if (!protectedPorts.includes(port.id))
                {
                    port.onLinkChanged = savePortData;

                    if (oldLinksIn[port.name])
                    {
                        oldLinksIn[port.name].forEach((link) =>
                        {
                            op.patch.link(op, port.name, link.op, link.portName);
                        });
                    }

                    if (typeof port.onChange == "function")
                    {
                        const oldHandler = port.onChange;
                        port.onChange = (p, v) =>
                        {
                            if (!port.isLinked()) savePortData();
                            oldHandler(p, v);
                        };
                    }
                    else
                    {
                        port.onChange = () =>
                        {
                            if (!port.isLinked()) savePortData();
                        };
                    }

                    // for backwards compatibility, do not add default handler (handled above)
                    if (typeof port.onValueChanged == "function")
                    {
                        const oldValueHandler = port.onValueChanged;
                        port.onValueChanged = (p, v) =>
                        {
                            if (!port.isLinked()) savePortData();
                            oldValueHandler(p, v);
                        };
                    }

                    if (oldValuesIn[port.name])
                    {
                        port.set(oldValuesIn[port.name]);
                    }
                }
            });
            op.portsOut.forEach((port) =>
            {
                port.onLinkChanged = savePortData;

                if (oldLinksOut[port.name])
                {
                    oldLinksOut[port.name].forEach((link) =>
                    {
                        op.patch.link(op, port.name, link.op, link.portName);
                    });
                }
            });
            if (wasPasted)
            {
                wasPasted = false;
            }
            savePortData();
        }
        catch (e)
        {
            if (op.patch.isEditorMode())
            {
                op.onError(e);
                const name = "Ops.Custom.CUSTOM" + op.id.replace(/-/g, "");
                const code = inJS.get();
                let codeHead = "Ops.Custom = Ops.Custom || {};\n";
                codeHead += name + " = " + name + " || {};\n";
                codeHead += name + " = function()\n{\nCABLES.Op.apply(this,arguments);\nconst op=this;\n";
                let codeFoot = "\n\n};\n\n" + name + ".prototype = new CABLES.Op();\n";
                codeFoot += "new " + name + "();\n";
                const opCode = codeHead + code + codeFoot;
                const errorEl = document.createElement("script");
                errorEl.id = "customop-error-" + op.id;
                errorEl.type = "text/javascript";
                errorEl.innerHTML = opCode;
                document.body.appendChild(errorEl);
            }
            else
            {
                op.logError("error executing javascript code", e);
            }
        }
    }
};

function savePortData()
{
    const newPortsData = { "portsIn": {}, "portsOut": {} };
    op.portsIn.forEach((port) =>
    {
        if (!protectedPorts.includes(port.id))
        {
            let v = port.get();
            if (port.ignoreValueSerialize)v = null;
            const portData = {
                "name": port.name,
                "title": port.title,
                "value": v,
                "type": port.type,
                "links": []
            };
            port.links.forEach((link) =>
            {
                const linkData = {
                    "objOut": link.portOut.parent.id,
                    "portOut": link.portOut.name
                };
                portData.links.push(linkData);
            });
            newPortsData.portsIn[port.name] = portData;
        }
    });

    op.portsOut.forEach((port) =>
    {
        if (!protectedPorts.includes(port.id))
        {
            let v = port.get();
            if (port.ignoreValueSerialize)v = null;

            const portData = {
                "name": port.name,
                "title": port.title,
                "value": v,
                "type": port.type,
                "links": []
            };
            port.links.forEach((link) =>
            {
                const linkData = {
                    "objIn": link.portIn.parent.id,
                    "portIn": link.portIn.name
                };
                portData.links.push(linkData);
            });
            newPortsData.portsOut[port.name] = portData;
        }
    });

    let serializedPortsData = "{}";
    try
    {
        serializedPortsData = JSON.stringify(newPortsData);
    }
    catch (e)
    {
        op.log("failed to stringify new port data", newPortsData);
    }
    portsData.set(serializedPortsData);
}

const getOldPorts = () =>
{
    const jsonData = portsData.get();
    let oldPorts = {};
    try
    {
        oldPorts = JSON.parse(jsonData);
    }
    catch (e)
    {
        op.log("failed to parse old port data", jsonData);
    }

    let oldPortsIn = {};
    let oldPortsOut = {};

    if (oldPorts.portsOut)
    {
        oldPortsOut = oldPorts.portsOut;
    }
    if (oldPorts.portsIn)
    {
        oldPortsIn = oldPorts.portsIn;
    }
    return { "portsIn": oldPortsIn, "portsOut": oldPortsOut };
};

const restorePorts = () =>
{
    const oldPorts = getOldPorts();
    const portInKeys = Object.keys(oldPorts.portsIn);
    if (op.patch.isEditorMode()) CABLES.UI.undo.pause();
    for (let i = 0; i < portInKeys.length; i++)
    {
        const oldPortIn = oldPorts.portsIn[portInKeys[i]];
        const newPort = op.addInPort(new CABLES.Port(op, oldPortIn.name, oldPortIn.type));

        if (!wasPasted && Array.isArray(oldPortIn.links))
        {
            oldPortIn.links.forEach((link) =>
            {
                let parent = op.patch.getOpById(link.objOut);
                if (parent)
                {
                    op.patch.link(parent, link.portOut, op, newPort.name);
                }
            });
        }
        if (!newPort.isLinked())
        {
            newPort.set(oldPortIn.value);
        }
        newPort.onLinkChanged = savePortData;

        if (oldPortIn.title)
        {
            newPort.setUiAttribs({ "title": oldPortIn.title });
        }
    }

    const portOutKeys = Object.keys(oldPorts.portsOut);
    for (let i = 0; i < portOutKeys.length; i++)
    {
        const oldPortOut = oldPorts.portsOut[portOutKeys[i]];
        const newPort = op.addOutPort(new CABLES.Port(op, oldPortOut.name, oldPortOut.type));
        if (!wasPasted && Array.isArray(oldPortOut.links))
        {
            oldPortOut.links.forEach((link) =>
            {
                let parent = op.patch.getOpById(link.objIn);
                if (parent)
                {
                    op.patch.link(op, newPort.name, parent, link.portIn);
                }
            });
            if (!newPort.isLinked())
            {
                newPort.set(oldPortOut.value);
            }
            newPort.onLinkChanged = savePortData;

            if (oldPortOut.title)
            {
                newPort.setUiAttribs({ "title": oldPortOut.title });
            }
        }
    }
    if (op.patch.isEditorMode()) CABLES.UI.undo.resume();
};


};

Ops.Cables.CustomOp_v2.prototype = new CABLES.Op();
CABLES.OPS["19166505-2619-4012-ad85-d2de60f27274"]={f:Ops.Cables.CustomOp_v2,objName:"Ops.Cables.CustomOp_v2"};




// **************************************************************
// 
// Ops.Cables.ExitError
// 
// **************************************************************

Ops.Cables.ExitError = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inId = op.inString("ID", "fail"),
    inMessage = op.inString("Message", "a critical error happened!"),
    exit = op.inTriggerButton("Exit");

exit.onTriggered = () =>
{
    op.patch.exitError(inId.get(), inMessage.get());
};


};

Ops.Cables.ExitError.prototype = new CABLES.Op();
CABLES.OPS["e1ad65d5-1f84-45d7-8291-925474bd2bd9"]={f:Ops.Cables.ExitError,objName:"Ops.Cables.ExitError"};




// **************************************************************
// 
// Ops.Cables.FPS_v2
// 
// **************************************************************

Ops.Cables.FPS_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    active = op.inBool("Active", true),
    outFPS = op.outNumber("FPS"),
    outMS = op.outNumber("MS");

const listener = op.patch.addEventListener("performance", update);

op.onDelete = function ()
{
    op.patch.removeEventListener(listener);
};

function update(p)
{
    if (active.get())
    {
        outFPS.set(p.fps);
        outMS.set(p.ms);
    }
}


};

Ops.Cables.FPS_v2.prototype = new CABLES.Op();
CABLES.OPS["6dbb866c-b57a-4875-9f1d-22172162eaa8"]={f:Ops.Cables.FPS_v2,objName:"Ops.Cables.FPS_v2"};




// **************************************************************
// 
// Ops.Cables.PatchInfo_v2
// 
// **************************************************************

Ops.Cables.PatchInfo_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const outConfig = op.outObject("Config");
const outName = op.outString("Name");
const outPatchId = op.outString("Patch Id");
const outNamespace = op.outString("Namespace");
const outSaveDate = op.outNumber("Last Saved");
const outExportDate = op.outNumber("Last Exported");

const patch = getPatch();

outConfig.set(patch.config);
outName.set(patch.name);
outPatchId.set(getPatchId());
outNamespace.set(patch.namespace);
outSaveDate.set(getLastSaveDate());
outExportDate.set(getLastExportDate());

function getPatchId()
{
    let id = null;
    if (patch && patch._id) id = patch._id;
    if (patch && patch.config && patch.config.patch && patch.config.patch._id) id = patch.config.patch._id;
    if (window.gui && window.gui.patchId) id = window.gui.patchId;
    if (window.CABLES && window.CABLES.patchId) id = window.CABLES.patchId;
    if (CABLES.patchId) id = CABLES.patchId;
    return id;
}

function getLastSaveDate()
{
    let date = null;
    if (patch && patch.config && patch.config.patch) date = patch.config.patch.updated;
    if (window.gui && window.gui.project) date = window.gui.project().updated;
    return new Date(date).getTime();
}

function getLastExportDate()
{
    let date = null;
    if (patch && patch.config && patch.config.patch)
    {
        if (patch.config.patch.deployments && patch.config.patch.deployments.lastDeployment)
        {
            date = patch.config.patch.deployments.lastDeployment.date;
        }
    }
    if (window.gui && window.gui.project)
    {
        const p = window.gui.project();
        if (p.deployments && p.deployments.lastDeployment)
        {
            date = p.deployments.lastDeployment.date;
        }
    }
    return new Date(date).getTime();
}

function getPatch()
{
    let thePatch = null;
    if (CABLES && CABLES.exportedPatch) thePatch = CABLES.exportedPatch;
    if (CABLES && CABLES.patch) thePatch = CABLES.patch;
    if (op.patch) thePatch = op.patch;
    return thePatch;
}


};

Ops.Cables.PatchInfo_v2.prototype = new CABLES.Op();
CABLES.OPS["7187c2f2-67a9-479e-92c4-0e415443f504"]={f:Ops.Cables.PatchInfo_v2,objName:"Ops.Cables.PatchInfo_v2"};




// **************************************************************
// 
// Ops.Cables.UIMode
// 
// **************************************************************

Ops.Cables.UIMode = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const outUI = op.outBool("UI", op.patch.isEditorMode());
const outRemoteViewer = op.outBool("Remote Viewer", window.gui ? window.gui.isRemoteClient : false);


};

Ops.Cables.UIMode.prototype = new CABLES.Op();
CABLES.OPS["7c110d60-829f-4b06-b3e4-0af911550570"]={f:Ops.Cables.UIMode,objName:"Ops.Cables.UIMode"};




// **************************************************************
// 
// Ops.Color.ColorPalettes
// 
// **************************************************************

Ops.Color.ColorPalettes = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const index = op.inValueInt("Index", 0);
const textureOut = op.outTexture("Texture");
const inLinear = op.inValueBool("Smooth");
const arrOut = op.outArray("Color Array");

let canvas = document.createElement("canvas");
canvas.id = "canvas_" + CABLES.generateUUID();
canvas.width = 5;
canvas.height = 8;
canvas.style.display = "none";

let body = document.getElementsByTagName("body")[0];
body.appendChild(canvas);
let ctx = canvas.getContext("2d");

index.onChange =
inLinear.onChange = buildTextureLater;

let arr = [];
arr.length = 5 * 3;
let lastFilter = null;

buildTextureLater();

function hexToR(h)
{
    return parseInt((cutHex(h)).substring(0, 2), 16);
}

function hexToG(h)
{
    return parseInt((cutHex(h)).substring(2, 4), 16);
}

function hexToB(h)
{
    return parseInt((cutHex(h)).substring(4, 6), 16);
}

function cutHex(h)
{
    return (h.charAt(0) == "#") ? h.substring(1, 7) : h;
}

function buildTextureLater()
{
    op.patch.cgl.addNextFrameOnceCallback(buildTexture);
}

function buildTexture()
{
    let ind = Math.round(index.get()) * 5;
    if (ind >= colors.length - 5)ind = 0;
    if (ind < 0)ind = 0;
    if (ind != ind)ind = 0;

    for (let i = 0; i < 5; i++)
    {
        let r = hexToR(colors[ind + i]);
        let g = hexToG(colors[ind + i]);
        let b = hexToB(colors[ind + i]);

        arr[i * 3 + 0] = r / 255;
        arr[i * 3 + 1] = g / 255;
        arr[i * 3 + 2] = b / 255;

        ctx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
        ctx.fillRect(
            canvas.width / 5 * i,
            0,
            canvas.width / 5,
            canvas.height
        );
    }

    let filter = CGL.Texture.FILTER_NEAREST;
    if (inLinear.get())filter = CGL.Texture.FILTER_LINEAR;

    if (lastFilter == filter && textureOut.get()) textureOut.get().initTexture(canvas, filter);
    else textureOut.set(new CGL.Texture.createFromImage(op.patch.cgl, canvas, { "filter": filter }));

    arrOut.set(null);
    arrOut.set(arr);
    textureOut.get().unpackAlpha = false;
    lastFilter = filter;
}

op.onDelete = function ()
{
    canvas.remove();
};

const colors = [
    "#E6E2AF", "#A7A37E", "#EFECCA", "#046380", "002F2F",
    "#468966", "#FFF0A5", "#FFB03B", "#B64926", "8E2800",
    "#FCFFF5", "#D1DBBD", "#91AA9D", "#3E606F", "193441",
    "#FF6138", "#FFFF9D", "#BEEB9F", "#79BD8F", "00A388",
    "#105B63", "#FFFAD5", "#FFD34E", "#DB9E36", "BD4932",
    "#225378", "#1695A3", "#ACF0F2", "#F3FFE2", "EB7F00",
    "#2C3E50", "#E74C3C", "#ECF0F1", "#3498DB", "2980B9",
    "#000000", "#263248", "#7E8AA2", "#FFFFFF", "FF9800",
    "#004358", "#1F8A70", "#BEDB39", "#FFE11A", "FD7400",
    "#DC3522", "#D9CB9E", "#374140", "#2A2C2B", "1E1E20",
    "#7D8A2E", "#C9D787", "#FFFFFF", "#FFC0A9", "FF8598",
    "#B9121B", "#4C1B1B", "#F6E497", "#FCFAE1", "BD8D46",
    "#2E0927", "#D90000", "#FF2D00", "#FF8C00", "04756F",
    "#595241", "#B8AE9C", "#FFFFFF", "#ACCFCC", "8A0917",
    "#10222B", "#95AB63", "#BDD684", "#E2F0D6", "F6FFE0",
    "#F6F792", "#333745", "#77C4D3", "#DAEDE2", "EA2E49",
    "#703030", "#2F343B", "#7E827A", "#E3CDA4", "C77966",
    "#2F2933", "#01A2A6", "#29D9C2", "#BDF271", "FFFFA6",
    "#D8CAA8", "#5C832F", "#284907", "#382513", "363942",
    "#FFF8E3", "#CCCC9F", "#33332D", "#9FB4CC", "DB4105",
    "#85DB18", "#CDE855", "#F5F6D4", "#A7C520", "493F0B",
    "#04BFBF", "#CAFCD8", "#F7E967", "#A9CF54", "588F27",
    "#292929", "#5B7876", "#8F9E8B", "#F2E6B6", "412A22",
    "#332532", "#644D52", "#F77A52", "#FF974F", "A49A87",
    "#405952", "#9C9B7A", "#FFD393", "#FF974F", "F54F29",
    "#2B3A42", "#3F5765", "#BDD4DE", "#EFEFEF", "FF530D",
    "#962D3E", "#343642", "#979C9C", "#F2EBC7", "348899",
    "#96CA2D", "#B5E655", "#EDF7F2", "#4BB5C1", "7FC6BC",
    "#1C1D21", "#31353D", "#445878", "#92CDCF", "EEEFF7",
    "#3E454C", "#2185C5", "#7ECEFD", "#FFF6E5", "FF7F66",
    "#00585F", "#009393", "#FFFCC4", "#F0EDBB", "FF3800",
    "#B4AF91", "#787746", "#40411E", "#32331D", "C03000",
    "#63A69F", "#F2E1AC", "#F2836B", "#F2594B", "CD2C24",
    "#88A825", "#35203B", "#911146", "#CF4A30", "ED8C2B",
    "#F2385A", "#F5A503", "#E9F1DF", "#4AD9D9", "36B1BF",
    "#CFC291", "#FFF6C5", "#A1E8D9", "#FF712C", "695D46",
    "#FF5335", "#B39C85", "#306E73", "#3B424D", "1D181F",
    "#000000", "#333333", "#FF358B", "#01B0F0", "AEEE00",
    "#E8E595", "#D0A825", "#40627C", "#26393D", "FFFAE4",
    "#E7E8D1", "#D3CEAA", "#FBF7E4", "#424242", "8E001C",
    "#354242", "#ACEBAE", "#FFFF9D", "#C9DE55", "7D9100",
    "#2F2933", "#01A2A6", "#29D9C2", "#BDF271", "FFFFA6",
    "#DDDCC5", "#958976", "#611427", "#1D2326", "6A6A61",
    "#6C6E58", "#3E423A", "#417378", "#A4CFBE", "F4F7D9",
    "#E1E6FA", "#C4D7ED", "#ABC8E2", "#375D81", "183152",
    "#6B0C22", "#D9042B", "#F4CB89", "#588C8C", "011C26",
    "#304269", "#91BED4", "#D9E8F5", "#FFFFFF", "F26101",
    "#96CEB4", "#FFEEAD", "#FF6F69", "#FFCC5C", "AAD8B0",
    "#B0CC99", "#677E52", "#B7CA79", "#F6E8B1", "89725B",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF5A49",
    "#16193B", "#35478C", "#4E7AC7", "#7FB2F0", "ADD5F7",
    "#00261C", "#044D29", "#168039", "#45BF55", "96ED89",
    "#36362C", "#5D917D", "#A8AD80", "#E6D4A7", "825534",
    "#F9E4AD", "#E6B098", "#CC4452", "#723147", "31152B",
    "#2C3E50", "#FC4349", "#D7DADB", "#6DBCDB", "FFFFFF",
    "#002635", "#013440", "#AB1A25", "#D97925", "EFE7BE",
    "#FF8000", "#FFD933", "#CCCC52", "#8FB359", "192B33",
    "#272F32", "#9DBDC6", "#FFFFFF", "#FF3D2E", "DAEAEF",
    "#B8ECD7", "#083643", "#B1E001", "#CEF09D", "476C5E",
    "#002F32", "#42826C", "#A5C77F", "#FFC861", "C84663",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#F3B562", "F06060",
    "#5A1F00", "#D1570D", "#FDE792", "#477725", "A9CC66",
    "#5E0042", "#2C2233", "#005869", "#00856A", "8DB500",
    "#52656B", "#FF3B77", "#CDFF00", "#FFFFFF", "B8B89F",
    "#801637", "#047878", "#FFB733", "#F57336", "C22121",
    "#730046", "#BFBB11", "#FFC200", "#E88801", "C93C00",
    "#24221F", "#363F45", "#4B5F6D", "#5E7C88", "FEB41C",
    "#E64661", "#FFA644", "#998A2F", "#2C594F", "002D40",
    "#C24704", "#D9CC3C", "#FFEB79", "#A0E0A9", "00ADA7",
    "#484A47", "#C1CE96", "#ECEBF0", "#687D77", "353129",
    "#588C7E", "#F2E394", "#F2AE72", "#D96459", "8C4646",
    "#BAB293", "#A39770", "#EFE4BD", "#A32500", "2B2922",
    "#6A7059", "#FDEEA7", "#9BCC93", "#1A9481", "003D5C",
    "#174C4F", "#207178", "#FF9666", "#FFE184", "F5E9BE",
    "#D5FBFF", "#9FBCBF", "#647678", "#2F3738", "59D8E6",
    "#DB5800", "#FF9000", "#F0C600", "#8EA106", "59631E",
    "#450003", "#5C0002", "#94090D", "#D40D12", "FF1D23",
    "#211426", "#413659", "#656F8C", "#9BBFAB", "F2EFDF",
    "#EA6045", "#F8CA4D", "#F5E5C0", "#3F5666", "2F3440",
    "#F2F2F2", "#C6E070", "#91C46C", "#287D7D", "1C344D",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF5A49",
    "#705B35", "#C7B07B", "#E8D9AC", "#FFF6D9", "570026",
    "#F7F2B2", "#ADCF4F", "#84815B", "#4A1A2C", "8E3557",
    "#1A1F2B", "#30395C", "#4A6491", "#85A5CC", "D0E4F2",
    "#25064D", "#36175E", "#553285", "#7B52AB", "9768D1",
    "#004056", "#2C858D", "#74CEB7", "#C9FFD5", "FFFFCB",
    "#CFCA4C", "#FCF5BF", "#9FE5C2", "#5EB299", "745A33",
    "#776045", "#A8C545", "#DFD3B6", "#FFFFFF", "0092B2",
    "#CC3910", "#F1F2C0", "#CCC59E", "#8FA68E", "332F29",
    "#FF6600", "#C13B00", "#5E6D70", "#424E4F", "1B1D1E",
    "#690011", "#BF0426", "#CC2738", "#F2D99C", "E5B96F",
    "#1B1D26", "#425955", "#778C7A", "#F1F2D8", "BFBD9F",
    "#F6B1C3", "#F0788C", "#DE264C", "#BC0D35", "A20D1E",
    "#597533", "#332F28", "#61B594", "#E6DEA5", "C44E18",
    "#3FB8AF", "#7FC7AF", "#DAD8A7", "#FF9E9D", "FF3D7F",
    "#0F2D40", "#194759", "#296B73", "#3E8C84", "D8F2F0",
    "#42282F", "#74A588", "#D6CCAD", "#DC9C76", "D6655A",
    "#002A4A", "#17607D", "#FFF1CE", "#FF9311", "D64700",
    "#003056", "#04518C", "#00A1D9", "#47D9BF", "F2D03B",
    "#13140F", "#D4FF00", "#E4FFE6", "#68776C", "00D6DD",
    "#FCFAD0", "#A1A194", "#5B605F", "#464646", "A90641",
    "#289976", "#67CC8E", "#B1FF91", "#FFE877", "FF5600",
    "#302B1D", "#3F522B", "#737D26", "#A99E46", "D9CB84",
    "#56626B", "#6C9380", "#C0CA55", "#F07C6C", "AD5472",
    "#32450C", "#717400", "#DC8505", "#EC5519", "BE2805",
    "#C7B773", "#E3DB9A", "#F5FCD0", "#B1C2B3", "778691",
    "#E83A25", "#FFE9A3", "#98CC96", "#004563", "191B28",
    "#3399CC", "#67B8DE", "#91C9E8", "#B4DCED", "E8F8FF",
    "#1A212C", "#1D7872", "#71B095", "#DEDBA7", "D13F32",
    "#7D2A35", "#CC9258", "#917A56", "#B4BA6C", "FEFFC2",
    "#E7E9D1", "#D3D4AA", "#FCFAE6", "#444444", "901808",
    "#FFFFFF", "#AEAEAE", "#E64C66", "#2D3E50", "1BBC9B",
    "#E0FFB3", "#61C791", "#31797D", "#2A2F36", "F23C55",
    "#EB5937", "#1C1919", "#403D3C", "#456F74", "D3CBBD",
    "#E6DD00", "#8CB302", "#008C74", "#004C66", "332B40",
    "#14A697", "#F2C12E", "#F29D35", "#F27649", "F25252",
    "#261822", "#40152A", "#731630", "#CC1E2C", "FF5434",
    "#261F27", "#FEE169", "#CDD452", "#F9722E", "C9313D",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#F3B562", "F06060",
    "#2F3837", "#C5C7B6", "#FFF8D3", "#4C493E", "222028",
    "#E3CBAC", "#9C9985", "#C46D3B", "#788880", "324654",
    "#3F0B1B", "#7A1631", "#CF423C", "#FC7D49", "FFD462",
    "#14212B", "#293845", "#4F6373", "#8F8164", "D9D7AC",
    "#98A89E", "#BAC0AC", "#FAFAC6", "#FF4411", "D40015",
    "#FEFFFF", "#3C3F36", "#9FB03E", "#EBE9DC", "72918B",
    "#CC6B32", "#FFAB48", "#FFE7AD", "#A7C9AE", "888A63",
    "#262526", "#404040", "#8C8979", "#F2F2F2", "F60A20",
    "#00305A", "#004B8D", "#0074D9", "#4192D9", "7ABAF2",
    "#0C273D", "#54D0ED", "#FFFEF1", "#70B85D", "2C5E2E",
    "#4C1B33", "#EFE672", "#98A942", "#2D6960", "141D14",
    "#2F3540", "#666A73", "#F2EDE4", "#D9D1C7", "8C8681",
    "#0D1F30", "#3B6670", "#8BADA3", "#F0E3C0", "DB6C0F",
    "#FFBC67", "#DA727E", "#AC6C82", "#685C79", "455C7B",
    "#092140", "#024959", "#F2C777", "#F24738", "BF2A2A",
    "#133463", "#365FB7", "#799AE0", "#F4EFDC", "BA9B65",
    "#C4D4CB", "#55665E", "#30282A", "#542733", "E84167",
    "#CDDEC6", "#4DAAAB", "#1E4F6A", "#2A423C", "93A189",
    "#EF5411", "#FA5B0F", "#FF6517", "#FF6D1F", "FF822E",
    "#41434A", "#6E9489", "#DEDCC3", "#F2F1E9", "877963",
    "#292929", "#2BBFBD", "#F2B33D", "#F29B30", "F22E2E",
    "#F2385A", "#F5A503", "#E9F1DF", "#56D9CD", "3AA1BF",
    "#D5F8B4", "#A6E3A8", "#8A9A85", "#7E566B", "422335",
    "#3CBAC8", "#93EDD4", "#F3F5C4", "#F9CB8F", "F19181",
    "#979926", "#38CCB5", "#EEFF8E", "#FFD767", "CC2A09",
    "#404040", "#024959", "#037E8C", "#F2EFDC", "F24C27",
    "#94B34D", "#D3FF82", "#363D52", "#121D2B", "111B1C",
    "#282E33", "#25373A", "#164852", "#495E67", "FF3838",
    "#313732", "#8AA8B0", "#DEDEDE", "#FFFFFF", "F26101",
    "#FFFFFF", "#E5E1D1", "#52616D", "#2C343B", "C44741",
    "#FFF6B8", "#ABCCA7", "#403529", "#7A5E2F", "A68236",
    "#4F1025", "#C5003E", "#D9FF5B", "#78AA00", "15362D",
    "#49404F", "#596166", "#D1FFCD", "#A9BD8B", "948A54",
    "#FF2151", "#FF7729", "#FFAD29", "#FFEBCA", "1AB58A",
    "#73603D", "#BF8A49", "#F2CA80", "#5E5A59", "0D0D0D",
    "#3D4C53", "#70B7BA", "#F1433F", "#E7E1D4", "FFFFFF",
    "#006D8D", "#008A6E", "#549E39", "#8AB833", "C0CF3A",
    "#BDDFB3", "#2BAA9C", "#2F2E2E", "#0F2625", "465F3F",
    "#F2F2F2", "#BF0404", "#8C0303", "#590202", "400101",
    "#76A19A", "#272123", "#A68D60", "#B0C5BB", "D9593D",
    "#0E3D59", "#88A61B", "#F29F05", "#F25C05", "D92525",
    "#C1E1ED", "#76C7C6", "#273D3B", "#131A19", "E35C14",
    "#2D112C", "#530031", "#820233", "#CA293E", "EF4339",
    "#AF7575", "#EFD8A1", "#BCD693", "#AFD7DB", "3D9CA8",
    "#D74B4B", "#DCDDD8", "#475F77", "#354B5E", "FFFFFF",
    "#FFF6C9", "#C8E8C7", "#A4DEAB", "#85CC9F", "499E8D",
    "#229396", "#8BA88F", "#C7C5A7", "#F0DFD0", "F23C3C",
    "#57385C", "#A75265", "#EC7263", "#FEBE7E", "FFEDBC",
    "#96526B", "#D17869", "#EBAD60", "#F5CF66", "8BAB8D",
    "#0D1C33", "#17373C", "#2B6832", "#4F9300", "A1D700",
    "#1B2B32", "#37646F", "#A3ABAF", "#E1E7E8", "B22E2F",
    "#C5D9B2", "#53A194", "#572C2C", "#3D2324", "695A3B",
    "#425957", "#81AC8B", "#F2E5A2", "#F89883", "D96666",
    "#002E40", "#2A5769", "#FFFFFF", "#FABD4A", "FA9600",
    "#FFFEFC", "#E2E3DF", "#515B5E", "#2E3233", "CAF200",
    "#FFF0A3", "#B8CC6E", "#4B6000", "#E4F8FF", "004460",
    "#3B596A", "#427676", "#3F9A82", "#A1CD73", "ECDB60",
    "#F2E6CE", "#8AB39F", "#606362", "#593325", "1D1D1F",
    "#212B40", "#C2E078", "#FFFFFF", "#BADCDD", "547B97",
    "#0B3C4D", "#0E5066", "#136480", "#127899", "1A8BB3",
    "#222130", "#464D57", "#D4E8D3", "#FFFCFB", "ED8917",
    "#B33600", "#FF8A00", "#FFC887", "#CC5400", "B31E00",
    "#012530", "#28544B", "#ACBD86", "#FFD6A0", "FF302C",
    "#2E95A3", "#50B8B4", "#C6FFFA", "#E2FFA8", "D6E055",
    "#112F41", "#068587", "#4FB99F", "#F2B134", "ED553B",
    "#202B30", "#4E7178", "#4FA9B8", "#74C0CF", "F1F7E2",
    "#302B2F", "#696153", "#FFA600", "#9BB58F", "FFD596",
    "#458C6B", "#F2D8A7", "#D9A86C", "#D94436", "A62424",
    "#22475E", "#75B08A", "#F0E797", "#FF9D84", "FF5460",
    "#FFAA5C", "#DA727E", "#AC6C82", "#685C79", "455C7B",
    "#686E75", "#9BAAC1", "#82787B", "#E4F1DB", "AAC19B",
    "#F0C755", "#E2AD3B", "#BF5C00", "#901811", "5C110F",
    "#FFFBDC", "#BFBCA5", "#7F7D6E", "#3F3E37", "E5E2C6",
    "#BEBEBE", "#F1E4D8", "#594735", "#94C7BA", "D8F1E4",
    "#1B1E26", "#F2EFBD", "#B6D051", "#70A99A", "2F6D7A",
    "#F7E4A2", "#A7BD5B", "#DC574E", "#8DC7B8", "ED9355",
    "#70E8CB", "#FFE9C7", "#FF5B5B", "#545454", "2D2D2F",
    "#17111A", "#321433", "#660C47", "#B33467", "CCBB51",
    "#2B2E2E", "#595855", "#A2ABA5", "#CAE6E8", "313F54",
    "#023B47", "#295E52", "#F2E085", "#FCAB55", "EE7F38",
    "#302C29", "#D1D1BC", "#A7C4BB", "#6C8C84", "466964",
    "#212629", "#067778", "#49B8A8", "#85EDB6", "D9E5CD",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF4949",
    "#2C3E50", "#FC4349", "#6DBCDB", "#D7DADB", "FFFFFF",
    "#35262D", "#FFFBFF", "#E8ECED", "#A4B7BB", "76A0B0",
    "#61E8D2", "#FCEEB9", "#302F25", "#704623", "BBE687",
    "#E1E6B9", "#C4D7A4", "#ABC8A4", "#375D3B", "183128",
    "#C98B2F", "#803C27", "#C56520", "#E1B41B", "807916",
    "#A3D9B0", "#93BF9E", "#F2F0D5", "#8C8474", "40362E",
    "#524656", "#CF4747", "#EA7A58", "#E4DCCB", "A6C4BC",
    "#5C2849", "#A73E5C", "#EC4863", "#FFDA66", "1FCECB",
    "#0EEAFF", "#15A9FA", "#1B76FF", "#1C3FFD", "2C1DFF",
    "#010000", "#393845", "#9B96A3", "#5C0009", "940315",
    "#468071", "#FFE87A", "#FFCA53", "#FF893B", "E62738",
    "#404040", "#024959", "#037E8C", "#F2EFDC", "F24C27",
    "#FF765E", "#C2AE8B", "#FCCF65", "#FFE5C6", "B7BDC4",
    "#003647", "#00717D", "#F2D8A7", "#A4A66A", "515932",
    "#FAFAC0", "#C4BE90", "#8C644C", "#594D37", "293033",
    "#2B3A42", "#3F5765", "#BDD4DE", "#EFEFEF", "E74C3C",
    "#3B3B3B", "#A8877E", "#FFA49D", "#FF7474", "FF476C",
    "#0A3A4A", "#196674", "#33A6B2", "#9AC836", "D0E64B",
    "#FFA340", "#38001C", "#571133", "#017A74", "00C2BA",
    "#DCEBDD", "#A0D5D6", "#789AA1", "#304345", "AD9A27",
    "#588C7E", "#F2E394", "#F2AE72", "#D96459", "8C4646",
    "#F0E6B1", "#B5D6AA", "#99A37A", "#70584B", "3D3536",
    "#2F400D", "#8CBF26", "#A8CA65", "#E8E5B0", "419184",
    "#010712", "#13171F", "#1C1F26", "#24262D", "961227",
    "#403F33", "#6E755F", "#AFC2AA", "#FFDEA1", "E64C10",
    "#C74029", "#FAE8CD", "#128085", "#385052", "F0AD44",
    "#CFF09E", "#A8DBA8", "#79BD9A", "#3B8686", "0B486B",
    "#E0401C", "#E6B051", "#272F30", "#F7EDB7", "9E2B20",
    "#FFE2C5", "#FFEEDD", "#FFDDAA", "#FFC484", "FFDD99",
    "#FFFFE4", "#F2E5BD", "#B9BF8E", "#A69F7C", "8C6865",
    "#5C8A2D", "#AFD687", "#FFFFFF", "#00C3A9", "008798",
    "#4F3130", "#FF1F3D", "#5BE3E3", "#FDFFF1", "8B9698",
    "#D23600", "#D95100", "#DE6D00", "#EE8900", "FCA600",
    "#FFFFFA", "#A1A194", "#5B605F", "#464646", "FF6600",
    "#F34A53", "#FAE3B4", "#AAC789", "#437356", "1E4147",
    "#2A7A8C", "#176273", "#063540", "#E6D9CF", "403D3A",
    "#21455B", "#567D8C", "#A59E8C", "#8C8372", "F2F2F2",
    "#012340", "#026873", "#83A603", "#BBBF45", "F2F0CE",
    "#FDFF98", "#A7DB9E", "#211426", "#6B073B", "DA8C25",
    "#002F36", "#142426", "#D1B748", "#EDDB43", "FFFD84",
    "#420000", "#600000", "#790000", "#931111", "BF1616",
    "#3C989E", "#5DB5A4", "#F4CDA5", "#F57A82", "ED5276",
    "#23A38F", "#B7C11E", "#EFF1C2", "#F0563D", "2E313D",
    "#F5ECD9", "#2BACB5", "#B4CCB9", "#E84D5B", "3B3B3B",
    "#A5EB3C", "#60C21E", "#159E31", "#53DB50", "C5FFCB",
    "#263138", "#406155", "#7C9C71", "#DBC297", "FF5755",
    "#0A111F", "#263248", "#7E8AA2", "#E3E3E3", "C73226",
    "#003B59", "#00996D", "#A5D900", "#F2E926", "FF930E",
    "#00A19A", "#04BF9D", "#F2E85C", "#F53D54", "404040",
    "#324152", "#47535E", "#796466", "#C1836A", "DEA677",
    "#036F73", "#84CDC2", "#FEF2D8", "#F18C79", "EF504F",
    "#174040", "#888C65", "#D9CA9C", "#D98162", "A65858",
    "#56797F", "#87A0A4", "#FCFBDC", "#F2DDB6", "A6937C",
    "#A8BAA9", "#FFF5CF", "#DBCDAD", "#B39C7D", "806854",
    "#60655F", "#AB9675", "#FFE0C9", "#D4CCBA", "CF8442",
    "#BDDFB3", "#009D57", "#2C372E", "#0F2925", "465F3F",
    "#3E3947", "#735360", "#D68684", "#F1B0B0", "EBD0C4",
    "#0A7B83", "#2AA876", "#FFD265", "#F19C65", "CE4D45",
    "#FFFFFF", "#F4921E", "#858585", "#C5D2DB", "3E6B85",
    "#11151E", "#212426", "#727564", "#B9AA81", "690C07",
    "#000000", "#910000", "#CBB370", "#FFFBF1", "21786C",
    "#F78F00", "#C43911", "#75003C", "#37154A", "0F2459",
    "#003354", "#91BED4", "#D9E8F5", "#FFFFFF", "F26101",
    "#3DA8A4", "#7ACCBE", "#FFFFF7", "#FF99A1", "FF5879",
    "#64C733", "#F0F0F0", "#3E879E", "#57524D", "36302B",
    "#343844", "#2AB69D", "#E65848", "#FDC536", "FCF2D7",
    "#E34517", "#F5FF53", "#B4E85E", "#00BD72", "0B4239",
    "#A84B3A", "#FF9F67", "#233138", "#FFF7F5", "4C646B",
    "#59535E", "#FAEEFF", "#F1BAF3", "#5D4970", "372049",
    "#FF6F22", "#D9984F", "#FFE8A9", "#3E4237", "32948A",
    "#5D7370", "#7FA6A1", "#B8D9B8", "#D6EDBD", "FFF5BC",
    "#FFBE00", "#FFDC00", "#FFD10F", "#FFDE20", "E8CA00",
    "#003840", "#005A5B", "#007369", "#008C72", "02A676",
    "#E1E6FA", "#C4D7ED", "#ABC8E2", "#375D81", "183152",
    "#BA2F1D", "#FFF8A4", "#F5E67F", "#264A59", "1E2C30",
    "#222526", "#FFBB6E", "#F28D00", "#D94F00", "80203B",
    "#EBD096", "#D1B882", "#5D8A66", "#1A6566", "21445B",
    "#F00807", "#5F6273", "#A4ABBF", "#CCC9D1", "E2E1E9",
    "#DFE0AF", "#A4BAA2", "#569492", "#41505E", "383245",
    "#152737", "#2B4E69", "#799AA5", "#FFFFF0", "682321",
    "#C44C51", "#FFB6B8", "#FFEFB6", "#A2B5BF", "5F8CA3",
    "#5ADED4", "#4DAAAB", "#26596A", "#163342", "6C98A1",
    "#FF5B2B", "#B1221C", "#34393E", "#8CC6D7", "FFDA8C",
    "#3D4D4D", "#99992E", "#E6E666", "#F2FFBF", "800033",
    "#242424", "#437346", "#97D95C", "#D9FF77", "E9EB9B",
    "#FFEBB0", "#FFB05A", "#F84322", "#C33A1A", "9F3818",
    "#4D2B2F", "#E57152", "#E8DE67", "#FFEFC3", "C0CCAB",
    "#A82221", "#DB5E31", "#EDA23E", "#F2CB67", "BFB840",
    "#3B3140", "#BFB8A3", "#F2E0C9", "#F2B9AC", "D97E7E",
    "#43464D", "#9197A6", "#D3DCF2", "#7690CF", "48577D",
    "#EFDFBB", "#9EBEA6", "#335D6A", "#D64F2A", "7A8A7F",
    "#000001", "#313634", "#C7CECF", "#5C0402", "941515",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF5A49",
    "#F5F4E1", "#D6C9B5", "#B4AA97", "#D44917", "82877A",
    "#19162B", "#1C425C", "#6ABDC4", "#F0E4C5", "D6C28F",
    "#00132B", "#7F9DB0", "#C5E2ED", "#FFFFFF", "F95900",
    "#1F3642", "#6D968D", "#B6CCB8", "#FFE2B3", "56493F",
    "#08A689", "#82BF56", "#C7D93D", "#E9F2A0", "F2F2F2",
    "#DE3961", "#A4E670", "#FFFFDC", "#B3EECC", "00ADA7",
    "#849972", "#D9D094", "#A6A23E", "#4F2F1D", "8F5145",
    "#F41C54", "#FF9F00", "#FBD506", "#A8BF12", "00AAB5",
    "#00585F", "#009393", "#F5F3DC", "#454445", "FF5828",
    "#FF6138", "#FFFF9D", "#BEEB9F", "#79BD8F", "00A388",
    "#140B04", "#332312", "#B59D75", "#E3D2B4", "FFF7EA",
    "#ED3B3B", "#171F26", "#77B59C", "#F2E7B1", "635656",
    "#46594B", "#A6977C", "#D9B384", "#734F30", "260B01",
    "#CCB8A3", "#FF8FB1", "#FFF5EA", "#4E382F", "B29882",
    "#B70000", "#FFFFFF", "#FFCA3D", "#94C4F4", "0092B3",
    "#053B44", "#06736C", "#A53539", "#B9543C", "EAD075",
    "#E8C1B9", "#FFB3AB", "#FFCAB8", "#E8B69C", "FFCEAB",
    "#E7F2DF", "#69043B", "#59023B", "#231E2D", "161726",
    "#E82B1E", "#E5DEAF", "#A0B688", "#557A66", "453625",
    "#F1E6D4", "#BA3D49", "#791F33", "#9F9694", "E3E1DC",
    "#CED59F", "#F1EDC0", "#B1BEA4", "#647168", "282828",
    "#2C3E50", "#E74C3C", "#ECF0F1", "#3498DB", "646464",
    "#DE7047", "#FFDE8D", "#FFFFFF", "#CDDE47", "528540",
    "#8EAB99", "#40232B", "#D95829", "#D97338", "DEC085",
    "#E9662C", "#EBAF3C", "#00AC65", "#068894", "2B2B2B",
    "#46483C", "#A0AA8F", "#EBE3CB", "#FFFFFF", "F26101",
    "#170F0E", "#290418", "#505217", "#FFD372", "FFF1AF",
    "#263545", "#C4273C", "#D7DADB", "#6DBCDB", "FFFFFF",
    "#DCFAC0", "#B1E1AE", "#85C79C", "#56AE8B", "00968B",
    "#075807", "#097609", "#70AF1A", "#B9D40B", "E5EB0B",
    "#521000", "#712800", "#744E1D", "#879666", "F1D98C",
    "#261F26", "#3F3B40", "#6C7367", "#BFBF8A", "F2E086",
    "#2C3E50", "#FC4349", "#D7DADB", "#6DBCDB", "FFFFFF",
    "#506D7D", "#94CCB9", "#FFECA7", "#FFB170", "F07D65",
    "#3F4036", "#8DA681", "#F2E1C2", "#BF2806", "8C1D04",
    "#990700", "#CC542E", "#FF964F", "#FFCB7C", "787730",
    "#195073", "#7F8C1F", "#EE913F", "#F2E5BD", "9FD7C7",
    "#1B3E59", "#F2F0F0", "#FFAC00", "#BF0404", "730202",
    "#EA6045", "#F8CA4D", "#F5E5C0", "#3F5666", "2F3440",
    "#F95759", "#FDA099", "#FFFFFF", "#D9F3CB", "8AC2B0",
    "#265573", "#386D73", "#81A68A", "#9FBF8F", "D4D9B0",
    "#E1DA36", "#FFEA1B", "#6FE4DA", "#1DB0BC", "007BBC",
    "#013859", "#185E65", "#F9CC7F", "#F15C25", "9E1617",
    "#36CC7C", "#D6FFBE", "#94D794", "#228765", "77A668",
    "#94201F", "#D4421F", "#478A80", "#D9E061", "F08835",
    "#F16233", "#00B5B5", "#F0F0F0", "#3E4651", "5C6D7E",
    "#2E806C", "#76CC99", "#E0FFED", "#FF5F3A", "D2413C",
    "#00393B", "#00766C", "#44A18E", "#E5EDB6", "F6695B",
    "#734854", "#F2F2E9", "#D9D7C5", "#A69580", "736766",
    "#03497E", "#0596D5", "#9DEBFC", "#8D7754", "FEB228",
    "#F0E14C", "#FFBB20", "#FA7B12", "#E85305", "59CC0D",
    "#FE4365", "#FC9D9A", "#F9CDAD", "#C8C8A9", "83AF9B",
    "#00557C", "#186D94", "#3488AD", "#81C1DC", "BBE5F3",
    "#DEE8D7", "#918773", "#420A1A", "#240001", "4D493A",
    "#FFFFFF", "#CAC535", "#97AF25", "#158471", "41342C",
    "#041F3D", "#0B2E41", "#165751", "#448C61", "9AC16D",
    "#FA8C01", "#FF6405", "#577700", "#082400", "A0A600",
    "#78C0F9", "#FFDDCE", "#FFFFFF", "#FFDBE6", "FE86A4",
    "#351330", "#CC2A41", "#E7CAA4", "#759A8A", "524549",
    "#02151A", "#043A47", "#087891", "#C8C8C8", "B31D14",
    "#F34A53", "#FAE3B4", "#AAC789", "#437356", "1E4147",
    "#58838C", "#DAD7C7", "#BF996B", "#BF5841", "A61C1C",
    "#556354", "#E68F0D", "#8C948A", "#495450", "42423F",
    "#323640", "#5B6470", "#8C94A1", "#BDC7D6", "DFE2FF",
    "#FF0000", "#FF950B", "#2FA88C", "#DEEB00", "4B2C04",
    "#0F3D48", "#174C5B", "#366774", "#ECECE7", "E96151",
    "#3DBB7E", "#A3CD39", "#FBAC1D", "#F96C1E", "EE4036",
    "#23363B", "#A44F3F", "#F8983D", "#8D9151", "BBC946",
    "#4B5657", "#969481", "#D2C9B0", "#F4E3C1", "B6B835",
    "#E8980C", "#B1F543", "#F2FF00", "#FF5E00", "59BBAB",
    "#849696", "#FEFFFB", "#232D33", "#17384D", "FF972C",
    "#555555", "#7BB38E", "#F4F1D7", "#F8AB65", "F15C4C",
    "#1D3C42", "#67BFAD", "#F2EC99", "#F2C48D", "F25050",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF4949",
    "#B8E1F2", "#249AA7", "#ABD25E", "#F8C830", "F1594A",
    "#FDEDD0", "#BCF1ED", "#FF634D", "#FD795B", "FFF0AA",
    "#FFFFFF", "#E5E1D1", "#52616D", "#2C343B", "C44741",
    "#FFFFF1", "#D5FF9B", "#8FB87F", "#5A7B6C", "374E5A",
    "#010340", "#0E1E8C", "#0003C7", "#1510F0", "1441F7",
    "#002A4A", "#17607D", "#FFF1CE", "#FF9311", "E33200",
    "#871E31", "#CCC097", "#9E9D7B", "#687061", "262626",
    "#F16663", "#F48D6C", "#F2E07B", "#8ABE9B", "4A6D8B",
    "#001F11", "#204709", "#0C8558", "#FFD96A", "FF4533",
    "#1D1626", "#F2E0BD", "#BFAA8F", "#8C786C", "594C4C",
    "#685D47", "#913420", "#1E2729", "#C1D9C5", "FEEFB1",
    "#1D7561", "#FC8448", "#FF4138", "#A8282B", "38141B",
    "#BF0633", "#FF484E", "#FF9273", "#D1D0B4", "E5ECED",
    "#8E9E63", "#E6DBB0", "#F5EED7", "#C4BCA0", "176573",
    "#665446", "#809994", "#AECCB6", "#DEF2C4", "E6683F",
    "#3D0D26", "#660A3E", "#891C56", "#B0276F", "C93482",
    "#082136", "#00294D", "#004B8D", "#0068C4", "2998FF",
    "#3C4631", "#9A746F", "#F8A2AB", "#F1C6B3", "EAE9C0",
    "#FF534E", "#FFD7AC", "#BED194", "#499989", "176785",
    "#006D80", "#BDA44D", "#3C2000", "#84CECC", "78A419",
    "#352C2B", "#3C555C", "#9E9657", "#FFEBCD", "CD5510",
    "#2C3E50", "#FC4349", "#6DBCDB", "#D7DADB", "FFFFFF",
    "#523631", "#D1BE91", "#605E3A", "#4D462F", "592F39",
    "#18293B", "#5B5A56", "#F2DEA0", "#D0B580", "FFFBFF",
    "#C8DBB6", "#ECEBB7", "#CCC68A", "#B8B165", "827A5D ",
    "#7DA88C", "#EBE9A0", "#BED24B", "#859132", "35323C",
    "#E8574C", "#F27B29", "#E6A51B", "#D9CC3C", "399977",
    "#324032", "#B7C22C", "#FFFFE1", "#22A8B5", "2A3F42",
    "#B3A589", "#FFB896", "#FFF9B1", "#9AB385", "11929E",
    "#272433", "#343F4F", "#3D6066", "#77994D", "B2D249",
    "#250701", "#6D4320", "#B0925F", "#E7DEC0", "82ABB8",
    "#023550", "#028A9E", "#04BFBF", "#EFEFEF", "FF530D",
    "#594732", "#40342A", "#7A422E", "#D4CA9A", "EDE5AE",
    "#013C4D", "#BA5B22", "#DB913C", "#F0B650", "FAD46B",
    "#143840", "#5C6B63", "#A69E89", "#E0C297", "D96523",
    "#3FB8AF", "#7FC7AF", "#DAD8A7", "#FFB38B", "FF3F34",
    "#CA3995", "#F58220", "#FFDF05", "#BED73D", "61BC46",
    "#FFE1D0", "#FFBFB4", "#FF837E", "#FF4242", "BF1616",
    "#C4EEFF", "#7BA32D", "#094201", "#A41717", "C48726",
    "#001325", "#187072", "#90BD90", "#D7D8A2", "F2E4C2",
    "#1A4F63", "#068587", "#6FB07F", "#FCB03C", "FC5B3F",
    "#97B350", "#333230", "#736D61", "#BAAB90", "FFE5BA",
    "#403D33", "#807966", "#CCC2A3", "#8C0000", "590000",
    "#5F8A42", "#86AD59", "#F6FAA1", "#F28410", "D66011",
    "#BF355D", "#ED8168", "#FAB66A", "#F2DC86", "83BFA1",
    "#E1F03E", "#FFBA14", "#DB3A0F", "#A1003D", "630024",
    "#212226", "#45433F", "#687067", "#BDBB99", "F0EAC3",
    "#FE4365", "#FC9D9A", "#F9CDAD", "#C8C8A9", "83AF9B",
    "#293B47", "#5F7A87", "#FFFFFF", "#CBFF48", "00ADA9",
    "#282A33", "#697371", "#FFE7A6", "#F5BA52", "FA8000",
    "#0C304A", "#2B79A1", "#F3F4F1", "#85A71E", "BFD841",
    "#008B83", "#4DAE83", "#A0AE79", "#FFE499", "FF665E",
    "#5D7359", "#E0D697", "#D6AA5C", "#8C5430", "661C0E",
    "#324452", "#97BDBF", "#F2DFBB", "#F28705", "BF3604",
    "#EEEFB9", "#6ACFAE", "#369C93", "#232928", "B03831",
    "#332F45", "#015770", "#2A8782", "#9FD6AE", "FFFED2",
    "#2B2830", "#5C504F", "#ABAB8E", "#D9D7A3", "C7BE88",
    "#DC941B", "#EDC266", "#B6952C", "#E1D3A6", "E9A119",
    "#00305A", "#00448D", "#0074D9", "#4192D9", "7ABAF2",
    "#344459", "#485F73", "#5DA6A6", "#A9D9CB", "F2EAD0",
    "#060719", "#4D1B2F", "#9E332E", "#EB6528", "FC9D1C",
    "#96CEB4", "#FFEEAD", "#FF6F69", "#FFCC5C", "AAD8B0",
    "#05F2F2", "#04BFBF", "#EEF1D9", "#A60201", "7E100E",
    "#E6F1F5", "#636769", "#AAB3B6", "#6E7476", "4B4E50",
    "#DA0734", "#F1A20D", "#4AABB1", "#FCF3E7", "3F1833",
    "#202D44", "#FC4349", "#6DBCDB", "#D7DADB", "FFFFFF",
    "#CC3B37", "#398899", "#FFFCE8", "#FF857F", "CCC1A3",
    "#5DBEA9", "#EFEDDF", "#EF7247", "#4E3F35", "D1CBBA",
    "#FFC62D", "#E49400", "#DD5200", "#EFE38A", "91B166",
    "#B67D14", "#F2921F", "#F0B23E", "#A62409", "441208",
    "#C71B1B", "#D6BA8A", "#017467", "#E08F23", "0B0D0C",
    "#474143", "#A69E9D", "#E7E2DA", "#FFFFFF", "E7E8E7",
    "#435772", "#2DA4A8", "#FEAA3A", "#FD6041", "CF2257",
    "#6DD19D", "#99E89D", "#D0E8A1", "#FFF9C0", "D40049",
    "#FAF1D5", "#DEC9AC", "#CCA18B", "#11282D", "A5C4BB",
    "#000000", "#141414", "#1C1919", "#1A1716", "24201F",
    "#D5D8DD", "#5CA2BE", "#135487", "#2A4353", "989DA4",
    "#73161E", "#BF0F30", "#BFB093", "#037F8C", "0A2140",
    "#195962", "#F56F6C", "#FFFFFF", "#252932", "191C21",
    "#F8EFB6", "#FEBAC5", "#6CD1EA", "#FACFD7", "C2EAE9",
    "#91D6BC", "#768C6A", "#755F31", "#B37215", "FFBA4B",
    "#F2E6BB", "#DD4225", "#202724", "#63BD99", "F8FDD8",
    "#762B1B", "#807227", "#CCBF7A", "#FFEF98", "60B0A1",
    "#707864", "#C1D74E", "#F5FF7C", "#DFE6B4", "A6B89C",
    "#FFF3D2", "#97B48F", "#E87657", "#FF9B6F", "E8D495",
    "#33262E", "#733230", "#CC5539", "#E6D27F", "86A677",
    "#122430", "#273E45", "#FFFCE2", "#EBD2B5", "E63531",
    "#30394F", "#FF434C", "#6ACEEB", "#EDE8DF", "FFFBED",
    "#0A3A4A", "#196A73", "#32A6A6", "#A1BF36", "C8D94A",
    "#FFF7CC", "#CCC28F", "#70995C", "#33664D", "142933",
    "#43464D", "#9197A6", "#D3DCF2", "#7690CF", "48577D",
    "#DFE0AF", "#A4BAA2", "#569492", "#41505E", "383245",
    "#B52841", "#FFC051", "#FF8939", "#E85F4D", "590051",
    "#473C35", "#A36D5C", "#9C968B", "#D9CEAD", "8A866A",
    "#DB4C39", "#2D3638", "#109489", "#44D487", "D0DB86",
    "#6F8787", "#AEC2AE", "#E6DFAE", "#B0B57B", "888F51",
    "#C8385A", "#FFCF48", "#ECEABE", "#1FCECB", "1CA9C9",
    "#42282E", "#75A48B", "#D9CFB0", "#DC9B74", "D6665A",
    "#362F2D", "#4C4C4C", "#94B73E", "#B5C0AF", "FAFDF2",
    "#98293A", "#B14A58", "#C86C6B", "#DE9D76", "EFC77F",
    "#C1D301", "#76AB01", "#0E6A00", "#083500", "042200",
    "#453F22", "#7A6B26", "#CCAD5C", "#A1191F", "4E1716",
    "#541E32", "#8E3557", "#88A33E", "#C2BD86", "F7F2B2",
    "#2B1B2E", "#54344D", "#FFFFD6", "#B89E95", "6E444F",
    "#6EC1A5", "#9FBEA6", "#F5D3A3", "#FF9F88", "FB7878",
    "#2F252C", "#D3CCB2", "#99AD93", "#6E6751", "5C3122",
    "#BE333F", "#F2E9CE", "#C8C5B1", "#939F88", "307360",
    "#F0F1F2", "#232625", "#647362", "#B3D929", "D2D9B8",
    "#FA2B31", "#FFBF1F", "#FFF146", "#ABE319", "00C481",
    "#09455C", "#527E7C", "#F5FFCC", "#E0EB6E", "C4D224",
    "#F2DA91", "#F2B950", "#F29D35", "#D96704", "BF4904",
    "#A2CFA5", "#E0E7AB", "#F5974E", "#E96B56", "D24344",
    "#150033", "#310D42", "#5C2445", "#AB6946", "FFCE4C",
    "#23A38F", "#B7C11E", "#EFF1C2", "#F0563D", "2E313D",
    "#FF2468", "#E0D4B1", "#FFFFE3", "#00A5A6", "005B63",
    "#65A683", "#218777", "#3F585F", "#47384D", "F53357",
    "#000623", "#28475C", "#4A6C74", "#8BA693", "F0E3C0",
    "#E65322", "#D19552", "#B8BF73", "#B6DB83", "FFF991",
    "#112F41", "#068587", "#6FB07F", "#FCB03C", "FC5B3F",
    "#C89B41", "#A16B2B", "#77312B", "#1C2331", "152C52",
    "#C24366", "#D9C099", "#FFF8D8", "#A8E0BA", "00ADA7",
    "#CC0000", "#006600", "#FFFFEC", "#9C9178", "6C644F",
    "#3D0319", "#720435", "#C1140E", "#FC5008", "32241B",
    "#CFC7A4", "#5A9E94", "#005275", "#002344", "A38650",
    "#FFEBC3", "#CC3A00", "#FF3600", "#FF851B", "800C00",
    "#EFC164", "#F3835D", "#F35955", "#286275", "00434C",
    "#E9F29D", "#B7C29D", "#878E8F", "#67617A", "51456B",
    "#445859", "#03A696", "#49C4BE", "#F1F2E4", "FF7746",
    "#FA726C", "#FFD794", "#BAD174", "#3BA686", "5F6F8C",
    "#4D2B1F", "#635D61", "#7992A2", "#97BFD5", "BFDCF5",
    "#CC4D00", "#E6CF73", "#668059", "#264D4D", "00CCB3",
    "#4385F5", "#DC4437", "#FCBE1F", "#109D59", "FFFFFF",
    "#271F2E", "#A4A680", "#F2EBC9", "#D9B166", "A66B38",
    "#0B2C3C", "#FF6666", "#DADFE1", "#FFFFFF", "444444",
    "#CFF09E", "#A8DBA8", "#79BD9A", "#3B8686", "0B486B",
    "#302B26", "#A6B827", "#EDE9DD", "#98D3D4", "594E7A",
    "#4B0505", "#720707", "#BFB694", "#004659", "00292B",
    "#B52C38", "#EBD1B0", "#536682", "#D9964B", "DE6846",
    "#F2F1DF", "#F2B705", "#F2C84B", "#BF820F", "734002",
    "#26140C", "#3D2216", "#784E3D", "#AB8574", "D6BCB1",
    "#26221D", "#8C2C0F", "#E6E5B8", "#BFB38D", "402D1F",
    "#1F8181", "#F2BC79", "#F28972", "#BF1B39", "730240",
    "#002635", "#013440", "#AB1A25", "#D97925", "EFE7BE",
    "#8EC447", "#FFFFFF", "#96D3D4", "#636466", "2D2D2E",
    "#2D1E1E", "#4B3C37", "#96A576", "#CDE196", "FFFFBE",
    "#F06060", "#FA987D", "#F7F2CB", "#72CCA7", "10A296",
    "#1D8281", "#44BF87", "#FBD258", "#F29A3F", "DB634F",
    "#DEDE91", "#EF9950", "#F34E52", "#C91452", "492449",
    "#6D8EAD", "#1F3447", "#1A0B07", "#362416", "CFCDB4",
    "#00CD73", "#008148", "#2D9668", "#3ECD8E", "004E2C",
    "#3D8080", "#628282", "#858383", "#A38282", "C28080",
    "#475159", "#839795", "#B2BDB7", "#CCC9C0", "F2F2F2",
    "#0E6870", "#C6B599", "#C65453", "#FFDDB4", "EDAA7D",
    "#CEF0B7", "#A8DBA8", "#79BD9A", "#3B8686", "0B486B",
    "#292C44", "#FF5349", "#F0F0F1", "#18CDCA", "4F80E1",
    "#272A2B", "#383737", "#473B39", "#692B28", "940500",
    "#D6C274", "#DB9E46", "#25706B", "#3D2423", "AB362E",
    "#FFA68F", "#FF4867", "#FFF9C8", "#B5EBB9", "18B29D",
    "#A1A16A", "#727D59", "#366353", "#133C40", "03212E",
    "#D45354", "#A9DC3A", "#2FCAD8", "#818B85", "CDCDC1",
    "#F14B6A", "#3D3C3E", "#22BDAF", "#BAD7D4", "F4F4F4",
    "#FFE2C5", "#FFEEDD", "#FFDDAA", "#FFC484", "FFDD99",
    "#9FFF4A", "#1ABF93", "#087363", "#004040", "2F1933",
    "#FFDB97", "#B28F4E", "#FFFDFB", "#466CB2", "97BBFF",
    "#991C00", "#E09A25", "#FFFCDB", "#008B83", "262B30",
    "#44281A", "#00ACAE", "#F5EFD5", "#F37606", "EE4717",
    "#FF5952", "#FCEEC9", "#96D6D9", "#4FAAC9", "176075",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#A5C88F", "EF847B",
    "#105F73", "#F7F3B2", "#C6CC33", "#F28322", "CC5404",
    "#137072", "#56B292", "#B7F5AB", "#FBFFC0", "BF223D",
    "#E3F23E", "#6C821C", "#A6A53F", "#E0E0AC", "33302E",
    "#00215E", "#003CAA", "#1967F7", "#5E4000", "AA7400",
    "#273A3D", "#54695C", "#AD9970", "#FFBF87", "FF8F60",
    "#FFAA00", "#C2B93E", "#808F5D", "#576157", "302F30",
    "#BE1405", "#F2DCAC", "#AABEAA", "#736E41", "413C2D",
    "#6B1229", "#C76A61", "#FAB99A", "#F7D9B5", "CCB1A7",
    "#2D9993", "#58B3A3", "#83BFA3", "#B0D9A8", "FFFCB6",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF5A49",
    "#F30B55", "#010326", "#012840", "#54717F", "F2E6CE",
    "#2A3411", "#73662C", "#BC9847", "#FFDFB2", "6B0031",
    "#637D74", "#403D3A", "#8C3B3B", "#AB6937", "D4A960",
    "#010A26", "#011640", "#B6D6F2", "#FFFFFF", "E83338",
    "#924847", "#EB986C", "#E4C678", "#9C7885", "372C2C",
    "#022440", "#3F95AA", "#4EC6DE", "#EAE2DF", "F7572F",
    "#2B1D2E", "#323657", "#076473", "#54B087", "D6F567",
    "#052229", "#004043", "#BCC373", "#E3FF55", "D0D90C",
    "#4C514A", "#907A62", "#879796", "#755854", "B09880",
    "#1D2939", "#1CAF9A", "#FFFFFF", "#EE4F4B", "D1DC48",
    "#004B67", "#41CCB4", "#FFEA95", "#FF7C5D", "C70151",
    "#C0272D", "#FCFBE7", "#9FD3DA", "#008C9A", "05484F",
    "#213130", "#FF5E3D", "#C9C83E", "#FDFFF1", "559398",
    "#B1E4FC", "#366D78", "#39D5F1", "#FFFFFF", "D9FF03",
    "#DECE6C", "#FCF9B6", "#BFE3B5", "#5D826E", "262E2B",
    "#520A17", "#668F91", "#F5E6AC", "#AB8E5B", "52301C",
    "#2D3032", "#DD5F18", "#FBA922", "#F7F7F7", "404333",
    "#0C2538", "#2B434F", "#638270", "#BCC98E", "EDE059",
    "#E85066", "#F28E76", "#E6CEB0", "#5A8C81", "382837",
    "#BF2633", "#A6242F", "#D9CEAD", "#C0B18F", "011C26",
    "#002A4A", "#17607D", "#FFF1CE", "#FF9311", "E33200",
    "#0A8B91", "#485956", "#C4B98F", "#FFF9BC", "EEDF2E",
    "#B89A7B", "#9BBAAC", "#F2D649", "#D95D50", "DBDBDB",
    "#BD7938", "#8D4421", "#643001", "#532700", "3A1C00",
    "#E1E6FA", "#C4D7ED", "#ABC8E2", "#375D81", "183152",
    "#2E4259", "#F7483B", "#ECF0F1", "#03C8FA", "737373",
    "#364656", "#5D6B74", "#94A4A5", "#F2F5E9", "FF8C31",
    "#3E5916", "#93A605", "#F28705", "#F25C05", "E5EFFA",
    "#248077", "#74AD8D", "#C82754", "#F7BB21", "F9E2B7",
    "#20736A", "#8BD9CA", "#B1D95B", "#93A651", "403E34",
    "#D74B4B", "#DCDDD8", "#475F77", "#354B5E", "FFFFFF",
    "#252F33", "#415C4F", "#869C80", "#93C2CC", "CEEAEE",
    "#012840", "#79C7D9", "#9BF2EA", "#497358", "9DBF8E",
    "#EE7E94", "#F8B4C4", "#C7CAC9", "#D8505C", "41424",
    "#282828", "#505050", "#FFFFFF", "#2DCEDB", "F20000",
    "#004358", "#1F8A70", "#BEDB39", "#FF5347", "FD7400",
    "#470C3B", "#802F56", "#C0576F", "#E38679", "FFBD83",
    "#573328", "#B05A3A", "#FF8548", "#29332E", "0F1B1C",
    "#461F2D", "#E1FFBB", "#BAD47F", "#849C23", "52533F",
    "#333A40", "#4C5E5E", "#ADD0E5", "#CDE4FF", "729EBF",
    "#DE5605", "#F7A035", "#B1DEB5", "#EFECCA", "65ABA6",
    "#76D6D2", "#F9E270", "#EF6F56", "#F4EED8", "596B56",
    "#403E3F", "#F2F2F2", "#D9D9D9", "#9DAABB", "8C8C8C",
    "#059E9A", "#F4F2ED", "#F5A243", "#DB3E3B", "585857",
    "#FFBF41", "#EE8943", "#C02221", "#FFF4D3", "249CA9",
    "#024E76", "#39A6B2", "#FCE138", "#F5B824", "F08106",
    "#FF0067", "#FF3D6A", "#E7FF04", "#9CFF00", "56FF00",
    "#003540", "#0D3F40", "#487360", "#8FA671", "F2D795",
    "#FF493C", "#FFFFFF", "#B3ECEF", "#31C4F5", "ADEB41",
    "#244358", "#4A8B87", "#7CBCAE", "#F0D4AF", "C5252B",
    "#EA5930", "#F8AF1E", "#F5E5C0", "#097380", "372560",
    "#A1DBB2", "#FEE5AD", "#FACA66", "#F7A541", "F45D4C",
    "#2C4A47", "#6C9A7F", "#BB523D", "#C89D11", "81810B",
    "#F0F1F2", "#232625", "#647362", "#FF5629", "D2D9B8",
    "#7C9B5F", "#B8D197", "#E3FFF3", "#9BDEC7", "568F84",
    "#E54E45", "#DBC390", "#F2F2EF", "#13A3A5", "403833",
    "#77A7FB", "#E57368", "#FBCB43", "#34B67A", "FFFFFF",
    "#001A2E", "#8F0000", "#FFFFFF", "#8A874B", "41594F",
    "#312F40", "#49A69C", "#EFEAC5", "#E89063", "BF5656",
    "#047C8C", "#018B8D", "#F3BF81", "#F49B78", "F1706D",
    "#00303E", "#7096AD", "#C1D1DE", "#FFF9EF", "EC4911",
    "#2D6891", "#70A0BF", "#F5EEDC", "#DC4C1A", "F0986C",
    "#040002", "#3D1309", "#E8B96A", "#BC5D15", "5C0F00",
    "#8B929C", "#5E6070", "#514454", "#3B313D", "FF2479",
    "#142D58", "#447F6E", "#E1B65B", "#C8782A", "9E3E17",
    "#22104D", "#2D1E5E", "#483A85", "#7067AB", "A49CFA",
    "#919C86", "#9E373E", "#2B2E36", "#D1B993", "C45A3B",
    "#332F45", "#015770", "#2A8782", "#9FD6AE", "FFFED2",
    "#37C78F", "#FEE293", "#FF4D38", "#CC2249", "380C2A",
    "#47282C", "#8C8468", "#C9B37F", "#DBDAB7", "C4C49C",
    "#14191A", "#2D2B21", "#A69055", "#CCB287", "FFB88C",
    "#F5E3CD", "#696158", "#B6A898", "#877D71", "504A43",
    "#005151", "#009393", "#F56200", "#454445", "969692",
    "#D95F47", "#FFF2C1", "#80A894", "#106153", "072C36",
    "#9E352C", "#E6E8A9", "#93C28C", "#2E5A5C", "2B2623",
    "#03013A", "#334A94", "#6B9EDF", "#83C3F2", "99E6FF",
    "#372A26", "#4D4D4D", "#6DA0A7", "#9ED5A8", "C7F5FF",
    "#03658C", "#022E40", "#F2B705", "#F28705", "F25C05",
    "#FF3B16", "#E87826", "#E8BA4A", "#80A272", "003045",
    "#00748E", "#E3DFBB", "#F4BA4D", "#E3753C", "DA3B3A",
    "#25401E", "#56732C", "#84A63C", "#B8D943", "EAF2AC",
    "#449BB5", "#043D5D", "#EB5055", "#68C39F", "FFFCF5",
    "#108F97", "#FF8B6B", "#FFE39F", "#16866D", "103636",
    "#1A4F63", "#068F86", "#6FD57F", "#FCB03C", "FC5B3F",
    "#381C19", "#472E29", "#948658", "#F0E99A", "362E29",
    "#D7E8F7", "#BBD0E3", "#9CB7CF", "#6A8BAB", "375D81",
    "#0F1C28", "#136972", "#67BFA7", "#F3CF5B", "F07444",
    "#FFFFFF", "#4EA9A0", "#969514", "#FE9C03", "FCDE8E",
    "#2F2D30", "#656566", "#65537A", "#51386E", "2A2333",
    "#4C2916", "#F05A28", "#FBAF3F", "#38B449", "FFFFFF",
    "#132537", "#006C80", "#EBCAB8", "#FE8315", "FA3113",
    "#ECEEE1", "#A8DACF", "#F05B4F", "#D8403A", "221E1F",
    "#00305A", "#004B8C", "#0074D9", "#4192D9", "7ABAF2",
    "#72CF3F", "#85FF00", "#23E000", "#2FB81B", "00FF1C",
    "#45CEEF", "#FFF5A5", "#FFD4DA", "#99D2E4", "D8CAB4",
    "#FF5B00", "#A1716C", "#728296", "#439AAB", "00CABD",
    "#EB6C2D", "#D9C8A2", "#939C80", "#496158", "232F38",
    "#D94214", "#FFF2C1", "#80A894", "#52736B", "093844",
    "#4D1B2F", "#9E332E", "#EB6528", "#FC9D1C", "FFCA50",
    "#FFEEB0", "#9AE8A4", "#C7C12D", "#F76245", "ED1C43",
    "#FFFAED", "#D4DBFF", "#879AC9", "#242942", "FF8800",
    "#022840", "#013440", "#517360", "#9DA67C", "F2DC99",
    "#331A0F", "#519994", "#BA4B3C", "#EEDDAA", "789F63",
    "#577867", "#EDCE82", "#D68644", "#AB3229", "662845",
    "#435A66", "#88A6AF", "#F5F2EB", "#D9CDB8", "424342",
    "#FF8840", "#958D4F", "#737B55", "#595540", "513E38",
    "#9D805A", "#EBC99D", "#FFE6C5", "#9DCEEA", "4B809E",
    "#272D40", "#364659", "#55736D", "#9DBF8E", "D0D991",
    "#23A38F", "#B7C11E", "#EFF1C2", "#F0563D", "2E313D",
    "#98C000", "#3D4C53", "#EA2E49", "#FFE11A", "0CDBE8",
    "#A20E30", "#E93C4F", "#DCDCD4", "#ADBCC3", "2D4255",
    "#1C2640", "#263357", "#384C80", "#4E6AB3", "5979CD",
    "#D94214", "#FFF2C1", "#80A894", "#52736B", "093844",
    "#3B596A", "#427676", "#3F9A82", "#A1CD73", "ECDB60",
    "#1E1E1F", "#424143", "#67666A", "#807F83", "CBC9CF",
    "#E04946", "#3BA686", "#B6D15D", "#FFD495", "FA847E",
    "#FFEBB0", "#FFB05A", "#F84322", "#C33A1A", "9F3818",
    "#FFA136", "#FF814A", "#E6635A", "#785D6B", "534557",
    "#CDCF91", "#EBEACC", "#D6D5B8", "#6D7D80", "41545E",
    "#011526", "#011C40", "#4E8DA6", "#F2EA79", "F2B33D",
    "#353230", "#3F4E51", "#7B8F70", "#99B2BE", "F6F4EA",
    "#063559", "#0D8C7F", "#8FBF4D", "#F2D13E", "D95929",
    "#158000", "#199900", "#20BF00", "#24D900", "29FF00",
    "#0B0D0E", "#137074", "#7EB7A3", "#F1DDBB", "EC6766",
    "#02151A", "#043A47", "#087891", "#C8C8C8", "B31D14",
    "#59361F", "#5C992E", "#A3CC52", "#E6E673", "FF5933",
    "#FE4365", "#FC9D9A", "#F9CDAD", "#C8C8A9", "83AF9B",
    "#4B1E18", "#F9E5C2", "#BBB082", "#829993", "4F5D4E",
    "#032843", "#1F595B", "#508C6D", "#71A670", "A6DB89",
    "#191724", "#4C4547", "#8C594E", "#D18952", "FDB157",
    "#191919", "#182828", "#60702D", "#AAB232", "E6FA87",
    "#212A3F", "#434F5B", "#F2F2F2", "#8AB839", "2E2E2E",
    "#004158", "#026675", "#038B8B", "#F1EEC9", "F09979",
    "#023059", "#3F7EA6", "#F2F2F2", "#D99E32", "BF5E0A",
    "#F21E52", "#FFFFFF", "#3D3B42", "#0C6F73", "63CFD4",
    "#452743", "#E7635E", "#F8E9A8", "#89E0AD", "00928C",
    "#FAAD63", "#D1714D", "#785E48", "#39403B", "3D1C24",
    "#4C0016", "#FFF7EB", "#DCCEA7", "#A17345", "104F53",
    "#BF2431", "#F24150", "#2A4557", "#3B848C", "EFF2E4",
    "#3B3013", "#8F6031", "#E88833", "#9C0C0A", "FDF3C1",
    "#1E2422", "#88BEB1", "#FF006D", "#DAFFFF", "718A94",
    "#F1F4F7", "#AF9F7B", "#775E43", "#40413C", "251C17",
    "#00182E", "#0C6BA1", "#D4D6D4", "#FFFDEB", "FF7500",
    "#FFAB4A", "#CCBAAB", "#1E2129", "#3D5E6E", "47A3A3",
    "#66B3A7", "#C0D4B6", "#EEF0BD", "#F0563D", "2C2F3B",
    "#332525", "#907465", "#EDC5B5", "#878C6D", "63674A",
    "#F04C16", "#DBDBD0", "#EDBD1F", "#4CB09C", "313B4A",
    "#2B211D", "#611C26", "#C5003E", "#8EB7A8", "F1E4B7",
    "#1A1F2B", "#30395C", "#4A6491", "#85A5CC", "D0E4F2",
    "#03497E", "#0596D5", "#9DEBFC", "#999999", "FE4B28",
    "#2F4159", "#465E73", "#88A649", "#F2ECE4", "D98841",
    "#323A46", "#22282F", "#EB4A33", "#FFFFFF", "E9F0F5",
    "#2C3E50", "#FC4349", "#6DBCDB", "#D7DADB", "FFFFFF",
    "#F29727", "#E05723", "#B0382F", "#982E4B", "713045",
    "#4D584A", "#465943", "#428552", "#3E754E", "4C694B",
    "#47191C", "#59574B", "#829690", "#B5B09A", "E1E3CB",
    "#1D5123", "#B1C661", "#FFDA68", "#FE9257", "F64448",
    "#59323C", "#260126", "#F2EEB3", "#BFAF80", "8C6954",
    "#4E0805", "#9E0522", "#FFF4D4", "#B8C591", "447622",
    "#424862", "#FB9A63", "#BFC4D5", "#F6FBF4", "FEBC98",
    "#FF2468", "#E0D4B1", "#FFFFE3", "#00A5A6", "005B63",
    "#1C2F40", "#4C6173", "#8094A6", "#D9D1BA", "F2E9D8",
    "#DFD7B7", "#EB7707", "#5C5445", "#3B2323", "9CBFC7",
    "#262E3B", "#9C8878", "#CFCAAA", "#FBF8FF", "992435",
    "#FFBC67", "#DA727E", "#AC6C82", "#685C79", "455C7B",
    "#404A69", "#516C8A", "#8AC0DE", "#FFFFFF", "FFAC00",
    "#485B61", "#4B8C74", "#74C476", "#A4E66D", "CFFC83",
    "#A31180", "#C42795", "#DE52B4", "#EA88CE", "FFBFE5",
    "#E64D2E", "#FFF5F1", "#7893AD", "#576B9C", "2D2A52",
    "#BF0436", "#8C0327", "#590219", "#F2CBA1", "8C674C",
    "#CF5B6F", "#FFF8C8", "#CAD9B1", "#8FB3A0", "648991",
    "#341D44", "#744D90", "#BB8CDD", "#3E4417", "88904D",
    "#00293E", "#003D4E", "#006269", "#00918F", "00BAB5",
    "#43212E", "#D9666F", "#F2D57E", "#A9A688", "516057",
    "#2A3B30", "#ABFFD1", "#EBFFF5", "#9DFEFF", "273B40",
    "#A63343", "#E65159", "#F5E9DB", "#F4F7CF", "BAD984",
    "#1BA68C", "#54BFAC", "#F2EDA7", "#F2E530", "D94625",
    "#1A2A40", "#3F7369", "#F2DEA0", "#CE5251", "EA895E",
    "#1E9382", "#70A758", "#EFF1C2", "#F0563D", "2E313D",
    "#A991E8", "#FFB4BB", "#ACF7FF", "#A2E891", "FFEDAE",
    "#225B66", "#17A3A5", "#8DBF67", "#FCCB5F", "FC6E59",
    "#282624", "#BFB7AA", "#403D39", "#807A71", "ABA398",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF4949",
    "#440008", "#605521", "#988432", "#D9A54E", "9E3711",
    "#649670", "#36291E", "#69AD6C", "#92E67C", "C5FF84",
    "#42342C", "#738076", "#B2B39B", "#DFE5E1", "294359",
    "#1A3838", "#3F7A51", "#82A352", "#D1C062", "FFBE59",
    "#7D8C22", "#B3BF67", "#F2E49B", "#D9DFF4", "6791BF",
    "#8A7D6D", "#2D2D38", "#E86E48", "#FFFFE8", "9CC9C9",
    "#CFC949", "#FFF5BF", "#A9E6C4", "#6AB39F", "665841",
    "#A1172D", "#FDFFBA", "#A7DB9E", "#275C57", "1F1B19",
    "#FF6C0D", "#F29E00", "#E6C10F", "#44996F", "216273",
    "#2C3E50", "#FA4248", "#D7DADB", "#6DBCDB", "FFFFFF",
    "#627369", "#99B397", "#E2F2C6", "#91CCAD", "376266",
    "#04496E", "#66CAFF", "#A3FC7E", "#70D44A", "2C6B0F",
    "#1BA68C", "#97BF3F", "#F2ECD8", "#F2B035", "F2522E",
    "#A2D9B1", "#7CBF9E", "#F2F1B9", "#8C8575", "193741",
    "#024959", "#037E8C", "#F2EFDC", "#E74C30", "363636",
    "#212625", "#9CA6A2", "#D0D9D6", "#BF0404", "C2C6AF",
    "#00FFFF", "#00FF00", "#FFFF00", "#FF5100", "FF007C",
    "#212629", "#CDCF19", "#FFF77D", "#96C4AB", "CF2A56",
    "#CFF9FF", "#BFC7BB", "#787051", "#332730", "57324F",
    "#98CACB", "#FDEFBE", "#F0542B", "#736E5B", "ABA68E",
    "#F2F1EB", "#BFB9A4", "#262222", "#802A30", "8C0303",
    "#65356B", "#AB434F", "#C76347", "#FFA24C", "519183",
    "#78BF82", "#A4D17C", "#CFD96C", "#EBD464", "FFD970",
    "#806265", "#FFA256", "#F7DD77", "#E0D054", "ABA73C",
    "#8F323C", "#123943", "#80BDDB", "#4189AB", "C98127",
    "#683820", "#8C9A89", "#E7D6A2", "#BEAA65", "9A8234",
    "#021B21", "#032C36", "#065F73", "#E8DFD6", "FF2A1D",
    "#2D6C73", "#3FA693", "#B4D9CB", "#9ABF49", "C6D93B",
    "#141F26", "#2B4040", "#405950", "#A69E86", "F2D9BB",
    "#4A8279", "#003330", "#610400", "#003B06", "02730F",
    "#69B5E1", "#D4E4F5", "#EAF2F8", "#BEDBED", "000000",
    "#893660", "#EF7261", "#68D693", "#A0D7E2", "299CA8",
    "#073A59", "#2D9AA6", "#F2E2DC", "#F23322", "A61B1B",
    "#2A3A48", "#3E6372", "#B2D4DC", "#FAFAFF", "FF6900",
    "#F3BD8D", "#F1A280", "#BE6D6B", "#704A5B", "3E263C",
    "#1C2742", "#3C91C7", "#5A9ABE", "#95C5DE", "E0EEFB",
    "#426261", "#465A59", "#577573", "#739A97", "9AC1C0",
    "#002A4A", "#17607D", "#FFF1CE", "#FF9311", "D64700",
    "#589373", "#BFBD99", "#F2D6B3", "#C2512F", "241E1E",
    "#1F518B", "#1488C8", "#F7E041", "#E2413E", "B5292A",
    "#549494", "#E85649", "#232C2E", "#E6E8D2", "706558",
    "#392133", "#FFECBE", "#D9D098", "#C4AB6D", "AB7D3A",
    "#F0F0F0", "#1C1C1C", "#A2FDF5", "#1CCDC7", "27EDDF",
    "#011526", "#025959", "#027353", "#03A678", "03A696",
    "#004358", "#1F8A70", "#BEDB39", "#FFE11A", "FD7400",
    "#37465D", "#F2F2F2", "#9DC02E", "#779324", "051A37",
    "#580022", "#AA2C30", "#FFBE8D", "#487B80", "011D24",
    "#F9F9F9", "#03A678", "#E9EDEB", "#F44647", "00707F",
    "#800000", "#BF0000", "#E2D6C2", "#F6EDD8", "FFFFFF",
    "#F7F6AF", "#1B2124", "#D62822", "#97D6A6", "468263",
    "#432852", "#992255", "#FF3D4C", "#28656E", "00968F",
    "#444344", "#52BBB2", "#2B344D", "#EE5555", "F8F7EE",
    "#45334A", "#796B7D", "#CCC4B0", "#FFF1B5", "FFA3A3",
    "#5A4B53", "#9C3C58", "#DE2B5B", "#D86A41", "D2A825",
    "#14151C", "#0C242B", "#297059", "#84D66E", "D1FB7A",
    "#272D40", "#364659", "#55736D", "#9DBF8E", "D0D991",
    "#23A38F", "#B7C11E", "#EFF1C2", "#F0563D", "2E313D",
    "#2E064D", "#80176B", "#B356A1", "#59580B", "FFFF00",
    "#CC3333", "#FF9D33", "#F7F7F0", "#3EBBA7", "00747A",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#F3B562", "BD6060",
    "#0D3E58", "#1C848C", "#19C0C2", "#F3EDD6", "DA6260",
    "#022629", "#2A5945", "#FAFFED", "#E6DCC0", "B3371C",
    "#F4FAC7", "#7BAD8D", "#FFB159", "#F77F45", "C2454E",
    "#A2C1C6", "#86B1B7", "#AECBAD", "#CFDCB0", "D6E1D1",
    "#B0DAFF", "#325B80", "#64B7FF", "#586D80", "5092CC",
    "#0F808C", "#6C8C26", "#F2A71B", "#F26A1B", "D91818",
    "#FFBC6C", "#FE9F6C", "#BD716E", "#74495F", "3B2C4D",
    "#FF4D41", "#F2931F", "#E6CA21", "#91B321", "1E8C65",
    "#302821", "#453629", "#5C4837", "#8A735F", "BDA895",
    "#415457", "#5F7B7F", "#9ACCAF", "#E6EBC4", "F9F7C8",
    "#474143", "#A69E9D", "#E7E2DA", "#FFFFFF", "E7E8E7",
    "#805939", "#BD9962", "#E6CD7D", "#578072", "2D4B4D",
    "#03588C", "#1763A6", "#419CA6", "#54BF83", "8DBF41",
    "#00CCFF", "#A1FCFF", "#040438", "#004878", "C9FAFF",
    "#534C64", "#B7DECF", "#F0F3D7", "#7E858C", "D96557",
    "#7F7364", "#CBB08E", "#CBC1B7", "#789DCB", "646F7F",
    "#5C2849", "#A73E5C", "#EC7263", "#FE9551", "FFD285",
    "#FF0012", "#FF7D00", "#FFD900", "#5BE300", "0084B0",
    "#F24C32", "#F29471", "#FCDFA6", "#36B898", "3D7585",
    "#083157", "#0A6C87", "#459C97", "#92CCA5", "C9F0B1",
    "#DC941B", "#EDC266", "#B6952C", "#E1D3A6", "E9A119",
    "#323836", "#BAD1B5", "#DBE8CF", "#F0F7E8", "FFFEF5",
    "#081724", "#589494", "#8EBBB4", "#D0DCD0", "F5EED2",
    "#50781C", "#9CAD1C", "#EAF7E6", "#40A5DE", "0B5191",
    "#537F79", "#78A68F", "#CBD49C", "#FED457", "CB252A",
    "#F23C13", "#CBAB78", "#FFFFFF", "#898373", "1F1C17",
    "#450003", "#5C0002", "#94090D", "#D40D12", "FFED75",
    "#0770A2", "#82D9F7", "#FEFEFE", "#AEC844", "F36622",
    "#30394F", "#FF434C", "#6ACEEB", "#EDE8DF", "0E6569",
    "#FF6B6B", "#556270", "#C7F464", "#4ECDC4", "EDC8BB",
    "#D9B500", "#FFED9C", "#BFCC85", "#748F74", "454545",
    "#452E32", "#A34B1B", "#B5A187", "#EDDF9A", "A7CC31",
    "#2C2B33", "#596664", "#909980", "#CCC08D", "FF8A00",
    "#C21F1F", "#FFFFFC", "#E34446", "#FFFFDB", "E36D6F",
    "#282828", "#00AAB5", "#C1C923", "#F41C54", "F5F0F0",
    "#3A3F40", "#202627", "#151B1E", "#EFF4FF", "41444D",
    "#DEBB73", "#4D0017", "#010000", "#4D0F30", "9A002F",
    "#EB9328", "#FFA754", "#FFD699", "#FFF5DC", "4FA6B3",
    "#025E73", "#037F8C", "#D9D59A", "#D9BD6A", "590202",
    "#636266", "#E0CEA4", "#E8A579", "#7D6855", "42403E",
    "#FF0000", "#FF4000", "#FF7F00", "#FFBF00", "FFFF00",
    "#FFFFFF", "#74ADA6", "#1E5E6F", "#241B1F", "68A81E",
    "#5A0532", "#FF6745", "#FFC861", "#9DAE64", "27404A",
    "#ACCBBC", "#467847", "#E8E4C1", "#A60303", "730202",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#F3B562", "F06060",
    "#0D2557", "#93A8C9", "#FFFFFF", "#F5DED5", "558D96",
    "#F53C4A", "#565157", "#10CFC8", "#F2EEE7", "F5D662",
    "#FFD97B", "#E65029", "#A60027", "#660033", "191C26",
    "#595408", "#A6800D", "#A66D03", "#A63F03", "730C02",
    "#2E031F", "#590424", "#8C072B", "#BF0A2B", "DEEFC5",
    "#E0C882", "#A6874E", "#BFA169", "#D9B779", "F2D399",
    "#D88681", "#A67673", "#746566", "#535A5D", "324F54",
    "#FC297D", "#FB607A", "#FDA286", "#FDC188", "FEE78A",
    "#FFECA1", "#B3B27F", "#4C5E52", "#2F3436", "FFBE2C",
    "#D93312", "#B3AB82", "#45735F", "#394D47", "2C3233",
    "#324143", "#6595A3", "#C8E3E8", "#FCFFED", "B6C28B",
    "#477984", "#FEF5EB", "#C03C44", "#EEAA4D", "313E4A",
    "#334D5C", "#45B29D", "#EFC94C", "#E27A3F", "DF4949",
    "#630B11", "#33322F", "#2A2927", "#1E1D1C", "000000",
    "#D94214", "#FFF2C1", "#80A894", "#52736B", "093844",
    "#051E21", "#00302D", "#856434", "#F28C28", "FFAD4E",
    "#D7DADD", "#DDDEE3", "#E1E1E9", "#EDEFF4", "F2F3F8",
    "#BF495E", "#41A693", "#F2EC9B", "#D9CF48", "D9583B",
    "#067072", "#14A589", "#DECFA6", "#BAAE8C", "F94B06",
    "#423A38", "#47B8C8", "#E7EEE2", "#BDB9B1", "D7503E",
    "#730324", "#DFE3E6", "#B4C4D4", "#8BA2BD", "456382",
    "#537374", "#F9BD7F", "#EBD7A5", "#ADC9A5", "5C9E99",
    "#88B59E", "#B6DEC8", "#39464D", "#C04229", "ABD1AB",
    "#11A7FC", "#95D127", "#F2E415", "#FF8638", "EE3551",
    "#212640", "#5D718C", "#4B95A6", "#60BFBF", "EFF2D8",
    "#D8A64D", "#9B5422", "#351411", "#5B0D0D", "991C11",
    "#53324F", "#668D6E", "#F2E0A0", "#F19B7A", "F0756E",
    "#DFE0AF", "#A4BAA2", "#569492", "#41505E", "383245",
    "#7BBADE", "#93DE7F", "#FFED5D", "#F29E4A", "FF7050",
    "#133800", "#1B4F1B", "#398133", "#5C9548", "93E036",
    "#D9D7AD", "#91A685", "#FF6A00", "#37485C", "1C232E",
    "#008767", "#FFB27A", "#FF6145", "#AB2141", "5E1638",
    "#727B7F", "#CCEAEA", "#7A7556", "#2E2125", "44CACC",
    "#FFFFED", "#FF2C38", "#FF9A3A", "#FFF040", "67D9FF",
    "#007148", "#60A859", "#9BDA6A", "#C7F774", "F9FFEF",
    "#092740", "#45698B", "#90B0CC", "#F1FAFF", "8FD36F",
    "#E2FFA0", "#7D8076", "#FAFFED", "#C2CCBE", "8F7D70",
    "#00736A", "#00BC9F", "#F1EEC7", "#FEA301", "F2561A",
    "#26282E", "#AD5138", "#F7F7F7", "#DDDAE0", "8594AE",
    "#1A191F", "#35352F", "#484042", "#4E5252", "E64D38",
    "#49454A", "#E69B02", "#FAF4C6", "#B1D631", "324052",
    "#5F1A2B", "#1D2834", "#6F8B78", "#E4D49E", "C96466",
    "#012D3D", "#38AD9E", "#FFEB9E", "#FF6867", "D0DBED",
    "#0D1F36", "#104954", "#1E9C89", "#38CC85", "60EB7B",
    "#8C4E03", "#9FA66A", "#F2EC94", "#F23005", "8B0F03",
    "#000001", "#20201F", "#E2E2E4", "#590402", "B80000",
    "#344059", "#465973", "#F2D272", "#A69460", "595139",
    "#33454C", "#608F85", "#B6E5CB", "#8BAF95", "54584E",
    "#FBFEF6", "#B7BFA4", "#687F70", "#1A3841", "BF3847",
    "#D7E836", "#86FFC7", "#FFB048", "#E8366C", "593BFF",
    "#34A9FF", "#5982DB", "#665EB8", "#684682", "632E62",
    "#004056", "#2C858D", "#74CEB7", "#C9FFD5", "FFFFCB",
    "#BFB978", "#84945C", "#516967", "#4D3130", "281B24",
    "#103B73", "#20638C", "#3786A6", "#4EABBF", "EBEFF2",
    "#9FB1BF", "#1D2D63", "#1C5357", "#1F6E56", "196331",
    "#FFEBBA", "#C3BD91", "#88947B", "#4C3F3F", "2A2727",
    "#347373", "#4EA6A6", "#91D9D9", "#FFFFFD", "F2E205",
    "#828948", "#EFDFC2", "#006971", "#DC533E", "840000",
    "#000137", "#29003F", "#79003D", "#D04D14", "F89801",
    "#370005", "#4B0005", "#5F0005", "#730005", "870005",
    "#C3AE8D", "#F25260", "#2D5F73", "#6BADC9", "8FCED6",
    "#9E1B36", "#F7EDBA", "#E69B3D", "#EB3355", "3D241D",
    "#1D8281", "#44BF87", "#FBD258", "#F29A3F", "DB634F",
    "#035C75", "#1B808C", "#31A6A8", "#F3F1BC", "F3AD14",
    "#FF7500", "#665130", "#EBB643", "#CEDAA8", "668E84",
    "#384D3A", "#3E6653", "#728053", "#A68357", "D97C71",
    "#012326", "#17455C", "#E1CAAB", "#FE8333", "FA4913",
    "#1A2944", "#2DA7C7", "#56ACBA", "#98C4C9", "CBD5D2",
    "#BF3542", "#CDC5BA", "#EBE3D6", "#3C3C3C", "2E2E2E",
    "#231921", "#695F74", "#BEB4CB", "#EBEBF0", "D2DCEB",
    "#34373F", "#686C75", "#F3E9D0", "#BEB7A7", "8E867C",
    "#661510", "#D9351A", "#F2C76F", "#BF9727", "204D3F",
    "#3CFFEE", "#24AABC", "#356781", "#2C3D51", "1C1F24",
    "#DA3537", "#FFFCC4", "#00585F", "#6A6A61", "2A2C2B",
    "#AE3135", "#D1AF87", "#8C826B", "#3D3C33", "F2F0CE",
    "#FF0894", "#FF5E9F", "#FF91A7", "#FFB5CA", "F5F0BA",
    "#99878D", "#323232", "#646464", "#7E4A5C", "372129",
    "#3FB8AF", "#7FC7AF", "#DAD8A7", "#FFB38B", "FF3F34",
    "#402B3C", "#6AA6A6", "#D9CCA7", "#F2B263", "F26835",
    "#6AA690", "#F2BC1B", "#F2DC99", "#F29057", "BF1F1F",
    "#F4FAC7", "#7BAD8D", "#FFB158", "#F77F45", "C2454E",
    "#E5533C", "#F5E346", "#93D06D", "#50AC6A", "227864",
    "#39588A", "#A9BDD7", "#FFFFFF", "#FFEADD", "FFD0BB",
    "#B0B595", "#615F4F", "#828567", "#91A380", "EAFFCD",
    "#00427F", "#0066BD", "#66B5CC", "#F0E4C5", "D6C28F",
    "#FF6313", "#F9E4B3", "#C29689", "#74474B", "45232E",
    "#00585F", "#009393", "#FFFCC4", "#C7C49B", "EB0A00",
    "#091840", "#44A2FF", "#F7F7EA", "#B3CC63", "4C6620",
    "#5CBBE3", "#FCF1BC", "#5C8182", "#383A47", "B4F257",
    "#9E9E9E", "#E5E1D1", "#E0393D", "#253746", "425563",
    "#4D9453", "#FFFFB1", "#ADDE4E", "#FF9D27", "A62A16",
    "#B70046", "#FF850B", "#FFEBC5", "#109679", "675A4C",
    "#363636", "#0599B0", "#A4BD0A", "#FFA615", "FF2E00",
    "#7D8077", "#BBBFB2", "#FAFFED", "#E82A33", "E3DEBC",
    "#FD9F44", "#FC5C65", "#007269", "#03A679", "FAF0B9",
    "#134B57", "#81A489", "#F1D8B5", "#F2A054", "C04D31",
    "#946E49", "#394042", "#EDDBAC", "#872A0C", "BA8E3A",
    "#404040", "#024959", "#037E8C", "#FFFFFF", "F24C27",
    "#2A3342", "#163C6E", "#4E5F61", "#E6A015", "EDE7BE",
    "#445060", "#829AB5", "#849E91", "#C14543", "D6D5D1",
    "#8A9126", "#B7BF5E", "#FFE9C4", "#F5B776", "F58E45",
    "#9B2D1E", "#3C3A28", "#78A080", "#9BCD9E", "FFFFAE",
    "#FF6138", "#FFFF9D", "#BEEB9F", "#79BD8F", "00A388",
    "#990000", "#FF6600", "#FF9900", "#996633", "CC9966",
    "#DCE6DA", "#B8CCBB", "#98B3A5", "#7A9994", "62858C",
    "#0B1C29", "#3B7C8F", "#73A5A3", "#98C1B7", "F0EBD2",
    "#F6CB51", "#E25942", "#13A89E", "#3F4953", "F2E7DA",
    "#282F36", "#FFFEFC", "#BDA21D", "#BFBC5B", "D2E098",
    "#8C182D", "#DE7140", "#FCB95A", "#FAE285", "6A7349",
    "#6B9100", "#FFE433", "#FF841F", "#E03D19", "A6001C",
    "#FFEAA7", "#D9D697", "#9FC49F", "#718C6A", "543122",
    "#CFF09E", "#A8DBA8", "#79BD9A", "#3B8686", "0B486B",
    "#0C2233", "#065471", "#0A91AB", "#FFC045", "F2F2F2",
    "#BEE8E0", "#373C40", "#2E2621", "#73320B", "FF5E00",
    "#1B2C35", "#A3BFC6", "#FF005D", "#222A30", "293A42",
    "#FF8400", "#3B4044", "#494948", "#E6E1D8", "F7F2E9",
    "#6A482D", "#518C86", "#F6BF3D", "#EF7C27", "BF2424",
    "#261C2B", "#292B39", "#226468", "#608D80", "829D8F",
    "#B2AD9A", "#110E00", "#363226", "#A9A695", "ECE9D8",
    "#1B1B26", "#26394D", "#286480", "#13B3BF", "A3FF57",
    "#F2C2A7", "#F5E5C5", "#593D28", "#422C21", "93DEDB",
    "#001028", "#033140", "#1E5A5B", "#7BA78C", "EBEDC6",
    "#544E6E", "#808CB0", "#ABD1D9", "#D9FFF7", "DDF556",
    "#323A45", "#596677", "#758194", "#FFFFFF", "E74C3C",
    "#45291A", "#AB926D", "#DBD1BC", "#4999C3", "5FCBEC",
    "#6B151D", "#2E1615", "#A8553A", "#DB8F5A", "F2C18E",
    "#000623", "#28475C", "#4A6C74", "#8BA693", "F0E3B1",
    "#60807B", "#81B37A", "#BCCC5F", "#FFEE65", "E64964",
    "#FFFFFA", "#A1A194", "#5B605F", "#464646", "FF6600",
    "#1E1B17", "#577270", "#9C9A79", "#C7BDA1", "580E0C",
    "#452F27", "#5E504A", "#6B6865", "#9BBAB2", "B0FFED",
    "#1B5257", "#F7F6C3", "#F28159", "#CC5850", "4F1C2E",
    "#FAA51B", "#BF511F", "#2C445E", "#2F6D82", "5EE4EB",
    "#BF3952", "#59364A", "#556D73", "#D9D1A9", "D95F5F",
    "#024959", "#037E8C", "#F2EFDC", "#E74C30", "363636",
    "#221A26", "#544759", "#A197A6", "#F27405", "D93D04",
    "#C4A44A", "#E6D399", "#9AB8A9", "#7C8A7F", "4E4B44",
    "#FFFEC8", "#B1BF99", "#5B604D", "#39382B", "26181E",
    "#4E3C51", "#21A68D", "#3BBF9A", "#F2E8B6", "F25749",
    "#102144", "#1B325E", "#254580", "#3C63B0", "5D8AEA",
    "#2A3A48", "#3E6372", "#B2D4DC", "#FAFAFF", "FF4B00",
    "#FFF1BF", "#F20058", "#FFAEAC", "#000001", "7D7A96",
    "#FDFFC6", "#F2F096", "#FF0080", "#DE0049", "521218",
    "#5B0E00", "#FBB500", "#FBD864", "#807D1A", "59233C",
    "#1E1E1F", "#424143", "#67666A", "#807F83", "CBC9CF",
    "#3C3658", "#3EC8B7", "#7CD0B4", "#B9D8B1", "F7E0AE",
    "#FFFFFF", "#99B75F", "#D5DD98", "#EBF4DB", "D8D8D8",
    "#248A8A", "#C9FA58", "#F9E555", "#FAAC38", "F2572A",
    "#086B63", "#77A490", "#E2D8C1", "#BFAE95", "7C7159",
    "#5C4B51", "#8CBEB2", "#F2EBBF", "#A5C88F", "EF847B",
    "#17162F", "#89346D", "#C76058", "#FFB248", "E8C475",
    "#6E8F4A", "#65D9C5", "#F2E7B6", "#EDA430", "AB3E2C",
    "#30394F", "#FF434C", "#6ACEEB", "#EDE8DF", "0E6569",
    "#8E1B13", "#F9E4B3", "#849689", "#46464A", "29232E",
    "#686B30", "#AB9A52", "#E8BA67", "#D68F4F", "BA512E",
    "#E54E45", "#DBC390", "#F2F2EF", "#13A3A5", "403833",
    "#65BA99", "#59A386", "#F1DDBB", "#D6C4A6", "E74C3C",
    "#A6FFBC", "#4ACFAF", "#00A995", "#006161", "003D4C",
    "#33271E", "#8B7653", "#C8D9A0", "#FDEE9D", "233331",
    "#048789", "#503D2E", "#D44D27", "#E2A72E", "EFEBC8",
    "#E5FF1E", "#A9D943", "#75A660", "#698070", "494D4B",
    "#2DEBA2", "#91F57F", "#EBAA69", "#E70049", "2B0027",
    "#990000", "#336699", "#DDDDDD", "#999999", "333333",
    "#F13A4B", "#3D3C3E", "#22BDAF", "#F4F4F4", "D7D7D7",
    "#F53A59", "#001D2D", "#15A88C", "#B7D9C8", "F3F5F4",];


};

Ops.Color.ColorPalettes.prototype = new CABLES.Op();
CABLES.OPS["31d33a1e-9a0a-49f7-8bc8-9e83ab71e23e"]={f:Ops.Color.ColorPalettes,objName:"Ops.Color.ColorPalettes"};




// **************************************************************
// 
// Ops.Color.HSBtoRGB
// 
// **************************************************************

Ops.Color.HSBtoRGB = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inH = op.inValueSlider("Hue"),
    inS = op.inValueSlider("Saturation", 1),
    inV = op.inValueSlider("Brightness", 0.5),
    outR = op.outNumber("R"),
    outG = op.outNumber("G"),
    outB = op.outNumber("B");

inH.onChange = inS.onChange = inV.onChange = update;
update();

function update()
{
    let hue = (inH.get());
    let saturation = (inS.get());
    let lightness = (inV.get());

    // based on algorithm from http://en.wikipedia.org/wiki/HSL_and_HSV#Converting_to_RGB

    let chroma = (1 - Math.abs((2 * lightness) - 1)) * saturation;
    let huePrime = hue * 6; // / 60;
    let secondComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));

    huePrime = Math.floor(huePrime) || 0;
    let red = 0;
    let green = 0;
    let blue = 0;

    if (huePrime === 0)
    {
        red = chroma;
        green = secondComponent;
        blue = 0;
    }
    else if (huePrime === 1)
    {
        red = secondComponent;
        green = chroma;
        blue = 0;
    }
    else if (huePrime === 2)
    {
        red = 0;
        green = chroma;
        blue = secondComponent;
    }
    else if (huePrime === 3)
    {
        red = 0;
        green = secondComponent;
        blue = chroma;
    }
    else if (huePrime === 4)
    {
        red = secondComponent;
        green = 0;
        blue = chroma;
    }
    else if (huePrime >= 5)
    {
        red = chroma;
        green = 0;
        blue = secondComponent;
    }
    let lightnessAdjustment = (lightness - (chroma / 2));
    red += lightnessAdjustment;
    green += lightnessAdjustment;
    blue += lightnessAdjustment;

    outR.set(red);
    outG.set(green);
    outB.set(blue);

    //   return [Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255)];
}


};

Ops.Color.HSBtoRGB.prototype = new CABLES.Op();
CABLES.OPS["909ee871-b0f3-477f-bee2-d0ab40bb5804"]={f:Ops.Color.HSBtoRGB,objName:"Ops.Color.HSBtoRGB"};




// **************************************************************
// 
// Ops.Color.HexToRGB_v2
// 
// **************************************************************

Ops.Color.HexToRGB_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    hex = op.inString("Hex", "#ff0000"),
    asBytes = op.inValueBool("Bytes"),
    outR = op.outNumber("R"),
    outG = op.outNumber("G"),
    outB = op.outNumber("B");

function hexToR(h)
{
    return parseInt((cutHex(h)).substring(0, 2), 16) || 0;
}
function hexToG(h)
{
    return parseInt((cutHex(h)).substring(2, 4), 16) || 0;
}
function hexToB(h)
{
    return parseInt((cutHex(h)).substring(4, 6), 16) || 0;
}
function cutHex(h)
{
    return (h.charAt(0) == "#") ? h.substring(1, 7) : h;
}

hex.onChange = parse;
asBytes.onChange = parse;

function parse()
{
    let str = hex.get() || "";
    let r = hexToR(str);
    let g = hexToG(str);
    let b = hexToB(str);

    if (!asBytes.get())
    {
        r /= 255;
        g /= 255;
        b /= 255;
    }

    outR.set(r);
    outB.set(b);
    outG.set(g);
}


};

Ops.Color.HexToRGB_v2.prototype = new CABLES.Op();
CABLES.OPS["9877f198-8dac-48e5-9310-244ef1a8dec5"]={f:Ops.Color.HexToRGB_v2,objName:"Ops.Color.HexToRGB_v2"};




// **************************************************************
// 
// Ops.Color.RGBtoHSB
// 
// **************************************************************

Ops.Color.RGBtoHSB = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inR = op.inValueSlider("R", 0),
    inG = op.inValueSlider("G", 0),
    inB = op.inValueSlider("B", 0),
    outH = op.outNumber("Hue"),
    outS = op.outNumber("Saturation"),
    outB = op.outNumber("Brightness");

inR.onChange = inG.onChange = inB.onChange = update;

/**
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and v in the set [0, 1].
 *
 * @param   Number  r       The red color value
 * @param   Number  g       The green color value
 * @param   Number  b       The blue color value
 * @return  Array           The HSV representation
 */

function update()
{
    let r = (inR.get());
    let g = (inG.get());
    let b = (inB.get());

    // public static float[] RGBtoHSB(var r, var g, var b, float[] hsbvals) {
    let hue, saturation, brightness;
    //   if (hsbvals == null) {
    //       hsbvals = [];
    //   }
    let cmax = (r > g) ? r : g;
    if (b > cmax) cmax = b;
    let cmin = (r < g) ? r : g;
    if (b < cmin) cmin = b;

    brightness = (cmax);
    if (cmax != 0)
        saturation = ((cmax - cmin)) / (cmax);
    else
        saturation = 0;
    if (saturation == 0)
        hue = 0;
    else
    {
        let redc = ((cmax - r)) / ((cmax - cmin));
        let greenc = ((cmax - g)) / ((cmax - cmin));
        let bluec = ((cmax - b)) / ((cmax - cmin));
        if (r == cmax)
            hue = bluec - greenc;
        else if (g == cmax)
            hue = 2.0 + redc - bluec;
        else
            hue = 4.0 + greenc - redc;
        hue /= 6.0;
        if (hue < 0)
            hue += 1.0;
    }

    //   hsbvals[0] = hue;
    //   hsbvals[1] = saturation;
    //   hsbvals[2] = brightness;
    //   return hsbvals;
    //   942       }
    // var max = Math.max(r, g, b), min = Math.min(r, g, b);
    // var h, s, v = max;

    // var d = max - min;
    // s = max == 0 ? 0 : d / max;

    // if (max == min) {
    //     h = 0; // achromatic
    // } else {
    //     switch (max) {
    //     case r: h = (g - b) / d + (g < b ? 6 : 0); break;
    //     case g: h = (b - r) / d + 2; break;
    //     case b: h = (r - g) / d + 4; break;
    //     }

    //     h /= 6;
    // }

    outH.set(hue);
    outS.set(saturation);
    outB.set(brightness / 2.0);
}

update();


};

Ops.Color.RGBtoHSB.prototype = new CABLES.Op();
CABLES.OPS["22dd3a12-79ff-49ce-abe6-d3b5a3b06ff3"]={f:Ops.Color.RGBtoHSB,objName:"Ops.Color.RGBtoHSB"};




// **************************************************************
// 
// Ops.Color.RgbToHex
// 
// **************************************************************

Ops.Color.RgbToHex = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    result=op.outString("Result");

r.setUiAttribs({ colorPick: true });

r.onChange=
g.onChange=
b.onChange=()=>
{

    const red=parseInt(r.get()*255);
    const green=parseInt(g.get()*255);
    const blue=parseInt(b.get()*255);

    result.set(((blue | green << 8 | red << 16) | 1 << 24).toString(16).slice(1));
};

};

Ops.Color.RgbToHex.prototype = new CABLES.Op();
CABLES.OPS["c0233dfa-ef4c-4451-b86e-3b2aadc8e9a5"]={f:Ops.Color.RgbToHex,objName:"Ops.Color.RgbToHex"};




// **************************************************************
// 
// Ops.Date.DateAndTime
// 
// **************************************************************

Ops.Date.DateAndTime = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let UPDATE_RATE_DEFAULT = 500;
let UPDATE_RATE_MIN = 50;
let updateRate = UPDATE_RATE_DEFAULT;

const
    outYear = op.outNumber("Year"),
    outMonth = op.outNumber("Month"),
    outDay = op.outNumber("Day"),
    outHours = op.outNumber("Hours"),
    outMinutes = op.outNumber("Minutes"),
    outSeconds = op.outNumber("Seconds"),
    outTimestemp = op.outNumber("Timestamp"),
    updateRatePort = op.inInt("Update Rate", UPDATE_RATE_DEFAULT);

let d = new Date();

let timeout = setTimeout(update, UPDATE_RATE_DEFAULT);
update();

function update()
{
    d = new Date();

    outSeconds.set(d.getSeconds());
    outMinutes.set(d.getMinutes());
    outHours.set(d.getHours());
    outDay.set(d.getDate());
    outMonth.set(d.getMonth());
    outYear.set(d.getFullYear());

    timeout = setTimeout(update, updateRate);

    outTimestemp.set(Date.now());
}

updateRatePort.onChange = function ()
{
    let newUpdateRate = updateRatePort.get();
    if (newUpdateRate && newUpdateRate >= UPDATE_RATE_MIN)
    {
        updateRate = newUpdateRate;
    }
};

op.onDelete = function ()
{
    clearTimeout(timeout);
};


};

Ops.Date.DateAndTime.prototype = new CABLES.Op();
CABLES.OPS["beff95ec-7b50-4b6e-80b8-a7e4ab97d8cc"]={f:Ops.Date.DateAndTime,objName:"Ops.Date.DateAndTime"};




// **************************************************************
// 
// Ops.Date.DateCalc
// 
// **************************************************************

Ops.Date.DateCalc = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTimestamp = op.inValue("timestamp"),
    inDiff = op.inInt("difference"),
    diffType = op.inDropDown("type", ["years", "months", "days", "hours", "minutes", "seconds"]),
    inTrigger = op.inTrigger("update"),

    outDate = op.outObject("Date"),
    outResult = op.outNumber("Timestamp");

inTimestamp.onChange =
    inDiff.onChange =
    diffType.onChange =
    inTrigger.onChange = update;

function update()
{
    let ts = inTimestamp.get();
    if (!inTimestamp.isLinked())
    {
        ts = Date.now();
    }
    const diff = inDiff.get();
    const date = new Date(ts);
    switch (diffType.get())
    {
    case "years":
        date.setYear(date.getYear() + diff);
        break;
    case "months":
        date.setMonth(date.getMonth() + diff);
        break;
    case "days":
        date.setDate(date.getDate() + diff);
        break;
    case "hours":
        date.setHours(date.getHours() + diff);
        break;
    case "minutes":
        date.setMinutes(date.getMinutes() + diff);
        break;
    case "seconds":
        date.setSeconds(date.getSeconds() + diff);
        break;

    default:
            // code
    }
    outResult.set(date.getTime());
    outDate.set(date);
}


};

Ops.Date.DateCalc.prototype = new CABLES.Op();
CABLES.OPS["1420b781-7b09-4102-b1fd-2cb841e57b95"]={f:Ops.Date.DateCalc,objName:"Ops.Date.DateCalc"};




// **************************************************************
// 
// Ops.Date.DateDifference
// 
// **************************************************************

Ops.Date.DateDifference = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    ts1 = op.inValue("Timestamp 1"),
    ts2 = op.inValue("Timestamp 2"),
    stopAtZero = op.inValueBool("Stop at 0"),
    outYear = op.outNumber("Year"),
    outMonth = op.outNumber("Month"),
    outDay = op.outNumber("Day"),
    outHours = op.outNumber("Hours"),
    outMinutes = op.outNumber("Minutes"),
    outSeconds = op.outNumber("Seconds"),
    outMilliSeconds = op.outNumber("Milliseconds"),
    outDiff = op.outNumber("Diff");

ts1.onChange = update;
ts2.onChange = update;

function update()
{
    let d = new Date(ts1.get() - ts2.get());
    outDiff.set(d.getTime());
    if (stopAtZero.get())
    {
        if (d.getTime() < 0)d = new Date(0);
    }

    outMilliSeconds.set(d.getMilliseconds());
    outSeconds.set(d.getSeconds());
    outMinutes.set(d.getMinutes());
    outHours.set(d.getHours() - 1);
    outDay.set(d.getDate() - 1);
    outMonth.set(d.getMonth());
    outYear.set(d.getFullYear() - 1970);
}


};

Ops.Date.DateDifference.prototype = new CABLES.Op();
CABLES.OPS["34cd865c-cc4d-4c58-afb2-626773eb412e"]={f:Ops.Date.DateDifference,objName:"Ops.Date.DateDifference"};




// **************************************************************
// 
// Ops.Date.DateFormatter
// 
// **************************************************************

Ops.Date.DateFormatter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inTimestamp = op.inValue("Timestamp");
const inDate = op.inObject("Date");
const inFormat = op.inString("Format", "YYYY-MM-DD");
const outString = op.outString("StringDate");

inTimestamp.onChange = function ()
{
    const ts = inTimestamp.get();
    update(new Date(ts));
};
inDate.onChange = function ()
{
    const date = inDate.get();
    update(date);
};
inFormat.onChange = function ()
{
    update(new Date());
};

function update(date)
{
    const m = moment(date);
    const f = inFormat.get();
    outString.set(m.format(f));
}


};

Ops.Date.DateFormatter.prototype = new CABLES.Op();
CABLES.OPS["8933d01f-39ac-428c-a64b-902c534a4fc0"]={f:Ops.Date.DateFormatter,objName:"Ops.Date.DateFormatter"};




// **************************************************************
// 
// Ops.Date.DateIsoToTimestamp
// 
// **************************************************************

Ops.Date.DateIsoToTimestamp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const date = op.inString("datetime");
const timestamp = op.outNumber("timestamp");

date.onChange = function() {
  const parsed = Date.parse(date.get());
  timestamp.set(parsed);
}

};

Ops.Date.DateIsoToTimestamp.prototype = new CABLES.Op();
CABLES.OPS["cedf9c37-f864-4416-9675-ecc15f07025d"]={f:Ops.Date.DateIsoToTimestamp,objName:"Ops.Date.DateIsoToTimestamp"};




// **************************************************************
// 
// Ops.Date.DateTimestamp
// 
// **************************************************************

Ops.Date.DateTimestamp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inYear = op.inValueInt("Year"),
    inMonth = op.inValueInt("Month"),
    inDay = op.inValueInt("Day"),
    inHour = op.inValueInt("Hour"),
    inMinute = op.inValueInt("Minute"),
    outTimestamp = op.outNumber("Timestamp");

inYear.onChange =
inMonth.onChange =
inDay.onChange =
inHour.onChange =
inMinute.onChange = setDate;

function setDate()
{
    const d = new Date();

    const datum = new Date(Date.UTC(
        inYear.get(),
        inMonth.get() - 1,
        inDay.get(),
        inHour.get(),
        inMinute.get()
    ) + d.getTimezoneOffset() * 60 * 1000);

    outTimestamp.set(datum.getTime());
}


};

Ops.Date.DateTimestamp.prototype = new CABLES.Op();
CABLES.OPS["e86a668b-db87-472e-9484-3fd102ccbf8a"]={f:Ops.Date.DateTimestamp,objName:"Ops.Date.DateTimestamp"};




// **************************************************************
// 
// Ops.Debug.Console
// 
// **************************************************************

Ops.Debug.Console = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    visible = op.inValueBool("visible", true),
    inClear = op.inTriggerButton("Clear"),
    outEle = op.outObject("Element", null, "element");

let eleLog = null;
let canvas = op.patch.cgl.canvas.parentElement;

let oldLog = console.log;
let oldLogError = console.error;
let oldLogWarn = console.warn;

console.log = thelog;
console.error = thelog;
console.warn = thelog;

addElement();

op.onDelete = function ()
{
    removeElement();
    console.log = oldLog;
    console.error = oldLogError;
    console.warn = oldLogWarn;
};

visible.onChange = function ()
{
    if (visible.get()) eleLog.style.display = "block";
    else eleLog.style.display = "none";
};

function addElement()
{
    if (eleLog)removeElement();
    eleLog = document.createElement("div");
    eleLog.style.padding = "0px";
    eleLog.style.position = "absolute";
    eleLog.style.overflow = "scroll";
    if (CABLES.UI)
    {
        eleLog.style.width = "100%";
        eleLog.style.height = "50%";
    }
    else
    {
        eleLog.style.width = "100vw";
        eleLog.style.height = "50vh";
    }
    eleLog.style["background-color"] = "rgba(0,0,0,0.74)";
    eleLog.style["box-sizing"] = "border-box";
    eleLog.style.padding = "5px";
    eleLog.style["z-index"] = "9999";
    eleLog.style.color = "#fff";

    canvas.appendChild(eleLog);
}

function removeElement()
{
    canvas.removeChild(eleLog);
    eleLog = null;
}

function thelog()
{
    if (!eleLog)addElement();
    oldLog.apply(console, arguments);

    try
    {
        let html = "<code style=\"display:block;overflow:hidden;margin-top:3px;border-bottom:1px solid #000;padding:3px;\">";
        for (let i = 0; i < arguments.length; i++)
        {
            if (typeof arguments[i] == "object") html += (JSON && JSON.stringify ? JSON.stringify(arguments[i], undefined, 2) : arguments[i]) + " ";
            else html += arguments[i] + " ";
        }
        eleLog.innerHTML += html + "</code>";
    }
    catch (e) {}
    eleLog.scrollTop = eleLog.scrollHeight;
}

inClear.onTriggered = () =>
{
    eleLog.innerHTML = "";
};


};

Ops.Debug.Console.prototype = new CABLES.Op();
CABLES.OPS["1e650a0b-672f-4dca-bcf0-5df281a2d31e"]={f:Ops.Debug.Console,objName:"Ops.Debug.Console"};




// **************************************************************
// 
// Ops.Debug.ConsoleLog
// 
// **************************************************************

Ops.Debug.ConsoleLog = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNumber=op.inFloat("Number",0),
    inString=op.inString("String","");


inNumber.onChange=function()
{
    console.log(inNumber.get());
};

inString.onChange=function()
{
    console.log(inString.get());
};

};

Ops.Debug.ConsoleLog.prototype = new CABLES.Op();
CABLES.OPS["545e7225-73b0-4d40-923b-4b39940403a8"]={f:Ops.Debug.ConsoleLog,objName:"Ops.Debug.ConsoleLog"};




// **************************************************************
// 
// Ops.Debug.GlLogErrors
// 
// **************************************************************

Ops.Debug.GlLogErrors = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Exec"),
    inLimit = op.inInt("Limit Error Logs Num", 1),
    inStop = op.inBool("Stop trigger after limit", false),
    inShowHistory = op.inTriggerButton("show gl history"),
    next = op.outTrigger("Next");

const gl = op.patch.cgl.gl;
const cgl = op.patch.cgl;

const originals = {};
let shouldStart = true;
let count = 0;
let errorCount = 0;
let history = [];
let countFrames = 0;

exec.onLinkChanged =
next.onLinkChanged = () =>
{
    end();
    shouldStart = true;
};


let showHistory = false;

inShowHistory.onTriggered = () =>
{
    showHistory = true;
};

let glConsts = {};

for (let i in op.patch.cgl.gl)
{
    if (i == i.toUpperCase() && typeof op.patch.cgl.gl[i] == "number")
    {
        glConsts[op.patch.cgl.gl[i]] = i;
    }
}

function showCodeModal(title, code, type)
{
    if (!CABLES.UI || !CABLES.UI.ModalDialog)
    {
        console.log(title, code);
    }

    let html = "";
    html += "<h2>Code</h2>";
    html += "<b>" + title + "</b> ";
    html += "<br/><br/>";
    html += "<br/><br/>";

    code = code || "";
    code = code.replace(/\</g, "&lt;"); // for <
    code = code.replace(/\>/g, "&gt;"); // for >

    html += "<pre><code class=\"" + (type || "javascript") + "\">" + code + "</code></pre>";

    new CABLES.UI.ModalDialog({
        "title": title,
        "html": html
    });

    Array.from(document.querySelectorAll("pre code")).forEach(function (block)
    {
        hljs.highlightBlock(block);
    });
}

exec.onTriggered = function ()
{
    count = 0;
    if (shouldStart) start();

    if (errorCount >= inLimit.get() && inStop.get()) return;

    next.trigger();

    countFrames++;
    shouldStart = false;

    if (showHistory)
    {
        if (CABLES.UI) showCodeModal("gl history", getHistoryAsString(), "javascript");

        showHistory = false;
    }
    history.length = 0;
};

function glGetError()
{
    return op.patch.cgl.gl.getError();
    // return originals["getError"].apply(this, arguments);
}

function getHistoryString(i)
{
    let str = history[i].f + "( ";
    for (let j in history[i].a)
    {
        if (j != 0)str += ", ";

        const typ = typeof history[i].a[j];

        if (typ == "number" || typ == "boolean")
        {
            let argStr = history[i].a[j];

            if (glConsts[history[i].a[j]]) argStr = "gl." + glConsts[history[i].a[j]];
            str += argStr;
        }
        else if (typ == "string")
        {
            let argStr = history[i].a[j] + "";
            if (argStr.length > 20)argStr = argStr.substr(0, 20) + "...\"";
            argStr = argStr.replace(/(\r\n|\n|\r)/gm, "");

            str += "\"" + argStr + "\"";
        }
        else
        {
            let argStr = "";
            if (history[i].a[j] instanceof Float32Array) argStr = "{Float32Array(" + history[i].a[j].length + ")}";
            else if (history[i].a[j] instanceof Uint16Array) argStr = "{Uint16Array(" + history[i].a[j].length + ")}";
            else if (history[i].a[j] instanceof Uint8Array) argStr = "{Uint8Array(" + history[i].a[j].length + ")}";
            else argStr = JSON.stringify(history[i].a[j]) + "";

            if (argStr == "{}") argStr = history[i].a[j];

            if (argStr.length > 20)argStr = argStr.substr(0, 20) + "...";
            str += argStr;
        }
    }
    str += " );";
    return str;
}

function getHistoryAsString()
{
    let str = "";
    for (let i = 0; i < history.length; i++)
    {
        str += "gl." + getHistoryString(i) + "\n";
    }
    return str;
}

function profile(func, funcName)
{
    return function ()
    {
        if (errorCount >= inLimit.get()) return;

        count++;
        // const start = performance.now(),
        let returnVal = func.apply(this, arguments);

        history.push({ "f": funcName, "a": arguments });

        // op.patch.cgl.gl.getError();
        const error = glGetError();

        if (error != gl.NO_ERROR)
        {
            let errStr = "";
            if (error == gl.OUT_OF_MEMORY) errStr = "OUT_OF_MEMORY";
            if (error == gl.INVALID_ENUM) errStr = "INVALID_ENUM";
            if (error == gl.INVALID_OPERATION) errStr = "INVALID_OPERATION";
            if (error == gl.INVALID_FRAMEBUFFER_OPERATION) errStr = "INVALID_FRAMEBUFFER_OPERATION";
            if (error == gl.INVALID_VALUE) errStr = "INVALID_VALUE";
            if (error == gl.CONTEXT_LOST_WEBGL)
            {
                this.aborted = true;
                errStr = "CONTEXT_LOST_WEBGL";
            }
            if (error == gl.NO_ERROR) errStr = "NO_ERROR";

            console.warn("GL ERROR in frame " + countFrames + ", " + count + "th command: ", funcName);
            console.log("arguments", arguments);

            console.log("gl error [" + this.canvas.id + "]: ", error, errStr);
            op.patch.printTriggerStack();
            console.log((new Error()).stack);

            op.patch.printTriggerStack();
            if (errorCount == 0)
            {
                for (let i = 0; i < history.length; i++)
                {
                    let str = getHistoryString(i);
                    console.log("[GL] " + i + ": gl." + str);
                }
            }

            const error2 = glGetError();
            console.log("err after", error2);
            errorCount++;

            if (errorCount == inLimit.get()) console.log("gl Errors stopping after " + inLimit.get() + " errors");
        }

        return returnVal;
    };
}

function start()
{
    for (const i in gl)
    {
        if (typeof gl[i] == "function" && i != "getError")
        {
            originals[i] = gl[i];
            const orig = originals[i];

            gl[i] = profile(gl[i], "" + i);
        }
    }
}

function end()
{
    cgl.debugOneFrame = false;
    for (const i in gl)
        if (originals[i] && typeof gl[i] == "function")
            gl[i] = originals[i];
}


};

Ops.Debug.GlLogErrors.prototype = new CABLES.Op();
CABLES.OPS["26be55ca-23c0-4f22-bdea-0fd4c63b2067"]={f:Ops.Debug.GlLogErrors,objName:"Ops.Debug.GlLogErrors"};




// **************************************************************
// 
// Ops.Debug.GlStates
// 
// **************************************************************

Ops.Debug.GlStates = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;

const
    exec = op.inTrigger("Update"),
    next = op.outTrigger("Next"),

    outError = op.outBoolNum("glGetError"),

    depth = op.outBoolNum("Depthtest"),
    depthStack = op.outBoolNum("Stack Depthtest"),

    depthWrite = op.outBoolNum("Depth Writing"),
    depthWriteStack = op.outBoolNum("Stack Depth Writing"),

    depthFunc = op.outBoolNum("DepthFunc"),
    depthFuncStack = op.outBoolNum("Stack DepthFunc"),

    blend = op.outBoolNum("Blend"),
    blendStack = op.outBoolNum("Blend Stack"),

    cull = op.outBoolNum("Cull Mode"),
    culling = op.outBoolNum("Face Culling"),
    isShadowPass = op.outBool("Is Shadowpass");

exec.onTriggered = function ()
{
    depth.set(cgl.gl.isEnabled(cgl.gl.DEPTH_TEST));
    depthStack.set(cgl.stateDepthTest());

    depthWrite.set(cgl.gl.getParameter(cgl.gl.DEPTH_WRITEMASK));
    depthWriteStack.set(cgl.stateDepthWrite());

    depthFunc.set(depthFuncToString(cgl.gl.getParameter(cgl.gl.DEPTH_FUNC)));
    depthFuncStack.set(depthFuncToString(cgl.stateDepthFunc()));

    blend.set(cgl.gl.isEnabled(cgl.gl.BLEND));
    blendStack.set(cgl.stateBlend());

    culling.set(cgl.gl.isEnabled(cgl.gl.CULL_FACE));

    cull.set(cullModeToString(cgl.gl.getParameter(cgl.gl.CULL_FACE_MODE)));

    outError.set(errorToString(cgl.gl.getError()));
    isShadowPass.set(cgl.frameStore.shadowPass);

    op.log(cgl._textureslots);
    next.trigger();
};

function errorToString(e)
{
    if (e == cgl.gl.NO_ERROR) return "NO_ERROR";
    if (e == cgl.gl.OUT_OF_MEMORY) return "OUT_OF_MEMORY";
    if (e == cgl.gl.INVALID_ENUM) return "INVALID_ENUM";
    if (e == cgl.gl.INVALID_OPERATION) return "INVALID_OPERATION";
    if (e == cgl.gl.INVALID_FRAMEBUFFER_OPERATION) return "INVALID_FRAMEBUFFER_OPERATION";
    if (e == cgl.gl.INVALID_VALUE) return "INVALID_VALUE";
    if (e == cgl.gl.CONTEXT_LOST_WEBGL) return "CONTEXT_LOST_WEBGL";
}

function cullModeToString(c)
{
    if (c == cgl.gl.FRONT) return "FRONT";
    if (c == cgl.gl.BACK) return "BACK";
    if (c == cgl.gl.FRONT_AND_BACK) return "FRONT_AND_BACK";
}

function depthFuncToString(f)
{
    if (f == cgl.gl.NEVER) return "NEVER";
    if (f == cgl.gl.LESS) return "LESS";
    if (f == cgl.gl.EQUAL) return "EQUAL";
    if (f == cgl.gl.LEQUAL) return "LEQUAL";
    if (f == cgl.gl.GREATER) return "GREATER";
    if (f == cgl.gl.NOTEQUAL) return "NOTEQUAL";
    if (f == cgl.gl.GEQUAL) return "GEQUAL";
    if (f == cgl.gl.ALWAYS) return "ALWAYS";
}


};

Ops.Debug.GlStates.prototype = new CABLES.Op();
CABLES.OPS["3e2bc72c-8af4-4fdb-a998-555aaf62cc9d"]={f:Ops.Debug.GlStates,objName:"Ops.Debug.GlStates"};




// **************************************************************
// 
// Ops.Debug.ProfileGL
// 
// **************************************************************

Ops.Debug.ProfileGL = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exec = op.inTrigger("Exec");
const next = op.outTrigger("Next");
const dump = op.inTriggerButton("Debug one Frame");

const gl = op.patch.cgl.gl;
const cgl = op.patch.cgl;

const originals = {};
const counts = {};
const durations = {};
let branches = {};
let dumpFrame = false;

const started = false;

// const query = null;
// const ext = gl.getExtension("EXT_disjoint_timer_query_webgl2");

exec.onTriggered = function ()
{
    if (dumpFrame)
    {
        start();
        resetStats();
    }

    next.trigger();

    if (dumpFrame)
    {
        end();
        const rows = [];
        let numGlCalls = 0;
        for (const i in originals)
            if (counts[i] > 0)
            {
                rows.push([i, counts[i], durations[i]]);
                numGlCalls += counts[i];
            }

        console.table(rows);

        const rowsBranches = [];
        for (const i in branches)
        {
            let count = 0;
            for (const j in branches[i].counts) count += branches[i].counts[j];

            op.log("branch", i, branches[i].counts);
            rowsBranches.push([i, count, Math.round(count / numGlCalls * 100) + "%"]);
        }
        console.table(rowsBranches);

        op.log(CABLES.profilerBranchesTimes);

        resetStats();
        dumpFrame = false;
    }
};

function profile(func, funcName)
{
    return function ()
    {
        const start = performance.now(),
            returnVal = func.apply(this, arguments),
            duration = performance.now() - start;

        if (CABLES.profilerBranches && CABLES.profilerBranches.length > 0)
        {
            let branchName = CABLES.profilerBranches.join(" / ");
            if (CABLES.profilerBranches.length == 0)branchName = "_unknown";
            branches[branchName] = branches[branchName] || {};
            branches[branchName].counts = branches[branchName].counts || {};
            branches[branchName].counts[funcName] = branches[branchName].counts[funcName] || 0;
            branches[branchName].counts[funcName]++;
        }

        durations[funcName] += duration;
        counts[funcName]++;
        return returnVal;
    };
}

function resetStats()
{
    branches = {};
    CABLES.profilerBranchesTimes = {};

    for (const i in originals)
    {
        durations[i] = 0;
        counts[i] = 0;
    }
}

function start()
{
    op.log("-----------------------------");
    cgl.debugOneFrame = true;
    for (const i in gl)
    {
        if (typeof gl[i] == "function")
        {
            originals[i] = gl[i];
            const orig = originals[i];

            gl[i] = profile(gl[i], "" + i);
        }
    }
}

function end()
{
    cgl.debugOneFrame = false;
    for (const i in gl)
        if (typeof gl[i] == "function")
            gl[i] = originals[i];
}

dump.onTriggered = function ()
{
    dumpFrame = true;
};


};

Ops.Debug.ProfileGL.prototype = new CABLES.Op();
CABLES.OPS["498a7c04-a1df-4318-8a60-048a7836710e"]={f:Ops.Debug.ProfileGL,objName:"Ops.Debug.ProfileGL"};




// **************************************************************
// 
// Ops.Debug.StopWatch
// 
// **************************************************************

Ops.Debug.StopWatch = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("exec"),
    next = op.outTrigger("next"),
    timeUsed = op.outNumber("Time used"),
    outTImes = op.outArray("Times");

let times = [];
times.length = 100;
for (let i = 0; i < times.length; i++)
{
    times[i] = 0;
}

let count = 0;
outTImes.set(times);

exec.onTriggered = function ()
{
    let start = performance.now();
    next.trigger();
    let end = performance.now();

    let l = end - start;
    times[count] = l;
    count++;
    if (count >= 100)count = 0;

    timeUsed.set(l);
    outTImes.set(null);
    outTImes.set(times);
};


};

Ops.Debug.StopWatch.prototype = new CABLES.Op();
CABLES.OPS["5dd205e6-b475-4a3b-9a3b-d242847f4b81"]={f:Ops.Debug.StopWatch,objName:"Ops.Debug.StopWatch"};




// **************************************************************
// 
// Ops.Debug.Trace
// 
// **************************************************************

Ops.Debug.Trace = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

const exePort = op.inTriggerButton("Trace");

exePort.onTriggered = console.trace;


};

Ops.Debug.Trace.prototype = new CABLES.Op();
CABLES.OPS["1b52e2b7-b3a4-400e-9a97-1b27ce80deed"]={f:Ops.Debug.Trace,objName:"Ops.Debug.Trace"};




// **************************************************************
// 
// Ops.Dev.Array.ArraySpreadSheet
// 
// **************************************************************

Ops.Dev.Array.ArraySpreadSheet = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    spread = op.inArray("Spreadsheet"),
    inNumColumns = op.inInt("Num Columns", 3),
    outp = op.inSwitch("Format", ["Flat", "Objects", "Arrays"], "Flat"),
    result = op.outArray("Array"),
    outColNames = op.outArray("Column Names");

// spread.hidePort();
spread.setUiAttribs({ "hidePort": true });
inNumColumns.setUiAttribs({ "hidePort": true });
outp.setUiAttribs({ "hidePort": true });
// inNumColumns.hidePort();

outp.onChange =
spread.onChange = update;

inNumColumns.onChange = updateUi;
updateUi();

function updateUi()
{
    spread.setUiAttribs({
        "display": "spreadsheet",
        "spread_numColumns": inNumColumns.get()
    });
}

function update()
{
    result.set(null);

    if (!spread.get()) return;

    outColNames.set(spread.get().colNames);

    if (outp.get() == "Flat")
    {
        result.set(asFlat());
    }
    else if (outp.get() == "Objects" || outp.get() == "Arrays")
    {
        result.set(asObjectArray(outp.get() == "Objects"));
    }
}

function asFlat()
{
    const data = spread.get();
    data.cells = data.cells || [];

    if (!data.cols) return;

    const arr = [];
    arr.length = data.cells.length * data.cols || 1;
    let lastRow = 0;
    for (let y = 0; y < data.cells.length; y++)
    {
        if (data.cells[y])
            for (let x = 0; x < data.cells[0].length; x++)
            {
                let v = data.cells[y][x] || null;
                if (CABLES.UTILS.isNumeric(v)) v = parseFloat(v);
                if (v !== "" && v !== null) lastRow = y;

                arr[x + (y * data.cols)] = v;
            }
    }

    let arrSize = (lastRow + 1) * data.cols;

    arr.length = arrSize;

    return arr;
}

function asObjectArray(objects)
{
    const data = spread.get() || {};
    data.cells = data.cells || [];

    const arr = [];
    arr.length = data.cells.length;
    let lastRow = 0;
    for (let y = 0; y < data.cells.length; y++)
    {
        let o = [];
        if (objects) o = {};
        arr[y] = o;

        if (data.cells[y])
            for (let x = 0; x < data.cols; x++)
            {
                let v = data.cells[y][x] || null;
                if (CABLES.UTILS.isNumeric(v)) v = parseFloat(v);
                if (v !== "" && v !== null) lastRow = y;

                if (objects) o[getColName(data, x)] = v;
                else o[x] = v;
            }
    }
    arr.length = lastRow + 1;

    return arr;
}

function getColName(data, c)
{
    if (data && data.colNames && data.colNames.length > c && data.colNames[c])
    {
        return data.colNames[c];
    }

    let str = "";

    while (c >= 0)
    {
        str = "abcdefghijklmnopqrstuvwxyz"[c % 26] + str;
        c = Math.floor(c / 26) - 1;
    }

    return str;
}


};

Ops.Dev.Array.ArraySpreadSheet.prototype = new CABLES.Op();
CABLES.OPS["e8f8f23c-e7d3-44bf-9f1f-86230f4e533a"]={f:Ops.Dev.Array.ArraySpreadSheet,objName:"Ops.Dev.Array.ArraySpreadSheet"};




// **************************************************************
// 
// Ops.Dev.Blueprint
// 
// **************************************************************

Ops.Dev.Blueprint = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const patchIdIn = op.inString("externalPatchId", "");
const subPatchIdIn = op.inString("subPatchId", "");
const activeIn = op.inBool("active", false);
const gotoIn = op.inTriggerButton("Open patch");
const resolveIn = op.inTriggerButton("Convert to SubPatch");
const portsData = op.inString("portsData", "{}");

const loadingOut = op.outBool("loading", false);
let loadingId = null;
patchIdIn.setUiAttribs({ "hidePort": true, "greyout": true });
subPatchIdIn.setUiAttribs({ "hidePort": true, "greyout": true });
portsData.setUiAttribs({ "hidePort": true });
portsData.setUiAttribs({ "hideParam": true });

gotoIn.setUiAttribs({ "greyout": true });
gotoIn.setUiAttribs({ "hidePort": true });

resolveIn.setUiAttribs({ "greyout": true });
resolveIn.setUiAttribs({ "hidePort": true });

let wasPasted = false;

subPatchIdIn.onChange = () =>
{
    if (!activeIn.get())
    {
        op.setUiError("fetchOps", null);
    }
    if (!loadingOut.get() && activeIn.get() && patchIdIn.get() && subPatchIdIn.get())
    {
        update();
    }
};

if (op.patch.isEditorMode())
{
    gotoIn.onTriggered = function ()
    {
        if (CABLES && CABLES.sandbox && CABLES.sandbox.getCablesUrl())
        {
            window.open(CABLES.sandbox.getCablesUrl() + "/edit/" + patchIdIn.get(), "_blank");
        }
    };

    resolveIn.onTriggered = () =>
    {
        if (CABLES && CABLES.CMD && CABLES.CMD.PATCH)
        {
            CABLES.CMD.PATCH.convertBlueprintToSubpatch(this);
        }
    };

    patchIdIn.onChange = function ()
    {
        if (patchIdIn.get())
        {
            gotoIn.setUiAttribs({ "greyout": false });
            if (!activeIn.get())
            {
                op.setUiError("fetchOps", null);
            }
            if (!loadingOut.get() && activeIn.get() && subPatchIdIn.get())
            {
                update();
            }
        }
        else
        {
            gotoIn.setUiAttribs({ "greyout": true });
        }
    };
}

const protectedPorts = [patchIdIn.id, subPatchIdIn.id, activeIn.id, portsData.id, loadingOut.id, gotoIn.id, resolveIn.id];

if (!activeIn.get())
{
    op.setUiError("inactive", "blueprint is inactive", 0);
}

const restorePorts = () =>
{
    const oldPorts = getOldPorts();
    const portInKeys = Object.keys(oldPorts.portsIn);
    if (op.patch.isEditorMode()) CABLES.UI.undo.pause();
    const newPorts = [];
    for (let i = 0; i < portInKeys.length; i++)
    {
        const oldPortIn = oldPorts.portsIn[portInKeys[i]];
        const newPort = op.addInPort(new CABLES.Port(op, oldPortIn.name, oldPortIn.type));
        if (!wasPasted && Array.isArray(oldPortIn.links))
        {
            oldPortIn.links.forEach((link) =>
            {
                let parent = op.patch.getOpById(link.objOut);
                if (parent)
                {
                    const newLink = op.patch.link(parent, link.portOut, op, newPort.name);
                    if (newLink) newLink.ignoreInSerialize = true;
                }
                else
                {
                    parent = op.patch.ops.find((subOp) =>
                    {
                        return subOp.storage &&
                        subOp.storage.blueprint &&
                        subOp.storage.blueprint.originalOpId == link.objOut &&
                        op.storage &&
                        op.storage.blueprint &&
                        subOp.storage.blueprint.blueprintOpId == op.storage.blueprint.blueprintOpId;
                    });
                    if (parent)
                    {
                        const newLink = op.patch.link(parent, link.portOut, op, newPort.name);
                        if (newLink) newLink.ignoreInSerialize = true;
                    }
                }
            });
        }
        if (!newPort.isLinked())
        {
            newPort.set(oldPortIn.value);
        }
        newPort.onLinkChanged = savePortData;

        if (oldPortIn.title)
        {
            newPort.setUiAttribs({ "title": oldPortIn.title });
        }
        newPorts.push(newPort);
    }
    op.setPortGroup("Blueprint Ports", newPorts);

    const portOutKeys = Object.keys(oldPorts.portsOut);
    for (let i = 0; i < portOutKeys.length; i++)
    {
        const oldPortOut = oldPorts.portsOut[portOutKeys[i]];
        const newPort = op.addOutPort(new CABLES.Port(op, oldPortOut.name, oldPortOut.type));
        if (!wasPasted && Array.isArray(oldPortOut.links))
        {
            oldPortOut.links.forEach((link) =>
            {
                let parent = op.patch.getOpById(link.objIn);
                if (parent)
                {
                    const newLink = op.patch.link(op, newPort.name, parent, link.portIn);
                    if (newLink) newLink.ignoreInSerialize = true;
                }
                else
                {
                    parent = op.patch.ops.find((subOp) =>
                    {
                        return subOp.storage &&
                        subOp.storage.blueprint &&
                            subOp.storage.blueprint.originalOpId == link.objIn &&
                            op.storage &&
                            op.storage.blueprint &&
                            subOp.storage.blueprint.blueprintOpId == op.storage.blueprint.blueprintOpId;
                    });
                    if (parent)
                    {
                        const newLink = op.patch.link(op, newPort.name, parent, link.portIn);
                        if (newLink) newLink.ignoreInSerialize = true;
                    }
                }
            });
            newPort.onLinkChanged = savePortData;

            if (oldPortOut.title)
            {
                newPort.setUiAttribs({ "title": oldPortOut.title });
            }
        }
    }
    if (op.patch.isEditorMode()) CABLES.UI.undo.resume();
};

activeIn.onChange = () =>
{
    if (!loadingOut.get())
    {
        if (activeIn.get())
        {
            op.setUiError("inactive", null);
            update();
        }
        else
        {
            op.setUiError("fetchOps", null);
            op.setUiError("inactive", "blueprint is inactive", 0);
            removeImportedOps();
            if (wasPasted) wasPasted = false;
        }
    }
};

op.onLoaded = () =>
{
    if (op.uiAttribs)
    {
        wasPasted = op.uiAttribs.pasted;
    }
    cleanupPorts();
    restorePorts();
};

op.onDelete = removeImportedOps;

function update()
{
    loadingOut.set(true);
    const patch = op.patch;
    const patchId = patchIdIn.get();
    const subPatchId = subPatchIdIn.get();
    const blueprintId = patchId + "-" + subPatchId;

    loadingId = op.patch.loading.start("blueprint", blueprintId);

    if (patch.isEditorMode())
    {
        const options = {
            "blueprintId": blueprintId,
            "patchId": patchId,
            "subPatchId": subPatchId,
            "opId": op.id,
            "blueprintSubpatchId": op.uiAttribs.subPatch
        };

        CABLES.sandbox.getBlueprintOps(options, (err, response) =>
        {
            op.setUiError("fetchOps", null);
            if (!err)
            {
                removeImportedOps();
                const blueprintData = {};
                blueprintData.ops = response.data.ops;
                blueprintData.settings = op.patch.settings;
                deSerializeBlueprint(blueprintData, subPatchId, true);
            }
            else
            {
                if (err.code === 403)
                {
                    op.setUiError("fetchOps", "You do not have permission to use this Blueprint");
                }
                else if (err.code === 404 && (gui.patchId === patchId))
                {
                    op.setUiError("fetchOps", "Save the patch and reload before using this Blueprint");
                }
                else
                {
                    op.setUiError("fetchOps", "Error fetching Blueprint, code: " + err.code + " (" + err.msg + ")");
                }
            }
            loadingOut.set(false);
            op.patch.loading.finished(loadingId);
            if (wasPasted)
            {
                wasPasted = false;
            }
        });
    }
    else if (CABLES.talkerAPI)
    {
        // use this to workaround /viewer/ and /p/ not being "isEditorMode" but also not having exported assets
        const callbackTalkerApi = (options, next) =>
        {
            if (options.blueprint && options.blueprint.data.blueprintOpId === op.id)
            {
                const blueprintData = options.blueprint;
                blueprintData.settings = op.patch.settings;
                blueprintData.ops = blueprintData.data.ops;
                deSerializeBlueprint(blueprintData, subPatchId, false);
                loadingOut.set(false);
                op.patch.loading.finished(loadingId);
                if (wasPasted)
                {
                    wasPasted = false;
                }
                CABLES.talkerAPI.removeEventListener(callbackTalkerApi);
            }
        };
        CABLES.talkerAPI.addEventListener("blueprint", callbackTalkerApi);
        CABLES.talkerAPI.send("sendBlueprint", { "url": "/" + blueprintId + "/" + patchId + "/" + subPatchId + "/" + op.id + "/" + op.uiAttribs.subPatch });
    }
    else
    {
        let exportId = op.id;
        if (CABLES.blueprints && CABLES.blueprints[exportId])
        {
            const blueprintData = CABLES.blueprints[exportId];
            blueprintData.settings = op.patch.settings;
            // for some reason we have to do this in a 0ms timeout to make
            // sure nested blueprints are not loaded before this one created all the ops...
            setTimeout(() =>
            {
                deSerializeBlueprint(blueprintData, subPatchId, false);
                loadingOut.set(false);
                op.patch.loading.finished(loadingId);
                if (wasPasted)
                {
                    wasPasted = false;
                }
            }, 0);
        }
        else
        {
            const blueprintUrl = op.patch.config.prefixJsPath + op.patch.getJsPath() + exportId + ".json";
            CABLES.ajax(
                blueprintUrl,
                function (err, data)
                {
                    if (!err)
                    {
                        const blueprintData = JSON.parse(data);
                        blueprintData.settings = op.patch.settings;
                        deSerializeBlueprint(blueprintData, subPatchId, false);
                    }
                    else
                    {
                        op.logError("failed to load blueprint from", blueprintUrl, err);
                    }
                    loadingOut.set(false);
                    op.patch.loading.finished(loadingId);
                    if (wasPasted)
                    {
                        wasPasted = false;
                    }
                }
            );
        }
    }
}

function deSerializeBlueprint(data, subPatchId, editorMode)
{
    resolveIn.setUiAttribs({ "greyout": true });
    if (Array.isArray(data.ops) && data.ops.length > 0)
    {
        let listenerId;
        const cb = () =>
        {
            const parentSubPatch = op.patch.ops.find((subOp) =>
            {
                return subOp.storage &&
                subOp.storage.blueprint &&
                subOp.storage.blueprint.isParentSubPatch &&
                subOp.storage.blueprint.blueprintOpId == op.id;
            }
            );
            if (parentSubPatch)
            {
                op.setUiAttrib({ "extendTitle": parentSubPatch.uiAttribs.title });
                setupPorts(parentSubPatch);
            }
            op.patch.removeEventListener(listenerId);
            if (editorMode)
            {
                CABLES.UI.undo.resume();
                if (originalSaveState === true)
                {
                    gui.setStateSaved();
                }
                resolveIn.setUiAttribs({ "greyout": false });
            }
        };

        let originalSaveState = null;
        if (editorMode)
        {
            originalSaveState = gui.getSavedState();
            CABLES.UI.undo.pause();

            gui.serverOps.loadProjectDependencies(data, () =>
            {
                listenerId = op.patch.addEventListener("patchLoadEnd", cb);
                data.settings = op.patch.settings;
                data.namespace = op.patch.namespace;
                data.name = op.patch.name;
                op.patch.deSerialize(data, false);
                const originalSubPatchId = gui.patchView.getCurrentSubPatch();
                gui.patchView.setCurrentSubPatch(originalSubPatchId);
            });
        }
        else
        {
            listenerId = op.patch.addEventListener("patchLoadEnd", cb);
            op.patch.deSerialize(data, false);
        }
    }
}

function removeImportedOps()
{
    const parentSubPatch = op.patch.ops.find((subOp) =>
    {
        return subOp.storage &&
        subOp.storage.blueprint &&
        subOp.storage.blueprint.isParentSubPatch &&
        subOp.storage.blueprint.blueprintOpId == op.id;
    }
    );
    if (parentSubPatch)
    {
        if (op.patch.isEditorMode()) CABLES.UI.undo.pause();
        op.patch.deleteOp(parentSubPatch.id, parentSubPatch.storage.blueprint.blueprintOpId);
        if (op.patch.isEditorMode()) CABLES.UI.undo.resume();
    }
}

const getOldPorts = () =>
{
    const oldPorts = JSON.parse(portsData.get());
    let oldPortsOut = {};
    if (oldPorts.portsOut)
    {
        oldPortsOut = oldPorts.portsOut;
    }
    let oldPortsIn = {};
    if (oldPorts.portsIn)
    {
        oldPortsIn = oldPorts.portsIn;
    }
    return { "portsIn": oldPortsIn, "portsOut": oldPortsOut };
};

const cleanupPorts = () =>
{
    const removeInPorts = [];
    const removeOutPorts = [];

    op.portsIn.forEach((port) =>
    {
        if (!protectedPorts.includes(port.id))
        {
            removeInPorts.push(port);
        }
    });
    op.portsOut.forEach((port) =>
    {
        if (!protectedPorts.includes(port.id))
        {
            removeOutPorts.push(port);
        }
    });

    removeInPorts.forEach((port) =>
    {
        removeInPort(port);
        op.emitEvent("onPortRemoved", {});
    });

    removeOutPorts.forEach((port) =>
    {
        removeOutPort(port);
        op.emitEvent("onPortRemoved", {});
    });

    if (removeOutPorts.length > 0 || removeInPorts.length > 0)
    {
        op.emitEvent("onUiAttribsChange", {});
    }
};

const removeInPort = (port) =>
{
    port.removeLinks();
    for (let ipi = 0; ipi < op.portsIn.length; ipi++)
    {
        if (op.portsIn[ipi] == port)
        {
            op.portsIn.splice(ipi, 1);
            return;
        }
    }
};

const removeOutPort = (port) =>
{
    port.removeLinks();
    for (let ipi = 0; ipi < op.portsOut.length; ipi++)
    {
        if (op.portsOut[ipi] == port)
        {
            op.portsOut.splice(ipi, 1);
            return;
        }
    }
};

function setupPorts(parentSubPatch)
{
    const subPatchDataPort = parentSubPatch.portsIn.find((port) => { return port.name === "dataStr"; });
    if (!subPatchDataPort) return;
    if (!subPatchDataPort.get()) return;

    const oldPorts = getOldPorts();
    cleanupPorts();

    const subPatchData = JSON.parse(subPatchDataPort.get());
    const subPatchPortsIn = subPatchData.ports || [];
    const subPatchPortsOut = subPatchData.portsOut || [];
    let i = 0;

    if (op.patch.isEditorMode()) CABLES.UI.undo.pause();
    const newPorts = [];
    for (i = 0; i < subPatchPortsIn.length; i++)
    {
        if (!op.getPortByName(subPatchPortsIn[i].name))
        {
            const subPatchPort = parentSubPatch.portsIn.find((port) => { return port.name == subPatchPortsIn[i].name; });
            const newPort = op.addInPort(new CABLES.Port(op, subPatchPort.name, subPatchPort.type));

            if (subPatchPort)
            {
                switch (subPatchPort.type)
                {
                case CABLES.OP_PORT_TYPE_FUNCTION:
                    newPort.onTriggered = () =>
                    {
                        subPatchPort.onTriggered();
                    };
                    break;
                default:
                    newPort.onChange = () =>
                    {
                        subPatchPort.set(newPort.get());
                        if (!newPort.isLinked())
                        {
                            savePortData();
                        }
                    };
                }
            }

            if (oldPorts.portsIn.hasOwnProperty(newPort.name))
            {
                if (!wasPasted && Array.isArray(oldPorts.portsIn[newPort.name].links))
                {
                    oldPorts.portsIn[newPort.name].links.forEach((link) =>
                    {
                        let parent = op.patch.getOpById(link.objOut);
                        if (parent)
                        {
                            const newLink = op.patch.link(parent, link.portOut, op, newPort.name);
                            if (newLink) newLink.ignoreInSerialize = true;
                        }
                        else
                        {
                            parent = op.patch.ops.find((subOp) =>
                            {
                                return subOp.storage &&
                                subOp.storage.blueprint &&
                                subOp.storage.blueprint.originalOpId == link.objOut &&
                                op.storage &&
                                op.storage.blueprint &&
                                subOp.storage.blueprint.blueprintOpId == op.storage.blueprint.blueprintOpId;
                            });
                            if (parent)
                            {
                                const newLink = op.patch.link(parent, link.portOut, op, newPort.name);
                                if (newLink) newLink.ignoreInSerialize = true;
                            }
                        }
                    });
                }
                if (!newPort.isLinked())
                {
                    newPort.set(oldPorts.portsIn[newPort.name].value);
                }
            }
            newPort.onLinkChanged = savePortData;

            if (subPatchPort.title)
            {
                newPort.setUiAttribs({ "title": subPatchPortsIn[i].title });
            }
            else if (subPatchPort.uiAttribs && subPatchPort.uiAttribs.title)
            {
                newPort.setUiAttribs({ "title": subPatchPort.uiAttribs.title });
            }
            if (subPatchPort.uiAttribs && subPatchPort.uiAttribs.objType)
            {
                newPort.setUiAttribs({ "objType": subPatchPort.uiAttribs.objType });
            }
            newPorts.push(newPort);
        }
    }
    op.setPortGroup("Blueprint Ports", newPorts);

    for (i = 0; i < subPatchPortsOut.length; i++)
    {
        if (!op.getPortByName(subPatchPortsOut[i].name))
        {
            const patchPortIn = parentSubPatch.portsIn.find((port) => { return port.name === "patchId"; });
            const patchOutputOP = op.patch.getSubPatchOp(patchPortIn.value, "Ops.Ui.PatchOutput");
            if (patchOutputOP.portsIn)
            {
                const subPatchPort = patchOutputOP.portsIn.find((port) => { return port.name == subPatchPortsOut[i].name; });
                const newPort = op.addOutPort(new CABLES.Port(op, subPatchPort.name, subPatchPort.type));
                newPort.ignoreValueSerialize = true;

                if (subPatchPort)
                {
                    switch (subPatchPort.type)
                    {
                    case CABLES.OP_PORT_TYPE_FUNCTION:
                        subPatchPort.onTriggered = () =>
                        {
                            newPort.trigger();
                        };
                        break;
                    default:
                        subPatchPort.onChange = () =>
                        {
                            newPort.set(subPatchPort.get());
                        };
                    }
                    newPort.set(subPatchPort.get());
                }

                if (oldPorts.portsOut.hasOwnProperty(newPort.name))
                {
                    if (!wasPasted && Array.isArray(oldPorts.portsOut[newPort.name].links))
                    {
                        oldPorts.portsOut[newPort.name].links.forEach((link) =>
                        {
                            let parent = op.patch.getOpById(link.objIn);
                            if (parent)
                            {
                                const newLink = op.patch.link(op, newPort.name, parent, link.portIn);
                                if (newLink) newLink.ignoreInSerialize = true;
                            }
                            else
                            {
                                parent = op.patch.ops.find((subOp) =>
                                {
                                    return subOp.storage &&
                                    subOp.storage.blueprint &&
                                    subOp.storage.blueprint.originalOpId == link.objIn &&
                                    op.storage &&
                                    op.storage.blueprint &&
                                    subOp.storage.blueprint.blueprintOpId == op.storage.blueprint.blueprintOpId;
                                });
                                if (parent)
                                {
                                    const newLink = op.patch.link(op, newPort.name, parent, link.portIn);
                                    if (newLink) newLink.ignoreInSerialize = true;
                                }
                            }
                        });
                    }
                }
                newPort.onLinkChanged = savePortData;

                if (subPatchPort.title)
                {
                    newPort.setUiAttribs({ "title": subPatchPortsOut[i].title });
                }
                else if (subPatchPort.uiAttribs && subPatchPort.uiAttribs.title)
                {
                    newPort.setUiAttribs({ "title": subPatchPort.uiAttribs.title });
                }

                if (subPatchPort.uiAttribs && subPatchPort.uiAttribs.objType)
                {
                    newPort.setUiAttribs({ "objType": subPatchPort.uiAttribs.objType });
                }
            }
        }
    }
    savePortData();
    if (op.patch.isEditorMode()) CABLES.UI.undo.resume();
}

function savePortData()
{
    const newPortsData = { "portsIn": {}, "portsOut": {} };
    op.portsIn.forEach((port) =>
    {
        if (!protectedPorts.includes(port.id))
        {
            const portData = {
                "name": port.name,
                "title": port.title,
                "type": port.type,
                "links": []
            };
            if (!port.links || port.links.length === 0) portData.value = port.get();
            port.links.forEach((link) =>
            {
                link.ignoreInSerialize = true;
                const linkData = {
                    "objOut": link.portOut.parent.id,
                    "portOut": link.portOut.name
                };
                portData.links.push(linkData);
            });
            newPortsData.portsIn[port.name] = portData;
        }
    });

    op.portsOut.forEach((port) =>
    {
        if (!protectedPorts.includes(port.id))
        {
            const portData = {
                "name": port.name,
                "title": port.title,
                "type": port.type,
                "links": []
            };
            if (!port.links || port.links.length === 0)
            {
                let portValue = port.get();
                try
                {
                    JSON.stringify(portValue);
                }
                catch (e)
                {
                    portValue = null;
                }
                portData.value = portValue;
            }
            port.links.forEach((link) =>
            {
                link.ignoreInSerialize = true;
                const linkData = {
                    "objIn": link.portIn.parent.id,
                    "portIn": link.portIn.name
                };
                portData.links.push(linkData);
            });
            newPortsData.portsOut[port.name] = portData;
        }
    });
    const serializedPortsData = JSON.stringify(newPortsData);
    portsData.set(serializedPortsData);
}


};

Ops.Dev.Blueprint.prototype = new CABLES.Op();
CABLES.OPS["3b25fb24-2a1f-4e5a-a18e-e08911a94030"]={f:Ops.Dev.Blueprint,objName:"Ops.Dev.Blueprint"};




// **************************************************************
// 
// Ops.Dev.BranchProfiler
// 
// **************************************************************

Ops.Dev.BranchProfiler = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Exec"),
    outNext = op.outTrigger("Next"),
    outProfilerStack = op.outObject("Profiler Data");

op.patch.cgl.frameStore.branchProfiler = op.patch.cgl.frameStore.branchProfiler || {};

inExec.onTriggered = () =>
{
    op.patch.cgl.frameStore.branchProfiler = {};

    op.patch.cgl.frameStore.branchStack = op.patch.cgl.frameStore.branchStack || new CABLES.BranchStack();

    op.patch.cgl.frameStore.branchStack.start();

    outNext.trigger();

    op.patch.cgl.frameStore.branchStack.finish();

    outProfilerStack.set(op.patch.cgl.frameStore.branchStack);
};


};

Ops.Dev.BranchProfiler.prototype = new CABLES.Op();
CABLES.OPS["5bc375f6-59f6-40f6-bc26-7b23e28d8bf2"]={f:Ops.Dev.BranchProfiler,objName:"Ops.Dev.BranchProfiler"};




// **************************************************************
// 
// Ops.Dev.BranchProfilerBranch
// 
// **************************************************************

Ops.Dev.BranchProfilerBranch = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Exec"),
    inName = op.inString("Branch Name", "default"),
    outNext = op.outTrigger("Next"),
    outDur = op.outNumber("Duration");

op.patch.cgl.frameStore.branchProfiler = op.patch.cgl.frameStore.branchProfiler || {};

inExec.onTriggered = () =>
{
    op.patch.cgl.frameStore.branchStack = op.patch.cgl.frameStore.branchStack || new CABLES.BranchStack();

    const c = op.patch.cgl.frameStore.branchStack.push(inName.get());

    outNext.trigger();

    if (op.patch.cgl.frameStore.branchStack.current == c) op.patch.cgl.frameStore.branchStack.pop();

    outDur.set(c.dur);
};


};

Ops.Dev.BranchProfilerBranch.prototype = new CABLES.Op();
CABLES.OPS["2082b704-0283-4645-b741-1e1955f28b66"]={f:Ops.Dev.BranchProfilerBranch,objName:"Ops.Dev.BranchProfilerBranch"};




// **************************************************************
// 
// Ops.Dev.BranchProfilerBranchEnd
// 
// **************************************************************

Ops.Dev.BranchProfilerBranchEnd = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Exec"),
    outNext = op.outTrigger("Next");

op.patch.cgl.frameStore.branchProfiler = op.patch.cgl.frameStore.branchProfiler || {};

inExec.onTriggered = ()=>
{
    if(op.patch.cgl.frameStore.branchStack) op.patch.cgl.frameStore.branchStack.pop();
    outNext.trigger();
};


};

Ops.Dev.BranchProfilerBranchEnd.prototype = new CABLES.Op();
CABLES.OPS["2c5f3947-9962-49ee-b09b-084bf8717f00"]={f:Ops.Dev.BranchProfilerBranchEnd,objName:"Ops.Dev.BranchProfilerBranchEnd"};




// **************************************************************
// 
// Ops.Dev.ColorAreaSDF_v5
// 
// **************************************************************

Ops.Dev.ColorAreaSDF_v5 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorarea_frag":"\nvec3 MOD_size=vec3(MOD_inSizeAmountFalloffSizeX.x);\n#ifdef MOD_DOSCALE\n    MOD_size*=MOD_scale.xyz;\n#endif\n\nvec3 MOD_col=MOD_color;\n\n#ifdef MOD_USE_TEX\n    MOD_col=texture(MOD_tex,gl_FragCoord.xy/float(textureSize(MOD_tex,0).xy)).rgb;\n#endif\n\n\n\n#ifdef MOD_AREA_SPHERE\n    float MOD_de=MOD_sdSphere(MOD_pos.xyz-MOD_vertPos.xyz,MOD_size.x);\n#endif\n\n#ifdef MOD_AREA_BOX\n    float MOD_r=MOD_scale.w;\n    MOD_r*=MOD_inSizeAmountFalloffSizeX.x;\n    float MOD_de=MOD_sdRoundBox(MOD_pos.xyz-MOD_vertPos.xyz,MOD_size-MOD_r,MOD_r);\n#endif\n\n#ifdef MOD_AREA_TRIPRISM\n    float MOD_de=MOD_sdTriPrism(MOD_pos.xyz-MOD_vertPos.xyz,vec2(MOD_size.x,MOD_size.z));\n#endif\n\n#ifdef MOD_AREA_HEXPRISM\n    float MOD_de=MOD_sdHexPrism(MOD_pos.xyz-MOD_vertPos.xyz,vec2(MOD_size.x,MOD_size.z));\n#endif\n\n\n\n// #ifndef MOD_AREA_SPHERE\n// #ifndef MOD_AREA_BOX\n//     float MOD_de=1.0-smoothstep(MOD_inSizeAmountFalloffSizeX.z*MOD_inSizeAmountFalloffSizeX.x,MOD_inSizeAmountFalloffSizeX.x,MOD_de);\n// #endif\n// #endif\n\n#ifdef MOD_AREA_AXIS_X\n    float MOD_de=abs(MOD_pos.x-MOD_vertPos.x);\n#endif\n#ifdef MOD_AREA_AXIS_Y\n    float MOD_de=abs(MOD_pos.y-MOD_vertPos.y);\n#endif\n#ifdef MOD_AREA_AXIS_Z\n    float MOD_de=abs(MOD_pos.z-MOD_vertPos.z);\n#endif\n\n#ifdef MOD_AREA_AXIS_X_INFINITE\n    float MOD_de=MOD_pos.x-MOD_vertPos.x;\n#endif\n#ifdef MOD_AREA_AXIS_Y_INFINITE\n    float MOD_de=MOD_pos.y-MOD_vertPos.y;\n#endif\n#ifdef MOD_AREA_AXIS_Z_INFINITE\n    float MOD_de=MOD_pos.z-MOD_vertPos.z;\n#endif\n\n\nMOD_de=1.0-MOD_map(\n    MOD_de,\n    0.0, MOD_inSizeAmountFalloffSizeX.z,\n    0.0,1.0\n    );\n\n\n#ifdef MOD_AREA_INVERT\n    MOD_de=1.0-MOD_de;\n#endif\n\n#ifdef MOD_BLEND_NORMAL\n    col.rgb=mix(col.rgb,MOD_col, MOD_de*MOD_inSizeAmountFalloffSizeX.y);\n#endif\n\n\n#ifdef MOD_BLEND_MULTIPLY\n    col.rgb=mix(col.rgb,col.rgb*MOD_col,MOD_de*MOD_inSizeAmountFalloffSizeX.y);\n#endif\n\n#ifdef MOD_BLEND_ADD\n    col.rgb+=MOD_de*MOD_inSizeAmountFalloffSizeX.y*MOD_col;\n#endif\n\n\n#ifdef MOD_BLEND_OPACITY\n    col.a*=(1.0-MOD_de*MOD_inSizeAmountFalloffSizeX.y);\n#endif\n\n#ifdef MOD_BLEND_DISCARD\n    if(MOD_de*MOD_inSizeAmountFalloffSizeX.y>=0.999)discard;\n#endif\n\n// col.rgb=vec3(distance(MOD_vertPos.xyz,MOD_pos.xyz))*0.1\n// col.rgb=MOD_pos.xyz;","colorarea_head_frag":"IN vec4 MOD_vertPos;\n\nfloat MOD_map(float value,float min1,float max1,float min2,float max2)\n{\n    return max(min2,min(max2,min2 + (value - min1) * (max2 - min2) / (max1 - min1)));\n\n}\n\n\nfloat MOD_sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat MOD_sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat MOD_sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat MOD_sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n",};
const
    render = op.inTrigger("Render"),
    inArea = op.inValueSelect("Area", ["Sphere", "Box", "Tri Prism", "Hex Prism", "Axis X", "Axis Y", "Axis Z", "Axis X Infinite", "Axis Y Infinite", "Axis Z Infinite"], "Sphere"),
    inSize = op.inValue("Size", 1),
    roundNess = op.inFloatSlider("Roundness", 0),
    inAmount = op.inValueSlider("Amount", 0.5),
    inFalloff = op.inFloat("Falloff", 0),
    inInvert = op.inValueBool("Invert"),
    inBlend = op.inSwitch("Blend ", ["Normal", "Multiply", "Opacity", "Add", "Discard"], "Normal"),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    x = op.inValue("x"),
    y = op.inValue("y"),
    z = op.inValue("z"),
    doScale = op.inBool("Change Size", false),
    sizeX = op.inFloat("Size X", 1),
    sizeY = op.inFloat("Size Y", 1),
    sizeZ = op.inFloat("Size Z", 1),
    inTex = op.inTexture("Texture"),

    inWorldSpace = op.inValueBool("WorldSpace", true),
    inPrio = op.inBool("Priority", true),
    next = op.outTrigger("Next");

op.setPortGroup("Scale", [doScale, sizeX, sizeZ, sizeY]);
op.setPortGroup("Position", [x, y, z]);
op.setPortGroup("Color", [inBlend, r, g, b]);
r.setUiAttribs({ "colorPick": true });

const cgl = op.patch.cgl;

const srcHeadVert = ""
    .endl() + "OUT vec4 MOD_vertPos;"
    .endl();

const srcBodyVert = ""
    .endl() + "#ifndef MOD_WORLDSPACE"
    .endl() + "   MOD_vertPos=vec4(vPosition,1.0);"
    .endl() + "#endif"

    .endl() + "#ifdef MOD_WORLDSPACE"
    .endl() + "   MOD_vertPos=mMatrix*pos;"
    .endl() + "#endif"
    .endl();

inWorldSpace.onChange =
    inTex.onLinkChanged =
    inArea.onChange =
    inInvert.onChange =
    doScale.onChange =
    inBlend.onChange = updateDefines;

render.onTriggered = doRender;

const vertModTitle = "vert_" + op.name;
const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "priority": 2,
    "title": vertModTitle,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": srcHeadVert,
    "srcBodyVert": srcBodyVert
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": attachments.colorarea_head_frag,
    "srcBodyFrag": attachments.colorarea_frag
});

mod.addUniform("4f", "MOD_inSizeAmountFalloffSizeX", inSize, inAmount, inFalloff, 0);
mod.addUniform("3f", "MOD_color", r, g, b);
mod.addUniform("3f", "MOD_pos", x, y, z);
mod.addUniform("4f", "MOD_scale", sizeX, sizeY, sizeZ, roundNess);
mod.addUniform("t", "MOD_tex");

updateDefines();

inPrio.onChange = updatePrio;
updatePrio();

function updatePrio()
{
    mod.removeModule(vertModTitle);

    const vmod = {
        // "priority": 0,
        "title": vertModTitle,
        "name": "MODULE_VERTEX_POSITION",
        srcHeadVert,
        srcBodyVert
    };

    if (inPrio.get()) vmod.priority = 2;

    mod.addModule(vmod);
}

function updateDefines()
{
    mod.toggleDefine("MOD_BLEND_NORMAL", inBlend.get() == "Normal");
    mod.toggleDefine("MOD_BLEND_OPACITY", inBlend.get() == "Opacity");
    mod.toggleDefine("MOD_BLEND_MULTIPLY", inBlend.get() == "Multiply");
    mod.toggleDefine("MOD_BLEND_DISCARD", inBlend.get() == "Discard");
    mod.toggleDefine("MOD_BLEND_ADD", inBlend.get() == "Add");

    mod.toggleDefine("MOD_AREA_SIZE", doScale.get());

    mod.toggleDefine("MOD_AREA_INVERT", inInvert.get());
    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get());

    mod.toggleDefine("MOD_AREA_AXIS_X", inArea.get() == "Axis X");
    mod.toggleDefine("MOD_AREA_AXIS_Y", inArea.get() == "Axis Y");
    mod.toggleDefine("MOD_AREA_AXIS_Z", inArea.get() == "Axis Z");
    mod.toggleDefine("MOD_AREA_AXIS_X_INFINITE", inArea.get() == "Axis X Infinite");
    mod.toggleDefine("MOD_AREA_AXIS_Y_INFINITE", inArea.get() == "Axis Y Infinite");
    mod.toggleDefine("MOD_AREA_AXIS_Z_INFINITE", inArea.get() == "Axis Z Infinite");
    mod.toggleDefine("MOD_AREA_SPHERE", inArea.get() == "Sphere");
    mod.toggleDefine("MOD_AREA_BOX", inArea.get() == "Box");
    mod.toggleDefine("MOD_AREA_TRIPRISM", inArea.get() == "Tri Prism");
    mod.toggleDefine("MOD_AREA_HEXPRISM", inArea.get() == "Hex Prism");

    mod.toggleDefine("MOD_DOSCALE", doScale.get());

    // mod.removeUniform("3f", "MOD_scale",sizeX,sizeY,sizeZ);
    sizeX.setUiAttribs({ "greyout": !doScale.get() });
    sizeY.setUiAttribs({ "greyout": !doScale.get() });
    sizeZ.setUiAttribs({ "greyout": !doScale.get() });

    roundNess.setUiAttribs({ "greyout": inArea.get() != "Box" });

    mod.toggleDefine("MOD_USE_TEX", inTex.isLinked());
}

function drawHelpers()
{
    if (cgl.frameStore.shadowPass) return;
    if (cgl.shouldDrawHelpers(op)) gui.setTransformGizmo({ "posX": x, "posY": y, "posZ": z });
}

function doRender()
{
    // if(doScale.get()) mod.setUniformValue("MOD_scale",[sizeX.get(),sizeY.get(),sizeZ.get()]);
    mod.bind();

    let tex = inTex.get();

    if (!tex) tex = CGL.Texture.getEmptyTexture(cgl).tex;
    else tex = tex.tex;

    mod.pushTexture("MOD_tex", tex);

    drawHelpers();
    next.trigger();

    mod.unbind();
}


};

Ops.Dev.ColorAreaSDF_v5.prototype = new CABLES.Op();
CABLES.OPS["3ea4bb8a-d2a0-4600-9d98-83d5a091ea4f"]={f:Ops.Dev.ColorAreaSDF_v5,objName:"Ops.Dev.ColorAreaSDF_v5"};




// **************************************************************
// 
// Ops.Dev.Gl.Geometry.CopyGeometry
// 
// **************************************************************

Ops.Dev.Gl.Geometry.CopyGeometry = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    geometry = op.inObject("Geometry"),
    outGeom = op.outObject("Result");

geometry.onChange = update;

function update()
{
    let oldGeom = geometry.get();

    if (oldGeom)
    {
        let geom = oldGeom.copy();

        outGeom.set(geom);
    }
    else outGeom.set(null);
}


};

Ops.Dev.Gl.Geometry.CopyGeometry.prototype = new CABLES.Op();
CABLES.OPS["b15f57c2-4b0c-45de-962b-dd249779addf"]={f:Ops.Dev.Gl.Geometry.CopyGeometry,objName:"Ops.Dev.Gl.Geometry.CopyGeometry"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Abs
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Abs = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("input", null, "sg_float"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "abs";

invec.onLinkChanged = () =>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([invec], [invec, outvec]);
};


};

Ops.Dev.Gl.ShaderGraph.Abs.prototype = new CABLES.Op();
CABLES.OPS["2543cfb4-c1e2-44f1-bfd4-de6cc8143b8b"]={f:Ops.Dev.Gl.ShaderGraph.Abs,objName:"Ops.Dev.Gl.ShaderGraph.Abs"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Color
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Color = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inColor = op.inDropDown("Color", ["Red", "Green", "Blue", "Cyan", "Pink", "Yellow", "White", "Black"], "Red");
const outvec = op.outObject("result", null, "sg_vec4");

const sg = new CGL.ShaderGraphOp(this);
inColor.onChange = update;
update();

function update()
{
    if (inColor.get() == "Red") op.shaderVar = "vec4(1.,0.,0.,1.)";
    if (inColor.get() == "Green") op.shaderVar = "vec4(0.,1.,0.,1.)";
    if (inColor.get() == "Blue") op.shaderVar = "vec4(0.,0.,1.,1.)";
    if (inColor.get() == "Cyan") op.shaderVar = "vec4(0.,1.,1.,1.)";
    if (inColor.get() == "Pink") op.shaderVar = "vec4(1.,0.,1.,1.)";
    if (inColor.get() == "Yellow") op.shaderVar = "vec4(1.,1.,0.,1.)";

    sg.updateGraph();
}


};

Ops.Dev.Gl.ShaderGraph.Color.prototype = new CABLES.Op();
CABLES.OPS["afb10809-c7cc-410a-8402-97604b548914"]={f:Ops.Dev.Gl.ShaderGraph.Color,objName:"Ops.Dev.Gl.ShaderGraph.Color"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Cos
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Cos = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("input", null, "sg_float"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "cos";

invec.onLinkChanged = () =>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([invec], [invec, outvec]);
};


};

Ops.Dev.Gl.ShaderGraph.Cos.prototype = new CABLES.Op();
CABLES.OPS["3596827c-fc80-4109-b98e-9183d7589286"]={f:Ops.Dev.Gl.ShaderGraph.Cos,objName:"Ops.Dev.Gl.ShaderGraph.Cos"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Cross
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Cross = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("value a", null, "sg_vec3"),
    invecb = op.inObject("value b", null, "sg_vec3"),
    outvec = op.outObject("result", null, "sg_vec3");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "cross";


};

Ops.Dev.Gl.ShaderGraph.Cross.prototype = new CABLES.Op();
CABLES.OPS["6c041b4c-2692-4068-b86e-47476f3ad261"]={f:Ops.Dev.Gl.ShaderGraph.Cross,objName:"Ops.Dev.Gl.ShaderGraph.Cross"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.CustomShaderGraphOp
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.CustomShaderGraphOp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inCode = op.inStringEditor("Code", "float main(vec3 rgb)\n{\nreturn rgb*2.0;\n}", "glsl");

const sgOp = new CGL.ShaderGraphOp(this);

op.shaderSrc = inCode.get();
op.shaderFunc = "";

inCode.onChange = () =>
{
    const info = sgOp.parseCode(inCode.get());
    sgOp.updatePorts(info);
};


};

Ops.Dev.Gl.ShaderGraph.CustomShaderGraphOp.prototype = new CABLES.Op();
CABLES.OPS["a4145b55-6ef9-4084-b32f-7eb224a7661c"]={f:Ops.Dev.Gl.ShaderGraph.CustomShaderGraphOp,objName:"Ops.Dev.Gl.ShaderGraph.CustomShaderGraphOp"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Distance
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Distance = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("value a", null, "sg_float"),
    invecb = op.inObject("value b", null, "sg_float"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "distance";

invecb.onLinkChanged =
invec.onLinkChanged = () =>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([invec, invecb], [invec, invecb]);
};


};

Ops.Dev.Gl.ShaderGraph.Distance.prototype = new CABLES.Op();
CABLES.OPS["bfb67ec3-a1b6-410f-a52c-0eba05b83453"]={f:Ops.Dev.Gl.ShaderGraph.Distance,objName:"Ops.Dev.Gl.ShaderGraph.Distance"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Dot
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Dot = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("value a", null, "sg_genType"),
    invecb = op.inObject("value b", null, "sg_genType"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "dot";

invecb.onLinkChanged =
invec.onLinkChanged = () =>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([invec, invecb], [invec, invecb]);
};


};

Ops.Dev.Gl.ShaderGraph.Dot.prototype = new CABLES.Op();
CABLES.OPS["aaa64cf2-b96f-40c7-be24-12d5de08cff7"]={f:Ops.Dev.Gl.ShaderGraph.Dot,objName:"Ops.Dev.Gl.ShaderGraph.Dot"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.FragColor
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.FragColor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"shader_frag":"void setColor(vec4 col)\n{\n    #ifdef SETCOLOR_ALPHA\n        col.a=1.0;\n    #endif\n    {{MODULE_COLOR}}\n    outColor=col;\n}",};
const sgOp = new CGL.ShaderGraphOp(this, attachments.shader_frag);

const inAlpha = op.inBool("Alpha always one", true);

inAlpha.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    sgOp.toggleDefine("SETCOLOR_ALPHA", inAlpha.get());
}


};

Ops.Dev.Gl.ShaderGraph.FragColor.prototype = new CABLES.Op();
CABLES.OPS["38ad0d02-7973-437b-8372-7f3f77bfad48"]={f:Ops.Dev.Gl.ShaderGraph.FragColor,objName:"Ops.Dev.Gl.ShaderGraph.FragColor"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.InputColor
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.InputColor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inName = op.inString("Name", "myColor"),
    uni1 = op.inFloat("R", 0),
    uni2 = op.inFloat("G", 0),
    uni3 = op.inFloat("B", 0),
    uni4 = op.inFloat("A", 1),
    inType = op.inSwitch("Type", ["Uniform", "Static"], "Uniform"),
    result = op.outObject("vec4", null, "sg_vec4");

uni1.setUiAttribs({ "colorPick": true });

const sgOp = new CGL.ShaderGraphOp(this);

inName.onChange =
inType.onChange = updateUniDefs;

updateUniDefs();

uni1.onChange =
    uni2.onChange =
    uni3.onChange =
    uni4.onChange = () =>
    {
        if (inType.get() == "Static")sgOp.updateGraph();
    };

function updateUniDefs()
{
    const varname = (inName.get() || "myColor") + "_" + CGL.ShaderGraph.getNewId();
    op.shaderVar = varname;
    op.shaderUniforms =
        [{
            "type": "4f",
            "name": varname,
            "ports": [uni1, uni2, uni3, uni4],
            "static": inType.get() == "Static"
        }];

    op.setUiAttrib({ "extendTitle": inName.get() });

    sgOp.updateGraph();
}


};

Ops.Dev.Gl.ShaderGraph.InputColor.prototype = new CABLES.Op();
CABLES.OPS["ad57d840-4fc7-43cf-9095-35e52fde5c14"]={f:Ops.Dev.Gl.ShaderGraph.InputColor,objName:"Ops.Dev.Gl.ShaderGraph.InputColor"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.InputTexture
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.InputTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

const
    inTex = op.inTexture("Texture"),
    inName = op.inString("Name", "myTexture"),
    result = op.outObject("vec4", null, "sg_sampler2D");

const sgOp = new CGL.ShaderGraphOp(this);
inName.onChange =
inTex.onChange = updateUniDefs;

updateUniDefs();

function updateUniDefs()
{
    const varname = (inName.get() || "myVec4") + "_" + CGL.ShaderGraph.getNewId();
    op.shaderVar = varname;
    op.shaderUniforms =
        [{
            "type": "t",
            "name": varname,
            "ports": [inTex]
        }];

    op.setUiAttrib({ "extendTitle": inName.get() });

    sgOp.updateGraph();
}


};

Ops.Dev.Gl.ShaderGraph.InputTexture.prototype = new CABLES.Op();
CABLES.OPS["025e1fe0-43be-4d57-b6f8-5a3e314068d1"]={f:Ops.Dev.Gl.ShaderGraph.InputTexture,objName:"Ops.Dev.Gl.ShaderGraph.InputTexture"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.InputVec4
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.InputVec4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inName = op.inString("Name", "myVec4"),
    uni1 = op.inFloat("Number X", 0),
    uni2 = op.inFloat("Number Y", 0),
    uni3 = op.inFloat("Number Z", 0),
    uni4 = op.inFloat("Number W", 1),
    inType = op.inSwitch("Type", ["Uniform", "Static"], "Uniform"),
    result = op.outObject("vec4", null, "sg_vec4");

const sgOp = new CGL.ShaderGraphOp(this);

inName.onChange =
inType.onChange = updateUniDefs;

updateUniDefs();

uni1.onChange =
    uni2.onChange =
    uni3.onChange =
    uni4.onChange = () =>
    {
        if (inType.get() == "Static")sgOp.updateGraph();
    };

function updateUniDefs()
{
    const varname = (inName.get() || "myVec4") + "_" + CGL.ShaderGraph.getNewId();
    op.shaderVar = varname;
    op.shaderUniforms =
        [{
            "type": "4f",
            "name": varname,
            "ports": [uni1, uni2, uni3, uni4],
            "static": inType.get() == "Static"
        }];

    op.setUiAttrib({ "extendTitle": inName.get() });

    sgOp.updateGraph();
}


};

Ops.Dev.Gl.ShaderGraph.InputVec4.prototype = new CABLES.Op();
CABLES.OPS["4e089d60-006b-4879-9b45-b9616c7fc18d"]={f:Ops.Dev.Gl.ShaderGraph.InputVec4,objName:"Ops.Dev.Gl.ShaderGraph.InputVec4"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Max
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Max = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("value a", null, "sg_float"),
    invecb = op.inObject("value b", null, "sg_float"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "max";

invecb.onLinkChanged =
invec.onLinkChanged = () =>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([invec, invecb], [invec, invecb, outvec]);
};


};

Ops.Dev.Gl.ShaderGraph.Max.prototype = new CABLES.Op();
CABLES.OPS["285b5693-5038-44a2-82f4-989266ac8655"]={f:Ops.Dev.Gl.ShaderGraph.Max,objName:"Ops.Dev.Gl.ShaderGraph.Max"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Min
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Min = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("value a", null, "sg_float"),
    invecb = op.inObject("value b", null, "sg_float"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "min";

invecb.onLinkChanged =
invec.onLinkChanged = () =>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([invec, invecb], [invec, invecb, outvec]);
};


};

Ops.Dev.Gl.ShaderGraph.Min.prototype = new CABLES.Op();
CABLES.OPS["58c146e1-8512-4f1c-b23f-52099b566978"]={f:Ops.Dev.Gl.ShaderGraph.Min,objName:"Ops.Dev.Gl.ShaderGraph.Min"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Mix
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Mix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inx=op.inObject("x",null,"sg_float"),
    iny=op.inObject("y",null,"sg_float"),
    ina=op.inObject("a",null,"sg_float"),
    result=op.outObject("result",null,"sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc="mix";

inx.onLinkChanged=
iny.onLinkChanged=
ina.onLinkChanged=()=>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([inx,iny],[inx,iny,result]);
};


};

Ops.Dev.Gl.ShaderGraph.Mix.prototype = new CABLES.Op();
CABLES.OPS["b4b9f9d3-10c1-4a8e-8282-d05df9e92801"]={f:Ops.Dev.Gl.ShaderGraph.Mix,objName:"Ops.Dev.Gl.ShaderGraph.Mix"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Multiply
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Multiply = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inputa = op.inObject("a", null, "sg_genType"),
    inputb = op.inObject("b", null, "sg_genType"),
    outvec = op.outObject("result", null, "sg_genType");

inputa.setUiAttribs({ "ignoreObjTypeErrors": true });
inputb.setUiAttribs({ "ignoreObjTypeErrors": true });

new CGL.ShaderGraphOp(this);

inputb.onLinkChanged =
inputa.onLinkChanged = () =>
{
    const t = CGL.ShaderGraphOp.getMaxGenTypeFromPorts([inputb, inputa]);

    inputa.setUiAttribs({ "objType": t });
    outvec.setUiAttribs({ "objType": t });
    inputb.setUiAttribs({ "objType": t });
};

op.shaderCodeOperator = "*";


};

Ops.Dev.Gl.ShaderGraph.Multiply.prototype = new CABLES.Op();
CABLES.OPS["84316631-39d6-45f7-8b03-2499dc22f3bb"]={f:Ops.Dev.Gl.ShaderGraph.Multiply,objName:"Ops.Dev.Gl.ShaderGraph.Multiply"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Normalize
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Normalize = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("input", null, "sg_float"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "normalize";

invec.onLinkChanged = () =>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([invec], [invec, outvec]);
};


};

Ops.Dev.Gl.ShaderGraph.Normalize.prototype = new CABLES.Op();
CABLES.OPS["2358fdab-8261-45f0-bb63-ddef88ad4fa3"]={f:Ops.Dev.Gl.ShaderGraph.Normalize,objName:"Ops.Dev.Gl.ShaderGraph.Normalize"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.PerlinNoise3D
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.PerlinNoise3D = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"perlin_glsl":"\n//\nfloat Interpolation_C2( float x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }   //  6x^5-15x^4+10x^3\t( Quintic Curve.  As used by Perlin in Improved Noise.  http://mrl.nyu.edu/~perlin/paper445.pdf )\nvec2 Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 Interpolation_C2( vec3 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2( vec4 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2_InterpAndDeriv( vec2 x ) { return x.xyxy * x.xyxy * ( x.xyxy * ( x.xyxy * ( x.xyxy * vec2( 6.0, 0.0 ).xxyy + vec2( -15.0, 30.0 ).xxyy ) + vec2( 10.0, -60.0 ).xxyy ) + vec2( 0.0, 30.0 ).xxyy ); }\nvec3 Interpolation_C2_Deriv( vec3 x ) { return x * x * (x * (x * 30.0 - 60.0) + 30.0); }\nfloat Falloff_Xsq_C1( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq; }\t// ( 1.0 - x*x )^2   ( Used by Humus for lighting falloff in Just Cause 2.  GPUPro 1 )\nfloat Falloff_Xsq_C2( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\t// ( 1.0 - x*x )^3.   NOTE: 2nd derivative is 0.0 at x=1.0, but non-zero at x=0.0\nvec4 Falloff_Xsq_C2( vec4 xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\n\n\nvoid FAST32_hash_3D( vec3 gridcell, out vec4 lowz_hash, out vec4 highz_hash )\t//\tgenerates a random number for each of the 8 cell corners\n{\n//    gridcell is assumed to be an integer coordinate\n//\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const float SOMELARGEFLOAT = 635.298681;\n    const float ZINC = 48.500388;\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    highz_hash.xy = vec2( 1.0 / ( SOMELARGEFLOAT + vec2( gridcell.z, gridcell_inc1.z ) * ZINC ) );\n    lowz_hash = fract( P * highz_hash.xxxx );\n    highz_hash = fract( P * highz_hash.yyyy );\n}\n\n\n\nvoid FAST32_hash_3D( \tvec3 gridcell,out vec4 lowz_hash_0,out vec4 lowz_hash_1,out vec4 lowz_hash_2,out vec4 highz_hash_0,out vec4 highz_hash_1,out vec4 highz_hash_2\t)\t\t//\tgenerates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\n\n\n//\n//\tPerlin Noise 3D  ( gradient noise )\n//\tReturn value range of -1.0->1.0\n//\thttp://briansharpe.files.wordpress.com/2011/11/perlinsample.jpg\n//\nfloat perlin3D( vec3 P )\n{\n    P*=8.0;\n\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    //\n    //\tclassic noise.\n    //\trequires 3 random values per point.\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n    //SGPP_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n\n    //\tcalculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n\n    //\tClassic Perlin Interpolation\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    final *= 1.1547005383792515290182975610039;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/sqrt(0.75)\n    return final;\n\n\n\n}\n",};


const sgOp = new CGL.ShaderGraphOp(this, attachments.perlin_glsl);


};

Ops.Dev.Gl.ShaderGraph.PerlinNoise3D.prototype = new CABLES.Op();
CABLES.OPS["bba73873-2b81-419b-899f-323e7dc159ea"]={f:Ops.Dev.Gl.ShaderGraph.PerlinNoise3D,objName:"Ops.Dev.Gl.ShaderGraph.PerlinNoise3D"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Pow
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Pow = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("input", null, "sg_float"),
    inpow = op.inObject("power", null, "sg_float"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "pow";

inpow.onLinkChanged = () =>
{
    return invec.onLinkChanged = () =>
    {
        CGL.ShaderGraphOp.getMaxGenTypeFromPorts([invec, inpow], [invec, inpow, outvec]);
    };
};


};

Ops.Dev.Gl.ShaderGraph.Pow.prototype = new CABLES.Op();
CABLES.OPS["eab198bd-b8e9-467e-ad05-8175b41a9732"]={f:Ops.Dev.Gl.ShaderGraph.Pow,objName:"Ops.Dev.Gl.ShaderGraph.Pow"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.SG_Noise
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.SG_Noise = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"shader_frag":"\nfloat noise(vec2 a)\n{\n    return fract(sin(dot(a, vec2(12.9898, 78.233))) * 43758.5453);\n}",};
new CGL.ShaderGraphOp(this,attachments.shader_frag);


};

Ops.Dev.Gl.ShaderGraph.SG_Noise.prototype = new CABLES.Op();
CABLES.OPS["7400ed85-8931-4669-b0bc-620623860864"]={f:Ops.Dev.Gl.ShaderGraph.SG_Noise,objName:"Ops.Dev.Gl.ShaderGraph.SG_Noise"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.SampleTexture
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.SampleTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"sampletex_frag":"vec4 sampleTex(sampler2D tex,vec2 texCoord)\n{\n    return texture(tex,texCoord);\n}",};
const sgOp = new CGL.ShaderGraphOp(this, attachments.sampletex_frag);


};

Ops.Dev.Gl.ShaderGraph.SampleTexture.prototype = new CABLES.Op();
CABLES.OPS["3eb89130-b02e-432c-9633-d1ab4635a783"]={f:Ops.Dev.Gl.ShaderGraph.SampleTexture,objName:"Ops.Dev.Gl.ShaderGraph.SampleTexture"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.SetPosition
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.SetPosition = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"position_vert":"void setPosition(vec4 pos)\n{\n    // vec3 tangent=attrTangent;\n    pos.w=1.0;\n    // vec3 bitangent=attrBiTangent;\n    mat4 mMatrix=modelMatrix;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    texCoord=attrTexCoord;\n\n    gl_Position = projMatrix * (viewMatrix*mMatrix) * pos;\n}",};
const sgOp = new CGL.ShaderGraphOp(this, attachments.position_vert);


};

Ops.Dev.Gl.ShaderGraph.SetPosition.prototype = new CABLES.Op();
CABLES.OPS["8772c543-f2f6-4684-8792-2a615cf861b0"]={f:Ops.Dev.Gl.ShaderGraph.SetPosition,objName:"Ops.Dev.Gl.ShaderGraph.SetPosition"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Sin
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Sin = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec=op.inObject("input",null,"sg_float"),
    outvec=op.outObject("result",null,"sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc="sin";

invec.onLinkChanged=()=>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([invec],[invec,outvec]);

};


};

Ops.Dev.Gl.ShaderGraph.Sin.prototype = new CABLES.Op();
CABLES.OPS["19e60bc9-4ddf-4c24-a6e6-ca48a3856676"]={f:Ops.Dev.Gl.ShaderGraph.Sin,objName:"Ops.Dev.Gl.ShaderGraph.Sin"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Sum
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Sum = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inputa = op.inObject("a", null, "sg_float"),
    inputb = op.inObject("b", null, "sg_float"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderCodeOperator = "+";

inputa.setUiAttribs({ "ignoreObjTypeErrors": true });
inputb.setUiAttribs({ "ignoreObjTypeErrors": true });

inputb.onLinkChanged =
inputa.onLinkChanged = () =>
{
    CGL.ShaderGraphOp.getMaxGenTypeFromPorts([inputb, inputa], [inputb, inputa, outvec]);
};


};

Ops.Dev.Gl.ShaderGraph.Sum.prototype = new CABLES.Op();
CABLES.OPS["5bca04f9-bb17-4bd0-bcd1-0427ee3b2933"]={f:Ops.Dev.Gl.ShaderGraph.Sum,objName:"Ops.Dev.Gl.ShaderGraph.Sum"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.Swizzle
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.Swizzle = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inp = op.inObject("vec", null, "sg_vec4", null, "sg_vec4"),
    inType = op.inSwitch("Type", ["float", "vec2", "vec3", "vec4"], "vec4"),
    xChannel = op.inSwitch("X", ["X", "Y", "Z", "W"], "X"),
    yChannel = op.inSwitch("Y", ["X", "Y", "Z", "W"], "Y"),
    zChannel = op.inSwitch("Z", ["X", "Y", "Z", "W"], "Z"),
    wChannel = op.inSwitch("W", ["X", "Y", "Z", "W"], "W"),
    result = op.outObject("Result", null, "sg_vec4");

inType.onChange =
    xChannel.onChange =
    yChannel.onChange =
    zChannel.onChange =
    wChannel.onChange = updateUi;

const sgOp = new CGL.ShaderGraphOp(this);
updateUi();

function updateUi()
{
    yChannel.setUiAttribs({ "greyout": inType.get() == "float" });
    zChannel.setUiAttribs({ "greyout": inType.get() == "float" || inType.get() == "vec2" });
    wChannel.setUiAttribs({ "greyout": inType.get() == "float" || inType.get() == "vec2" || inType.get() == "vec3" });

    result.setUiAttribs({ "objType": "sg_" + inType.get() });

    let swizzStr = xChannel.get().toLowerCase();
    let str = "";

    // if (inType.get() == "float")
    // {
    //     str = swizzStr;
    //     str = inType.get() + " swizzle(" + inType.get() + " vec){return " + vec + "; }";
    // }
    // else
    {
        if (inType.get() == "float") swizzStr = "vec";
        if (inType.get() == "vec2" || inType.get() == "vec3" || inType.get() == "vec4") swizzStr += "vec." + yChannel.get().toLowerCase();
        if (inType.get() == "vec3" || inType.get() == "vec4") swizzStr += "vec." + zChannel.get().toLowerCase();
        if (inType.get() == "vec4") swizzStr += "vec." + wChannel.get().toLowerCase();

        str = inType.get() + " swizzle(" + inType.get() + " vec){return " + swizzStr + "; }";
    }

    // console.log(str);
    sgOp.parseCode(str);
    // console.log(sgOp.info);
    sgOp.updateGraph();
}


};

Ops.Dev.Gl.ShaderGraph.Swizzle.prototype = new CABLES.Op();
CABLES.OPS["8a25f41b-6ded-4aaf-bd1f-219d644040d0"]={f:Ops.Dev.Gl.ShaderGraph.Swizzle,objName:"Ops.Dev.Gl.ShaderGraph.Swizzle"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.TexCoord
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.TexCoord = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
op.outObject("texCoord",null,"sg_vec2");
op.shaderVar="texCoord";

new CGL.ShaderGraphOp(this);


};

Ops.Dev.Gl.ShaderGraph.TexCoord.prototype = new CABLES.Op();
CABLES.OPS["3a7e40e5-29bd-4e17-abbd-1570ab4cfb1d"]={f:Ops.Dev.Gl.ShaderGraph.TexCoord,objName:"Ops.Dev.Gl.ShaderGraph.TexCoord"};




// **************************************************************
// 
// Ops.Dev.Gl.ShaderGraph.VertexPosition
// 
// **************************************************************

Ops.Dev.Gl.ShaderGraph.VertexPosition = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
op.outObject("vposition", null, "sg_vec3");
op.shaderVar = "vPosition";

new CGL.ShaderGraphOp(this);


};

Ops.Dev.Gl.ShaderGraph.VertexPosition.prototype = new CABLES.Op();
CABLES.OPS["b2d21d20-a29a-441d-9ffa-0535a771042f"]={f:Ops.Dev.Gl.ShaderGraph.VertexPosition,objName:"Ops.Dev.Gl.ShaderGraph.VertexPosition"};




// **************************************************************
// 
// Ops.Dev.Gl.Shadergraph.Length
// 
// **************************************************************

Ops.Dev.Gl.Shadergraph.Length = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    invec = op.inObject("input", null, "sg_genType"),
    outvec = op.outObject("result", null, "sg_float");

new CGL.ShaderGraphOp(this);
op.shaderFunc = "length";

invec.onLinkChanged = () =>
{
    invec.copyLinkedUiAttrib("objType", invec);
};


};

Ops.Dev.Gl.Shadergraph.Length.prototype = new CABLES.Op();
CABLES.OPS["27f420c0-aecc-447c-927c-3536abc8849a"]={f:Ops.Dev.Gl.Shadergraph.Length,objName:"Ops.Dev.Gl.Shadergraph.Length"};




// **************************************************************
// 
// Ops.Dev.Gl.Shadergraph.Shadergraph
// 
// **************************************************************

Ops.Dev.Gl.Shadergraph.Shadergraph = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Exec"),
    inFrag = op.inObject("Fragment", null, "sg_void"),
    inVertex = op.inObject("Vertex", null, "sg_void"),
    next = op.outTrigger("Next"),
    outshader = op.outObject("Shader"),
    outSrcFrag = op.outString("Source Fragment"),
    outSrcVert = op.outString("Source Vertex");

const cgl = op.patch.cgl;
const sg = new CGL.ShaderGraph(this, inFrag, inVertex);
const shader = new CGL.Shader(cgl, op.name);
let needsUpdate = true;

shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_BEGIN_VERTEX"]);
outshader.set(shader);

let uniformTextures = [];

sg.on("compiled", () =>
{
    outSrcFrag.set(sg.getSrcFrag());
    outSrcVert.set(sg.getSrcVert());
    needsUpdate = true;
});

inExec.onTriggered = () =>
{
    if (needsUpdate)
    {
        uniformTextures = [];
        shader.removeAllUniforms();

        shader.setSource(sg.getSrcVert(), sg.getSrcFrag());

        const unis = sg.getUniforms();
        for (let i = 0; i < unis.length; i++)
        {
            const su = unis[i];
            shader.removeUniform(su.name);

            let uni = null;
            if (su.ports) uni = shader.addUniformFrag(su.type, su.name, su.ports[0], su.ports[1], su.ports[2], su.ports[3]);
            else console.log("uni has no ports", su.ports);

            if (su.type == "t")uniformTextures.push({ "uni": uni, "port": su.ports[0] });
        }
        needsUpdate = false;
    }

    for (let i = 0; i < uniformTextures.length; i++)
        shader.pushTexture(uniformTextures[i].uni, uniformTextures[i].port.get());

    cgl.pushShader(shader);

    next.trigger();

    shader.popTextures();
    cgl.popShader();
};


};

Ops.Dev.Gl.Shadergraph.Shadergraph.prototype = new CABLES.Op();
CABLES.OPS["aef36334-477a-4173-af03-d4e162d31bfb"]={f:Ops.Dev.Gl.Shadergraph.Shadergraph,objName:"Ops.Dev.Gl.Shadergraph.Shadergraph"};




// **************************************************************
// 
// Ops.Dev.Gl.TextureEffects.ChromaKeyAlpha
// 
// **************************************************************

Ops.Dev.Gl.TextureEffects.ChromaKeyAlpha = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"chromakey_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI vec3 color;\nUNI float weightMul;\n\n\n{{MODULE_BEGIN_FRAG}}\n\nvec3 rgb2hsv(vec4 rgb)\n{\n\tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n\tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n    float delta = Cmax - Cmin;\n\n\tvec3 hsv = vec3(0., 0., Cmax);\n\n\tif (Cmax > Cmin)\n\t{\n\t\thsv.y = delta / Cmax;\n\n\t\tif (rgb.r == Cmax)\n\t\t\thsv.x = (rgb.g - rgb.b) / delta;\n\t\telse\n\t\t{\n\t\t\tif (rgb.g == Cmax)\n\t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n\t\t\telse\n\t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n\t\t}\n\t\thsv.x = fract(hsv.x / 6.);\n\t}\n\treturn hsv;\n}\n\nfloat chromaKey(vec4 col)\n{\n    vec4 backgroundColor = vec4(color,0.0);\n    vec3 weights = vec3(4.*weightMul, 1., 2.*weightMul);\n\n    vec3 hsv = rgb2hsv(col);\n    vec3 target = rgb2hsv(backgroundColor);\n    float dist = length(weights * (target - hsv));\n\n    return 1. - clamp(3. * dist - 1.5, 0., 1.);\n}\n\nfloat random(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * (43758.5453));\n}\n\nvoid main()\n{\n    vec4 col=vec4(1.0,1.0,0.0,1.0);\n    {{MODULE_COLOR}}\n    col=texture(tex,texCoord);\n\n    // #ifdef MODE_R\n    //   float maxrb = max( col.g, col.b );\n    //   float perc = min(1.0,(col.r*weightMul-maxrb)*2.0);\n    // #endif\n\n    // #ifdef MODE_G\n    //   float maxrb = max( col.r, col.b );\n    //   float perc = min(1.0,(col.g*weightMul-maxrb)*2.0);\n    //   col.g=min(maxrb,col.g);\n    // #endif\n\n    // #ifdef MODE_COLOR\n    float perc=chromaKey(col);\n    // #endif\n\n    float len=length(col);\n    col=normalize(col)*len;\n\n    col.a=1.0-perc;\n    outColor= col;\n}\n\n\n\n",};
const
    render = op.inTrigger("Render"),
    w = op.inValueSlider("WeightMul", 0.6),
    inR = op.inFloat("R", Math.random()),
    inG = op.inFloat("G", Math.random()),
    inB = op.inFloat("B", Math.random()),
    trigger = op.outTrigger("Next");

op.setPortGroup("Color", [inR, inG, inB]);
inR.setUiAttribs({ "colorPick": true });

const
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.chromakey_frag);

new CGL.Uniform(shader, "t", "tex", 0),
new CGL.Uniform(shader, "3f", "color", inR, inG, inB),
new CGL.Uniform(shader, "f", "weightMul", w);

render.onTriggered = function ()
{
    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Dev.Gl.TextureEffects.ChromaKeyAlpha.prototype = new CABLES.Op();
CABLES.OPS["5614f8a5-7267-4ed6-9cf9-b4a3c7531f7d"]={f:Ops.Dev.Gl.TextureEffects.ChromaKeyAlpha,objName:"Ops.Dev.Gl.TextureEffects.ChromaKeyAlpha"};




// **************************************************************
// 
// Ops.Dev.GlArrayCurlNoise
// 
// **************************************************************

Ops.Dev.GlArrayCurlNoise = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"curlnoise_frag":"UNI float z;\nUNI float x;\nUNI float y;\nUNI float scale;\nIN vec2 texCoord;\nUNI sampler2D tex;\n\nUNI float amount;\nUNI float timeDelta;\nUNI float offset;\n\n{{CGL.BLENDMODES}}\n{{CGL.RANDOM_TEX}}\n\nfloat Interpolation_C2( float x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }   //  6x^5-15x^4+10x^3\t( Quintic Curve.  As used by Perlin in Improved Noise.  http://mrl.nyu.edu/~perlin/paper445.pdf )\nvec2 Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 Interpolation_C2( vec3 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2( vec4 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2_InterpAndDeriv( vec2 x ) { return x.xyxy * x.xyxy * ( x.xyxy * ( x.xyxy * ( x.xyxy * vec2( 6.0, 0.0 ).xxyy + vec2( -15.0, 30.0 ).xxyy ) + vec2( 10.0, -60.0 ).xxyy ) + vec2( 0.0, 30.0 ).xxyy ); }\nvec3 Interpolation_C2_Deriv( vec3 x ) { return x * x * (x * (x * 30.0 - 60.0) + 30.0); }\n\n\nvoid FAST32_hash_3D( \tvec3 gridcell,\n                        out vec4 lowz_hash_0,\n                        out vec4 lowz_hash_1,\n                        out vec4 lowz_hash_2,\n                        out vec4 highz_hash_0,\n                        out vec4 highz_hash_1,\n                        out vec4 highz_hash_2\t)\t\t//\tgenerates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\n\n//\n//\tPerlin Noise 3D  ( gradient noise )\n//\tReturn value range of -1.0->1.0\n//\thttp://briansharpe.files.wordpress.com/2011/11/perlinsample.jpg\n//\nfloat Perlin3D( vec3 P )\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n#if 1\n    //\n    //\tclassic noise.\n    //\trequires 3 random values per point.  with an efficent hash function will run faster than improved noise\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n    //SGPP_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n\n    //\tcalculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n#if 1\n    //\tClassic Perlin Interpolation\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    final *= 1.1547005383792515290182975610039;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/sqrt(0.75)\n    return final;\n#else\n    //\tClassic Perlin Surflet\n    //\thttp://briansharpe.wordpress.com/2012/03/09/modifications-to-classic-perlin-noise/\n    Pf *= Pf;\n    Pf_min1 *= Pf_min1;\n    vec4 vecs_len_sq = vec4( Pf.x, Pf_min1.x, Pf.x, Pf_min1.x ) + vec4( Pf.yy, Pf_min1.yy );\n    float final = dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf.zzzz ) ), grad_results_0 ) + dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf_min1.zzzz ) ), grad_results_1 );\n    final *= 2.3703703703703703703703703703704;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/cube(0.75)\n    return final;\n#endif\n\n#else\n    //\n    //\timproved noise.\n    //\trequires 1 random value per point.  Will run faster than classic noise if a slow hashing function is used\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_lowz, hash_highz;\n    FAST32_hash_3D( Pi, hash_lowz, hash_highz );\n    //BBS_hash_3D( Pi, hash_lowz, hash_highz );\n    //SGPP_hash_3D( Pi, hash_lowz, hash_highz );\n\n    //\n    //\t\"improved\" noise using 8 corner gradients.  Faster than the 12 mid-edge point method.\n    //\tKen mentions using diagonals like this can cause \"clumping\", but we'll live with that.\n    //\t[1,1,1]  [-1,1,1]  [1,-1,1]  [-1,-1,1]\n    //\t[1,1,-1] [-1,1,-1] [1,-1,-1] [-1,-1,-1]\n    //\n    hash_lowz -= 0.5;\n    vec4 grad_results_0_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_lowz );\n    hash_lowz = abs( hash_lowz ) - 0.25;\n    vec4 grad_results_0_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_lowz );\n    vec4 grad_results_0_2 = Pf.zzzz * sign( abs( hash_lowz ) - 0.125 );\n    vec4 grad_results_0 = grad_results_0_0 + grad_results_0_1 + grad_results_0_2;\n\n    hash_highz -= 0.5;\n    vec4 grad_results_1_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_highz );\n    hash_highz = abs( hash_highz ) - 0.25;\n    vec4 grad_results_1_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_highz );\n    vec4 grad_results_1_2 = Pf_min1.zzzz * sign( abs( hash_highz ) - 0.125 );\n    vec4 grad_results_1 = grad_results_1_0 + grad_results_1_1 + grad_results_1_2;\n\n    //\tblend the gradients and return\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy ) * (2.0 / 3.0);\t//\t(optionally) mult by (2.0/3.0) to scale to a strict -1.0->1.0 range\n#endif\n}\n\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n\n\n    vec3 rnd=\n        vec3(\n            Perlin3D( ( (base.xyz+20.0) + vec3(x,y,z)) *scale ),\n            Perlin3D( ( (base.xyz-20.0) + vec3(x,y,z)) *scale ),\n            Perlin3D( ( (base.xyz+60.0) + vec3(x,y,z)) *scale )\n        );\n\n\n    vec3 noise=(cgl_random3(texCoord.xy)-0.5)*offset;\n    rnd+=\n        vec3(\n            Perlin3D( ( (base.xyz+20.0+noise.x) + vec3(x,y,z)) *scale ),\n            Perlin3D( ( (base.xyz-20.0+noise.y) + vec3(x,y,z)) *scale ),\n            Perlin3D( ( (base.xyz+60.0+noise.z) + vec3(x,y,z)) *scale )\n        );\n\n\n    // rnd=\n    // (\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0) + vec3(x,y,z)) *scale )\n    //     )+\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0+(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0+(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0+(offset*scale)) + vec3(x,y,z)) *scale )\n    //     )*0.25+\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0-(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0-(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0-(offset*scale)) + vec3(x,y,z)) *scale )\n    //     )*0.25+\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0-(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0+(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0-(offset*scale)) + vec3(x,y,z)) *scale )\n    //     )*0.25+\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0+(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0-(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0+(offset*scale)) + vec3(x,y,z)) *scale )\n    //     )*0.25\n\n    //     )/2.0;\n\n\n\n\n\n\n\n    #ifdef MOD_NORM_SPEED\n        rnd=normalize(rnd)*0.2;\n    #endif\n    #ifndef MOD_NORM_SPEED\n        // rnd*=timeDelta;\n    #endif\n\n    // rnd=clamp(rnd,vec3(-0.01),vec3(0.01));\n    // rnd*=0.01;\n    // float cl=0.03;\n    // rnd.x=clamp(rnd.x,-cl,cl);\n    // rnd.y=clamp(rnd.y,-cl,cl);\n    // rnd.z=clamp(rnd.z,-cl,cl);\n\n    rnd*=timeDelta;\n\n    vec3 coord=base.xyz+rnd;\n    // coord.x+=( Perlin3D( ( (base.xyz+20.0) + vec3(x,y,z)) *scale )*timeDelta);\n    // coord.y+=( Perlin3D( ( (base.xyz-20.0) + vec3(x,y,z)) *scale )*timeDelta);\n    // coord.z+=( Perlin3D( ( (base.xyz+30.0) + vec3(x,y,z)) *scale )*timeDelta);\n\n    // additional noise on top\n    // coord.x+=Perlin3D(vec3(texCoord.x))*0.001;\n    // coord.y+=Perlin3D(vec3(texCoord.y))*0.001;\n    // coord.z+=Perlin3D(vec3(texCoord.y,texCoord.x,texCoord.y))*0.001;\n\n\n    outColor=vec4(coord,1.0);\n\n\n    // outColor=cgl_blend(base,col,amount);\n}\n",};
const
    render = op.inTrigger("Render"),
    inTex = op.inTexture("GlArray"),
    scale = op.inValue("Scale", 1),
    time = op.inValue("Time", 0),

    inNormSpeed = op.inBool("Normalize Speed", false),

    x = op.inValue("X", 0),
    y = op.inValue("Y", 0),
    z = op.inValue("Z", 0),
    a = op.inValue("a", 1),

    inOffset = op.inFloatSlider("offset", 0),
    trigger = op.outTrigger("trigger"),
    outTex = op.outTexture("Result");

let lastTime = time.get();
render.onTriggered = dorender;

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
const texMath = new CGL.ShaderTextureMath(cgl, op.objName, { "texturePort": inTex });

shader.setSource(shader.getDefaultVertexShader(), attachments.curlnoise_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniformR = new CGL.Uniform(shader, "f", "x", x),
    uniformG = new CGL.Uniform(shader, "f", "y", y),
    uniformB = new CGL.Uniform(shader, "f", "z", z),
    uniformA = new CGL.Uniform(shader, "f", "scale", scale),
    uniformTimeDelta = new CGL.Uniform(shader, "f", "timeDelta", 0),
    uniforoffs = new CGL.Uniform(shader, "f", "offset", inOffset);

inNormSpeed.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("MOD_NORM_SPEED", inNormSpeed.get());
}

function dorender()
{
    uniformTimeDelta.set(time.get() - lastTime);
    lastTime = time.get();

    outTex.set(null);
    const finTex = texMath.render(shader);
    outTex.set(finTex);
    trigger.trigger();
}


};

Ops.Dev.GlArrayCurlNoise.prototype = new CABLES.Op();
CABLES.OPS["25467f40-8f78-4dca-ba6c-951ae49cac59"]={f:Ops.Dev.GlArrayCurlNoise,objName:"Ops.Dev.GlArrayCurlNoise"};




// **************************************************************
// 
// Ops.Dev.GlArrayMath
// 
// **************************************************************

Ops.Dev.GlArrayMath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbMath_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D tex2;\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n    vec4 v=vec4(r,g,b,a);\n\n    #ifdef MOD_USE_TEX\n        v=texture(tex2,texCoord);\n    #endif\n\n\n    #ifdef MOD_OP_SUB_CX\n        #ifdef MOD_CHAN_R\n            col.r=col.r-v.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g=col.g-v.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b=col.b-v.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a=col.a-v.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_SUB_XC\n        #ifdef MOD_CHAN_R\n            col.r=v.r-col.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g=v.g-col.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b=v.b-col.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a=v.a-col.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_ADD\n        #ifdef MOD_CHAN_R\n            col.r+=v.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g+=v.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b+=v.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a+=v.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_MUL\n        #ifdef MOD_CHAN_R\n            col.r*=v.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g*=v.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b*=v.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a*=v.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_DIV_XC\n        #ifdef MOD_CHAN_R\n            col.r=v.r/col.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g=v.g/col.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b=v.b/col.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a=v.a/col.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_DIV_CX\n        #ifdef MOD_CHAN_R\n            col.r=col.r/v.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g=col.g/v.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b=col.b/v.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a=col.a/v.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_MODULO\n        col=mod(col,v);\n    #endif\n\n\n   outColor= col;\n}\n",};
const
    render = op.inTrigger("Render"),
    inTex = op.inTexture("GlArray"),
    inOp = op.inSwitch("Operation", ["c-x", "x-c", "c+x", "c*x", "x/c", "c/x", "c%x"], "c*x"),
    chanR = op.inBool("R Active", true),
    chanG = op.inBool("G Active", true),
    chanB = op.inBool("B Active", true),
    chanA = op.inBool("A Active", false),
    inTex2 = op.inTexture("Value"),
    r = op.inValue("r", 1),
    g = op.inValue("g", 1),
    b = op.inValue("b", 1),
    a = op.inValue("a", 1),
    trigger = op.outTrigger("trigger"),
    outTex = op.outTexture("Result");

render.onTriggered = dorender;

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
const texMath = new CGL.ShaderTextureMath(cgl, op.objName, { "texturePort": inTex });

shader.setSource(shader.getDefaultVertexShader(), attachments.rgbMath_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const textureUniform2 = new CGL.Uniform(shader, "t", "tex2", 1);

const uniformR = new CGL.Uniform(shader, "f", "r", r);
const uniformG = new CGL.Uniform(shader, "f", "g", g);
const uniformB = new CGL.Uniform(shader, "f", "b", b);
const uniformA = new CGL.Uniform(shader, "f", "a", a);

chanR.onChange =
    chanG.onChange =
    chanB.onChange =
    chanA.onChange =
    inTex2.onChange =
    inOp.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("MOD_OP_SUB_CX", inOp.get() === "c-x");
    shader.toggleDefine("MOD_OP_SUB_XC", inOp.get() === "x-c");

    shader.toggleDefine("MOD_OP_ADD", inOp.get() === "c+x");
    shader.toggleDefine("MOD_OP_MUL", inOp.get() === "c*x");

    shader.toggleDefine("MOD_OP_DIV_XC", inOp.get() === "x/c");
    shader.toggleDefine("MOD_OP_DIV_CX", inOp.get() === "c/x");

    shader.toggleDefine("MOD_OP_MODULO", inOp.get() === "c%x");

    shader.toggleDefine("MOD_USE_TEX", inTex2.get());

    shader.toggleDefine("MOD_CHAN_R", chanR.get());
    r.setUiAttribs({ "greyout": !chanR.get() || inTex2.get() });

    shader.toggleDefine("MOD_CHAN_G", chanG.get());
    g.setUiAttribs({ "greyout": !chanG.get() || inTex2.get() });

    shader.toggleDefine("MOD_CHAN_B", chanB.get());
    b.setUiAttribs({ "greyout": !chanB.get() || inTex2.get() });

    shader.toggleDefine("MOD_CHAN_A", chanA.get());
    a.setUiAttribs({ "greyout": !chanA.get() || inTex2.get() });
}

function dorender()
{
    shader.popTextures();
    if (inTex.get()) shader.pushTexture(textureUniform, inTex.get().tex);
    if (inTex2.get()) shader.pushTexture(textureUniform2, inTex2.get().tex);

    const finTex = texMath.render(shader);

    outTex.set(null);
    outTex.set(finTex);
    trigger.trigger();
}


};

Ops.Dev.GlArrayMath.prototype = new CABLES.Op();
CABLES.OPS["0204b33a-2917-4eea-9c31-3b185e4fe638"]={f:Ops.Dev.GlArrayMath,objName:"Ops.Dev.GlArrayMath"};




// **************************************************************
// 
// Ops.Dev.GlArrayModulo
// 
// **************************************************************

Ops.Dev.GlArrayModulo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbMath_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n\nUNI float modX;\nUNI float modY;\nUNI float modZ;\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\n    #ifdef MOD_MODULO_X\n        col.x=mod(col.x,modX);\n    #endif\n\n    #ifdef MOD_MODULO_Z\n        col.y=mod(col.y,modY);\n    #endif\n\n    #ifdef MOD_MODULO_Z\n        col.z=mod(col.z,modZ);\n    #endif\n\n   outColor= col;\n}\n",};
const
    render = op.inTrigger("Render"),
    inTex = op.inTexture("GlArray"),

    inDoModX = op.inBool("X",true),
    inModX = op.inValue("Modulo X", 1),

    inDoModY = op.inBool("Y",true),
    inModY = op.inValue("Modulo Y", 1),

    inDoModZ = op.inBool("Z",true),
    inModZ = op.inValue("Modulo Z", 1),

    trigger = op.outTrigger("trigger"),
    outTex = op.outTexture("Result");

render.onTriggered = dorender;

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
const texMath = new CGL.ShaderTextureMath(cgl, op.objName, { "texturePort": inTex });

shader.setSource(shader.getDefaultVertexShader(), attachments.rgbMath_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniModX = new CGL.Uniform(shader, "f", "modX", inModX),
    uniModY = new CGL.Uniform(shader, "f", "modY", inModY),
    uniModZ = new CGL.Uniform(shader, "f", "modZ", inModZ);

inDoModX.onChange =
inDoModY.onChange =
inDoModZ.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    shader.toggleDefine("MOD_MODULO_X", inDoModX.get());
    inModX.setUiAttribs({ "greyout": !inDoModX.get() });

    shader.toggleDefine("MOD_MODULO_Y", inDoModY.get());
    inModY.setUiAttribs({ "greyout": !inDoModY.get() });

    shader.toggleDefine("MOD_MODULO_Z", inDoModZ.get());
    inModZ.setUiAttribs({ "greyout": !inDoModZ.get() });
}

function dorender()
{
    const finTex = texMath.render(shader);
    outTex.set(finTex);
    trigger.trigger();
}


};

Ops.Dev.GlArrayModulo.prototype = new CABLES.Op();
CABLES.OPS["a017cc92-2354-45df-820f-ed6aad3bbb0e"]={f:Ops.Dev.GlArrayModulo,objName:"Ops.Dev.GlArrayModulo"};




// **************************************************************
// 
// Ops.Dev.GlArrayNormalize
// 
// **************************************************************

Ops.Dev.GlArrayNormalize = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbMath_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n\nUNI float modX;\nUNI float modY;\nUNI float modZ;\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\ncol.xyz=normalize(col.xyz);\n\n   outColor= col;\n}\n",};
const
    render = op.inTrigger("Render"),
    inTex = op.inTexture("GlArray"),

    trigger = op.outTrigger("trigger"),
    outTex = op.outTexture("Result");

render.onTriggered = dorender;

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
const texMath = new CGL.ShaderTextureMath(cgl, op.objName, { "texturePort": inTex });

shader.setSource(shader.getDefaultVertexShader(), attachments.rgbMath_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);



function dorender()
{
    const finTex = texMath.render(shader);
    outTex.set(finTex);
    trigger.trigger();
}


};

Ops.Dev.GlArrayNormalize.prototype = new CABLES.Op();
CABLES.OPS["c7ee53af-2d34-4ca9-bcea-5cbf7f5aab4e"]={f:Ops.Dev.GlArrayNormalize,objName:"Ops.Dev.GlArrayNormalize"};




// **************************************************************
// 
// Ops.Dev.GlArrayRandom
// 
// **************************************************************

Ops.Dev.GlArrayRandom = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"randoms_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\n\nUNI float seed;\n\nUNI float rmin;\nUNI float rmax;\nUNI float gmin;\nUNI float gmax;\nUNI float bmin;\nUNI float bmax;\n\n{{CGL.BLENDMODES}}\n{{MODULES_HEAD}}\n\n{{CGL.RANDOM_TEX}}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nvoid main()\n{\n    vec4 rnd=vec4((cgl_random3(texCoord.xy + vec2(seed))), 1.0);\n\n    rnd.r=map(rnd.x, 0., 1., rmin, rmax);\n    rnd.y=map(rnd.y, 0., 1., gmin, gmax);\n    rnd.z=map(rnd.z, 0., 1., bmin, bmax);\n    rnd.a=1.0;\n\n    // vec4 base¿=texture(tex,texCoord);\n    // vec4 col¿=vec4( _blend(base.rgb,rnd.rgb) ,1.0);\n\n    // outColor=vec4( mix( col.rgb, base.rgb ,1.0-base.a*amount),1.0);\n    outColor=rnd;\n}",};
const
    render = op.inTrigger("Render"),
    next = op.outTrigger("Next"),
    inNum = op.inInt("Length", 10000),
    inLayout = op.inSwitch("Layout", ["Square", "Vertical", "Horizontal"], "Square"),

    inRMin = op.inFloat("X Min", 0),
    inRMax = op.inFloat("X Max", 1),

    inGMin = op.inFloat("Y Min", 0),
    inGMax = op.inFloat("Y Max", 1),

    inBMin = op.inFloat("Z Min", 0),
    inBMax = op.inFloat("Z Max", 1),

    inSeed = op.inFloat("Seed", 1),

    outTex = op.outTexture("Result");

render.onTriggered = dorender;

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
let texMath = null;// = new CGL.ShaderTextureMath(cgl, op.objName, { "width":100,"height":100 });

updateSize();

shader.setSource(shader.getDefaultVertexShader(), attachments.randoms_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniformRMin = new CGL.Uniform(shader, "f", "rmin", inRMin),
    uniformRMax = new CGL.Uniform(shader, "f", "rmax", inRMax),
    uniformGMin = new CGL.Uniform(shader, "f", "gmin", inGMin),
    uniformGMax = new CGL.Uniform(shader, "f", "gmax", inGMax),
    uniformBMin = new CGL.Uniform(shader, "f", "bmin", inBMin),
    uniformBMax = new CGL.Uniform(shader, "f", "bmax", inBMax),
    uniformSeed = new CGL.Uniform(shader, "f", "seed", inSeed);

updateDefines();

inLayout.onChange =
    inNum.onChange = updateSize;

function updateSize()
{
    let w = Math.ceil(Math.sqrt(inNum.get())); // square texture size
    let h = w;
    const max = op.patch.cgl.gl.getParameter(op.patch.cgl.gl.MAX_TEXTURE_SIZE);

    if (inLayout.get() === "Vertical" || inLayout.get() === "Horizontal")
    {
        if (inNum.get() < max)
        {
            w = 1;
            h = inNum.get();
        }
        else
        {
            w = Math.ceil(inNum.get() / max);
            h = max;
        }
    }

    if (inLayout.get() === "Horizontal")
    {
        let x = w;
        w = h;
        h = x;
    }

    texMath = new CGL.ShaderTextureMath(cgl, op.objName, { "width": w, "height": h });
}

function updateDefines()
{

}

function dorender()
{
    const finTex = texMath.render(shader);
    outTex.set(finTex);
    next.trigger();
}


};

Ops.Dev.GlArrayRandom.prototype = new CABLES.Op();
CABLES.OPS["041f5b18-74b4-4a03-9987-4451bd334464"]={f:Ops.Dev.GlArrayRandom,objName:"Ops.Dev.GlArrayRandom"};




// **************************************************************
// 
// Ops.Dev.GlPatch
// 
// **************************************************************

Ops.Dev.GlPatch = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    refresh = op.inTriggerButton("Refresh"),
    debug = op.inTriggerButton("debug"),
    next = op.inTrigger("Next");

const p = new CABLES.GLGUI.GlPatch(op.patch.cgl);
const api = new CABLES.GLGUI.GlPatchAPI(op.patch, p);

let firstTime = true;

refresh.onTriggered = function ()
{
    api.reset();
};

render.onTriggered = function ()
{
    if (firstTime)
    {
        api.reset();
        firstTime = false;
    }

    p.render(
        op.patch.cgl.canvasWidth,
        op.patch.cgl.canvasHeight
    );
    next.trigger();
};

debug.onTriggered = () =>
{
    let count = 0;
    for (const i in p._glOpz)
    {
        p._glOpz[i].updateVisible();
        p._glOpz[i].updatePosition();

        for (const k in p._glOpz[i]._links)
        {
            count++;
            if (p._glOpz[i]._links[k]) p._glOpz[i]._links[k].update();
            console.log(p._glOpz[i]._links[k]);

            p._glOpz[i]._links[k]._cable.updateLineStyle();
            p._glOpz[i]._links[k]._cable._updateLinePos();
        }
    }
};


};

Ops.Dev.GlPatch.prototype = new CABLES.Op();
CABLES.OPS["ad6e3e6b-9d88-4378-b09f-6b57999d4f91"]={f:Ops.Dev.GlPatch,objName:"Ops.Dev.GlPatch"};




// **************************************************************
// 
// Ops.Dev.GltfExplodeNodes
// 
// **************************************************************

Ops.Dev.GltfExplodeNodes = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Update"),
    inFilter = op.inString("Filter", ""),

    inSeed = op.inFloat("Seed", 1),

    axisX = op.inFloat("Axis X", 0),
    axisY = op.inFloat("Axis Y", 0),
    axisZ = op.inFloat("Axis Z", 0),

    rotationX = op.inFloat("Rotation X", 0),
    rotationY = op.inFloat("Rotation Y", 0),
    rotationZ = op.inFloat("Rotation Z", 0),

    pivotOffsetX = op.inFloat("Random Pivot Offset X", 0),
    pivotOffsetY = op.inFloat("Random Pivot Offset Y", 0),
    pivotOffsetZ = op.inFloat("Random Pivot Offset Z", 0),

    next = op.outTrigger("Next"),
    outNum = op.outNumber("Found");

const cgl = op.patch.cgl;

const mat = mat4.create();

inExec.onTriggered = function ()
{
    if (!cgl.frameStore.currentScene) return;

    let node = null;

    const ax = axisX.get();
    const ay = axisY.get();
    const az = axisZ.get();

    Math.randomSeed = inSeed.get();
    let found = 0;

    for (let i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
    {
        if (cgl.frameStore.currentScene.nodes[i].name.indexOf(inFilter.get()) >= 0)
        {
            node = cgl.frameStore.currentScene.nodes[i];

            found++;

            const oldTrans = vec3.create();

            mat4.getTranslation(oldTrans, node.mat);

            // const v = Math.sin(time + (Math.seededRandom() * offs)) * ampl;
            // node.addTranslate = [v * ax, v * ay, v * az];
            node.addTranslate = [oldTrans[0] * axisX.get(), oldTrans[1] * axisY.get(), oldTrans[2] * axisZ.get()];

            mat4.identity(mat);
            mat4.rotateX(mat, mat, rotationX.get() * (Math.seededRandom() * 301) * CGL.DEG2RAD);
            mat4.rotateY(mat, mat, rotationY.get() * (Math.seededRandom() * 301) * CGL.DEG2RAD);
            mat4.rotateZ(mat, mat, rotationZ.get() * (Math.seededRandom() * 301) * CGL.DEG2RAD);

            mat4.translate(mat, mat, [(Math.seededRandom() - 0.5) * pivotOffsetX.get(), (Math.seededRandom() - 0.5) * pivotOffsetY.get(), (Math.seededRandom() - 0.5) * pivotOffsetZ.get()]);

            node.addMulMat = mat;
        }
    }

    outNum.set(found);

    next.trigger();
};


};

Ops.Dev.GltfExplodeNodes.prototype = new CABLES.Op();
CABLES.OPS["5652c2ef-2a9f-48f6-80ef-70e154db04b5"]={f:Ops.Dev.GltfExplodeNodes,objName:"Ops.Dev.GltfExplodeNodes"};




// **************************************************************
// 
// Ops.Dev.Graphics.Meshes.Circle_v2
// 
// **************************************************************

Ops.Dev.Graphics.Meshes.Circle_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Trigger"),
    radius = op.inValue("radius", 0.5),
    innerRadius = op.inValueSlider("innerRadius", 0),
    segments = op.inValueInt("segments", 40),
    percent = op.inValueSlider("percent", 1),
    steps = op.inValue("steps", 0),
    invertSteps = op.inValueBool("invertSteps", false),
    mapping = op.inSwitch("mapping", ["flat", "round"], "flat"),
    drawSpline = op.inValueBool("Spline", false),
    doRender = op.inValueBool("Render", true),
    trigger = op.outTrigger("next"),
    geomOut = op.outObject("geometry", null, "geometry");

op.setPortGroup("Size", [radius, innerRadius]);
op.setPortGroup("Display", [percent, steps, invertSteps]);

mapping.onChange =
    segments.onChange =
    radius.onChange =
    innerRadius.onChange =
    percent.onChange =
    steps.onChange =
    invertSteps.onChange =
    drawSpline.onChange = calcLater;

geomOut.ignoreValueSerialize = true;

let geom = new CGL.Geometry("circle");
let mesh = null;
const lastSegs = -1;

let oldPrim = 0;
let shader = null;
let needsCalc = true;

render.onTriggered = renderMesh;

op.preRender = () =>
{
    renderMesh();
};

render.onLinkChanged = () =>
{
    if (!trigger.isLinked())
    {
        if (mesh) mesh.dispose();
        mesh = null;
        geomOut.set(null);
    }
};

function renderMesh()
{
    const cgl = op.patch.cg;
    if (!CGL.TextureEffect.checkOpNotInTextureEffect(op)) return;

    if (needsCalc)calc();
    shader = cgl.getShader();
    if (!shader) return;
    oldPrim = shader.glPrimitive;

    if (drawSpline.get()) shader.glPrimitive = cgl.gl.LINE_STRIP;

    if (mesh && doRender.get())mesh.render(shader);
    trigger.trigger();

    shader.glPrimitive = oldPrim;
}

function calc()
{
    const segs = Math.max(3, Math.floor(segments.get()));

    geom.clear();

    const faces = [];
    const texCoords = [];
    const vertexNormals = [];
    const tangents = [];
    const biTangents = [];

    let i = 0, degInRad = 0;
    let oldPosX = 0, oldPosY = 0;
    let oldPosXTexCoord = 0, oldPosYTexCoord = 0;

    let oldPosXIn = 0, oldPosYIn = 0;
    let oldPosXTexCoordIn = 0, oldPosYTexCoordIn = 0;

    let posxTexCoordIn = 0, posyTexCoordIn = 0;
    let posxTexCoord = 0, posyTexCoord = 0;
    let posx = 0, posy = 0;

    const perc = Math.max(0.0, percent.get());
    const verts = [];

    if (drawSpline.get())
    {
        let lastX = 0;
        let lastY = 0;
        const tc = [];
        for (i = 0; i <= segs * perc; i++)
        {
            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            posyTexCoord = 0.5;

            if (i > 0)
            {
                verts.push(lastX);
                verts.push(lastY);
                verts.push(0);
                posxTexCoord = 1.0 - (i - 1) / segs;

                tc.push(posxTexCoord, posyTexCoord);
            }
            verts.push(posx);
            verts.push(posy);
            verts.push(0);

            lastX = posx;
            lastY = posy;
        }
        geom.setPointVertices(verts);
    }
    else
    if (innerRadius.get() <= 0)
    {
        for (i = 0; i <= segs * perc; i++)
        {
            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            if (mapping.get() == "flat")
            {
                posxTexCoord = (Math.cos(degInRad) + 1.0) / 2;
                posyTexCoord = 1.0 - (Math.sin(degInRad) + 1.0) / 2;
                posxTexCoordIn = 0.5;
                posyTexCoordIn = 0.5;
            }
            else if (mapping.get() == "round")
            {
                posxTexCoord = 1.0 - i / segs;
                posyTexCoord = 0;
                posxTexCoordIn = posxTexCoord;
                posyTexCoordIn = 1;
            }

            faces.push(
                [posx, posy, 0],
                [oldPosX, oldPosY, 0],
                [0, 0, 0]
            );

            texCoords.push(posxTexCoord, posyTexCoord, oldPosXTexCoord, oldPosYTexCoord, posxTexCoordIn, posyTexCoordIn);
            vertexNormals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
            tangents.push(1, 0, 0, 1, 0, 0, 1, 0, 0);
            biTangents.push(0, -1, 0, 0, -1, 0, 0, -1, 0);

            oldPosXTexCoord = posxTexCoord;
            oldPosYTexCoord = posyTexCoord;

            oldPosX = posx;
            oldPosY = posy;
        }

        geom = CGL.Geometry.buildFromFaces(faces, "circle");
        geom.vertexNormals = vertexNormals;
        geom.tangents = tangents;
        geom.biTangents = biTangents;
        geom.texCoords = texCoords;
    }
    else
    {
        let count = 0;
        const numSteps = segs * perc;
        const pos = 0;

        for (i = 0; i <= numSteps; i++)
        {
            count++;

            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            const posxIn = Math.cos(degInRad) * innerRadius.get() * radius.get();
            const posyIn = Math.sin(degInRad) * innerRadius.get() * radius.get();

            if (mapping.get() == "round")
            {
                posxTexCoord = 1.0 - i / segs;
                posyTexCoord = 0;
                posxTexCoordIn = posxTexCoord;
                posyTexCoordIn = 1;
            }

            if (steps.get() === 0.0 ||
                (count % parseInt(steps.get(), 10) === 0 && !invertSteps.get()) ||
                (count % parseInt(steps.get(), 10) !== 0 && invertSteps.get()))
            {
                faces.push(
                    [posx, posy, 0],
                    [oldPosX, oldPosY, 0],
                    [posxIn, posyIn, 0]
                );

                faces.push(
                    [posxIn, posyIn, 0],
                    [oldPosX, oldPosY, 0],
                    [oldPosXIn, oldPosYIn, 0]
                );

                texCoords.push(
                    posxTexCoord, 0,
                    oldPosXTexCoord, 0,
                    posxTexCoordIn, 1,

                    posxTexCoord, 1,
                    oldPosXTexCoord, 0,
                    oldPosXTexCoordIn, 1);

                vertexNormals.push(
                    0, 0, 1, 0, 0, 1, 0, 0, 1,
                    0, 0, 1, 0, 0, 1, 0, 0, 1
                );
                tangents.push(
                    1, 0, 0, 1, 0, 0, 1, 0, 0,
                    1, 0, 0, 1, 0, 0, 1, 0, 0
                );
                biTangents.push(
                    0, -1, 0, 0, -1, 0, 0, -1, 0,
                    0, -1, 0, 0, -1, 0, 0, -1, 0);
            }

            oldPosXTexCoordIn = posxTexCoordIn;
            oldPosYTexCoordIn = posyTexCoordIn;

            oldPosXTexCoord = posxTexCoord;
            oldPosYTexCoord = posyTexCoord;

            oldPosX = posx;
            oldPosY = posy;

            oldPosXIn = posxIn;
            oldPosYIn = posyIn;
        }

        geom = CGL.Geometry.buildFromFaces(faces, "circle");
        geom.vertexNormals = vertexNormals;
        geom.tangents = tangents;
        geom.biTangents = biTangents;

        if (mapping.get() == "flat") geom.mapTexCoords2d();
        else geom.texCoords = texCoords;
    }

    geomOut.set(null);
    geomOut.set(geom);

    if (geom.vertices.length == 0) return;
    if (mesh) mesh.dispose();
    mesh = op.patch.cg.createMesh(geom);
    needsCalc = false;
}

function calcLater()
{
    needsCalc = true;
}

op.onDelete = function ()
{
    if (mesh)mesh.dispose();
};


};

Ops.Dev.Graphics.Meshes.Circle_v2.prototype = new CABLES.Op();
CABLES.OPS["e1dc7dd7-269e-4f6f-8522-35e641d7af9a"]={f:Ops.Dev.Graphics.Meshes.Circle_v2,objName:"Ops.Dev.Graphics.Meshes.Circle_v2"};




// **************************************************************
// 
// Ops.Dev.InstancedModulo
// 
// **************************************************************

Ops.Dev.InstancedModulo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorize_frag":"\n\n\n\nvec4 MOD_col=texture(MOD_texture,MOD_coord);\n\n#ifdef METH_ADD\ncol.rgb+=MOD_col.rgb*MOD_strength;\n#endif\n#ifdef METH_MUL\ncol.rgb*=MOD_col.rgb*MOD_strength;\n#endif\n\n#ifdef MOD_DEBUG\n    col.rg=mod(MOD_coord,1.0).rg;\n#endif\n","colorize_head_frag":"\nIN vec2 MOD_coord;\n\nUNI sampler2D MOD_texture;\nUNI float MOD_strength;","displace_vert":"\n#ifdef INSTANCING\n\nvec4 MOD_p=vec4(instMat[3][0],instMat[3][1],instMat[3][2],0.0);\n// MOD_coord=MOD_p.xy*(1.0/MOD_scale)+MOD_offset-vec2(0.5,0.5);\n\nMOD_p*=viewMatrix;\n\n// pos.x=mod(MOD_p.x,20.0);\n\nmMatrix[3].x=-viewMatrix[3].x+mod(viewMatrix[3].x-mMatrix[3].x,MOD_size.x)-(MOD_size.x/2.0)-MOD_pos.x;\nmMatrix[3].y=-2.0*viewMatrix[3].y+mod(viewMatrix[3].y-mMatrix[3].y,MOD_size.y)-(MOD_size.y/2.0)-MOD_pos.y;\n// mMatrix[3].y=mMatrix[3].y;\nmMatrix[3].z=mMatrix[3].z;\n\n\n#endif\n\n","displace_head_vert":"OUT vec2 MOD_coord;\n\n// #ifdef MOD_COLORIZE\n//     OUT vec3 MOD_dispColor;\n// #endif",};
const
    inTrigger = op.inTrigger("Trigger"),
    inWidth = op.inFloat("Width", 0),
    inHeight = op.inFloat("Height", 0),
    inX = op.inFloat("Pos X", 0),
    inY = op.inFloat("Pos Y", 0),
    next = op.outTrigger("Next");

inTrigger.onTriggered = render;

const cgl = op.patch.cgl;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.displace_head_vert || "",
    "srcBodyVert": attachments.displace_vert || ""
});

// mod.addModule({
//     "title": op.name,
//     "name": "MODULE_COLOR",
//     "srcHeadFrag": attachments.colorize_head_frag,
//     "srcBodyFrag": attachments.colorize_frag
// });

mod.addUniformVert("2f", "MOD_size", inWidth, inHeight);
mod.addUniformVert("2f", "MOD_pos", inX, inY);

function updateDefines()
{
}

function render()
{
    mod.bind();
    next.trigger();
    mod.unbind();
}


};

Ops.Dev.InstancedModulo.prototype = new CABLES.Op();
CABLES.OPS["7d944e9c-c21a-460b-be18-17aa3233fde3"]={f:Ops.Dev.InstancedModulo,objName:"Ops.Dev.InstancedModulo"};




// **************************************************************
// 
// Ops.Dev.Json.ObjectSpreadSheet
// 
// **************************************************************

Ops.Dev.Json.ObjectSpreadSheet = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    spread = op.inArray("Spreadsheet"),
    inNumColumns = op.inInt("Num Columns", 2),
    result = op.outObject("Result");

spread.setUiAttribs({ "hidePort": true });
inNumColumns.setUiAttribs({ "hidePort": true });

spread.onChange = update;
inNumColumns.onChange = updateUi;

updateUi();

function updateUi()
{
    spread.setUiAttribs({
        "display": "spreadsheet",
        "spread_numColumns": inNumColumns.get()
    });
    update();
}

function update()
{
    result.set(null);

    if (!spread.get()) return;

    const data = spread.get();
    data.cells = data.cells || [];

    const obj = {};

    for (let y = 0; y < data.cells.length; y++)
    {
        if (data.cells[y])
        {
            if (data.cols == 2)
            {
                let v = data.cells[y][1] || null;
                if (CABLES.UTILS.isNumeric(v)) v = parseFloat(v);

                if (data.cells[y][0]) obj[data.cells[y][0]] = v;
            }

            if (data.cols > 2)
            {
                let row = {};

                for (let x = 1; x < data.cols; x++)
                {
                    let v = data.cells[y][x] || null;
                    if (CABLES.UTILS.isNumeric(v)) v = parseFloat(v);

                    row[getColName(data, x)] = v;
                }
                if (data.cells[y] && data.cells[y][0] && row) obj[data.cells[y][0]] = row;
            }
        }
    }
    result.set(obj);
}

function getColName(data, c)
{
    if (data && data.colNames && data.colNames.length > c && data.colNames[c])
    {
        return data.colNames[c];
    }

    let str = "";

    while (c >= 0)
    {
        str = "abcdefghijklmnopqrstuvwxyz"[c % 26] + str;
        c = Math.floor(c / 26) - 1;
    }

    return str;
}


};

Ops.Dev.Json.ObjectSpreadSheet.prototype = new CABLES.Op();
CABLES.OPS["09667032-43c9-4f7c-8740-76a90f8ac356"]={f:Ops.Dev.Json.ObjectSpreadSheet,objName:"Ops.Dev.Json.ObjectSpreadSheet"};




// **************************************************************
// 
// Ops.Dev.ParticleSystem
// 
// **************************************************************

Ops.Dev.ParticleSystem = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"particle_frag":"IN vec2 texCoord;\n\nUNI sampler2D texOldPos;\nUNI sampler2D texSpawnPos;\nUNI sampler2D texTiming;\n\nUNI sampler2D texFeedbackVel;\nUNI sampler2D texSpawnVel;\n\nUNI float mass;\nUNI float reset;\n\nUNI vec3 pos;\nUNI vec3 scale;\nUNI vec3 gravity;\n\nUNI vec2 lifeTime;\nUNI float time;\nUNI float timeDiff;\n\n\n\nUNI vec4 velocity; // xyz: xyz  / w: inherit velocity\n\n\nUNI float spread;\n\n{{MODULES_HEAD}}\n{{CGL.RANDOM_LOW}}\n\nvoid main()\n{\n    vec4 oldPos=texture(texOldPos,texCoord);\n    vec4 vtiming=texture(texTiming,texCoord);\n    vec4 oldVelocity=texture(texFeedbackVel,texCoord);\n    vec4 newPos=oldPos;//vec4(1.0);\n\n    // respawn!!\n    if( time>vtiming.g || reset==1.0 )\n    {\n        newPos.rgb =pos;\n        vec3 rnd=(cgl_random3(texCoord+gl_FragCoord.x/gl_FragCoord.y+time));\n\n        rnd=texture(texSpawnPos,rnd.xy).rgb;\n\n        oldVelocity=texture(texSpawnVel,texCoord);\n\n        newPos.rgb+=rnd;\n\n        vtiming.r=time;\n\n        vtiming.g=(cgl_random(time*texCoord)*(lifeTime.y-lifeTime.x))+lifeTime.x+time;\n\n        if(reset==1.0)\n            vtiming.g=time+cgl_random(time*22.0*texCoord)*lifeTime.y;\n    }\n\n    vtiming.a=1.0;\n\n    float lifeProgress=( (time-vtiming.r) / (vtiming.g-vtiming.r));\n\n    vec3 grav=gravity*mass*lifeProgress;\n\n\n\n    // newPos.rgb+=timeDiff*velocity.rgb*3.0;\n\n    newPos.rgb+=grav*timeDiff;\n    newPos.rgb+=velocity.xyz*timeDiff;\n\n    // newPos.g-=time*0.01;\n\n\n    // newPos.rgb+=normalize(newPos.rgb-oldPos.rgb)*0.2;\n\n    // newPos.rgb+=(oldVelocity.rgb)*smoothstep(0.0,1.0,lifeProgress)*0.9;\n    // newPos.rgb+=(oldVelocity.rgb)*(1.0-smoothstep(0.0,1.0,lifeProgress)*0.1);\n\n    newPos.rgb-=((1.0-lifeProgress)*timeDiff*40.8*velocity.w)*oldVelocity.rgb;\n\n\n    // gl_Position\n    // r:x\n    // g:y\n    // b:z\n    outColor0=vec4(newPos.rgb,1.0);\n\n    // timing\n    // r: starttime\n    // g: endtime\n    outColor1=vtiming;\n\n    // timing output\n    // r: life progress\n    outColor2=vec4(vec3(lifeProgress ),1.);\n\n    // velocity\n    // oldVelocity.rgb*=1.995;\n    outColor3=oldVelocity;\n\n\n    // outColor0=vec4(1.0,0.3,0.0,1.0);\n    // outColor1=vec4(0.0,1.0,0.0,1.0);\n    // outColor2=vec4(0.0,0.0,1.0,1.0);\n    // outColor3=vec4(1.0,1.0,0.0,1.0);\n\n\n}",};
const
    emptyTex = CGL.Texture.getEmptyTexture(op.patch.cgl),
    exec = op.inTrigger("Execute"),
    inNumParticles = op.inInt("Num Particles", 10000),
    inReset = op.inTriggerButton("Reset"),

    // inTime=op.inFloat("Time",0),
    inLifeTimeMin = op.inFloat("Min Lifetime", 0.5),
    inLifeTimeMax = op.inFloat("Max Lifetime", 2),

    inMass = op.inFloat("Mass", 0),

    posX = op.inFloatSlider("Position X", 0),
    posY = op.inFloatSlider("Position Y", 0),
    posZ = op.inFloatSlider("Position Z", 0),

    moveX = op.inFloatSlider("Velocity X", 0),
    moveY = op.inFloatSlider("Velocity Y", 1),
    moveZ = op.inFloatSlider("Velocity Z", 0),

    gravX = op.inFloatSlider("Gravity X", 0),
    gravY = op.inFloatSlider("Gravity Y", 1),
    gravZ = op.inFloatSlider("Gravity Z", 0),

    inherVel = op.inFloatSlider("Inherit Velocity", 0),

    inTexOldPos = op.inTexture("Feedback Positions"),
    inTexSpawn = op.inTexture("Spawn Positions"),
    inTexSpawnVel = op.inTexture("Spawn Velocity"),

    next = op.outTrigger("Next"),
    outTexPos = op.outTexture("Positions", emptyTex),
    outTexTiming = op.outTexture("Timing", emptyTex),
    outTest = op.outTexture("Test", emptyTex),
    outTexSize = op.outNumber("Tex Size");

op.setPortGroup("Constant Velocity", [moveX, moveY, moveZ]);
op.setPortGroup("Position", [posX, posY, posZ]);

let lastX = 0;
let lastY = 0;
let lastZ = 0;

let texTiming = null;
let texPos = null;
let lastTime = CABLES.now();

const tcPos = new CGL.CopyTexture(op.patch.cgl, "particlesys_pos",
    {
        "shader": attachments.particle_frag,
        "numRenderBuffers": 4,
        "isFloatingPointTexture": true,
        "filter": CGL.Texture.FILTER_NEAREST
    });

const tcTiming = new CGL.CopyTexture(op.patch.cgl, "particlesys_timing", { "isFloatingPointTexture": true, "filter": CGL.Texture.FILTER_NEAREST });

// only used when no input texture is given, just for simple systems...
const tcFeedback = new CGL.CopyTexture(op.patch.cgl, "particlesys_feedback", { "isFloatingPointTexture": true, "filter": CGL.Texture.FILTER_NEAREST });
const tcFeedbackVel = new CGL.CopyTexture(op.patch.cgl, "particlesys_feedbackvel", { "isFloatingPointTexture": true, "filter": CGL.Texture.FILTER_NEAREST });

const
    cgl = op.patch.cgl,
    uniTexOldPos = new CGL.Uniform(tcPos.bgShader, "t", "texOldPos", 0),
    uniTexSpawn = new CGL.Uniform(tcPos.bgShader, "t", "texSpawnPos", 1),
    uniTexTiming = new CGL.Uniform(tcPos.bgShader, "t", "texTiming", 2),
    uniTexSpawnVel = new CGL.Uniform(tcPos.bgShader, "t", "texSpawnVel", 3),
    uniTexFeedbackVel = new CGL.Uniform(tcPos.bgShader, "t", "texFeedbackVel", 4),

    uniTime = new CGL.Uniform(tcPos.bgShader, "f", "time", 0),
    uniLifeTime = new CGL.Uniform(tcPos.bgShader, "2f", "lifeTime", inLifeTimeMin, inLifeTimeMax),
    uniTimeDiff = new CGL.Uniform(tcPos.bgShader, "f", "timeDiff", 0),

    uniVel = new CGL.Uniform(tcPos.bgShader, "4f", "velocity", moveX, moveY, moveZ, inherVel),
    uniPos = new CGL.Uniform(tcPos.bgShader, "3f", "pos", posX, posY, posZ),
    unigrav = new CGL.Uniform(tcPos.bgShader, "3f", "gravity", gravX, gravY, gravZ),
    uniMass = new CGL.Uniform(tcPos.bgShader, "f", "mass", inMass),

    uniReset = new CGL.Uniform(tcPos.bgShader, "f", "reset", 0);

inReset.onTriggered = () =>
{
    uniReset.setValue(1);
};

inNumParticles.onChange = createTextures;

const texBlack = new CGL.Texture(cgl, {
    "isFloatingPointTexture": true,
    "width": 8,
    "height": 8 });

function createTextures()
{
    const size = Math.ceil(Math.sqrt(inNumParticles.get()));
    outTexSize.set(size);

    console.log(size);

    texTiming = new CGL.Texture(cgl, {
        "isFloatingPointTexture": true,
        "filter": CGL.Texture.FILTER_NEAREST,
        "width": size,
        "height": size });
    texPos = new CGL.Texture(cgl, {
        "isFloatingPointTexture": true,
        "filter": CGL.Texture.FILTER_NEAREST,
        "width": size,
        "height": size });
}

exec.onTriggered = () =>
{
    let firsttime = false;
    // if (!inTexOldPos.get()) return;
    if (!texTiming)
    {
        firsttime = true;
        createTextures();
        uniReset.setValue(1);
    }

    tcPos.bgShader.popTextures();

    uniTime.setValue(op.patch.freeTimer.get());

    if (!inTexOldPos.isLinked())
    {

    }

    if (firsttime)tcPos.bgShader.pushTexture(uniTexOldPos, texPos.tex);
    else
    {
        if (inTexOldPos.isLinked())
            tcPos.bgShader.pushTexture(uniTexOldPos, inTexOldPos.get().tex);
        else
            tcPos.bgShader.pushTexture(uniTexOldPos, tcFeedback.copy(outTexPos.get()));
    }

    if (inTexSpawn.get()) tcPos.bgShader.pushTexture(uniTexSpawn, inTexSpawn.get().tex);
    else tcPos.bgShader.pushTexture(uniTexSpawn, texBlack.tex);

    if (inTexSpawnVel.get()) tcPos.bgShader.pushTexture(uniTexSpawnVel, inTexSpawnVel.get().tex);

    if (tcPos.fb) tcPos.bgShader.pushTexture(uniTexFeedbackVel, tcFeedbackVel.copy(tcPos.fb.getTextureColorNum(3)));

    if (firsttime)tcPos.bgShader.pushTexture(uniTexTiming, texTiming.tex);
    else
    if (tcPos.fb && tcPos.fb.getTextureColorNum(1))tcPos.bgShader.pushTexture(uniTexTiming, tcTiming.copy(tcPos.fb.getTextureColorNum(1)));

    tcPos.copy(texPos);

    uniReset.setValue(0);

    uniTimeDiff.setValue((CABLES.now() - lastTime) / 1000);
    lastTime = CABLES.now();

    lastX = moveX.get();
    lastY = moveY.get();
    lastZ = moveZ.get();

    outTexPos.set(emptyTex);
    outTexPos.set(tcPos.fb.getTextureColorNum(0));

    outTexTiming.set(emptyTex);
    outTexTiming.set(tcPos.fb.getTextureColorNum(2));

    outTest.set(texPos);
    outTest.set(tcPos.fb.getTextureColorNum(3));

    next.trigger();
};

//


};

Ops.Dev.ParticleSystem.prototype = new CABLES.Op();
CABLES.OPS["bd94c323-a211-4fb6-a8aa-b724b610d885"]={f:Ops.Dev.ParticleSystem,objName:"Ops.Dev.ParticleSystem"};




// **************************************************************
// 
// Ops.Dev.String.ConcatMultiArray
// 
// **************************************************************

Ops.Dev.String.ConcatMultiArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const addSpacesCheckBox = op.inBool("add spaces", false),
    newLineX = op.inBool("new lines", false),
    result = op.outString("concat string"),
    outArr = op.outArray("Result"),
    outLines=op.outNumber("Total Lines");

const
    stringPorts = [],
    arrayPorts = [];

stringPorts.onChange =
    addSpacesCheckBox.onChange =
    newLineX.onChange = update;

for (let i = 0; i < 8; i++)
{
    let p = op.inString("String " + i);
    let pA = op.inArray("Array " + i);
    stringPorts.push(p);
    arrayPorts.push(pA);

    p.onChange =
        pA.onChange = update;
}

function update()
{
    let str = "";
    let nl = "";
    let space = addSpacesCheckBox.get();
    let line = 0;
    let numLines = 1;
    let countStringLines=0;

    for (let i = 0; i < arrayPorts.length; i++)
    {
        if(arrayPorts[i].get()) numLines = Math.max(numLines, arrayPorts[i].get().length);
    }

    for (let j = 0; j < numLines; j++)
    {
        for (let i = 0; i < stringPorts.length; i++)
        {
            const inString = stringPorts[i].get();
            const inArray = arrayPorts[i].get();
            if (!inString && !inArray) continue;
            if (i > 0 && space) str += " ";

            str += inString;
            if (inArray)
            {
                if(space)str += " ";
                str += inArray[j];
            }
        }
        if (newLineX.get() )
        {
            str += "\n";
            countStringLines++;
        }

    }

    result.set(str);
    outLines.set(countStringLines);
}


};

Ops.Dev.String.ConcatMultiArray.prototype = new CABLES.Op();
CABLES.OPS["9420ebd1-e0e9-44a6-825e-402b9b1ce71f"]={f:Ops.Dev.String.ConcatMultiArray,objName:"Ops.Dev.String.ConcatMultiArray"};




// **************************************************************
// 
// Ops.Dev.SvgPathToPoints
// 
// **************************************************************

Ops.Dev.SvgPathToPoints = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("SVG Path"),
    inStepSize = op.inFloat("Bezier Stepsize", 3),
    outArr = op.outArray("Points A"),
    outHoles = op.outArray("Points B");

inStepSize.onChange =
inStr.onChange = () =>
{
    let str = inStr.get();

    if (!str || str.length < 2) return;

    str = str.replace(/([A-Z,a-z])/g, " $1 ");

    const cmds = fromPathToArray(str);

    // create a list of closed contours
    const polys = [];
    cmds.forEach(({ type, x, y, x1, y1, x2, y2 }) =>
    {
        switch (type)
        {
        case "M":
            polys.push(new Polygon());
            polys[polys.length - 1].moveTo({ x, y });
            break;
        case "L":
            polys[polys.length - 1].moveTo({ x, y });
            break;
        case "C":
            polys[polys.length - 1].cubicTo({ x, y }, { "x": x1, "y": y1 }, { "x": x2, "y": y2 });
            break;
        case "Q":
            polys[polys.length - 1].conicTo({ x, y }, { "x": x1, "y": y1 });
            break;
        case "Z":
            polys[polys.length - 1].close();
            break;
        }
    });

    // sort contours by descending area
    polys.sort((a, b) => Math.abs(b.area) - Math.abs(a.area));
    // classify contours to find holes and their 'parents'
    const root = [];
    for (let i = 0; i < polys.length; ++i)
    {
        let parent = null;
        for (let j = i - 1; j >= 0; --j)
        {
            // a contour is a hole if it is inside its parent and has different winding
            if (polys[j].inside(polys[i].points[0]) && polys[i].area * polys[j].area < 0)
            {
                parent = polys[j];
                break;
            }
        }
        if (parent)
        {
            parent.children.push(polys[i]);
        }
        else
        {
            root.push(polys[i]);
        }
    }

    const totalPoints = polys.reduce((sum, p) => sum + p.points.length, 0);
    const vertexData = new Float32Array(totalPoints * 2);
    let vertexCount = 0;
    const indices = [];

    // function process(poly) {
    //   // construct input for earcut
    //   const coords = [];
    //   const holes = [];
    //   poly.points.forEach(({x, y}) => coords.push(x, y));
    //   poly.children.forEach(child => {
    //     // children's children are new, separate shapes
    //     child.children.forEach(process);

    //     holes.push(coords.length / 2);
    //     child.points.forEach(({x, y}) => coords.push(x, y));
    //   });

    //   // add vertex data
    //   vertexData.set(coords, vertexCount * 2);
    //   // add index data
    //   earcut(coords, holes).forEach(i => indices.push(i + vertexCount));
    //   vertexCount += coords.length / 2;
    // }
    // root.forEach(process);

    const coords = [];
    const holes = [];

    for (let i = 0; i < polys.length; i++)
    {
        const arr = [];
        for (let j = 0; j < polys[i].points.length; j++)
        {
            arr.push(polys[i].points[j].x, polys[i].points[j].y, 0);
        }
        coords.push(arr);

        if (polys[i].children)
        {
            for (let j = 0; j < polys[i].children.length; j++)
            {
                const hole = [];

                for (let k = 0; k < polys[i].children[j].points.length; k++)
                {
                    hole.push(
                        polys[i].children[j].points[k].x,
                        polys[i].children[j].points[k].y,
                        0);
                }

                holes.push(hole);
                if (j > 0) coords.push([]);
            }
        }

        // if (!polys[i].children || polys[i].children.length == 0)holes.push([]);

        // polys[i].children.forEach((child) =>
        // {
        //     const hole = [];
        //     child.points.forEach(({ x, y }) => hole.push(x, y, 0));

        //     holes.push(hole);
        //     coords.push([]);
        // });

        // for(let i=holes.length;i<arr.length;i++) holes.push([]);

        // if (polys[i].children.length == 0)console.log(arr);

        // for(let i=coords.length;i<holes.length;i++) coords.push([]);
    }

    outArr.set(null);
    outHoles.set(null);

    outArr.set(coords);
    outHoles.set(holes);
};

const PATH_COMMANDS = {
    "M": ["x", "y"],
    "m": ["dx", "dy"],
    "H": ["x"],
    "h": ["dx"],
    "V": ["y"],
    "v": ["dy"],
    "L": ["x", "y"],
    "l": ["dx", "dy"],
    "Z": [],
    "C": ["x1", "y1", "x2", "y2", "x", "y"],
    "c": ["dx1", "dy1", "dx2", "dy2", "dx", "dy"],
    "S": ["x2", "y2", "x", "y"],
    "s": ["dx2", "dy2", "dx", "dy"],
    "Q": ["x1", "y1", "x", "y"],
    "q": ["dx1", "dy1", "dx", "dy"],
    "T": ["x", "y"],
    "t": ["dx", "dy"],
    "A": ["rx", "ry", "rotation", "large-arc", "sweep", "x", "y"],
    "a": ["rx", "ry", "rotation", "large-arc", "sweep", "dx", "dy"]
};

function fromPathToArray(path)
{
    const items = path.replace(/[\n\r]/g, "")
        .replace(/-/g, " -")
        .replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ")
        .trim()
        .split(/\s*,|\s+/);

    // console.log(items);
    const segments = [];
    let currentCommand = "";
    let currentElement = {};
    while (items.length > 0)
    {
        let it = items.shift();
        if (PATH_COMMANDS.hasOwnProperty(it))
        {
            currentCommand = it;
        }
        else
        {
            items.unshift(it);
        }

        currentElement = { "type": currentCommand };
        PATH_COMMANDS[currentCommand].forEach((prop) =>
        {
            it = items.shift(); // TODO sanity check
            currentElement[prop] = parseFloat(it);
        });
        if (currentCommand === "M")
        {
            currentCommand = "L";
        }
        else if (currentCommand === "m")
        {
            currentCommand = "l";
        }
        segments.push(currentElement);
    }
    return segments;
}

// https://stackoverflow.com/questions/50554803/triangulate-path-data-from-opentype-js-using-earcut

const MAX_BEZIER_STEPS = 15;
// this is for inside checks - doesn't have to be particularly
// small because glyphs have finite resolution
const EPSILON = 1e-6;

class Polygon
{
    constructor()
    {
        this.points = [];
        this.children = [];
        this.area = 0.0;

        this.BEZIER_STEP_SIZE = inStepSize.get();
    }

    moveTo(p)
    {
        this.points.push(p);
    }

    lineTo(p)
    {
        this.points.push(p);
    }

    close()
    {
        let cur = this.points[this.points.length - 1];
        this.points.forEach((next) =>
        {
            this.area += 0.5 * cross(cur, next);
            cur = next;
        });
    }

    conicTo(p, p1)
    {
        const p0 = this.points[this.points.length - 1];
        const dist = distance(p0, p1) + distance(p1, p);
        const steps = Math.max(2, Math.min(MAX_BEZIER_STEPS, dist / this.BEZIER_STEP_SIZE));
        for (let i = 1; i <= steps; ++i)
        {
            const t = i / steps;
            this.points.push(lerp(lerp(p0, p1, t), lerp(p1, p, t), t));
        }
    }

    cubicTo(p, p1, p2)
    {
        const p0 = this.points[this.points.length - 1];
        const dist = distance(p0, p1) + distance(p1, p2) + distance(p2, p);
        const steps = Math.max(2, Math.min(MAX_BEZIER_STEPS, dist / this.BEZIER_STEP_SIZE));
        for (let i = 1; i <= steps; ++i)
        {
            const t = i / steps;
            const a = lerp(lerp(p0, p1, t), lerp(p1, p2, t), t);
            const b = lerp(lerp(p1, p2, t), lerp(p2, p, t), t);
            this.points.push(lerp(a, b, t));
        }
    }

    inside(p)
    {
        let count = 0, cur = this.points[this.points.length - 1];
        this.points.forEach((next) =>
        {
            const p0 = (cur.y < next.y ? cur : next);
            const p1 = (cur.y < next.y ? next : cur);
            if (p0.y < p.y + EPSILON && p1.y > p.y + EPSILON)
            {
                if ((p1.x - p0.x) * (p.y - p0.y) > (p.x - p0.x) * (p1.y - p0.y))
                {
                    count += 1;
                }
            }
            cur = next;
        });
        return (count % 2) !== 0;
    }
}

function distance(p1, p2)
{
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}

function lerp(p1, p2, t)
{
    return { "x": (1 - t) * p1.x + t * p2.x, "y": (1 - t) * p1.y + t * p2.y };
}

function cross(p1, p2)
{
    return p1.x * p2.y - p1.y * p2.x;
}


};

Ops.Dev.SvgPathToPoints.prototype = new CABLES.Op();
CABLES.OPS["43bcfbe3-7460-4b22-9a42-be787adf180d"]={f:Ops.Dev.SvgPathToPoints,objName:"Ops.Dev.SvgPathToPoints"};




// **************************************************************
// 
// Ops.Dev.TestOp
// 
// **************************************************************

Ops.Dev.TestOp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"sdsdsd":"",};
// your new op
// have a look at the documentation at:
// https://docs.cables.gl/dev_hello_op/dev_hello_op.html

// sss

const a = op.inFloat("name", 0);
const aa = op.inFloat("aaaa", 0);
const trig = op.inTrigger("Render");

const cgl = op.patch.cgl;
const meshRect = new CGL.WireframeRect(cgl);

trig.onTriggered = function ()
{
    meshRect.render();
};


};

Ops.Dev.TestOp.prototype = new CABLES.Op();
CABLES.OPS["274d0d70-00a0-4a19-88ca-e480b5143715"]={f:Ops.Dev.TestOp,objName:"Ops.Dev.TestOp"};




// **************************************************************
// 
// Ops.Dev.VertexTexture.RgbCurlNoise
// 
// **************************************************************

Ops.Dev.VertexTexture.RgbCurlNoise = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"curl_frag":"UNI float z;\nUNI float x;\nUNI float y;\nUNI float scale;\nIN vec2 texCoord;\nUNI sampler2D tex;\n\n// UNI float amount;\nUNI float timeDelta;\nUNI vec3 offset;\n\n{{CGL.BLENDMODES}}\n{{CGL.RANDOM_TEX}}\n\nfloat Interpolation_C2( float x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }   //  6x^5-15x^4+10x^3\t( Quintic Curve.  As used by Perlin in Improved Noise.  http://mrl.nyu.edu/~perlin/paper445.pdf )\nvec2 Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 Interpolation_C2( vec3 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2( vec4 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2_InterpAndDeriv( vec2 x ) { return x.xyxy * x.xyxy * ( x.xyxy * ( x.xyxy * ( x.xyxy * vec2( 6.0, 0.0 ).xxyy + vec2( -15.0, 30.0 ).xxyy ) + vec2( 10.0, -60.0 ).xxyy ) + vec2( 0.0, 30.0 ).xxyy ); }\nvec3 Interpolation_C2_Deriv( vec3 x ) { return x * x * (x * (x * 30.0 - 60.0) + 30.0); }\n\n\nvoid FAST32_hash_3D( \tvec3 gridcell,\n                        out vec4 lowz_hash_0,\n                        out vec4 lowz_hash_1,\n                        out vec4 lowz_hash_2,\n                        out vec4 highz_hash_0,\n                        out vec4 highz_hash_1,\n                        out vec4 highz_hash_2\t)\t\t//\tgenerates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\n\n//\n//\tPerlin Noise 3D  ( gradient noise )\n//\tReturn value range of -1.0->1.0\n//\thttp://briansharpe.files.wordpress.com/2011/11/perlinsample.jpg\n//\nfloat Perlin3D( vec3 P )\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n#if 1\n    //\n    //\tclassic noise.\n    //\trequires 3 random values per point.  with an efficent hash function will run faster than improved noise\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n    //SGPP_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n\n    //\tcalculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n#if 1\n    //\tClassic Perlin Interpolation\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    final *= 1.1547005383792515290182975610039;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/sqrt(0.75)\n    return final;\n#else\n    //\tClassic Perlin Surflet\n    //\thttp://briansharpe.wordpress.com/2012/03/09/modifications-to-classic-perlin-noise/\n    Pf *= Pf;\n    Pf_min1 *= Pf_min1;\n    vec4 vecs_len_sq = vec4( Pf.x, Pf_min1.x, Pf.x, Pf_min1.x ) + vec4( Pf.yy, Pf_min1.yy );\n    float final = dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf.zzzz ) ), grad_results_0 ) + dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf_min1.zzzz ) ), grad_results_1 );\n    final *= 2.3703703703703703703703703703704;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/cube(0.75)\n    return final;\n#endif\n\n#else\n    //\n    //\timproved noise.\n    //\trequires 1 random value per point.  Will run faster than classic noise if a slow hashing function is used\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_lowz, hash_highz;\n    FAST32_hash_3D( Pi, hash_lowz, hash_highz );\n    //BBS_hash_3D( Pi, hash_lowz, hash_highz );\n    //SGPP_hash_3D( Pi, hash_lowz, hash_highz );\n\n    //\n    //\t\"improved\" noise using 8 corner gradients.  Faster than the 12 mid-edge point method.\n    //\tKen mentions using diagonals like this can cause \"clumping\", but we'll live with that.\n    //\t[1,1,1]  [-1,1,1]  [1,-1,1]  [-1,-1,1]\n    //\t[1,1,-1] [-1,1,-1] [1,-1,-1] [-1,-1,-1]\n    //\n    hash_lowz -= 0.5;\n    vec4 grad_results_0_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_lowz );\n    hash_lowz = abs( hash_lowz ) - 0.25;\n    vec4 grad_results_0_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_lowz );\n    vec4 grad_results_0_2 = Pf.zzzz * sign( abs( hash_lowz ) - 0.125 );\n    vec4 grad_results_0 = grad_results_0_0 + grad_results_0_1 + grad_results_0_2;\n\n    hash_highz -= 0.5;\n    vec4 grad_results_1_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_highz );\n    hash_highz = abs( hash_highz ) - 0.25;\n    vec4 grad_results_1_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_highz );\n    vec4 grad_results_1_2 = Pf_min1.zzzz * sign( abs( hash_highz ) - 0.125 );\n    vec4 grad_results_1 = grad_results_1_0 + grad_results_1_1 + grad_results_1_2;\n\n    //\tblend the gradients and return\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy ) * (2.0 / 3.0);\t//\t(optionally) mult by (2.0/3.0) to scale to a strict -1.0->1.0 range\n#endif\n}\n\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n\n\n    vec3 rnd=\n        vec3(\n            Perlin3D( ( (base.xyz+20.0) + vec3(x,y,z)) *scale ),\n            Perlin3D( ( (base.xyz-20.0) + vec3(x,y,z)) *scale ),\n            Perlin3D( ( (base.xyz+60.0) + vec3(x,y,z)) *scale )\n        );\n\nfloat seed=1.0;\n    vec3 noise=(cgl_random3(texCoord.xy)-0.5)*seed;\n    rnd+=\n        vec3(\n            Perlin3D( ( (base.xyz+20.0+noise.x+offset.x) + vec3(x,y,z)) *scale ),\n            Perlin3D( ( (base.xyz-20.0+noise.y+offset.y) + vec3(x,y,z)) *scale ),\n            Perlin3D( ( (base.xyz+60.0+noise.z+offset.z) + vec3(x,y,z)) *scale )\n        );\n\n\n    // rnd=\n    // (\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0) + vec3(x,y,z)) *scale )\n    //     )+\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0+(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0+(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0+(offset*scale)) + vec3(x,y,z)) *scale )\n    //     )*0.25+\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0-(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0-(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0-(offset*scale)) + vec3(x,y,z)) *scale )\n    //     )*0.25+\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0-(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0+(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0-(offset*scale)) + vec3(x,y,z)) *scale )\n    //     )*0.25+\n    //     vec3(\n    //         Perlin3D( ( (base.xyz+20.0+(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz-20.0-(offset*scale)) + vec3(x,y,z)) *scale ),\n    //         Perlin3D( ( (base.xyz+60.0+(offset*scale)) + vec3(x,y,z)) *scale )\n    //     )*0.25\n\n    //     )/2.0;\n\n\n\n\n\n\n\n    #ifdef MOD_NORM_SPEED\n        rnd=normalize(rnd)*0.2;\n    #endif\n    #ifndef MOD_NORM_SPEED\n        // rnd*=timeDelta;\n    #endif\n\n    // rnd=clamp(rnd,vec3(-0.01),vec3(0.01));\n    // rnd*=0.01;\n    // float cl=0.03;\n    // rnd.x=clamp(rnd.x,-cl,cl);\n    // rnd.y=clamp(rnd.y,-cl,cl);\n    // rnd.z=clamp(rnd.z,-cl,cl);\n\n    rnd*=timeDelta;\n\n    vec3 coord=base.xyz+rnd*0.3;\n    // coord.x+=( Perlin3D( ( (base.xyz+20.0) + vec3(x,y,z)) *scale )*timeDelta);\n    // coord.y+=( Perlin3D( ( (base.xyz-20.0) + vec3(x,y,z)) *scale )*timeDelta);\n    // coord.z+=( Perlin3D( ( (base.xyz+30.0) + vec3(x,y,z)) *scale )*timeDelta);\n\n    // additional noise on top\n    // coord.x+=Perlin3D(vec3(texCoord.x))*0.001;\n    // coord.y+=Perlin3D(vec3(texCoord.y))*0.001;\n    // coord.z+=Perlin3D(vec3(texCoord.y,texCoord.x,texCoord.y))*0.001;\n\n\n    outColor=vec4(coord,1.0);\n\n\n    // outColor=cgl_blend(base,coord,1.0);\n}\n",};
const
    render = op.inTrigger("Render"),
    scale = op.inFloat("Scale", 1),
    time = op.inFloat("Time", 0),
    posX = op.inFloat("Pos X", 0),
    posY = op.inFloat("Pos Y", 0),
    posZ = op.inFloat("Pos Z", 0),

    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.curl_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    // textureMaskUniform = new CGL.Uniform(shader, "t", "texMask", 1),

    uniSeed = new CGL.Uniform(shader, "3f", "offset", posX, posX, posX),
    uniTime = new CGL.Uniform(shader, "f", "time", time),
    uniScale = new CGL.Uniform(shader, "f", "scale", scale),
    uniTimeDelta = new CGL.Uniform(shader, "f", "timeDelta", 1);

time.onChange =
    scale.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    shader.toggleDefine("MOD_NORM_SPEED", true);
}

let lastTime = 0;

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    uniTimeDelta.set(time.get() - lastTime);
    lastTime = time.get();

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Dev.VertexTexture.RgbCurlNoise.prototype = new CABLES.Op();
CABLES.OPS["10bc3a93-47c6-48ea-aebb-20f990153e62"]={f:Ops.Dev.VertexTexture.RgbCurlNoise,objName:"Ops.Dev.VertexTexture.RgbCurlNoise"};




// **************************************************************
// 
// Ops.Dev.VizBranchProfiler
// 
// **************************************************************

Ops.Dev.VizBranchProfiler = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj = op.inObject("Profiler Data"),

    inRender = op.inSwitch("Render", ["Patch", "Canvas", "Both"], "Patch"),
    inWidth = op.inInt("Width", 500),
    inHeight = op.inInt("Height", 200),
    outCanvas = op.outObject("Canvas", null, "element"),
    outTotalDur = op.outNumber("Duration"),
    inUpdate = op.inTriggerButton("Update");

op.setUiAttrib({ "height": 100, "width": 500, "resizable": true });

op.setPortGroup("Canvas", [inWidth, inHeight]);

const colors = ["#D183BF", "#9091D6", "#FFC395", "#F0D165", "#63A8E8", "#CF5D9D", "#66C984", "#D66AA6", "#515151", "#7AC4E0"];

let colorCycle = 0;
let totalDur = 1;
let root = null;
let doUpdate = true;
let canvas = null;
let render2Canvas = false;
let canvasWidth = 0;
let canvasHeight = 0;

inRender.onChange = updateUi;

inHeight.onChange = inWidth.onChange = setupCanvas;

function setupCanvas()
{
    if (render2Canvas && (!canvas || canvasHeight != inHeight.get() || canvasWidth != inWidth.get()))
    {
        if (canvas)canvas.remove();
        canvas = document.createElement("canvas");

        canvasWidth = inWidth.get();
        canvasHeight = inHeight.get();
        canvas.setAttribute("width", canvasWidth);
        canvas.setAttribute("height", canvasHeight);
    }
}

function updateUi()
{
    render2Canvas = inRender.get() != "Patch";

    inWidth.setUiAttribs({ "greyout": !render2Canvas });
    inHeight.setUiAttribs({ "greyout": !render2Canvas });

    setupCanvas();
}

function getWidth(layer, d)
{
    // if (d < 0.2) d = 0.004;
    return layer.width * (d / totalDur);
}

inUpdate.onTriggered = () =>
{
    doUpdate = true;

    if (render2Canvas && inObj.get() && inObj.get().root)
    {
        const layer = { "width": inWidth.get(), "height": inHeight.get(), "x": 0, "y": 0 };
        const ctx = canvas.getContext("2d");

        totalDur = inObj.get().root.dur;
        // console.log(inObj.get());
        // console.log(inObj.get().root.dur)
        clear(ctx, layer);
        drawBranch(ctx, layer, inObj.get().root, 0, 0);
        outCanvas.set(null);
        outCanvas.set(canvas);
    }

    outTotalDur.set(totalDur);
};

function clear(ctx, layer)
{
    ctx.fillStyle = "#222";
    ctx.fillRect(
        layer.x, layer.y,
        layer.width, layer.height);
}

function drawBranch(ctx, layer, b, level, posx)
{
    if (!b) return;

    colorCycle++;
    colorCycle %= (colors.length - 1);

    let rowHeight = (layer.height / 10);
    let posy = rowHeight * level;

    ctx.fillStyle = colors[colorCycle];
    ctx.fillRect(
        layer.x + posx, posy + layer.y,
        getWidth(layer, b.dur), rowHeight);

    let fontSize = 18;
    ctx.fillStyle = "#222";
    ctx.font = "normal " + fontSize + "px sourceCodePro";

    let durs = "(" + Math.round(b.dur * 100) / 100 + "ms)";
    if (b.dur < 0.2)durs = "";
    ctx.fillText(b.name + durs, layer.x + posx, layer.y + posy + fontSize);

    let xadd = 0;
    for (let i = 0; i < b.childs.length; i++)
    {
        drawBranch(ctx, layer, b.childs[i], level + 1, posx + xadd);
        xadd += getWidth(layer, b.childs[i].dur);
    }
}

op.renderVizLayer = (ctx, layer) =>
{
    if (!inObj.get().root) return;
    clear(ctx, layer);

    colorCycle = 0;

    // console.log(totalDur);
    if (doUpdate)
    {
        doUpdate = false;
        totalDur = inObj.get().root.dur;
        root = inObj.get().root;
        // console.log(root);
    }

    drawBranch(ctx, layer, root, 0, 0);
};


};

Ops.Dev.VizBranchProfiler.prototype = new CABLES.Op();
CABLES.OPS["236fb6ea-4e98-4039-b831-98dc2ff2844b"]={f:Ops.Dev.VizBranchProfiler,objName:"Ops.Dev.VizBranchProfiler"};




// **************************************************************
// 
// Ops.Dev.WebGpu.Computetest
// 
// **************************************************************

Ops.Dev.WebGpu.Computetest = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"compute_wgsl":"// struct Matrix {\n// size : vec2<f32>,\n// numbers: array<f32>,\n// }\n\n@group(0) @binding(0) var<storage, read_write> resultMatrix : array<f32>;\n\n@compute @workgroup_size(50,1)\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>)\n{\n    // Guard against out-of-bounds work group sizes\n    //     if (global_id.x >= u32(firstMatrix.size.x) || global_id.y >= u32(secondMatrix.size.y))\n    //       return;\n    //     }\n\n    // resultMatrix.size = vec2(firstMatrix.size.x, secondMatrix.size.y);\n\n    // let resultCell = vec2(global_id.x, global_id.y);\n    // var result = 0.0;\n    // for (var i = 0u; i < u32(firstMatrix.size.y); i = i + 1u) {\n    //   let a = i + resultCell.x * u32(firstMatrix.size.y);\n    //   let b = resultCell.y + i * u32(secondMatrix.size.y);\n    //   result = result + firstMatrix.numbers[a] * secondMatrix.numbers[b];\n    // }\n\n    // let index = resultCell.y + resultCell.x * u32(secondMatrix.size.y);\n    // resultMatrix.numbers[index] = result;\n\n    resultMatrix[global_id.x] = f32(global_id.x);\n}",};
const
    compute=op.inTrigger("Computer"),
    next=op.outTrigger("Next");

let comp=null;
compute.onTriggered=()=>
{
    if(!comp)
    {
        comp=new CABLES.CGP.GpuCompute(op.patch.cg,"c0mput",attachments.compute_wgsl);

        comp.compute();
    }

}

};

Ops.Dev.WebGpu.Computetest.prototype = new CABLES.Op();
CABLES.OPS["7f179cc1-a1bd-4989-9fe2-6b6f8a95a6d7"]={f:Ops.Dev.WebGpu.Computetest,objName:"Ops.Dev.WebGpu.Computetest"};




// **************************************************************
// 
// Ops.Dev.WebGpu.WebGpuCanvas
// 
// **************************************************************

Ops.Dev.WebGpu.WebGpuCanvas = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"tri_wgsl_frag":"@fragment\n\nfn main() -> @location(0) vec4<f32>\n{\n  return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}","tri_wgsl_vert":"@vertex\n\nfn main(@builtin(vertex_index) VertexIndex : u32)\n     -> @builtin(position) vec4<f32>\n     {\n        var pos = array<vec2<f32>, 3>(\n            vec2<f32>(0.0, 0.5),\n            vec2<f32>(-0.5, -0.5),\n            vec2<f32>(0.5, -0.5));\n\n    return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n}\n",};
const
    next = op.outTrigger("Next"),
    supported = op.outBoolNum("Supported", false),
    outLimits = op.outObject("Limits");

let device = null;
let context = null, pipeline = null;

const canvas = document.createElement("canvas");
canvas.id = "webgpucanvas";
canvas.setAttribute("tabindex", 4);
canvas.style.width = 128 + "px";
canvas.style.height = 128 + "px";
canvas.style.right = 0 + "px";
canvas.style["z-index"] = "22222";
canvas.style.border = "1px solid red";
canvas.style.position = "absolute";

const container = document.getElementById("cablescanvas");
container.appendChild(canvas);

// canvas.addEventListener("blur", () => { if (supported.get())canvas.style.border = "1px solid black"; });
// canvas.addEventListener("focus", () => { if (supported.get())canvas.style.border = "1px solid white"; });

const pm = mat4.create();

let renderTarget = null;
let depthTexture = null;
let canvasInfo = {};

let sizeWidth = 0;
let sizeHeight = 0;

op.patch.cgp = op.patch.cgp || new CABLES.CGP.Context(op.patch);
const cgp = op.patch.cgp;
const sampleCount = 1;

cgp.canvas = canvas;

if (CABLES.UI)
{
    gui.canvasManager.addContext(cgp);
    // setTimeout(() =>
    // {
    //     gui.emitEvent("resizecanvas");
    //     gui.setLayout();
    // }, 200);
}

let stopped = false;
op.onDelete = () =>
{
    stopped = true;
    canvas.remove();
    device =
            op.patch.cgp.device =
            op.patch.cgp.adapter =
            op.patch.cgp.pipeline = null;
};

if (!navigator.gpu)
{
    const warn = "Your browser does not support webGPU";
    op.setUiError("nowebgpu", warn);
    console.log(warn);
}

if (navigator.gpu)
    navigator.gpu.requestAdapter().then((adapter) =>
    {
        if (!adapter)
        {
            op.warn("webgpu: could not get adapter...");
            supported.set(false);
            return;
        }
        adapter.requestDevice().then((_device) =>
        {
            canvas.style.border = "1px solid black";

            cgp.setCanvas(canvas);
            cgp.setSize(container.clientWidth, container.clientHeight);

            supported.set(true);
            device = _device;

            //

            const limits = {};
            for (let i in device.limits) limits[i] = device.limits[i];
            outLimits.set(limits);

            //

            cgp.device = device;
            cgp.adapter = adapter;
            cgp.canvas = canvas;

            console.log(adapter);
            console.log(device);

            context = canvas.getContext("webgpu");
            cgp.context = context;

            createTargets(cgp);
            // pipeline = device.createRenderPipeline({
            //     "layout": "auto",
            //     "vertex":
            //     {
            //         "module": device.createShaderModule(
            //             {
            //                 "code": attachments.tri_wgsl_vert,
            //             }),
            //         "entryPoint": "main",
            //     },
            //     "fragment":
            //     {
            //         "module": device.createShaderModule(
            //             {
            //                 "code": attachments.tri_wgsl_frag,
            //             }),
            //         "entryPoint": "main",
            //         "targets":
            //         [
            //             {
            //                 "format": presentationFormat,
            //             },
            //         ],
            //     },
            //     "primitive": {
            //         "topology": "triangle-list",
            //     },
            // });
            // cgp.pipeline = pipeline;

            // canvasInfo.depthTextureView = depthTexture.createView();
            cgp.canvasInfo = canvasInfo;

            requestAnimationFrame(frame);
        });
    });

function createTargets(cgp)
{
    const devicePixelRatio = 1;// window.devicePixelRatio || 1;

    sizeWidth = canvas.clientWidth * devicePixelRatio;
    sizeHeight = canvas.clientHeight * devicePixelRatio;

    cgp.setSize(sizeWidth, sizeHeight);

    console.log("re create targets");
    // const presentationSize = [
    //     canvas.clientWidth * devicePixelRatio,
    //     canvas.clientHeight * devicePixelRatio,
    // ];

    console.log("presentationSize", sizeWidth, sizeHeight);
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat(cgp.adapter);
    cgp.presentationFormat = presentationFormat;

    context.configure({
        device,
        "format": presentationFormat
    });

    if (renderTarget)renderTarget.destroy();
    if (depthTexture)depthTexture.destroy();

    renderTarget = device.createTexture(
        {
            "size": [sizeWidth, sizeHeight],
            "format": presentationFormat,
            "sampleCount": sampleCount,
            "usage": GPUTextureUsage.RENDER_ATTACHMENT,
        });
    // canvasInfo.renderTarget = newRenderTarget;
    // canvasInfo.renderTargetView = newRenderTarget.createView();
    //   });

    depthTexture = device.createTexture({
        "size": [sizeWidth, sizeHeight],
        "format": "depth24plus",
        "sampleCount": sampleCount,
        "usage": GPUTextureUsage.RENDER_ATTACHMENT,
    });
}

function frame()
{
    if (stopped) return;
    if (!device)
    {
        requestAnimationFrame(frame);

        return;
    }

    const devicePixelRatio = 1;// window.devicePixelRatio || 1;
    if (sizeWidth != canvas.clientWidth * devicePixelRatio || sizeHeight != canvas.clientHeight * devicePixelRatio)
    {
        createTargets(cgp);
    }

    // mat4.perspective(cgp.pMatrix, 45, canvas.clientWidth / canvas.clientHeight, 0.1, 1110.0);
    // mat4.copy(cgp.pMatrix, pm);

    const commandEncoder = device.createCommandEncoder();

    cgp.textureView = renderTarget.createView();
    cgp.canvasInfo.depthTextureView = depthTexture.createView();

    // cgp.textureView = textureView;
    const renderPassDescriptor = {
        "colorAttachments": [
            {
                "view": context.getCurrentTexture().createView(),
                "loadOp": "clear",
                // "resolveTarget": context.getCurrentTexture().createView(),
                // "clearValue": { "r": 0.8, "g": 0.2, "b": 0.8, "a": 1.0 },
                "storeOp": "store",
            },
        ],
        "depthStencilAttachment": {
            "view": cgp.canvasInfo.depthTextureView,
            // "depthTexture": cgp.canvasInfo.depthTexture,

            "depthClearValue": 1,
            "depthLoadOp": "clear",
            "depthStoreOp": "store",
        },
    };
    cgp.renderPassDescriptor = renderPassDescriptor;
    cgp.passEncoder = commandEncoder.beginRenderPass(cgp.renderPassDescriptor);

    op.patch.cg = cgp;
    // cgp.passEncoders = [];
    cgp.renderStart();

    const oldCgl = op.patch.cgl;
    op.patch.cgl = null; // force crash if something tries to use it
    next.trigger();

    op.patch.cgl = oldCgl;

    cgp.renderEnd();

    // for(let i=0;i<cgp.passEncoders.length;i++)

    op.patch.cg = null;

    //     const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    //     passEncoder.setPipeline(pipeline);
    //     passEncoder.draw(3, 1, 0, 0);
    cgp.passEncoder.end();

    const passEncoders = [commandEncoder.finish()];
    // device.queue.submit([commandEncoder.finish()]);

    cgp.device.queue.submit(passEncoders);

    if (!stopped)requestAnimationFrame(frame);
}


};

Ops.Dev.WebGpu.WebGpuCanvas.prototype = new CABLES.Op();
CABLES.OPS["95191541-a155-48b6-880f-e40b8be7a469"]={f:Ops.Dev.WebGpu.WebGpuCanvas,objName:"Ops.Dev.WebGpu.WebGpuCanvas"};




// **************************************************************
// 
// Ops.Dev.WebGpu.WebGpuMesh
// 
// **************************************************************

Ops.Dev.WebGpu.WebGpuMesh = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"mesh_wgsl":"struct VSUniforms\n{\n    modelMatrix: mat4x4<f32>,\n    viewMatrix: mat4x4<f32>,\n    projMatrix: mat4x4<f32>,\n};\n\nstruct FSUniforms\n{\n    color:vec3<f32>//,\n    // lightDirection: vec3<f32>,\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n@group(0) @binding(1) var<uniform> fsUniforms: FSUniforms;\n\n\n\nstruct MyVSInput\n{\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n    @location(2) texcoord: vec2<f32>,\n};\n\nstruct MyVSOutput\n{\n    @builtin(position) position: vec4<f32>,\n    @location(0) normal: vec3<f32>,\n    @location(1) texcoord: vec2<f32>,\n};\n\n@vertex\nfn myVSMain(v: MyVSInput) -> MyVSOutput\n{\n    var vsOut: MyVSOutput;\n    var pos =vec4<f32>(v.position, 1.0);// vsUniforms.worldViewProjection * v.position;\n    // vsOut.normal = (vsUniforms.worldInverseTranspose * vec4<f32>(v.normal, 0.0)).xyz;\n\n    var mvMatrix=vsUniforms.viewMatrix * vsUniforms.modelMatrix;\n    vsOut.position = vsUniforms.projMatrix * mvMatrix * pos;\n\n    vsOut.normal = v.normal;\n    vsOut.texcoord = v.texcoord;\n    return vsOut;\n}\n\n\n\n\n\n// @group(0) @binding(2) var diffuseSampler: sampler;\n// @group(0) @binding(3) var diffuseTexture: texture_2d<f32>;\n\n@fragment\nfn myFSMain(v: MyVSOutput) -> @location(0) vec4<f32>\n{\n    // var diffuseColor = textureSample(diffuseTexture, diffuseSampler, v.texcoord);\n    // var a_normal = normalize(v.normal);\n    // var l = dot(a_normal, fsUniforms.lightDirection) * 0.5 + 0.5;\n    // return vec4<f32>(diffuseColor.rgb * l, diffuseColor.a);\n    // return vec4<f32>(fsUniforms.color, 1.0);\n    return vec4<f32>(v.normal.xyz+fsUniforms.color*0.001 , 1.0);\n}\n\n",};
// !! https://alain.xyz/blog/raw-webgpu
// https://github.com/gfxfundamentals/webgpufundamentals/blob/main/webgpu/webgpu-cube.html

const
    inTrigger = op.inTrigger("Render"),
    inGeom = op.inObject("Geometry", null, "geometry"),
    next = op.outTrigger("Next");

let cgp = op.patch.cgp;
let needsbuild = true;

let bindGroup;
let positionBuffer;
let normalBuffer;
let texcoordBuffer;
let indicesBuffer;
let geom = null;
let pipeline;
let renderPassDescriptor;
let numIndices = 0;

let depthTexture, depthTextureView;

let vsUniformBuffer;
let fsUniformBuffer;
let vsUniformValues;
let fsUniformValues;
let matModel;
let matView;
let matProj;

let mesh = null;
let shader = null;
let pipe = null;

inTrigger.onTriggered = () =>
{
    cgp = op.patch.cgp;
    if (needsbuild)rebuild();

    if (geom && cgp.renderPassDescriptor)
    {
        mat4.copy(matModel, cgp.mMatrix);
        mat4.copy(matView, cgp.vMatrix);
        mat4.copy(matProj, cgp.pMatrix);

        cgp.device.queue.writeBuffer(
            vsUniformBuffer,
            0,
            vsUniformValues.buffer,
            vsUniformValues.byteOffset,
            vsUniformValues.byteLength
        );

        // const colorTexture = cgp.context.getCurrentTexture();
        // renderPassDescriptor.colorAttachments[0].view = colorTexture.createView();

        // const commandEncoder = cgp.device.createCommandEncoder();
        // const passEncoder = commandEncoder.beginRenderPass(cgp.renderPassDescriptor);

        // cgp.passEncoder.setPipeline(pipeline);
        cgp.passEncoder.setPipeline(pipeline);

        cgp.passEncoder.setBindGroup(0, bindGroup);
        cgp.passEncoder.setVertexBuffer(0, positionBuffer);
        cgp.passEncoder.setVertexBuffer(1, normalBuffer);
        cgp.passEncoder.setVertexBuffer(2, texcoordBuffer);
        cgp.passEncoder.setIndexBuffer(indicesBuffer, "uint32");

        cgp.passEncoder.drawIndexed(numIndices);
        // else cgp.passEncoder.draw(geom.vertices.length );

        // passEncoder.end();

        // cgp.passEncoders.push(commandEncoder.finish());
    }

    cgp.pushShader(shader);
    next.trigger();
    cgp.popShader();
};

inGeom.onChange = () =>
{
    needsbuild = true;
};

//   @group(0) @binding(2) var diffuseSampler: sampler;
//   @group(0) @binding(3) var diffuseTexture: texture_2d<f32>;

function createShaderModule(device, code)
{
    cgp.pushErrorScope("validation");

    const shaderModule = device.createShaderModule({ code });
    // const error = await device.popErrorScope();
    // if (error) {
    //   throw new Error(error.message);
    // }

    cgp.popErrorScope("cgp_pipeline createshadermodule");

    return shaderModule;
}

function createBuffer(device, data, usage)
{
    const buffer = device.createBuffer({
        "size": data.byteLength,
        "usage": usage,
        "mappedAtCreation": true,
    });
    const dst = new data.constructor(buffer.getMappedRange());
    dst.set(data);
    buffer.unmap();
    return buffer;
}

function rebuild()
{
    geom = inGeom.get();
    if (!geom) return;

    positionBuffer = createBuffer(cgp.device, new Float32Array(geom.vertices), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
    normalBuffer = createBuffer(cgp.device, new Float32Array(geom.vertexNormals), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
    texcoordBuffer = createBuffer(cgp.device, new Float32Array(geom.texcoords), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);

    let vi = geom.verticesIndices;
    if (!geom.isIndexed())
    {
        vi = Array.from(Array(geom.vertices.length / 3).keys());
    }

    numIndices = vi.length;
    indicesBuffer = createBuffer(cgp.device, new Uint32Array(vi), GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST);

    if (!shader)shader = new CGP.Shader(cgp, "testshad0r");

    shader.shaderModule = createShaderModule(cgp.device, attachments.mesh_wgsl);

    cgp.pushErrorScope();

    if (!pipe)pipe = new CGP.Pipeline(cgp);

    const pipeCfg = pipe.getPiplelineObject(shader, mesh);
    console.log(pipeCfg);
    pipeline = cgp.device.createRenderPipeline(pipeCfg);

    cgp.popErrorScope(op.name);

    const vUniformBufferSize = 3 * 16 * 4; // 2 mat4s * 16 floats per mat * 4 bytes per float
    const fUniformBufferSize = 2 * 3 * 4; // 1 vec3 * 3 floats per vec3 * 4 bytes per float

    vsUniformBuffer = cgp.device.createBuffer({
        "size": vUniformBufferSize,
        "usage": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    fsUniformBuffer = cgp.device.createBuffer({
        "size": fUniformBufferSize,
        "usage": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    vsUniformValues = new Float32Array(vUniformBufferSize / 4);
    fsUniformValues = new Float32Array(fUniformBufferSize / 4);

    matModel = vsUniformValues.subarray(0, 16);
    matView = vsUniformValues.subarray(16, 32);
    matProj = vsUniformValues.subarray(32, 48);

    fsUniformValues[1] = 1.0;
    fsUniformValues[0] = 1.0;
    const lightDirection = fsUniformValues.subarray(0, 3);

    // console.log("pipeline bindgrouplayout ", pipeline.getBindGroupLayout(0));

    bindGroup = cgp.device.createBindGroup(
        {
            "layout": pipeline.getBindGroupLayout(0),
            "entries": [
                { "binding": 0, "resource": { "buffer": vsUniformBuffer } },
                { "binding": 1, "resource": { "buffer": fsUniformBuffer } }
                //   { binding: 2, resource: sampler },
                //   { binding: 3, resource: tex.createView() },
            ],
        });

    cgp.device.queue.writeBuffer(
        vsUniformBuffer,
        0,
        vsUniformValues.buffer,
        vsUniformValues.byteOffset,
        vsUniformValues.byteLength
    );
    cgp.device.queue.writeBuffer(
        fsUniformBuffer,
        0,
        fsUniformValues.buffer,
        fsUniformValues.byteOffset,
        fsUniformValues.byteLength
    );

    const textureView = cgp.context.getCurrentTexture().createView();

    needsbuild = false;
}


};

Ops.Dev.WebGpu.WebGpuMesh.prototype = new CABLES.Op();
CABLES.OPS["daf22c14-6ba3-4c63-83d2-27e9e60d3dbf"]={f:Ops.Dev.WebGpu.WebGpuMesh,objName:"Ops.Dev.WebGpu.WebGpuMesh"};




// **************************************************************
// 
// Ops.Dev.WebGpu.WebGpuMinimalMaterial
// 
// **************************************************************

Ops.Dev.WebGpu.WebGpuMinimalMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"mat_wgsl":"struct VSUniforms\n{\n    modelMatrix: mat4x4<f32>,\n    viewMatrix: mat4x4<f32>,\n    projMatrix: mat4x4<f32>,\n};\n\nstruct FSUniforms\n{\n    color:vec4<f32>\n};\n\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\n@group(0) @binding(1) var<uniform> fsUniforms: FSUniforms;\n\nstruct MyVSInput\n{\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n    @location(2) texcoord: vec2<f32>,\n};\n\nstruct MyVSOutput\n{\n    @builtin(position) position: vec4<f32>,\n    @location(0) normal: vec3<f32>,\n    @location(1) texcoord: vec2<f32>,\n};\n\n@vertex\nfn myVSMain(v: MyVSInput) -> MyVSOutput\n{\n    var vsOut: MyVSOutput;\n    var pos =vec4<f32>(v.position, 1.0);\n\n    var mvMatrix=vsUniforms.viewMatrix * vsUniforms.modelMatrix;\n    vsOut.position = vsUniforms.projMatrix * mvMatrix * pos;\n\n    vsOut.normal = v.normal;\n    vsOut.texcoord = v.texcoord;\n    return vsOut;\n}\n\n@fragment\nfn myFSMain(v: MyVSOutput) -> @location(0) vec4<f32>\n{\n    return fsUniforms.color;\n}\n\n",};
const
    inTrigger = op.inTrigger("Render"),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    a = op.inValueSlider("a", 1),
    next = op.outTrigger("Next");

r.setUiAttribs({ "colorPick": true });

let shader = null;

inTrigger.onTriggered = () =>
{
    const cgp = op.patch.cg;
    if (!shader)
    {
        shader = new CGP.Shader(cgp, op.name);
        shader.setSource(attachments.mat_wgsl);

        shader.addUniformFrag("4f", "color", r, g, b, a);
    }

    cgp.pushShader(shader);

    next.trigger();

    cgp.popShader(shader);
};


};

Ops.Dev.WebGpu.WebGpuMinimalMaterial.prototype = new CABLES.Op();
CABLES.OPS["681ffbbf-cdf4-4d4f-ad7c-934b3a601a80"]={f:Ops.Dev.WebGpu.WebGpuMinimalMaterial,objName:"Ops.Dev.WebGpu.WebGpuMinimalMaterial"};




// **************************************************************
// 
// Ops.Dev.WebGpu.WebGpuTexture
// 
// **************************************************************

Ops.Dev.WebGpu.WebGpuTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    trigger = op.inTrigger("trigger"),
    filename = op.inUrl("File", [".jpg", ".png", ".webp", ".jpeg", ".avif"]),
    result = op.outTexture("Texture");

let needsReload = false;

filename.onChange = () =>
{
    needsReload = true;
};

trigger.onTriggered = () =>
{
    if (needsReload)
    {
        needsReload = false;

        CGP.Texture.load(op.patch.cgp, filename.get(), (t) =>
        {
            result.set(t);
        });
    }
};


};

Ops.Dev.WebGpu.WebGpuTexture.prototype = new CABLES.Op();
CABLES.OPS["3a952a05-8b7b-4dab-9c08-f2c00f6cd899"]={f:Ops.Dev.WebGpu.WebGpuTexture,objName:"Ops.Dev.WebGpu.WebGpuTexture"};




// **************************************************************
// 
// Ops.Device.Mobile.ShakeGesture
// 
// **************************************************************

Ops.Device.Mobile.ShakeGesture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    accX = op.outNumber("Acceleration X"),
    accY = op.outNumber("Acceleration Y"),
    accZ = op.outNumber("Acceleration Z");

let lastTime = 0;
let lastTimeAcc = 0;

let obj = {};

registerEvents();

let lastX = 0;
let lastY = 0;
let lastZ = 0;

function moved(event)
{
    if (CABLES.now() - lastTimeAcc > 30)
    {
        lastTimeAcc = CABLES.now();

        let deltaX = lastX - event.accelerationIncludingGravity.x;
        let deltaY = lastY - event.accelerationIncludingGravity.y;
        let deltaZ = lastZ - event.accelerationIncludingGravity.z;

        accX.set(Math.abs(deltaX));
        accY.set(Math.abs(deltaY));
        accZ.set(Math.abs(deltaZ));

        lastX = event.accelerationIncludingGravity.x;
        lastY = event.accelerationIncludingGravity.y;
        lastZ = event.accelerationIncludingGravity.z;
    }
}

function registerEvents()
{
    window.addEventListener("devicemotion", moved, true);
}

op.onDelete = function ()
{
    window.removeEventListener("devicemotion", moved);
};


};

Ops.Device.Mobile.ShakeGesture.prototype = new CABLES.Op();
CABLES.OPS["7b32f8ad-ff4a-4634-927b-ede9955e3b53"]={f:Ops.Device.Mobile.ShakeGesture,objName:"Ops.Device.Mobile.ShakeGesture"};




// **************************************************************
// 
// Ops.Devices.GamePad.GamePad
// 
// **************************************************************

Ops.Devices.GamePad.GamePad = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let data = op.inObject("GamePad Data");
let outID = op.outString("ID");
let digitalAnalog = op.inValueBool("Analog to Digital", true);
let outAxes = op.outArray("Axes");

let pressedLeft = op.outBoolNum("Pad Left");
let pressedRight = op.outBoolNum("Pad Right");
let pressedUp = op.outBoolNum("Pad Up");
let pressedDown = op.outBoolNum("Pad Down");

let pressedButton1 = op.outBoolNum("Button 1");
let pressedButton2 = op.outBoolNum("Button 2");
let pressedButton3 = op.outBoolNum("Button 3");
let pressedButton4 = op.outBoolNum("Button 4");

let outLeftShoulder = op.outNumber("Left Shoulder");
let outLeftShoulderBottom = op.outNumber("Left Shoulder Bottom");

let outRightShoulder = op.outNumber("Right Shoulder");
let outRightShoulderBottom = op.outNumber("Right Shoulder Bottom");

data.onChange = function ()
{
    if (data.get())
    {
        outID.set(data.get().id);
        if (data.get().axes)outAxes.set(data.get().axes);

        let buttons = data.get().buttons;
        if (buttons)
        {
            pressedButton1.set(buttons[0].pressed);
            pressedButton2.set(buttons[1].pressed);
            pressedButton3.set(buttons[2].pressed);
            pressedButton4.set(buttons[3].pressed);
        }

        if (digitalAnalog.get())
        {
            let axes = data.get().axes;
            if (axes)
            {
                if (axes[0] < -0.5)pressedLeft.set(true);
                else pressedLeft.set(false || buttons[14].pressed);
                if (axes[0] > 0.5)pressedRight.set(true);
                else pressedRight.set(false || buttons[15].pressed);

                if (axes[1] < -0.5)pressedUp.set(true);
                else pressedUp.set(false || buttons[12].pressed);
                if (axes[1] > 0.5)pressedDown.set(true);
                else pressedDown.set(false || buttons[13].pressed);
            }
        }
        else
        {
            pressedLeft.set(buttons[14].pressed);
            pressedRight.set(buttons[15].pressed);
            pressedDown.set(buttons[13].pressed);
            pressedUp.set(buttons[12].pressed);
        }

        outLeftShoulder.set(buttons[4].value);
        outLeftShoulderBottom.set(buttons[6].value);

        outRightShoulder.set(buttons[5].value);
        outRightShoulderBottom.set(buttons[7].value);
    }
};

// gamepad.BUTTONS = {
//   FACE_1: 0, // Face (main) buttons
//   FACE_2: 1,
//   FACE_3: 2,
//   FACE_4: 3,
//   LEFT_SHOULDER: 4, // Top shoulder buttons
//   RIGHT_SHOULDER: 5,
//   LEFT_SHOULDER_BOTTOM: 6, // Bottom shoulder buttons
//   RIGHT_SHOULDER_BOTTOM: 7,
//   SELECT: 8,
//   START: 9,
//   LEFT_ANALOGUE_STICK: 10, // Analogue sticks (if depressible)
//   RIGHT_ANALOGUE_STICK: 11,
//   PAD_TOP: 12, // Directional (discrete) pad
//   PAD_BOTTOM: 13,
//   PAD_LEFT: 14,
//   PAD_RIGHT: 15
// };

// gamepad.AXES = {
//   LEFT_ANALOGUE_HOR: 0,
//   LEFT_ANALOGUE_VERT: 1,
//   RIGHT_ANALOGUE_HOR: 2,
//   RIGHT_ANALOGUE_VERT: 3
// };


};

Ops.Devices.GamePad.GamePad.prototype = new CABLES.Op();
CABLES.OPS["3acf39ed-53cc-45eb-8516-43319839d457"]={f:Ops.Devices.GamePad.GamePad,objName:"Ops.Devices.GamePad.GamePad"};




// **************************************************************
// 
// Ops.Devices.GamePad.GamePadJoystickAxis
// 
// **************************************************************

Ops.Devices.GamePad.GamePadJoystickAxis = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inAxis = op.inArray("Axis"),
    inAxisNum = op.inValueInt("Index"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    inDeadZone = op.outNumber("DeadZone", 0.1),
    outAngle = op.outNumber("Angle");

inAxis.onChange = function ()
{
    let arr = inAxis.get();
    if (!arr) return;

    let idx = inAxisNum.get() * 2;

    let x = 0;
    let y = 0;

    if (arr[idx + 0] > 0)x = CABLES.map(arr[idx + 0], inDeadZone.get(), 1, 0, 1);
    else x = CABLES.map(arr[idx + 0], -1, -inDeadZone.get(), -1, 0);

    if (arr[idx + 1] > 0)y = CABLES.map(arr[idx + 1], inDeadZone.get(), 1, 0, 1);
    else y = CABLES.map(arr[idx + 1], -1, -inDeadZone.get(), -1, 0);

    outX.set(x);
    outY.set(y);

    if (x != 0 || y != 0)
    {
        let theta = Math.atan2(x, y);

        let angle = theta * 180 / Math.PI * -1;
        outAngle.set(360 - (angle + 180));
    }
};


};

Ops.Devices.GamePad.GamePadJoystickAxis.prototype = new CABLES.Op();
CABLES.OPS["05be9e0d-c6bd-42f6-9f2c-16ae5ad4db7a"]={f:Ops.Devices.GamePad.GamePadJoystickAxis,objName:"Ops.Devices.GamePad.GamePadJoystickAxis"};




// **************************************************************
// 
// Ops.Devices.GamePad.GamePads
// 
// **************************************************************

Ops.Devices.GamePad.GamePads = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    outNumPads = op.outNumber("Num Gamepads"),
    pad0 = op.outObject("Pad 0"),
    pad1 = op.outObject("Pad 1"),
    pad2 = op.outObject("Pad 2"),
    pad3 = op.outObject("Pad 3");

exe.onTriggered = function ()
{
    let gamePads = navigator.getGamepads();
    let count = 0;

    for (let gp = 0; gp < gamePads.length; gp++)
    {
        if (gamePads[gp])
        {
            count++;

            if (gp == 0)
            {
                pad0.set(null);
                pad0.set(gamePads[gp]);
            }
            if (gp == 1)
            {
                pad1.set(null);
                pad1.set(gamePads[gp]);
            }
            if (gp == 2)
            {
                pad2.set(null);
                pad2.set(gamePads[gp]);
            }
            if (gp == 3)
            {
                pad3.set(null);
                pad3.set(gamePads[gp]);
            }
        }
    }

    outNumPads.set(count);
};

exe.onTriggered();


};

Ops.Devices.GamePad.GamePads.prototype = new CABLES.Op();
CABLES.OPS["76b42a0b-21a4-4eef-b20c-5a969a2189f0"]={f:Ops.Devices.GamePad.GamePads,objName:"Ops.Devices.GamePad.GamePads"};




// **************************************************************
// 
// Ops.Devices.Keyboard.CursorKeys
// 
// **************************************************************

Ops.Devices.Keyboard.CursorKeys = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    canvasOnly = op.inValueBool("canvas only", true),
    keysCursor = op.inValueBool("Cursor Keys", true),
    keysWasd = op.inValueBool("WASD", true),
    inActive = op.inBool("Active", true),
    pressedUp = op.outBoolNum("Up"),
    pressedDown = op.outBoolNum("Down"),
    pressedLeft = op.outBoolNum("Left"),
    pressedRight = op.outBoolNum("Right");

const cgl = op.patch.cgl;

function onKeyDown(e)
{
    if (keysWasd.get())
    {
        if (e.keyCode == 87) pressedUp.set(true);
        if (e.keyCode == 83) pressedDown.set(true);
        if (e.keyCode == 65) pressedLeft.set(true);
        if (e.keyCode == 68) pressedRight.set(true);
    }
    if (keysCursor.get())
    {
        if (e.keyCode == 38) pressedUp.set(true);
        if (e.keyCode == 40) pressedDown.set(true);
        if (e.keyCode == 37) pressedLeft.set(true);
        if (e.keyCode == 39) pressedRight.set(true);
    }
}

function onKeyUp(e)
{
    if (keysWasd.get())
    {
        if (e.keyCode == 87) pressedUp.set(false);
        if (e.keyCode == 83) pressedDown.set(false);
        if (e.keyCode == 65) pressedLeft.set(false);
        if (e.keyCode == 68) pressedRight.set(false);
    }
    if (keysCursor.get())
    {
        if (e.keyCode == 38) pressedUp.set(false);
        if (e.keyCode == 40) pressedDown.set(false);
        if (e.keyCode == 37) pressedLeft.set(false);
        if (e.keyCode == 39) pressedRight.set(false);
    }
}

op.onDelete = function ()
{
    cgl.canvas.removeEventListener("keyup", onKeyUp, false);
    cgl.canvas.removeEventListener("keydown", onKeyDown, false);
    document.removeEventListener("keyup", onKeyUp, false);
    document.removeEventListener("keydown", onKeyDown, false);
};

function addListener()
{
    if (canvasOnly.get()) addCanvasListener();
    else addDocumentListener();
}

function onBlur()
{
    pressedUp.set(false);
    pressedDown.set(false);
    pressedLeft.set(false);
    pressedRight.set(false);
}

inActive.onChange = () =>
{
    pressedUp.set(false);
    pressedDown.set(false);
    pressedLeft.set(false);
    pressedRight.set(false);
};

function removeListeners()
{
    cgl.canvas.removeEventListener("blur", onBlur);
    document.removeEventListener("keydown", onKeyDown, false);
    document.removeEventListener("keyup", onKeyUp, false);
    cgl.canvas.removeEventListener("keydown", onKeyDown, false);
    cgl.canvas.removeEventListener("keyup", onKeyUp, false);
}

function addCanvasListener()
{
    cgl.canvas.addEventListener("blur", onBlur);

    cgl.canvas.addEventListener("keydown", onKeyDown, false);
    cgl.canvas.addEventListener("keyup", onKeyUp, false);
}

function addDocumentListener()
{
    document.addEventListener("keydown", onKeyDown, false);
    document.addEventListener("keyup", onKeyUp, false);
}

canvasOnly.onChange = function ()
{
    removeListeners();
    addListener();
};

canvasOnly.set(true);
addCanvasListener();


};

Ops.Devices.Keyboard.CursorKeys.prototype = new CABLES.Op();
CABLES.OPS["65930ca9-c923-453f-b8c4-144eda13fa0a"]={f:Ops.Devices.Keyboard.CursorKeys,objName:"Ops.Devices.Keyboard.CursorKeys"};




// **************************************************************
// 
// Ops.Devices.Keyboard.KeyPressLearn
// 
// **************************************************************

Ops.Devices.Keyboard.KeyPressLearn = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const learnedKeyCode = op.inValueInt("key code");
const canvasOnly = op.inValueBool("canvas only", true);
const modKey = op.inValueSelect("Mod Key", ["none", "alt"], "none");
const inEnable = op.inValueBool("Enabled", true);
const preventDefault = op.inValueBool("Prevent Default");
const learn = op.inTriggerButton("learn");
const onPress = op.outTrigger("on press");
const onRelease = op.outTrigger("on release");
const outPressed = op.outBoolNum("Pressed", false);
const outKey = op.outString("Key");

const cgl = op.patch.cgl;
let learning = false;

modKey.onChange = learnedKeyCode.onChange = updateKeyName;

function onKeyDown(e)
{
    if (learning)
    {
        learnedKeyCode.set(e.keyCode);
        if (CABLES.UI)
        {
            op.refreshParams();
        }
        // op.log("Learned key code: " + learnedKeyCode.get());
        learning = false;
        removeListeners();
        addListener();

        if (CABLES.UI)gui.emitEvent("portValueEdited", op, learnedKeyCode, learnedKeyCode.get());
    }
    else
    {
        if (e.keyCode == learnedKeyCode.get())
        {
            if (modKey.get() == "alt")
            {
                if (e.altKey === true)
                {
                    onPress.trigger();
                    outPressed.set(true);
                    if (preventDefault.get())e.preventDefault();
                }
            }
            else
            {
                onPress.trigger();
                outPressed.set(true);
                if (preventDefault.get())e.preventDefault();
            }
        }
    }
}

function onKeyUp(e)
{
    if (e.keyCode == learnedKeyCode.get())
    {
        // op.log("Key released, key code: " + e.keyCode);
        onRelease.trigger();
        outPressed.set(false);
    }
}

op.onDelete = function ()
{
    cgl.canvas.removeEventListener("keyup", onKeyUp, false);
    cgl.canvas.removeEventListener("keydown", onKeyDown, false);
    document.removeEventListener("keyup", onKeyUp, false);
    document.removeEventListener("keydown", onKeyDown, false);
};

learn.onTriggered = function ()
{
    // op.log("Listening for key...");
    learning = true;
    addDocumentListener();

    setTimeout(function ()
    {
        learning = false;
        removeListeners();
        addListener();
    }, 3000);
};

function addListener()
{
    if (canvasOnly.get()) addCanvasListener();
    else addDocumentListener();
}

function removeListeners()
{
    document.removeEventListener("keydown", onKeyDown, false);
    document.removeEventListener("keyup", onKeyUp, false);
    cgl.canvas.removeEventListener("keydown", onKeyDown, false);
    cgl.canvas.removeEventListener("keyup", onKeyUp, false);
    outPressed.set(false);
}

function addCanvasListener()
{
    cgl.canvas.addEventListener("keydown", onKeyDown, false);
    cgl.canvas.addEventListener("keyup", onKeyUp, false);
}

function addDocumentListener()
{
    document.addEventListener("keydown", onKeyDown, false);
    document.addEventListener("keyup", onKeyUp, false);
}

inEnable.onChange = function ()
{
    if (!inEnable.get())
    {
        removeListeners();
    }
    else
    {
        addListener();
    }
};

canvasOnly.onChange = function ()
{
    removeListeners();
    addListener();
};

function updateKeyName()
{
    let keyName = CABLES.keyCodeToName(learnedKeyCode.get());
    const modKeyName = modKey.get();
    if (modKeyName && modKeyName !== "none")
    {
        keyName = modKeyName.charAt(0).toUpperCase() + modKeyName.slice(1) + "-" + keyName;
    }
    op.setUiAttribs({ "extendTitle": keyName });
    outKey.set(keyName);
}

addCanvasListener();


};

Ops.Devices.Keyboard.KeyPressLearn.prototype = new CABLES.Op();
CABLES.OPS["f069c0db-4051-4eae-989e-6ef7953787fd"]={f:Ops.Devices.Keyboard.KeyPressLearn,objName:"Ops.Devices.Keyboard.KeyPressLearn"};




// **************************************************************
// 
// Ops.Devices.Keyboard.KeyPress_v2
// 
// **************************************************************

Ops.Devices.Keyboard.KeyPress_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inArea = op.inValueSelect("Area", ["Canvas", "Document", "Parent Element"], "Canvas");
const preventDefault = op.inBool("Prevent Default", false);
const inEnable = op.inBool("Enabled", true);
const onPress = op.outTrigger("On Press");
const keyCode = op.outNumber("Key Code");
const outKey = op.outString("Key");

const cgl = op.patch.cgl;
let listenerElement = null;

inArea.onChange = inEnable.onChange = () =>
{
    if (inEnable.get())
    {
        addListeners();
    }
    else
    {
        removeListeners();
    }
};

op.onDelete = () =>
{
    removeListeners();
};

function onKeyPress(e)
{
    const keyName = CABLES.keyCodeToName(e.keyCode);
    op.setUiAttribs({ "extendTitle": keyName });
    outKey.set(keyName);
    keyCode.set(e.keyCode);
    onPress.trigger();
    if (preventDefault.get()) e.preventDefault();
}

function addListeners()
{
    if (listenerElement) removeListeners();

    listenerElement = cgl.canvas;
    if (inArea.get() === "Document") listenerElement = document.body;
    if (inArea.get() === "Parent Element") listenerElement = cgl.canvas.parentElement;

    listenerElement.addEventListener("keydown", onKeyPress);
}

function removeListeners()
{
    if (!listenerElement) return;
    listenerElement.removeEventListener("keydown", onKeyPress);
    listenerElement = null;
}

addListeners();


};

Ops.Devices.Keyboard.KeyPress_v2.prototype = new CABLES.Op();
CABLES.OPS["023d1e35-1231-4c50-a044-4a0e63609ba5"]={f:Ops.Devices.Keyboard.KeyPress_v2,objName:"Ops.Devices.Keyboard.KeyPress_v2"};




// **************************************************************
// 
// Ops.Devices.Keyboard.QWERTYtoMidi
// 
// **************************************************************

Ops.Devices.Keyboard.QWERTYtoMidi = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let canvasOnly = op.addInPort(new CABLES.Port(op, "canvas only", CABLES.OP_PORT_TYPE_VALUE, { "display": "bool" }));

let noteNumberPort = op.outValue("Note Number");
let velocityPort = op.outValue("Velocity");
let channelPort = op.outValue("Channel");
let commandPort = op.outValue("Command");

let cgl = op.patch.cgl;

function midiMessageReceived(msgs)
{
    for (let i = 0; i < msgs.length; i++)
    {
        let cmd = msgs[i].data[0] >> 4;
        let channel = msgs[i].data[0] & 0xf;
        let noteNumber = msgs[i].data[1];
        let velocity = msgs[i].data[2];

        noteNumberPort.set(noteNumber);
        velocityPort.set(velocity);
        channelPort.set(channel);
        commandPort.set(cmd);

    /*
    if (cmd==8) {
      //myNode.noteOff(0);
    } else if (cmd == 9) {
      //myNode.noteOn(0);
    }
    */
    }
}

/*
 * Midikeys.js
 * > Turn your keyboard into a midi keyboard, compatible with the Web MIDI API.
 * Copyright 2012 Nick Thompson
 * MIT License
 * https://gist.github.com/3995530
 */

// Keycode to MIDI note values
let map = {};

map[81] = 72; // q C5
map[87] = 74; // w D5
map[69] = 76; // e E5
map[82] = 77; // r F5
map[84] = 79; // t G5
map[89] = 81; // y A5
map[85] = 83; // u B5
map[73] = 84; // i C6
map[79] = 86; // o D6
map[80] = 88; // p E6
map[219] = 89; // [ F6
map[221] = 91; // ] G6

map[83] = 61; // s C#4
map[68] = 63; // d D#4
map[71] = 66; // g F#4
map[72] = 68; // h G#4
map[74] = 70; // j A#4
map[76] = 73; // l C#5
map[186] = 75; // ; D#5

map[90] = 60; // z C4
map[88] = 62; // x D4
map[67] = 64; // c E4
map[86] = 65; // v F4
map[66] = 67; // b G4
map[78] = 69; // n A4
map[77] = 71; // m B4
map[188] = 72; // , C5
map[190] = 74; // . D5
map[191] = 76; // / E5

// Keep track of keydown and keyup events so that the keydown event doesn't
// send messages repeatedly until keyup.
let flags = {};

function sendMessage(e, command)
{
    // Check the event key against the midi map.
    let note = map[(typeof e.which === "number") ? e.which : e.keyCode];

    // If the key doesn't exist in the midi map, or we're trying to send a
    // noteOn event without having most recently sent a noteOff, end here.
    if (note === undefined || (flags[note] && command === 0x9))
    {
        return false;
    }

    // Build the data
    let data = new Uint8Array(3);

    data[0] = (command << 4) + 0x00; // Send the command on channel 0
    data[1] = note; // Attach the midi note
    data[2] = 127; // Keyboard keys default to 127 velocity.

    // Package the message
    let msg = {
        "data": data,
        "timestamp": 0
    };

    // Send it
    api.onmessage.call(window, [msg]);

    // Update the flag table
    if (command === 0x9)
    {
        flags[note] = true;
    }
    else
    {
        flags[note] = false;
    }
}

// MIDIKeys api object, to be exposed as window.Keys
let api = {

    // Expose the onmessage parameter like on a MIDIInput object
    "onmessage": null

};

let MIDIKeys = api;

// Including Midikeys.js in your project file packages fake MIDI messages the same as a normal message,
// so you can then just attach your message handler to MIDI keys and you're done

MIDIKeys.onmessage = midiMessageReceived;

function onKeyDown(e)
{
    sendMessage(e, 0x09);
}

function onKeyUp(e)
{
    sendMessage(e, 0x08);
}

function addListener()
{
    if (canvasOnly.get())
    {
        addCanvasListener();
    }
    else
    {
        addDocumentListener();
    }
}

function removeListeners()
{
    document.removeEventListener("keydown", onKeyDown, false);
    document.removeEventListener("keyup", onKeyUp, false);
    cgl.canvas.removeEventListener("keydown", onKeyDown, false);
    cgl.canvas.removeEventListener("keyup", onKeyUp, false);
}

function addCanvasListener()
{
    cgl.canvas.addEventListener("keydown", onKeyDown, false);
    cgl.canvas.addEventListener("keyup", onKeyUp, false);
}

function addDocumentListener()
{
    document.addEventListener("keydown", onKeyDown, false);
    document.addEventListener("keyup", onKeyUp, false);
}

canvasOnly.onChange = function ()
{
    removeListeners();
    addListener();
};

canvasOnly.set(true);
addCanvasListener();


};

Ops.Devices.Keyboard.QWERTYtoMidi.prototype = new CABLES.Op();
CABLES.OPS["0aecef8b-3bcb-44ac-ae62-38ce8cd4051e"]={f:Ops.Devices.Keyboard.QWERTYtoMidi,objName:"Ops.Devices.Keyboard.QWERTYtoMidi"};




// **************************************************************
// 
// Ops.Devices.Midi.DeviceList
// 
// **************************************************************

Ops.Devices.Midi.DeviceList = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const outNumDevices = op.outValue("Num Devices");
const outSupport = op.outValueBool("Midi Support");
const outNames = op.outArray("Device Names");

let midi = null;

function onMIDIFailure()
{
    outSupport.set(false);
}

if (navigator.requestMIDIAccess) navigator.requestMIDIAccess({ "sysex": false }).then(onMIDISuccess, onMIDIFailure);
else onMIDIFailure();

function onMIDISuccess(midiAccess)
{
    let arr = [];
    midi = midiAccess;
    outSupport.set(true);
    let inputs = midi.inputs.values();

    let devices = [];
    let numDevices = 0;

    for (let input = inputs.next(); input && !input.done; input = inputs.next())
    {
        arr.push(input.value.name);
        numDevices++;
    }

    outNames.set(arr);
    outNumDevices.set(numDevices);
}


};

Ops.Devices.Midi.DeviceList.prototype = new CABLES.Op();
CABLES.OPS["6e52048f-557d-4332-9d5e-2201f728cb23"]={f:Ops.Devices.Midi.DeviceList,objName:"Ops.Devices.Midi.DeviceList"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiCC
// 
// **************************************************************

Ops.Devices.Midi.MidiCC = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
/* UTIL */
const MIDIChannels = Array.from(Array(16).keys(), (i) => { return i + 1; });
/* IN */
const inEvent = op.inObject("MIDI Event In");
const midiChannelDropdown = op.inValueSelect("MIDI Channel", MIDIChannels, 1);
const ccIndexDropdown = op.inValueInt("CC Index", 0);
const normalizeDropdown = op.inSwitch("Normalize", ["none", "0 to 1", "-1 to 1"], "none");
const learn = op.inTriggerButton("learn");
const clear = op.inTriggerButton("clear");

op.setPortGroup("MIDI", [inEvent, midiChannelDropdown]);
op.setPortGroup("CC", [ccIndexDropdown, normalizeDropdown]);
op.setPortGroup("", [learn, clear]);

const ccArray = Array.from(Array(128).keys(), (key) => { return 0; });

/* OUT */
const eventOut = op.outObject("Event");
const triggerOut = op.outTrigger("Trigger Out");
const ccIndexOut = op.outNumber("CC Index Out");
const ccValueOut = op.outNumber("CC Value Out");
const arrayOut = op.outArray("Value Array");

op.setPortGroup("MIDI/Trigger Out", [eventOut, triggerOut]);
op.setPortGroup("CC Out", [ccIndexOut, ccValueOut]);

arrayOut.set(ccArray);

ccIndexDropdown.set(0);
midiChannelDropdown.set(1);
normalizeDropdown.set(normalizeDropdown.get("none"));

let learning = false;
learn.onTriggered = () =>
{
    learning = true;
};

clear.onTriggered = () =>
{
    ccIndexDropdown.set(0);
    midiChannelDropdown.set(1);
    normalizeDropdown.set(normalizeDropdown.get("none"));
    op.refreshParams();
};

inEvent.onChange = () =>
{
    const event = inEvent.get();
    if (!event) return;
    if (event.messageType !== "CC") return;

    const [, ccIndex, ccValue] = event.data;
    if (learning)
    {
        ccIndexDropdown.set(ccIndex);
        midiChannelDropdown.set(event.channel + 1);

        learning = false;

        if (CABLES.UI)
        {
            gui.emitEvent("portValueEdited", op, ccIndexDropdown, ccIndexDropdown.get());
            gui.emitEvent("portValueEdited", op, midiChannelDropdown, midiChannelDropdown.get());

            op.uiAttr({ "info": `bound to CC: ${ccIndexDropdown.get()}` });
            op.refreshParams();
        }
    }

    if (event.channel === midiChannelDropdown.get() - 1)
    {
        if (normalizeDropdown.get() === "0 to 1")
        {
            ccArray[ccIndex] = ccValue / 127;
        }
        else if (normalizeDropdown.get() === "-1 to 1")
        {
            ccArray[ccIndex] = ccValue / (127 / 2) - 1;
        }
        else if (normalizeDropdown.get() === "none")
        {
            ccArray[ccIndex] = ccValue;
        }

        if (ccIndex === ccIndexDropdown.get())
        {
            ccIndexOut.set(ccIndex);
            let value = ccValue;
            ccArray[ccIndex] = ccValue;
            if (normalizeDropdown.get() === "0 to 1")
            {
                value = ccValue / 127;
                ccValueOut.set(value);
                ccArray[ccIndex] = ccValue;
                triggerOut.trigger();
            }
            else if (normalizeDropdown.get() === "-1 to 1")
            {
                value = ccValue / (127 / 2) - 1;
                triggerOut.trigger();
                ccValueOut.set(value);
                ccArray[ccIndex] = ccValue;
            }
            else if (normalizeDropdown.get() === "none")
            {
                triggerOut.trigger();
                ccValueOut.set(value);
                ccArray[ccIndex] = ccValue;
            }
            else
            {
                ccArray[ccIndex] = 0;
                ccValue.set(0);
            }
        }
    }

    arrayOut.set(null);
    arrayOut.set(ccArray);
    eventOut.set(null);
    eventOut.set(event);
};


};

Ops.Devices.Midi.MidiCC.prototype = new CABLES.Op();
CABLES.OPS["28616ffc-a761-4792-9076-8625f9ccc965"]={f:Ops.Devices.Midi.MidiCC,objName:"Ops.Devices.Midi.MidiCC"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiCCOut
// 
// **************************************************************

Ops.Devices.Midi.MidiCCOut = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const MIDIChannels = Array.from(Array(16).keys(), i => i + 1);
const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
const CC_STATUS_BYTE = 0xb;

const inChannel = op.inDropDown("MIDI Channel", MIDIChannels, "1");
const inCcIndex = op.inInt("CC Index", 1);
const inCCValue = op.inInt("CC Value", 0);
const inMin = op.inFloat("Min In Value", 0);
const inMax = op.inFloat("Max In Value", 1);

op.setPortGroup("General",[inChannel]);
op.setPortGroup("CC", [inCCValue, inCcIndex]);
op.setPortGroup("Value Range", [inMin,inMax]);

const outEvent = op.outObject("MIDI Event Out");

inCCValue.onChange = function() {
    const val = inCCValue.get();

    const ccValue = Math.floor(CABLES.map(val,inMin.get(), inMax.get(), 0, 127));
    const ccIndex = clamp(inCcIndex.get(), 1, 127);


  const event = {
      deviceName: null,
      output: null,
      inputId: 0,
      messageType: "CC",
      data: [CC_STATUS_BYTE << 4 | (inChannel.get() - 1), ccIndex, ccValue],
      index: ccIndex,
      value: ccValue,
      channel: inChannel.get() - 1,
  }

  outEvent.set(null);
  outEvent.set(event);
}

};

Ops.Devices.Midi.MidiCCOut.prototype = new CABLES.Op();
CABLES.OPS["f63adc97-7f4a-4cad-a53a-a20ad1e9b30e"]={f:Ops.Devices.Midi.MidiCCOut,objName:"Ops.Devices.Midi.MidiCCOut"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiChord3
// 
// **************************************************************

Ops.Devices.Midi.MidiChord3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
/* UTIL */
const NOTE_OFF = 0x8;
const NOTE_ON = 0x9;
const NOTE_VALUES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

const MIDIChannels = Array.from(Array(16).keys()).map((i) => { return i + 1; });

function getMIDINote(dataByte1LSB)
{
    return dataByte1LSB <= 126
        ? `${NOTE_VALUES[dataByte1LSB % 12]}${Math.floor(dataByte1LSB / 12) - 2} - ${dataByte1LSB}`
        : "NO NOTE";
}

const noteValues = Array.from(Array(128).keys(), (key) => { return getMIDINote(key); });

/* IN */
const inEvent = op.inObject("MIDI Event In");
const midiChannelDropdown = op.inValueSelect("MIDI Channel", MIDIChannels, 1);
const noteDropdown = op.inValueSelect("Note 1", noteValues, 0);
const noteDropdown2 = op.inValueSelect("Note 2", noteValues, 0);
const noteDropdown3 = op.inValueSelect("Note 3", noteValues, 0);
const noteDropdowns = [noteDropdown, noteDropdown2, noteDropdown3];

const normalizeDropdown = op.inValueSelect(
    "Normalize Velocity",
    ["none", "0 to 1", "-1 to 1"],
    "none"
);

const learn = op.inTriggerButton("learn");
const reset = op.inTriggerButton("reset");

op.setPortGroup("MIDI", [inEvent, midiChannelDropdown]);
op.setPortGroup("Notes", [...noteDropdowns, normalizeDropdown]);
op.setPortGroup("", [learn, reset]);
/* OUT */

const eventOut = op.outObject("MIDI Event Out");
const triggerOut = op.outTrigger("Trigger Out");

const noteIndexOut1 = op.outNumber("Note Out 1");
const velocityOut1 = op.outNumber("Velocity 1");
const gateOut1 = op.outValueBool("Gate 1");

const out1 = {
    "noteIndexOut": noteIndexOut1,
    "velocityOut": velocityOut1,
    "gateOut": gateOut1,
};

const noteIndexOut2 = op.outValue("Note Out 2");
const velocityOut2 = op.outValue("Velocity 2");
const gateOut2 = op.outValueBool("Gate 2");

const out2 = {
    "noteIndexOut": noteIndexOut2,
    "velocityOut": velocityOut2,
    "gateOut": gateOut2,
};

const noteIndexOut3 = op.outValue("Note Out 3");
const velocityOut3 = op.outValue("Velocity 3");
const gateOut3 = op.outValueBool("Gate 3");

const out3 = {
    "noteIndexOut": noteIndexOut3,
    "velocityOut": velocityOut3,
    "gateOut": gateOut3,
};

const outs = [out1, out2, out3];
noteDropdown.set(0);
midiChannelDropdown.set(1);

op.setPortGroup("MIDI/Trigger Out", [eventOut, triggerOut]);
op.setPortGroup("Note 1", [noteIndexOut1, velocityOut1, gateOut1]);
op.setPortGroup("Note 2", [noteIndexOut2, velocityOut2, gateOut2]);
op.setPortGroup("Note 3", [noteIndexOut3, velocityOut3, gateOut3]);

let learning = false;
let learnCount = 0;
let learnedNotes = [];

learn.onTriggered = () =>
{
    learning = true;
};

reset.onTriggered = () =>
{
    learning = false;
    learnCount = 0;
    learnedNotes = [];
    noteDropdowns.forEach((nd) => { return nd.set(0); });
    op.refreshParams();
};

inEvent.onChange = () =>
{
    const event = inEvent.get();
    if (!event) return;
    if (event.messageType !== "Note") return;
    if (!event.newNote) return;

    const [statusByte] = event.data;

    const { newNote, velocity, channel } = event;
    const [noteIndex, noteName] = newNote;
    const midiNote = getMIDINote(noteIndex);
    const msgType = statusByte >> 4;

    if (learning && learnCount < 3)
    {
        if (msgType === NOTE_OFF)
        {
            eventOut.set(event);
            return;
        }

        if (!learnedNotes.includes(midiNote)) noteDropdowns[learnCount].set(midiNote);
        else
        {
            eventOut.set(event);
            return;
        }

        learnedNotes.push(midiNote);
        if (learnCount === 0) midiChannelDropdown.set(event.channel + 1);

        if (CABLES.UI)
        {
            op.uiAttr({ "info": `bound to Note: ${noteDropdowns[learnCount].get()}` });
            op.refreshParams();
        }

        learnCount += 1;
        learning = learnCount < 3;
    }

    if (channel === midiChannelDropdown.get() - 1)
    {
        const chordIndex = noteDropdowns.map((nd) => { return nd.get(); }).indexOf(midiNote);

        if (chordIndex === -1)
        {
            eventOut.set(event);
            return;
        }

        const {
            gateOut, noteIndexOut, velocityOut,
        } = outs[chordIndex];

        if (msgType === NOTE_OFF || velocity === 0)
        {
            gateOut.set(false);
            if (velocity === 0) velocityOut.set(0);
        }

        if (msgType === NOTE_ON)
        {
            gateOut.set(true);
            triggerOut.trigger();
            noteIndexOut.set(noteIndex);

            if (normalizeDropdown.get() === "0 to 1")
            {
                // (max'-min')/(max-min)*(value-min)+min'
                velocityOut.set(1 / 126 * (velocity - 1));
            }

            else if (normalizeDropdown.get() === "-1 to 1")
            {
                // (max'-min')/(max-min)*(value-min)+min'
                const normalizedValue = 2 / 126 * (velocity - 1) - 1;
                velocityOut.set(normalizedValue);
            }
            else if (normalizeDropdown.get() === "none") velocityOut.set(velocity);
        }
    }

    eventOut.set(event);
};


};

Ops.Devices.Midi.MidiChord3.prototype = new CABLES.Op();
CABLES.OPS["58388fbb-3161-417f-8c12-49d4c8ee7a19"]={f:Ops.Devices.Midi.MidiChord3,objName:"Ops.Devices.Midi.MidiChord3"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiClock
// 
// **************************************************************

Ops.Devices.Midi.MidiClock = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const eventIn = op.inObject("MIDI Event In");
const timingIn = op.inValueSelect("Timing", ["straight", "dotted", "triplet"], "straight");
const eventOut = op.outObject("MIDI Event Out");
const beatOut = op.outTrigger("Tick Out");
const clockStartOut = op.outTrigger("Clock Start");
const clockStopOut = op.outTrigger("Clock Stop");
const clockContinueOut = op.outTrigger("Clock Continue");

let outBPM = op.outValue("BPM");
let outBeatDuration = op.outValue("Tick Duration");
let outSubTick = op.outValue("Sub Tick");

const fullNoteOut = op.outTrigger("1/1");
const halfNoteOut = op.outTrigger("1/2");
const quarterNoteOut = op.outTrigger("1/4");
const eigthNoteOut = op.outTrigger("1/8");
const sixteenthNoteOut = op.outTrigger("1/16");

const outs = {
    "full": fullNoteOut,
    "half": halfNoteOut,
    "quarter": quarterNoteOut,
    "eigth": eigthNoteOut,
    "sixteenth": sixteenthNoteOut,
};

const CLOCK = 0xf8;
const CLOCK_START = 0xfa;
const CLOCK_CONTINUE = 0xfb;
const CLOCK_STOP = 0xfc;

const STRAIGHT_TICKS = {
    "full": 96,
    "half": 48,
    "quarter": 24,
    "eigth": 12,
    "sixteenth": 6,
};

const TICKS = {
    "straight": STRAIGHT_TICKS,
    "dotted": {
        "full": STRAIGHT_TICKS.full + STRAIGHT_TICKS.full / 2,
        "half": STRAIGHT_TICKS.half + STRAIGHT_TICKS.half / 2,
        "quarter": STRAIGHT_TICKS.quarter + STRAIGHT_TICKS.quarter / 2,
        "eigth": STRAIGHT_TICKS.eigth + STRAIGHT_TICKS.eigth / 2,
        "sixteenth": STRAIGHT_TICKS.sixteenth + STRAIGHT_TICKS.sixteenth / 2,
    },
    "triplet": {
        "full": (STRAIGHT_TICKS.full * 2) / 3,
        "half": (STRAIGHT_TICKS.half * 2) / 3,
        "quarter": (STRAIGHT_TICKS.quarter * 2) / 3,
        "eigth": (STRAIGHT_TICKS.eigth * 2) / 3,
        "sixteenth": (STRAIGHT_TICKS.sixteenth * 2) / 3,
    }
};

let tickCount = 0;
let lastBeat = 0;

eventIn.onChange = () =>
{
    const event = eventIn.get();
    if (!event) return;

    const [statusByte, , ] = event.data;
    if (statusByte === CLOCK_START)
    {
        tickCount = 0;
        clockStartOut.trigger();
    }
    else if (statusByte === CLOCK_STOP)
    {
        clockStopOut.trigger();
    }
    else if (statusByte === CLOCK || statusByte === CLOCK_CONTINUE)
    {
        if (statusByte === CLOCK_CONTINUE) clockContinueOut.trigger();

        const {
            full, half, quarter, eigth, sixteenth,
        } = TICKS[timingIn.get()];
        if (tickCount % 24 === 0)
        {
            if (lastBeat !== 0)
            {
                const diff = CABLES.now() - lastBeat;
                const bpm = 60000 / diff;
                outBPM.set(bpm);
                outBeatDuration.set(15 / bpm);
            }

            lastBeat = CABLES.now();
        }
        if (tickCount % full === 0) outs.full.trigger();
        if (tickCount % half === 0) outs.half.trigger();
        if (tickCount % quarter === 0) outs.quarter.trigger();
        if (tickCount % eigth === 0) outs.eigth.trigger();
        if (tickCount % sixteenth === 0) outs.sixteenth.trigger();
        beatOut.trigger();
        tickCount += 1;
        outSubTick.set(tickCount % 24);
    }

    eventOut.set(event);
};


};

Ops.Devices.Midi.MidiClock.prototype = new CABLES.Op();
CABLES.OPS["5eea2f30-4e10-42a7-a761-63fb274cdb4f"]={f:Ops.Devices.Midi.MidiClock,objName:"Ops.Devices.Midi.MidiClock"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiInputDevice_v2
// 
// **************************************************************

Ops.Devices.Midi.MidiInputDevice_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// http://www.keithmcmillen.com/blog/making-music-in-the-browser-web-midi-api/

// https://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html

/* INPUTS */

const deviceSelect = op.inValueSelect("Device", ["none"]);

let learning = false;
const learn = op.inTriggerButton("Learn");
const resetIn = op.inTriggerButton("Panic");

op.setPortGroup("Device Select", [deviceSelect]);
op.setPortGroup("Controls", [learn, resetIn]);
/* OPS */
const opPrefix = "Ops.Devices.Midi.Midi";
const OPS = {
    "CC": { "NAMESPACE": `${opPrefix}CC`, "IN_PORT": "CC Index" },
    "NRPN": { "NAMESPACE": `${opPrefix}NRPN`, "IN_PORT": "NRPN Index" },
    "Note": { "NAMESPACE": `${opPrefix}Note`, "IN_PORT": "Note" },
};
/* OUTPUTS */
const OUTPUT_KEYS = [
    "Event",
    "Note",
    "CC",

    // "Channel Pressure",
    // "Poly Key Pressure",
    "NRPN",
    // 'SysEx',
    // "Pitchbend",
    "Program Change",
    "Clock",
];

// unused midi signals
const NOT_YET_USED = ["Pitchbend", "Channel Pressure", "Poly Key Pressure", "SysEx"];

// create outputs from keys specified above
const OUTPUTS = OUTPUT_KEYS.reduce((acc, cur) =>
{
    acc[cur] = op.outObject(cur);
    return acc;
}, {});

op.setPortGroup("MIDI Event", [OUTPUTS.Event]);
op.setPortGroup(
    "MIDI Event by Type",
    Object.keys(OUTPUTS).map((key) => { return key !== "Event" && OUTPUTS[key]; }).filter(Boolean),
);

/* CONSTANTS */
/* http://www.indiana.edu/~emusic/etext/MIDI/chapter3_MIDI3.shtml */
const NOTE_VALUES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

/* MIDI STATUS BYTES */
const NOTE_OFF = 0x8;
const NOTE_ON = 0x9;
const POLY_KEY_PRESSURE = 0xa;
const CC = 0xb;
const PROGRAM_CHANGE = 0xc;
const CHANNEL_PRESSURE = 0xd;
const PITCH_BEND = 0xe;
const CLOCK = 0xf8;
const CLOCK_START = 0xfa;
const CLOCK_CONTINUE = 0xfb;
const CLOCK_STOP = 0xfc;
const CLOCK_SIGNALS = [CLOCK, CLOCK_START, CLOCK_CONTINUE, CLOCK_STOP];

const MESSAGE_TYPES = {
    [NOTE_OFF]: "Note",
    [NOTE_ON]: "Note",
    [POLY_KEY_PRESSURE]: "Poly Key Pressure",
    [CC]: "CC",
    [PROGRAM_CHANGE]: "Program Change",
    [CHANNEL_PRESSURE]: "Channel Pressure",
    [PITCH_BEND]: "Pitchbend",
    [CLOCK]: "Clock",
};

/* UTILITY FUNCTIONS */
function getMIDIChannel(statusByte)
{
    return statusByte & 0x0f;
}

function getMessageType(statusByte)
{
    return MESSAGE_TYPES[statusByte >> 4] || "UNKNOWN";
}

function getMIDINote(dataByte1LSB)
{
    return dataByte1LSB <= 126
        ? `${NOTE_VALUES[dataByte1LSB % 12]}${Math.floor(dataByte1LSB / 12) - 2} - ${dataByte1LSB}`
        : "NO NOTE";
}

const NRPN_CCS = [98, 99, 6, 38];
const NRPN_VALUE_MSB = 6;
const NRPN_VALUE_LSB = 38;
const NRPN_INDEX_MSB = 99;
const NRPN_INDEX_LSB = 98;

let nrpnIndexMSB = null;
let nrpnIndexLSB = null;
let nrpnValueMSB = null;
let nrpnValueLSB = null;

let nrpnIndex_ = null;
let nrpnValue_ = null;

/* NRPN implementations differ, we need to check whether the cycle starts with LSB or MSB */
const MSB_START = 9;
const LSB_START = 10;
let FIRST_CC = null;
let ROUTINE_TYPE = null;
/* the state of the current NRPN construction cycle */


const LSBRoutine = (ccIndex, ccValue) =>
{
    // NOTE: this is still the MSBRoutine
    if (ccIndex === NRPN_INDEX_MSB) nrpnIndexMSB = ccValue << 7;
    else if (ccIndex === NRPN_INDEX_LSB) nrpnIndexLSB = ccValue;

    nrpnIndex_ = nrpnIndexMSB | nrpnIndexLSB;

    if (typeof nrpnIndex_ === "number")
    {
        if (ccIndex === NRPN_VALUE_MSB)
        {
            nrpnValueMSB = ccValue << 7;


            if (typeof nrpnValueLSB === "number")
            {
                nrpnValue_ = nrpnValueMSB | nrpnValueLSB;
                return [nrpnIndex_, nrpnValue_];
            }
        }
        else if (ccIndex === NRPN_VALUE_LSB)
        {
            nrpnValueLSB = ccValue;

            nrpnValue_ = nrpnValueMSB | nrpnValueLSB;
            return [nrpnIndex_, nrpnValue_];
        }
    }

    return null;
};

const MSBRoutine = (ccIndex, ccValue) =>
{
    if (ccIndex === NRPN_INDEX_MSB) nrpnIndexMSB = ccValue << 7;
    else if (ccIndex === NRPN_INDEX_LSB) nrpnIndexLSB = ccValue;

    nrpnIndex_ = nrpnIndexMSB | nrpnIndexLSB;
    if (typeof nrpnIndex_ === "number")
    {
        if (ccIndex === NRPN_VALUE_MSB)
        {
            nrpnValueMSB = ccValue << 7;

            if (typeof nrpnValueLSB === "number")
            {
                nrpnValue_ = nrpnValueMSB | nrpnValueLSB;
                return [nrpnIndex_, nrpnValue_];
            }
        }
        else if (ccIndex === NRPN_VALUE_LSB)
        {
            nrpnValueLSB = ccValue;
            nrpnValue_ = nrpnValueMSB | nrpnValueLSB;
            return [nrpnIndex_, nrpnValue_];
        }
    }

    return null;
};

const NRPNRoutine = (ccIndex, ccValue) =>
{
    if (FIRST_CC === null)
    {
        FIRST_CC = ccIndex;
        ROUTINE_TYPE = FIRST_CC === NRPN_INDEX_MSB ? MSB_START : LSB_START;
    }
    if (ROUTINE_TYPE === MSB_START)
    {
        return MSBRoutine(ccIndex, ccValue);
    }
    if (ROUTINE_TYPE === LSB_START)
    {
        return LSBRoutine(ccIndex, ccValue);
    }
    return null;
};
let midi = null;

/* INIT FUNCTIONS */
let outputDevice = null;

function onMIDIMessage(_event)
{
    if (!_event) return;

    if (op.patch.isEditorMode()) gui.emitEvent("userActivity");

    const { data } = _event;
    const [statusByte, LSB, MSB] = data;

    if (CLOCK_SIGNALS.includes(statusByte))
    {
        OUTPUTS.Clock.set(_event);
        return;
    }

    if (statusByte > 248)
    {
    // we don't use statusbytes above 248 for now
        return;
    }

    const deviceName = deviceSelect.get();
    const channel = getMIDIChannel(statusByte);

    let messageType = getMessageType(statusByte);
    const outputIndex = LSB;
    const outputValue = MSB;

    const isNRPNByte = messageType === "CC" && NRPN_CCS.some((cc) => { return cc === LSB; });
    let nrpnIndex;
    let nrpnValue;

    if (isNRPNByte)
    {
        const nrpnValueRes = NRPNRoutine(LSB, MSB);
        if (nrpnValueRes)
        {
            const [index, value] = nrpnValueRes;
            messageType = "NRPN";
            nrpnIndex = index;
            nrpnValue = value;
        }
    }

    const newEvent = {
        /* OLD EVENT v */
        deviceName,
        "inputId": 0, // what is this for?
        messageType,
        // ...,
        "index": outputIndex,
        "value": outputValue,

        "cmd": data[0] >> 4,
        "channel": data[0] & 0xf,
        "type": data[0] & 0xf0,
        "note": data[1],
        "velocity": data[2],
        data,
        ...messageType === "Note" && {
            "newNote": [LSB, getMIDINote(LSB)],
            "velocity": outputValue,
        },
        ...messageType === "NRPN" && { nrpnIndex, nrpnValue },
    };

    if (learning)
    {
        if (["Note", "CC", "NRPN"].includes(messageType))
        {
            const newOp = op.patch.addOp(OPS[messageType].NAMESPACE, {
                "translate": {
                    "x": op.uiAttribs.translate.x,
                    "y": op.uiAttribs.translate.y + 100,
                },
            });

            op.patch.link(op, messageType, newOp, "MIDI Event In");
            newOp.getPortByName("MIDI Channel").set(channel + 1);

            if (messageType === "Note")
            {
                const {
                    "newNote": [, noteName],
                } = newEvent;
                newOp.getPortByName("Note").set(noteName);
            }

            if (messageType === "CC")
            {
                const { index } = newEvent;
                newOp.getPortByName("CC Index").set(index);
            }

            if (messageType === "NRPN")
            {
                newOp.getPortByName("NRPN Index").set(nrpnIndex);
            }
        }
        learning = false;
    }
    // if (normalize.get()) event.velocity /= 127;

    // with pressure and tilt off
    // note off: 128, cmd: 8
    // note on: 144, cmd: 9
    // pressure / tilt on
    // pressure: 176, cmd 11:
    // bend: 224, cmd: 14
    OUTPUTS.Event.set(null);
    OUTPUTS.Event.set(newEvent);

    if (messageType !== "UNKNOWN" && !NOT_YET_USED.includes(messageType))
    {
        OUTPUTS[messageType].set(null);
        OUTPUTS[messageType].set(newEvent);
    }
}

function setDevice()
{
    if (!midi || !midi.inputs) return;
    const name = deviceSelect.get();

    op.setTitle(`Midi ${name}`);

    const inputs = midi.inputs.values();
    //  const outputs = midi.outputs.values();

    for (let input = inputs.next(); input && !input.done; input = inputs.next())
    {
        if (input.value.name === name)
        {
            input.value.onmidimessage = onMIDIMessage;
            outputDevice = midi.inputs.get(input.value.id);
        }
        else if (input.value.onmidimessage === onMIDIMessage) input.value.onmidimessage = null;
    }

    /* for (let output = outputs.next(); output && !output.done; output = outputs.next()) {
    if (output.value.name === name) {
      outputDevice = midi.outputs.get(output.value.id);
    }
  } */
}

function onMIDIFailure()
{
    op.uiAttr({ "warning": "No MIDI support in your browser." });
}

function onMIDISuccess(midiAccess)
{
    midi = midiAccess;
    const inputs = midi.inputs.values();
    op.uiAttr({ "info": "no midi devices found" });

    const deviceNames = [];

    for (let input = inputs.next(); input && !input.done; input = inputs.next())
    {
        deviceNames.push(input.value.name);
    }

    deviceSelect.uiAttribs.values = deviceNames;

    op.refreshParams();
    setDevice();
}

deviceSelect.onChange = setDevice;

if (navigator.requestMIDIAccess)
{
    navigator.requestMIDIAccess({ "sysex": false }).then(onMIDISuccess, onMIDIFailure);
}
else onMIDIFailure();

resetIn.onTriggered = () =>
{

    // TODO: senmd note off to every note
    /*
  if (!outputDevice) return;
  for (let i = 0; i < 12; i += 1) {
    outputDevice.send([0x90, i, 0]);
    outputDevice.send([0xb0, i, 0]);
  } */
};

learn.onTriggered = () =>
{
    if (!outputDevice) return;
    learning = true;
};


};

Ops.Devices.Midi.MidiInputDevice_v2.prototype = new CABLES.Op();
CABLES.OPS["484b3a00-41b7-4e3f-8a99-a1b32a764eff"]={f:Ops.Devices.Midi.MidiInputDevice_v2,objName:"Ops.Devices.Midi.MidiInputDevice_v2"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiMonitor
// 
// **************************************************************

Ops.Devices.Midi.MidiMonitor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inData = op.inObject("Event");

op.setPortGroup("MIDI", [inData]);

/* OUTPUTS */
const OUTPUT_KEYS = [
    "Device",
    "MIDI Channel",
    "Message Type",
    "Note",
    "Note Velocity",
    "CC Number",
    "CC Value",
    "Pitch Bend Value",
    "NRPN Number",
    "NRPN Value",
    "Program Change",
];

const eventOut = op.outObject("MIDI Event Out");
const triggerOut = op.outTrigger("Trigger Out");

// create outputs from keys specified above
const OUTPUTS = {
    "Device": op.outNumber("Device", -1),
    "MIDI Channel": op.outNumber("MIDI Channel", -1),
    "Message Type": op.outNumber("Message Type", -1),
    "Note": op.outNumber("Note", -1),
    "Note Velocity": op.outNumber("Note Velocity", -1),
    "CC Number": op.outNumber("CC Number", -1),
    "CC Value": op.outNumber("CC Value", -1),
    "Pitch Bend Value": op.outNumber("Pitch Bend Value", -1),
    "NRPN Number": op.outNumber("NRPN Number", -1),
    "NRPN Value": op.outNumber("NRPN Value", -1),
    "Program Change Value": op.outNumber("Program Change Value", -1),

};

op.setPortGroup("MIDI/Trigger Out", [eventOut, triggerOut]);
op.setPortGroup("General Info", ["Device", "MIDI Channel", "Message Type"].map((key) => OUTPUTS[key]));
op.setPortGroup("Note", ["Note", "Note Velocity"].map((key) => OUTPUTS[key]));
op.setPortGroup("CC", ["CC Number", "CC Value"].map((key) => OUTPUTS[key]));
op.setPortGroup("Pitch Bend", [OUTPUTS["Pitch Bend Value"]]);
op.setPortGroup("NRPN", ["NRPN Number", "NRPN Value"].map((key) => OUTPUTS[key]));
op.setPortGroup("Program Change", ["Program Change Value"].map((key) => OUTPUTS[key]));

/* http://midiio.sapp.org/src/MidiOutput.cpp for NRPN */
/* http://www.indiana.edu/~emusic/etext/MIDI/chapter3_MIDI3.shtml */

/*
The two things we can assume is that we will receive the NRPN index messages BEFORE the data
and that the LSB of the data will change every time we get an NRPN change.
*/

function getMIDIChannel(statusByte)
{
    return (statusByte & 0x0f) + 1;
}

function getPitchBendValue(dataByte1LSB, dataByte2MSB)
{
    const pitchBendValue = (dataByte2MSB << 7) + dataByte1LSB - 8192; //  scale to -1 to 1 = /8192;
    return pitchBendValue;
}

/* http://tetradev.blogspot.com/2010/03/nrpns-part-2-nrpns-in-ableton-with-max.html */
/* https://sites.uci.edu/camp2014/2014/04/30/managing-midi-pitchbend-messages/ */

inData.onChange = function ()
{
    const event = inData.get();

    if (!event || !event.data) return;
    const [statusByte, dataByte1LSB, dataByte2MSB] = event.data;
    /* We skip MIDI signals that at the moment are not relevant for CABLES,
       i.e. Ableton: if SYNC is on, every 2nd 3-Byte-Tuple sent
       is a Timing clock message
       we don't wanna show that for now, hence we skip everything above 248 */
    if (statusByte >= 248)
    {
        eventOut.set(event);
        triggerOut.trigger();
        return;
    }

    const { messageType, deviceName } = event;

    OUTPUTS.Device.set(deviceName);
    OUTPUTS["MIDI Channel"].set(getMIDIChannel(statusByte));
    OUTPUTS["Message Type"].set(messageType);

    switch (messageType)
    {
    case "NRPN":
        OUTPUTS["NRPN Number"].set(event.nrpnIndex);
        OUTPUTS["NRPN Value"].set(event.nrpnValue);
        Object.keys(OUTPUTS)
            .filter(
                (key) => !key.startsWith(messageType)
          && key !== "Message Type" && key !== "MIDI Channel" && key !== "Device",
            )
            .forEach((filteredKey) => OUTPUTS[filteredKey].set("-"));
        break;
    case "CC":
        const [, ccIndex, ccValue] = event.data;
        OUTPUTS["CC Number"].set(ccIndex);
        OUTPUTS["CC Value"].set(ccValue);
        Object.keys(OUTPUTS)
            .filter(
                (key) => !key.startsWith(messageType)
          && key !== "Message Type" && key !== "MIDI Channel" && key !== "Device",
            )
            .forEach((filteredKey) => OUTPUTS[filteredKey].set("-"));
        break;
    case "Note":
        const {
            "newNote": [noteIndex],
            velocity,
        } = event;
        OUTPUTS.Note.set(noteIndex);
        OUTPUTS["Note Velocity"].set(velocity);
        Object.keys(OUTPUTS)
            .filter(
                (key) => !key.startsWith(messageType)
          && key !== "Message Type" && key !== "MIDI Channel" && key !== "Device"
            )
            .forEach((filteredKey) => OUTPUTS[filteredKey].set("-"));
        break;
    case "Pitch Bend":
        OUTPUTS["Pitch Bend Value"].set(getPitchBendValue(dataByte1LSB, dataByte2MSB));
        Object.keys(OUTPUTS)
            .filter(
                (key) => !key.startsWith(messageType)
          && key !== "Message Type" && key !== "MIDI Channel" && key !== "Device"
            )
            .forEach((filteredKey) => OUTPUTS[filteredKey].set("-"));
        break;
    case "Program Change":
        const [, pcValue] = event.data;
        OUTPUTS["Program Change Value"].set(pcValue);
        Object.keys(OUTPUTS)
            .filter(
                (key) => !key.startsWith(messageType)
          && key !== "Message Type" && key !== "MIDI Channel" && key !== "Device"
            )
            .forEach((filteredKey) => OUTPUTS[filteredKey].set("-"));
        break;
    default:
        Object.keys(OUTPUTS)
            .filter((key) => key !== "Message Type" && key !== "MIDI Channel" && key !== "Device")
            .forEach((filteredKey) => OUTPUTS[filteredKey].set("-"));
    }

    triggerOut.trigger();
    eventOut.set(event);
    // }
};


};

Ops.Devices.Midi.MidiMonitor.prototype = new CABLES.Op();
CABLES.OPS["3f585ff5-afd6-45d5-b082-80c62f6cdf2b"]={f:Ops.Devices.Midi.MidiMonitor,objName:"Ops.Devices.Midi.MidiMonitor"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiNRPN
// 
// **************************************************************

Ops.Devices.Midi.MidiNRPN = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
/* UTIL */
const MIDIChannels = Array.from(Array(16).keys()).map((i) => { return i + 1; });

/* IN */
const inEvent = op.inObject("MIDI Event In");
const midiChannelDropdown = op.inValueSelect("MIDI Channel", MIDIChannels, 1);

const nrpnIndexDropdown = op.inValueInt("NRPN Index", 0);
const normalizeDropdown = op.inValueSelect("Normalize", ["none", "0 to 1", "-1 to 1"], "none");
const learn = op.inTriggerButton("learn");
const clear = op.inTriggerButton("clear");

op.setPortGroup("MIDI", [inEvent, midiChannelDropdown]);
op.setPortGroup("NRPN", [nrpnIndexDropdown, normalizeDropdown]);
op.setPortGroup("", [learn, clear]);
/* OUT */
const eventOut = op.outObject("MIDI Event Out");
const triggerOut = op.outTrigger("Trigger Out");
const nrpnIndexOut = op.outValue("NRPN Index");
const nrpnValueOut = op.outValue("NRPN Value");

op.setPortGroup("MIDI/Trigger Out", [eventOut, triggerOut]);
op.setPortGroup("NRPN Out", [nrpnIndexOut, nrpnValueOut]);

nrpnIndexDropdown.set(0);
midiChannelDropdown.set(1);
normalizeDropdown.set(normalizeDropdown.get("none"));

let learning = false;
learn.onTriggered = () =>
{
    learning = true;
};

clear.onTriggered = () =>
{
    nrpnIndexDropdown.set(0);
    midiChannelDropdown.set(1);
    normalizeDropdown.set(normalizeDropdown.get("none"));
    op.refreshParams();
};
let outValue;
inEvent.onChange = () =>
{
    const event = inEvent.get();
    if (!event) return;
    if (event.messageType !== "NRPN") return;

    const { channel, nrpnIndex, nrpnValue } = event;

    if (learning)
    {
        nrpnIndexDropdown.set(nrpnIndex);
        midiChannelDropdown.set(channel + 1);

        learning = false;

        if (CABLES.UI)
        {
            op.uiAttr({ "info": `bound to NRPN: ${nrpnIndexDropdown.get()}` });
            op.refreshParams();
        }
    }

    if (channel === midiChannelDropdown.get() - 1)
    {
        if (nrpnIndex === nrpnIndexDropdown.get())
        {
            nrpnIndexOut.set(nrpnIndex);

            outValue = nrpnValue;

            if (normalizeDropdown.get() === "0 to 1")
            {
                nrpnValueOut.set(outValue / 16383);
                triggerOut.trigger();
            }
            else if (normalizeDropdown.get() === "-1 to 1")
            {
                nrpnValueOut.set(outValue / (16383 / 2) - 1);
                triggerOut.trigger();
            }
            else if (normalizeDropdown.get() === "none")
            {
                nrpnValueOut.set(outValue);
                triggerOut.trigger();
            }
            else nrpnValueOut.set(0);
        }
    }
    eventOut.set(null);
    eventOut.set(event);
};


};

Ops.Devices.Midi.MidiNRPN.prototype = new CABLES.Op();
CABLES.OPS["2b13bc7b-c1bd-4319-9c85-86a81a6e2354"]={f:Ops.Devices.Midi.MidiNRPN,objName:"Ops.Devices.Midi.MidiNRPN"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiNRPNOut
// 
// **************************************************************

Ops.Devices.Midi.MidiNRPNOut = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// your new op
// have a look at the documentation at:
// https://docs.cables.gl/dev_hello_op/dev_hello_op.html
const MIDIChannels = Array.from(Array(16).keys(), i => i + 1);
const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
const CC_STATUS_BYTE = 0xb;
const CC_STATUS_BYTE_START = 176;

const inChannel = op.inDropDown("MIDI Channel", MIDIChannels, "1");
const inNrpnIndex = op.inInt("NRPN Index", 0);
const inNrpnValue = op.inInt("NRPN Value", 0);
const inMin = op.inFloat("Min In Value", 0);
const inMax = op.inFloat("Max In Value", 1);
op.setPortGroup("General",[inChannel]);
op.setPortGroup("NRPN",[inNrpnValue, inNrpnIndex]);
op.setPortGroup("Value Range",[inMin, inMax]);
const outEvent = op.outObject("MIDI Event Out");

inNrpnValue.onChange = function() {
    const val = inNrpnValue.get();

    const nrpnValue = Math.floor(CABLES.map(val,inMin.get(), inMax.get(), 0, 16383));
    const nrpnIndex = clamp(inNrpnIndex.get(), 0, 16383);
   // const ccValue = clamp(inNrpnValue.get(), 0, 127);
    /*
  const newEvent = Object.assign(
    {
      // OLD EVENT v
      deviceName,
      output: outputDevice,
      inputId: 0, // what is this for?
      messageType,
      // ...,
      index: outputIndex,
      value: outputValue,

      cmd: data[0] >> 4,
      channel: data[0] & 0xf,
      type: data[0] & 0xf0,
      note: data[1],
      velocity: data[2],
      data,
    },
    messageType === 'Note' && {
      newNote: [LSB, getMIDINote(LSB)],
      velocity: outputValue,
    },
    messageType === 'NRPN' && { nrpnIndex, nrpnValue },
  );
  */

  const event = {
      deviceName: null,
      output: null,
      inputId: 0,
      messageType: "NRPN",
      data: [],
      channel: inChannel.get() - 1,
      nrpnIndex,
      nrpnValue,
  }

  outEvent.set(null);
  outEvent.set(event);
}

};

Ops.Devices.Midi.MidiNRPNOut.prototype = new CABLES.Op();
CABLES.OPS["469abc8f-598a-4a42-a5df-881bf80ee363"]={f:Ops.Devices.Midi.MidiNRPNOut,objName:"Ops.Devices.Midi.MidiNRPNOut"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiNote
// 
// **************************************************************

Ops.Devices.Midi.MidiNote = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
/* UTIL */
const NOTE_OFF = 0x8;
const NOTE_ON = 0x9;
const NOTE_VALUES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

const MIDIChannels = Array.from(Array(16).keys()).map((i) => { return i + 1; });

function getMIDINote(dataByte1LSB)
{
    return dataByte1LSB <= 126
        ? `${NOTE_VALUES[dataByte1LSB % 12]}${Math.floor(dataByte1LSB / 12) - 2} - ${dataByte1LSB}`
        : "NO NOTE";
}

const noteValues = Array.from(Array(128).keys(), (key) => { return getMIDINote(key); });
const velocityArray = Array.from(Array(128).keys(), (key) => { return 0; });
/* IN */
const inEvent = op.inObject("MIDI Event In");
const midiChannelDropdown = op.inValueSelect("MIDI Channel", MIDIChannels, 1);
const noteDropdown = op.inValueSelect("Note", noteValues, "none");
const normalizeDropdown = op.inSwitch(
    "Normalize Velocity",
    ["none", "0 to 1", "-1 to 1"],
    "none",
);
const gateType = op.inBool("Toggle Gate", false);
const learn = op.inTriggerButton("learn");
const clear = op.inTriggerButton("clear");

op.setPortGroup("MIDI", [inEvent, midiChannelDropdown]);
op.setPortGroup("", [learn, clear]);
op.setPortGroup("Note", [noteDropdown, normalizeDropdown, gateType]);

/* OUT */
const eventOut = op.outObject("MIDI Event Out");
const triggerOut = op.outTrigger("Trigger Out");
const currentNoteOut = op.outNumber("Current Note");
const velocityOut = op.outNumber("Velocity");
const gateOut = op.outValueBool("Gate");
const arrayOut = op.outArray("Velocity Array");
arrayOut.set(velocityArray);

op.setPortGroup("MIDI/Trigger Out", [eventOut, triggerOut]);
op.setPortGroup("Note Out", [currentNoteOut, velocityOut, gateOut]);
noteDropdown.set(0);
midiChannelDropdown.set(1);

let learning = false;
learn.onTriggered = () =>
{
    learning = true;
};

clear.onTriggered = () =>
{
    noteDropdown.set(0);
    midiChannelDropdown.set(1);
    normalizeDropdown.set(normalizeDropdown.get("none"));
    gateType.set(false);
    op.refreshParams();
};

gateType.onChange = () =>
{
    if (!gateType.get()) gateOut.set(false);
};

inEvent.onChange = () =>
{
    const event = inEvent.get();
    if (!event) return;
    if (event.messageType !== "Note") return;
    if (!event.newNote) return;

    const [statusByte] = event.data;

    const { newNote, velocity } = event;
    const [noteIndex, noteName] = newNote;

    if (learning || noteDropdown.onChange)
    {
        noteDropdown.set(noteName);
        midiChannelDropdown.set(event.channel + 1);

        learning = false;

        if (CABLES.UI)
        {
            gui.emitEvent("portValueEdited", op, noteDropdown, noteDropdown.get());
            gui.emitEvent("portValueEdited", op, midiChannelDropdown, midiChannelDropdown.get());

            op.uiAttr({ "info": `bound to Note: ${noteDropdown.get()}` });
            op.refreshParams();
        }
    }

    if (event.channel === midiChannelDropdown.get() - 1)
    {
        if (getMIDINote(noteIndex) === noteDropdown.get())
        {
            if ((statusByte >> 4 === NOTE_OFF || velocity === 0) && !gateType.get())
            {
                gateOut.set(false);
                velocityOut.set(0);
                velocityArray[noteIndex] = 0;
                arrayOut.set(null);
                arrayOut.set(velocityArray);
            }
            else if (statusByte >> 4 === NOTE_ON)
            {
                if (gateType.get())
                {
                    gateOut.set(!gateOut.get());
                }
                else
                {
                    gateOut.set(true);
                }
                currentNoteOut.set(noteIndex);
                velocityArray[noteIndex] = velocity;
                arrayOut.set(null);
                arrayOut.set(velocityArray);
                if (normalizeDropdown.get() === "0 to 1")
                {
                    // (max'-min')/(max-min)*(value-min)+min'
                    velocityOut.set((1 / 126) * (velocity - 1));
                    velocityArray[noteIndex] = (1 / 126) * (velocity - 1);
                    triggerOut.trigger();
                }
                else if (normalizeDropdown.get() === "-1 to 1")
                {
                    // (max'-min')/(max-min)*(value-min)+min'
                    const normalizedValue = (2 / 126) * (velocity - 1) - 1;
                    velocityArray[noteIndex] = normalizedValue;
                    velocityOut.set(normalizedValue);
                    triggerOut.trigger();
                }
                else if (normalizeDropdown.get() === "none")
                {
                    velocityOut.set(velocity);
                    triggerOut.trigger();
                }
            }
        }
        else if (noteDropdown.get() === 0)
        {
            // no note selected
            if ((statusByte >> 4 === NOTE_OFF || velocity === 0) && !gateType.get())
            {
                gateOut.set(false);
                velocityOut.set(0);
                velocityArray[noteIndex] = 0;
                arrayOut.set(null);
                arrayOut.set(velocityArray);
            }
            else if (statusByte >> 4 === NOTE_ON)
            {
                if (gateType.get())
                {
                    gateOut.set(!gateOut.get());
                }
                else
                {
                    gateOut.set(true);
                }
                currentNoteOut.set(noteIndex);

                if (normalizeDropdown.get() === "0 to 1")
                {
                    // (max'-min')/(max-min)*(value-min)+min'
                    const newVelocity = (1 / 126) * (velocity - 1);
                    velocityOut.set(newVelocity);
                    velocityArray[noteIndex] = newVelocity;
                    arrayOut.set(null);
                    arrayOut.set(velocityArray);
                    triggerOut.trigger();
                }
                else if (normalizeDropdown.get() === "-1 to 1")
                {
                    // (max'-min')/(max-min)*(value-min)+min'
                    const normalizedValue = (2 / 126) * (velocity - 1) - 1;
                    velocityOut.set(normalizedValue);
                    velocityArray[noteIndex] = normalizedValue;
                    arrayOut.set(null);
                    arrayOut.set(velocityArray);
                    triggerOut.trigger();
                }
                else if (normalizeDropdown.get() === "none")
                {
                    velocityOut.set(velocity);
                    velocityArray[noteIndex] = velocity;
                    arrayOut.set(null);
                    arrayOut.set(velocityArray);
                    triggerOut.trigger();
                }
            }
        }
    }
    eventOut.set(null);
    eventOut.set(event);
};


};

Ops.Devices.Midi.MidiNote.prototype = new CABLES.Op();
CABLES.OPS["517ed1fc-6110-4611-9cc7-8dd459191c65"]={f:Ops.Devices.Midi.MidiNote,objName:"Ops.Devices.Midi.MidiNote"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiNoteFilter
// 
// **************************************************************

Ops.Devices.Midi.MidiNoteFilter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
/* UTIL */
const NOTE_OFF = 0x8;
const NOTE_ON = 0x9;
const NOTE_VALUES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

const MIDIChannels = Array.from(Array(16).keys()).map((i) => { return i + 1; });

function getMIDINote(dataByte1LSB)
{
    return dataByte1LSB <= 126
        ? `${NOTE_VALUES[dataByte1LSB % 12]}${Math.floor(dataByte1LSB / 12) - 2} - ${dataByte1LSB}`
        : "NO NOTE";
}

function getNoteIndexFromMIDINote(midiNote)
{
    if (!midiNote || midiNote === "NO NOTE") return null;
    const string = midiNote.split("- ")[1];
    return Number(string);
}

const noteValues = Array.from(Array(128).keys()).map((key) => { return getMIDINote(key); });

/* IN */
// persistent array for learned notes
const learnedNotesIn = op.inArray("Note Values", []);
learnedNotesIn.setUiAttribs({ "hidePort": true });

const inEvent = op.inObject("MIDI Event");
const midiChannelDropdown = op.inValueSelect("MIDI Channel", MIDIChannels, 1);
const noteStartDropdown = op.inValueSelect("Note Start", noteValues, 0);
const noteEndDropdown = op.inValueSelect("Note End", noteValues, 0);
const normalizeDropdown = op.inValueSelect(
    "Normalize Velocity",
    ["none", "0 to 1", "-1 to 1"],
    "none",
);
const learn = op.inTriggerButton("learn");
const reset = op.inTriggerButton("reset");

op.setPortGroup("MIDI", [inEvent, midiChannelDropdown]);
op.setPortGroup("Notes", [noteStartDropdown, noteEndDropdown, normalizeDropdown]);

/* OUT */
const eventOut = op.outObject("Event");
const triggerOut = op.outTrigger("Trigger Out");
const noteIndexOut = op.outNumber("Current Note");
const velocityOut = op.outNumber("Velocity");
const gateOut = op.outValueBool("Gate");

op.setPortGroup("MIDI/Trigger Out", [eventOut, triggerOut]);
op.setPortGroup("Notes Out", [noteIndexOut, velocityOut, gateOut]);

noteStartDropdown.set(0);
noteEndDropdown.set(0);
midiChannelDropdown.set(1);

let learning = false;

learn.onTriggered = () =>
{
    if (learnedNotesIn.get().length > 0)
    {
        learnedNotesIn.set([]);
    }
    learning = true;
};
reset.onTriggered = () =>
{
    learning = false;
    learnedNotesIn.set([]);
    noteStartDropdown.set(0);
    noteEndDropdown.set(0);
    midiChannelDropdown.set(1);
    op.refreshParams();
};

let selfRef = false;
noteStartDropdown.onChange = () =>
{
    const learnedNotes = learnedNotesIn.get();
    learnedNotes[0] = getNoteIndexFromMIDINote(noteStartDropdown.get());
    op.refreshParams();

    if (selfRef) return;
    if (learnedNotes.length === 2)
    {
        selfRef = true;
        learnedNotes.sort((a, b) => { return a - b; });
        const [start, end] = learnedNotes;
        noteStartDropdown.set(getMIDINote(start));
        noteEndDropdown.set(getMIDINote(end));
        selfRef = false;
    }
    learnedNotesIn.set(learnedNotes);
};

noteEndDropdown.onChange = () =>
{
    const learnedNotes = learnedNotesIn.get();
    learnedNotes[1] = getNoteIndexFromMIDINote(noteEndDropdown.get());
    op.refreshParams();

    if (selfRef) return;
    if (learnedNotes.length === 2)
    {
        selfRef = true;
        learnedNotes.sort((a, b) => { return a - b; });
        const [start, end] = learnedNotes;
        noteStartDropdown.set(getMIDINote(start));
        noteEndDropdown.set(getMIDINote(end));
        selfRef = false;
    }
    learnedNotesIn.set(learnedNotes);
};

inEvent.onChange = () =>
{
    const event = inEvent.get();
    if (!event) return;
    if (event.messageType !== "Note") return;
    if (!event.newNote) return;

    const [statusByte] = event.data;

    const { newNote, velocity } = event;
    const [noteIndex, noteName] = newNote;
    const midiNote = getMIDINote(noteIndex);
    const learnedNotes = learnedNotesIn.get();

    if (learning)
    {
        if (statusByte >> 4 === NOTE_OFF)
        {
            eventOut.set(event);
            return;
        }
        if (!learnedNotes.includes(midiNote) && learnedNotes.length < 2)
        {
            learnedNotes.push(noteIndex);
            learnedNotesIn.set(learnedNotes);
        }
        if (learnedNotes.length === 2)
        {
            learnedNotes.sort((a, b) => { return a - b; });
            learnedNotesIn.set(learnedNotes);
            const [start, end] = learnedNotes;

            noteStartDropdown.set(getMIDINote(start));
            noteEndDropdown.set(getMIDINote(end));
            learning = false;
        }

        midiChannelDropdown.set(event.channel + 1);

        if (CABLES.UI)
        {
            gui.emitEvent("portValueEdited", op, midiChannelDropdown, midiChannelDropdown.get());
            gui.emitEvent("portValueEdited", op, learnedNotes, learnedNotes.get());
            gui.emitEvent("portValueEdited", op, learnedNotesIn, learnedNotesIn.get());
            gui.emitEvent("portValueEdited", op, noteEndDropdown, noteEndDropdown.get());
            gui.emitEvent("portValueEdited", op, noteStartDropdown, noteStartDropdown.get());

            op.uiAttr({ "info": `Start bound to Note: ${noteStartDropdown.get()}` });
            op.uiAttr({ "info": `End bound to Note: ${noteEndDropdown.get()}` });
            op.refreshParams();
        }
        eventOut.set(event);
        return;
    }

    if (event.channel === midiChannelDropdown.get() - 1 && learnedNotes.length === 2)
    {
        const [start, end] = learnedNotes;
        if (start <= noteIndex && noteIndex <= end)
        {
            if (statusByte >> 4 === NOTE_OFF || velocity === 0)
            {
                gateOut.set(false);
                if (velocity === 0) velocityOut.set(0);
            }
            if (statusByte >> 4 === NOTE_ON)
            {
                gateOut.set(true);

                noteIndexOut.set(noteIndex);
                triggerOut.trigger();

                if (normalizeDropdown.get() === "0 to 1")
                {
                    // (max'-min')/(max-min)*(value-min)+min'
                    velocityOut.set((1 / 126) * (velocity - 1));
                }
                else if (normalizeDropdown.get() === "-1 to 1")
                {
                    // (max'-min')/(max-min)*(value-min)+min'
                    const normalizedValue = (2 / 126) * (velocity - 1) - 1;
                    velocityOut.set(normalizedValue);
                }
                else if (normalizeDropdown.get() === "none") velocityOut.set(velocity);
            }
        }
    }

    eventOut.set(event);
};


};

Ops.Devices.Midi.MidiNoteFilter.prototype = new CABLES.Op();
CABLES.OPS["b248a588-81cc-47af-a65b-36509abd2888"]={f:Ops.Devices.Midi.MidiNoteFilter,objName:"Ops.Devices.Midi.MidiNoteFilter"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiNoteOut
// 
// **************************************************************

Ops.Devices.Midi.MidiNoteOut = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const MIDIChannels = Array.from(Array(16).keys(), (i) => { return i + 1; });
const NOTE_VALUES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

const clamp = (val, min, max) => { return Math.min(Math.max(val, min), max); };
const NOTE_OFF = 0x8;
const NOTE_ON = 0x9;

function getMIDINote(dataByte1LSB)
{
    return dataByte1LSB <= 126
        ? `${NOTE_VALUES[dataByte1LSB % 12]}${Math.floor(dataByte1LSB / 12) - 2} - ${dataByte1LSB}`
        : "NO NOTE";
}

const noteValues = Array.from(Array(128).keys(), (key) => { return getMIDINote(key); });
const velocityArray = Array.from(Array(128).keys(), (key) => { return 0; });

const inChannel = op.inDropDown("MIDI Channel", MIDIChannels, "1");
const inNoteDropdown = op.inDropDown("Note", noteValues);
const inNoteNumber = op.inInt("Note Number", 0);
const inVelocity = op.inInt("Velocity", 0);
const inMin = op.inFloat("Min In Velocity", 0);
const inMax = op.inFloat("Max In Velocity", 1);
const inNoteArray = op.inArray("Velocity Array In");
op.setPortGroup("General", [inChannel, inNoteDropdown]);
op.setPortGroup("Note", [inNoteNumber, inVelocity]);
op.setPortGroup("Velocity Range", [inMin, inMax]);

const outEvent = op.outObject("MIDI Event Out");

// this is a safety mechanism for when changing a note while another one is playing, kill old one
let currentNote = null;
const killAllNotes = () =>
{
    for (let i = 0; i < 128; i += 1)
    {
        outEvent.set(null);
        outEvent.set({ "data": [(NOTE_OFF << 4 | (inChannel.get() - 1)), i, 0] });
    }
};

const killLastNote = () =>
{
    outEvent.set(null);
    outEvent.set({ "data": [(NOTE_OFF << 4 | (inChannel.get() - 1)), currentNote, 0] });
};

inNoteNumber.onLinkChanged = function ()
{
    if (!inNoteNumber.isLinked()) killLastNote();
};

inVelocity.onLinkChanged = function ()
{
    if (!inVelocity.isLinked()) killAllNotes();
};

inNoteArray.onLinkChanged = function ()
{
    if (!inNoteArray.isLinked()) killAllNotes();
};

inNoteDropdown.onChange = inChannel.onChange = killLastNote;

inNoteNumber.onChange = inVelocity.onChange = function ()
{
    /* if (!inNoteDropdown.get()) {
       // if (!op.uiAttribs.error) op.uiAttr({ error: "Please choose a MIDI Note!" });
        return;
    }
    */
    // if (op.uiAttribs.error) op.uiAttr({ error: null });

    const val = inVelocity.get();
    const noteNumber = inNoteNumber.get();
    const velocity = Math.floor(CABLES.map(val, inMin.get(), inMax.get(), 0, 127));

    let noteIndex = Math.floor(clamp(noteNumber, 0, 127));

    if (inNoteDropdown.get() !== 0) noteIndex = clamp(Number(inNoteDropdown.get().split("-").pop()), 0, 127);

    else
    {
        if (currentNote)
        {
            if (noteIndex !== currentNote)
            {
                const killEvent = {
                    "deviceName": null,
                    "output": null,
                    "inputId": 0,
                    "messageType": "Note",
                    "data": [(NOTE_OFF << 4 | (inChannel.get() - 1)), currentNote, 0],
                    "index": currentNote,
                    "value": 0,
                    "newNote": [currentNote, getMIDINote(currentNote)],
                    "velocity": 0,
                    "channel": inChannel.get() - 1,
                };
                outEvent.set(null);
                outEvent.set(killEvent);
            }
        }
    }

    const data = velocity > 0 ?
        [(NOTE_ON << 4 | (inChannel.get() - 1)), noteIndex, velocity]
        : [(NOTE_OFF << 4 | (inChannel.get() - 1)), noteIndex, velocity];

    const event = {
        "deviceName": null,
        "output": null,
        "inputId": 0,
        "messageType": "Note",
        "data": data,
        "index": noteIndex,
        "value": velocity,
        "newNote": [noteIndex, getMIDINote(noteIndex)],
        velocity,
        "channel": inChannel.get() - 1,
    };

    outEvent.set(null);
    outEvent.set(event);
    currentNote = noteIndex;
};
let oldArr = [];

inNoteArray.onChange = function ()
{
    if (!inNoteArray.get()) return;
    const arr = inNoteArray.get();
    const length = arr.length > 127 ? 128 : arr.length;

    for (let i = 0; i < length; i += 1)
    {
        const velocity = Math.floor(CABLES.map(arr[i], inMin.get(), inMax.get(), 0, 127));
        const event = {
            "deviceName": null,
            "output": null,
            "inputId": 0,
            "messageType": "Note",
            "data": velocity > 0 ?
                [(NOTE_ON << 4 | (inChannel.get() - 1)), i, velocity]
                : [(NOTE_OFF << 4 | (inChannel.get() - 1)), i, velocity],
            "index": i,
            "value": velocity,
            "newNote": [i, getMIDINote(i)],
            velocity,
            "channel": inChannel.get() - 1,
        };

        oldArr = arr;
        outEvent.set(null);
        outEvent.set(event);
    }
};


};

Ops.Devices.Midi.MidiNoteOut.prototype = new CABLES.Op();
CABLES.OPS["172dcd08-cd5b-4272-bc7d-2b1a61ecfd4a"]={f:Ops.Devices.Midi.MidiNoteOut,objName:"Ops.Devices.Midi.MidiNoteOut"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiOutputDevice
// 
// **************************************************************

Ops.Devices.Midi.MidiOutputDevice = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// your new op
// have a look at the documentation at:
// https://docs.cables.gl/dev_hello_op/dev_hello_op.html
const CC_STATUS_BYTE = 0xb;
const NOTE_OFF = 0x8;

let midi = null;
let outputDevice = null;

const inDeviceSelect = op.inValueSelect("Device", ["none"]);
const inNote = op.inObject("Note");
const inCC = op.inObject("CC");
const inNRPN = op.inObject("NRPN");

op.setPortGroup("Device", [inDeviceSelect]);
op.setPortGroup("Midi Events", [inNote, inCC, inNRPN]);


inNRPN.onChange = function (_event)
{
    if (!outputDevice) return;
    if (!_event) return;

    const event = _event.get();

    if (!event) return;
    if (!event.data) return;
    if (event.messageType !== "NRPN") return;

    const indexLSB = (event.nrpnIndex & 0b1111111);
    const indexMSB = (event.nrpnIndex >> 7);

    const valueLSB = (event.nrpnValue & 0b1111111);
    const valueMSB = (event.nrpnValue >> 7);

    const dataIndexLSB = [CC_STATUS_BYTE << 4 | event.channel, 98, indexLSB];
    const dataIndexMSB = [CC_STATUS_BYTE << 4 | event.channel, 99, indexMSB];

    const dataValueLSB = [CC_STATUS_BYTE << 4 | event.channel, 38, valueLSB];
    const dataValueMSB = [CC_STATUS_BYTE << 4 | event.channel, 6, valueMSB];

    outputDevice.send(dataIndexLSB);
    outputDevice.send(dataIndexMSB);
    outputDevice.send(dataValueLSB);
    outputDevice.send(dataValueMSB);
};

inCC.onChange = function (_event)
{
    if (!outputDevice) return;
    if (!_event) return;

    const event = _event.get();

    if (!event) return;
    if (!event.data) return;
    if (event.messageType !== "CC") return;
    // TODO: Check for invalid status bytes
    outputDevice.send(event.data);
};

let currentNote = null;
let currentChannel = null;

const killLastNote = () =>
{
    if (!outputDevice || !currentNote || !currentChannel) return;
    outputDevice.send([(NOTE_OFF << 4 | (currentChannel)), currentNote, 0]);
};

const killAllNotes = () =>
{
    if (!outputDevice) return;
    for (let i = 0; i < 128; i += 1)
    {
        for (let channel = 0; channel < 16; channel += 1) outputDevice.send([(NOTE_OFF << 4 | channel), i, 0]);
    }
};

inNote.onLinkChanged = function ()
{
    if (!inNote.isLinked()) killAllNotes();
};

inNote.onChange = function (_event)
{
    if (!outputDevice) return;
    if (!_event) return;

    const event = _event.get();

    if (!event) return;
    if (!event.data) return;
    // TODO: let CC all notes off message pass through
    // if (event.messageType !== "Note") return;
    // TODO: Check for invalid status bytes

    setTimeout(function ()
    {
        outputDevice.send(event.data);
        currentNote = event.index;
        currentChannel = event.channel;
    }, 20);
};

function setDevice()
{
    if (!midi || !midi.inputs) return;
    const name = inDeviceSelect.get();

    op.setTitle(`Midi ${name}`);

    const inputs = midi.inputs.values();
    const outputs = midi.outputs.values();

    for (let output = outputs.next(); output && !output.done; output = outputs.next())
    {
        if (output.value.name === name)
        {
            outputDevice = midi.outputs.get(output.value.id);
        }
    }
}


function onMIDIFailure()
{
    op.uiAttr({ "warning": "No MIDI support in your browser." });
}

function onMIDISuccess(midiAccess)
{
    midi = midiAccess;
    const inputs = midi.inputs.values();
    const outputs = midi.outputs.values();
    op.uiAttr({ "info": "no midi devices found" });

    const deviceNames = [];

    for (let output = outputs.next(); output && !output.done; output = outputs.next())
    {
        deviceNames.push(output.value.name);
    }

    inDeviceSelect.uiAttribs.values = deviceNames;

    op.refreshParams();
    setDevice();
}

inDeviceSelect.onChange = setDevice;

if (navigator.requestMIDIAccess)
{
    navigator.requestMIDIAccess({ "sysex": false }).then(onMIDISuccess, onMIDIFailure);
}
else onMIDIFailure();


};

Ops.Devices.Midi.MidiOutputDevice.prototype = new CABLES.Op();
CABLES.OPS["a874a81a-4416-4ed5-bea9-66531ed83376"]={f:Ops.Devices.Midi.MidiOutputDevice,objName:"Ops.Devices.Midi.MidiOutputDevice"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiTranspose
// 
// **************************************************************

Ops.Devices.Midi.MidiTranspose = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const NOTE_VALUES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

const MIDIChannels = Array.from(Array(16).keys()).map((i) => { return i + 1; });
const NOTE_OFF = 0x8;
const NOTE_ON = 0x9;
const CC_MSG = 0xb;
function getMIDINote(dataByte1LSB)
{
    return dataByte1LSB <= 126
        ? `${NOTE_VALUES[dataByte1LSB % 12]}${Math.floor(dataByte1LSB / 12) - 2} - ${dataByte1LSB}`
        : "NO NOTE";
}

/* IN */
const inEvent = op.inObject("MIDI Event In");
const midiChannelDropdown = op.inValueSelect("MIDI Channel", MIDIChannels, 1);
const inTranspose = op.inInt("Transpose Amount", 0);
const learn = op.inTriggerButton("learn");

op.setPortGroup("MIDI", [inEvent, midiChannelDropdown, learn]);
op.setPortGroup("Transpose", [inTranspose]);

/* OUT */
/* OUT */
const eventOut = op.outObject("MIDI Event Out");
const triggerOut = op.outTrigger("Trigger Out");

const killAllNotes = () =>
{
    for (let i = 0; i < 128; i += 1)
    {
        for (let channel = 0; channel < 16; channel += 1)
        {
            eventOut.set(null);
            eventOut.set({ "data": [(NOTE_OFF << 4 | channel), i, 0] });
        }
        op.log("killAllNotes transpose");
    }
};

const killAllNotesAgain = () =>
{
    for (let channel = 0; channel < 16; channel += 1)
    {
        eventOut.set(null);
        eventOut.set({ "data": [(CC_MSG << 4 | channel), 123, 0] });
    }
};
inTranspose.onChange = function ()
{
    killAllNotesAgain();
    if (lastTransposedNote)
    {
        // eventOut.set(null);
        // eventOut.set({ data: [(NOTE_OFF << 4 | lastTransposedNote.channel), lastTransposedNote.index, 0] });
    }
};
let lastTransposedNote = null;

let learning = false;
learn.onTriggered = () =>
{
    learning = true;
};

inEvent.onChange = () =>
{
    const event = inEvent.get();

    if (!event) return;
    if (event.messageType !== "Note") return;
    if (!event.newNote) return;

    if (learning)
    {
        midiChannelDropdown.set(event.channel + 1);
        learning = false;
        if (CABLES.UI)
        {
            op.uiAttr({ "info": `bound to MIDI Channel: ${midiChannelDropdown.get()}` });
            op.refreshParams();
        }
    }

    if (event.channel === midiChannelDropdown.get() - 1)
    {
        const newEvent = { ...event };

        const note = event.index;
        const transposeAmount = inTranspose.get();
        const newNoteIndex = Math.min(Math.max(note + transposeAmount, 0), 127);

        if (event.data[0] === (NOTE_ON << 4 | (event.channel)))
        {
            eventOut.set(null);
            eventOut.set({ ...newEvent,
                "data": [(NOTE_OFF << 4 | (event.channel)), note, 0],
                "note": note,
                "index": note,
                "velocity": 0,
                "newNote": [note, getMIDINote(note)], });
        }

        newEvent.note = newNoteIndex;
        newEvent.index = newNoteIndex;
        newEvent.data[1] = newNoteIndex;
        newEvent.newNote = [newNoteIndex, getMIDINote(newNoteIndex)];

        lastTransposedNote = newEvent;

        eventOut.set(newEvent);
    }
    else
    {
        eventOut.set(event);
    }
    triggerOut.trigger();
};


};

Ops.Devices.Midi.MidiTranspose.prototype = new CABLES.Op();
CABLES.OPS["c3b01c76-a300-44d3-8e1a-c8ae7a776463"]={f:Ops.Devices.Midi.MidiTranspose,objName:"Ops.Devices.Midi.MidiTranspose"};




// **************************************************************
// 
// Ops.Devices.Midi.MidiValueToNote_v2
// 
// **************************************************************

Ops.Devices.Midi.MidiValueToNote_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let midiValuePort = op.inValue("Midi Value");
let notePort = op.outString("Note");

let FLATS = "C Db D Eb E F Gb G Ab A Bb B".split(" ");
let SHARPS = "C C# D D# E F F# G G# A A# B".split(" ");

function note(num, sharps)
{
    if (num === true || num === false) return function (m) { return note(m, num); };
    num = Math.round(num);
    let pcs = sharps === true ? SHARPS : FLATS;
    let pc = pcs[num % 12];
    let o = Math.floor(num / 12) - 1;
    return pc + o;
}

midiValuePort.onChange = function ()
{
    let val = midiValuePort.get();
    if (val)
    {
        let n = note(val, true);
        notePort.set(n);
    }
};


};

Ops.Devices.Midi.MidiValueToNote_v2.prototype = new CABLES.Op();
CABLES.OPS["6f9cc2b3-8dba-44de-a677-a0706952a64c"]={f:Ops.Devices.Midi.MidiValueToNote_v2,objName:"Ops.Devices.Midi.MidiValueToNote_v2"};




// **************************************************************
// 
// Ops.Devices.Mobile.DeviceVibrate
// 
// **************************************************************

Ops.Devices.Mobile.DeviceVibrate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inVibrate = op.inTriggerButton("Vibrate");
let outSupported = op.outBoolNum("Supported");

navigator.vibrate = navigator.vibrate || navigator.webkitVibrate ||
navigator.mozVibrate || navigator.msVibrate;

if (navigator.vibrate) outSupported.set(true);
else outSupported.set(false);

inVibrate.onTriggered = function ()
{
    if (navigator.vibrate)
    {
        navigator.vibrate(1500);
    }
};

if (window.self !== window.top)
{
    op.setUiError("iframe", "DeviceVibrate does not work in an iframe, open the patch without an iframe to get it to work", 1);
    op.warn("DeviceVibrate does not work in an iframe, open the patch without an iframe to get it to work");
}


};

Ops.Devices.Mobile.DeviceVibrate.prototype = new CABLES.Op();
CABLES.OPS["e947fc63-e44e-4bdd-98e0-89e79373f073"]={f:Ops.Devices.Mobile.DeviceVibrate,objName:"Ops.Devices.Mobile.DeviceVibrate"};




// **************************************************************
// 
// Ops.Devices.Mobile.GeoLocation
// 
// **************************************************************

Ops.Devices.Mobile.GeoLocation = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    outSupported = op.outBoolNum("Browser Support", navigator.geolocation != false),
    outLat = op.outNumber("Latitude"),
    outLon = op.outNumber("Longitude"),
    outData = op.outObject("Data");

if (navigator.geolocation && navigator.geolocation.watchPosition)
    navigator.geolocation.watchPosition(updatePos);

function updatePos(position)
{
    outLat.set(position.coords.latitude);
    outLon.set(position.coords.longitude);
    outData.set(position);
}


};

Ops.Devices.Mobile.GeoLocation.prototype = new CABLES.Op();
CABLES.OPS["7d9ae643-d011-417e-afe3-b3acb78a6d63"]={f:Ops.Devices.Mobile.GeoLocation,objName:"Ops.Devices.Mobile.GeoLocation"};




// **************************************************************
// 
// Ops.Devices.Mobile.LockOrientation
// 
// **************************************************************

Ops.Devices.Mobile.LockOrientation = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inPortrait = op.inValueBool("Portrait");
const inLandscape = op.inValueBool("Landscape");

screen.lockOrientationUniversal = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;

const support = op.outBoolNum("Supported", screen.lockOrientationUniversal !== undefined);
const locked = op.outBoolNum("Locked");

inPortrait.onChange = setup;
inLandscape.onChange = setup;

function setup()
{
    if (screen.lockOrientationUniversal)
    {
        let orientations = [];
        if (inPortrait.get())orientations.push("portrait");
        if (inLandscape.get())orientations.push("landscape");

        if (screen.lockOrientationUniversal(orientations)) locked.set(true);
        else locked.set(false);
    }
    locked.set(false);
}


};

Ops.Devices.Mobile.LockOrientation.prototype = new CABLES.Op();
CABLES.OPS["486d5713-5292-47af-bbd3-df81fb7cd3ca"]={f:Ops.Devices.Mobile.LockOrientation,objName:"Ops.Devices.Mobile.LockOrientation"};




// **************************************************************
// 
// Ops.Devices.Mobile.MotionSensor_v2
// 
// **************************************************************

Ops.Devices.Mobile.MotionSensor_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    mulAxis = op.inValue("Mul Orientation", 1),
    req = op.inTrigger("Request Permissions"),
    axis1 = op.outNumber("Orientation Alpha"),
    axis2 = op.outNumber("Orientation Beta"),
    axis3 = op.outNumber("Orientation Gamma"),
    accX = op.outNumber("Acceleration X"),
    accY = op.outNumber("Acceleration Y"),
    accZ = op.outNumber("Acceleration Z"),
    accNoGravX = op.outNumber("Acceleration X no gravity"),
    accNoGravY = op.outNumber("Acceleration Y no gravity"),
    accNoGravZ = op.outNumber("Acceleration Z no gravity"),

    rotRate1 = op.outNumber("Rotation Rate Alpha"),
    rotRate2 = op.outNumber("Rotation Rate Beta"),
    rotRate3 = op.outNumber("Rotation Rate Gamma"),

    outObj = op.outObject("Object");

let lastTime = 0;
let lastTimeAcc = 0;
let obj = {};

function handleDeviceMotion(event)
{
    if (CABLES.now() - lastTimeAcc > 15)
    {
        lastTimeAcc = CABLES.now();

        accX.set(event.accelerationIncludingGravity.x || 0);
        accY.set(event.accelerationIncludingGravity.y || 0);
        accZ.set(event.accelerationIncludingGravity.z || 0);

        accNoGravX.set(event.acceleration.x || 0);
        accNoGravY.set(event.acceleration.y || 0);
        accNoGravZ.set(event.acceleration.z || 0);

        obj.AccelerationX = accX.get();
        obj.AccelerationY = accY.get();
        obj.AccelerationZ = accZ.get();

        rotRate1.set(event.rotationRate.alpha || 0);
        rotRate2.set(event.rotationRate.beta || 0);
        rotRate3.set(event.rotationRate.gamma || 0);

        outObj.set(null);
        outObj.set(obj);
    }
}

function handleDeviceOrientation(event)
{
    if (CABLES.now() - lastTime > 15)
    {
        lastTime = CABLES.now();
        axis1.set((event.alpha || 0) * mulAxis.get());
        axis2.set((event.beta || 0) * mulAxis.get());
        axis3.set((event.gamma || 0) * mulAxis.get());

        obj.OrientationAlpha = axis1.get();
        obj.OrientationBeta = axis2.get();
        obj.OrientationGamma = axis3.get();

        outObj.set(null);
        outObj.set(obj);
    }
}

req.onTriggered = function ()
{
    if (window.DeviceMotionEvent && window.DeviceMotionEvent.requestPermission)
    {
        window.DeviceMotionEvent.requestPermission()
            .then((response) =>
            {
                if (response == "granted")
                {
                    window.addEventListener("devicemotion", handleDeviceMotion, true);
                }
                else
                    console.log(response);
            })
            .catch((e) =>
            {
                console.log(e);
            });

        window.DeviceOrientationEvent.requestPermission()
            .then((response) =>
            {
                if (response == "granted")
                {
                    window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                }
                else
                    console.log(response);
            })
            .catch((e) =>
            {
                console.log(e);
            });
    }
    else
    {
        window.addEventListener("devicemotion", handleDeviceMotion, true);
        window.addEventListener("deviceorientation", handleDeviceOrientation, true);
    }
};

if (window.self !== window.top)
{
    op.setUiError("iframe", "MotionSensor does not work in an iframe, open the patch without an iframe to get it to work", 1);
    op.warn("MotionSensor does not work in an iframe, open the patch without an iframe to get it to work");
}


};

Ops.Devices.Mobile.MotionSensor_v2.prototype = new CABLES.Op();
CABLES.OPS["f4102f07-e5ff-4c1e-ac5b-6a4758b81727"]={f:Ops.Devices.Mobile.MotionSensor_v2,objName:"Ops.Devices.Mobile.MotionSensor_v2"};




// **************************************************************
// 
// Ops.Devices.Mobile.Pinch
// 
// **************************************************************

Ops.Devices.Mobile.Pinch = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// constants
const elId = "glcanvas";
const initialScale = 1.0;

// inputs
const enabledPort = op.inValueBool("Enabled", true);
const minScalePort = op.inValue("Min Scale", 0.0);
const maxScalePort = op.inValue("Max Scale", 4.0);
const resetScalePort = op.inTriggerButton("Reset Scale");
const inLimit = op.inBool("Limit", true);

// variables
let scale = initialScale;
let tmpScale = initialScale;
let pinchInProgress = false;

// setup
const el = document.getElementById(elId);
const hammertime = new Hammer(el);
hammertime.get("pinch").set({ "enable": true });

// outputs
const scalePort = op.outNumber("Scale", 1);
const eventPort = op.outObject("Event Details");
const outDelta = op.outNumber("Delta");

// change listeners
window.addEventListener("gesturestart", (e) => { return e.preventDefault(); });
window.addEventListener("gesturechange", (e) => { return e.preventDefault(); });
window.addEventListener("gestureend", (e) => { return e.preventDefault(); });

hammertime.on("pinch", function (ev)
{
    op.log(ev.additionalEvent);
    ev.preventDefault(); // this is ignored in some browsers
    if (!enabledPort.get()) { return; }

    // if(ev.isFinal || ev.isFirst) { op.log(ev); }

    tmpScale = ev.scale;
    pinchInProgress = true;

    // if(ev.isFinal || !ev.isFinal && pinchInProgress) {
    const oldScale = scale;
    outDelta.set(0);

    if (ev.isFinal)
    {
        scale *= tmpScale;
        scale = checkAndCorrectBoundaries(scale);

        scalePort.set(scale);
        pinchInProgress = false;
        op.log("Final Pinch detected, resetting");
        tmpScale = initialScale;
    }
    else
    {
        scalePort.set(checkAndCorrectBoundaries(scale * tmpScale));
    }

    let d = oldScale - scalePort.get();
    if (d < 0) d = -1;
    else if (d > 0) d = 1;

    outDelta.set(d);

    // if(ev.additionalEvent) {
	    /*
	    if(ev.additionalEvent === 'pinchin') {
	        scale -=  Math.abs(ev.velocity);
	    } else if (ev.additionalEvent === 'pinchout') {
	        scale += Math.abs(ev.velocity);
	    }
	    */
    // }
    // scale += ev.velocity;
    /*
	op.log('ev.scale: ', ev.scale);
	tmpScale = ev.scale;

	var scaleToSet;
	if(ev.isFinal) {
	    scale *= tmpScale;
	    scaleToSet = scale;
	    tmpScale = initialScale;
	} else {
	    scaleToSet = scale * tmpScale;
	}

	op.log('scaleToSet', scaleToSet);

	scale = checkAndCorrectBoundaries(scale);
	scaleToSet = checkAndCorrectBoundaries(scaleToSet);

	scalePort.set(scaleToSet);
	*/
});

el.addEventListener("touchend", function (ev)
{
    op.log("touchend");
    if (pinchInProgress)
    {
        op.log("touchend, setting manually");
        ev.preventDefault(); // this is ignored in some browsers
        ev.stopPropagation();
        pinchInProgress = false;
        scale *= tmpScale;
        scale = checkAndCorrectBoundaries(scale);
        tmpScale = initialScale;
        scalePort.set(scale);
    }
});

function checkAndCorrectBoundaries(s)
{
    let correctedS = s;

    if (inLimit.get())
    {
        if (s < minScalePort.get())
        {
    	    correctedS = minScalePort.get();
    	}
        else if (s > maxScalePort.get())
        {
    	    correctedS = maxScalePort.get();
    	}
    }
    return correctedS;
}

resetScalePort.onTriggered = reset;

// functions

function reset()
{
    scale = initialScale;
    scalePort.set(scale);
}


};

Ops.Devices.Mobile.Pinch.prototype = new CABLES.Op();
CABLES.OPS["98e19e37-88ca-4c07-bed7-a050dac31e3a"]={f:Ops.Devices.Mobile.Pinch,objName:"Ops.Devices.Mobile.Pinch"};




// **************************************************************
// 
// Ops.Devices.Mobile.ScreenOrientation
// 
// **************************************************************

Ops.Devices.Mobile.ScreenOrientation = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    angle = op.outNumber("Angle"),
    str = op.outString("Description");

let count = 0;
window.addEventListener("resize", onOrientationChange, false);
window.addEventListener("orientationchange", onOrientationChange, false);

onOrientationChange();

if (screen && screen.orientation)
{
    screen.orientation.addEventListener("change", onOrientationChange);
}

function onOrientationChange()
{
    count++;
    if (!screen.orientation) return;
    if (screen.orientation.hasOwnProperty("angle"))angle.set(screen.orientation.angle);
    let s = screen.orientation.type + " #" + count + " WINORIENT:" + window.orientation;
    str.set(s);
}

op.onDelete = function ()
{
    window.removeEventListener("resize", onOrientationChange);
    window.removeEventListener("orientationchange", onOrientationChange);
};


};

Ops.Devices.Mobile.ScreenOrientation.prototype = new CABLES.Op();
CABLES.OPS["ef8f5f5a-4652-4fad-983b-aca96d9cc13b"]={f:Ops.Devices.Mobile.ScreenOrientation,objName:"Ops.Devices.Mobile.ScreenOrientation"};




// **************************************************************
// 
// Ops.Devices.Mouse.MouseButtons
// 
// **************************************************************

Ops.Devices.Mouse.MouseButtons = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    mouseClickLeft = op.outTrigger("Click Left"),
    mouseClickRight = op.outTrigger("Click Right"),
    mouseDoubleClick = op.outTrigger("Double Click"),
    mouseDownLeft = op.outBoolNum("Button pressed Left", false),
    mouseDownMiddle = op.outBoolNum("Button pressed Middle", false),
    mouseDownRight = op.outBoolNum("Button pressed Right", false),
    triggerMouseDownLeft = op.outTrigger("Mouse Down Left"),
    triggerMouseDownMiddle = op.outTrigger("Mouse Down Middle"),
    triggerMouseDownRight = op.outTrigger("Mouse Down Right"),
    triggerMouseUpLeft = op.outTrigger("Mouse Up Left"),
    triggerMouseUpMiddle = op.outTrigger("Mouse Up Middle"),
    triggerMouseUpRight = op.outTrigger("Mouse Up Right"),
    area = op.inValueSelect("Area", ["Canvas", "Document"], "Canvas"),
    active = op.inValueBool("Active", true);

const cgl = op.patch.cgl;
let listenerElement = null;
area.onChange = updateListeners;
op.onDelete = removeListeners;
updateListeners();

function onMouseDown(e)
{
    if (e.which == 1)
    {
        mouseDownLeft.set(true);
        triggerMouseDownLeft.trigger();
    }
    else if (e.which == 2)
    {
        mouseDownMiddle.set(true);
        triggerMouseDownMiddle.trigger();
    }
    else if (e.which == 3)
    {
        mouseDownRight.set(true);
        triggerMouseDownRight.trigger();
    }
}

function onMouseUp(e)
{
    if (e.which == 1)
    {
        mouseDownLeft.set(false);
        triggerMouseUpLeft.trigger();
    }
    else if (e.which == 2)
    {
        mouseDownMiddle.set(false);
        triggerMouseUpMiddle.trigger();
    }
    else if (e.which == 3)
    {
        mouseDownRight.set(false);
        triggerMouseUpRight.trigger();
    }
}

function onClickRight(e)
{
    mouseClickRight.trigger();
    e.preventDefault();
}

function onDoubleClick(e)
{
    mouseDoubleClick.trigger();
}

function onmouseclick(e)
{
    mouseClickLeft.trigger();
}

function ontouchstart(event)
{
    if (event.touches && event.touches.length > 0)
    {
        event.touches[0].which = 1;
        onMouseDown(event.touches[0]);
    }
}

function ontouchend(event)
{
    onMouseUp({ "which": 1 });
}

function removeListeners()
{
    if (!listenerElement) return;
    listenerElement.removeEventListener("touchend", ontouchend);
    listenerElement.removeEventListener("touchcancel", ontouchend);
    listenerElement.removeEventListener("touchstart", ontouchstart);
    listenerElement.removeEventListener("dblclick", onDoubleClick);
    listenerElement.removeEventListener("click", onmouseclick);
    listenerElement.removeEventListener("mousedown", onMouseDown);
    listenerElement.removeEventListener("mouseup", onMouseUp);
    listenerElement.removeEventListener("contextmenu", onClickRight);
    listenerElement.removeEventListener("mouseleave", onMouseUp);
    listenerElement = null;
}

function addListeners()
{
    if (listenerElement)removeListeners();

    listenerElement = cgl.canvas;
    if (area.get() == "Document") listenerElement = document.body;

    listenerElement.addEventListener("touchend", ontouchend);
    listenerElement.addEventListener("touchcancel", ontouchend);
    listenerElement.addEventListener("touchstart", ontouchstart);
    listenerElement.addEventListener("dblclick", onDoubleClick);
    listenerElement.addEventListener("click", onmouseclick);
    listenerElement.addEventListener("mousedown", onMouseDown);
    listenerElement.addEventListener("mouseup", onMouseUp);
    listenerElement.addEventListener("contextmenu", onClickRight);
    listenerElement.addEventListener("mouseleave", onMouseUp);
}

op.onLoaded = updateListeners;

active.onChange = updateListeners;

function updateListeners()
{
    removeListeners();
    if (active.get()) addListeners();
}


};

Ops.Devices.Mouse.MouseButtons.prototype = new CABLES.Op();
CABLES.OPS["c7e5e545-c8a1-4fef-85c2-45422b947f0d"]={f:Ops.Devices.Mouse.MouseButtons,objName:"Ops.Devices.Mouse.MouseButtons"};




// **************************************************************
// 
// Ops.Devices.Mouse.MouseDrag
// 
// **************************************************************

Ops.Devices.Mouse.MouseDrag = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    active = op.inValueBool("Active", true),
    speed = op.inValue("Speed", 0.01),
    inputType = op.inSwitch("Input Type", ["All", "Mouse", "Touch"], "All"),
    area = op.inSwitch("Area", ["Canvas", "Document"], "Canvas"),
    outDeltaX = op.outNumber("Delta X"),
    outDeltaY = op.outNumber("Delta Y"),
    outDragging = op.outNumber("Is Dragging");

let listenerElement = null;
const absoluteX = 0;
const absoluteY = 0;
let pressed = false;
let lastX = 0;
let lastY = 0;
let firstMove = true;

area.onChange = updateArea;

updateArea();

function onMouseMove(e)
{
    if (e.touches) e = e.touches[0];

    if (pressed && e)
    {
        if (!firstMove)
        {
            outDragging.set(true);
            const deltaX = (e.clientX - lastX) * speed.get();
            const deltaY = (e.clientY - lastY) * speed.get();

            outDeltaX.set(0);
            outDeltaY.set(0);
            outDeltaX.set(deltaX);
            outDeltaY.set(deltaY);
        }

        firstMove = false;

        lastX = e.clientX;
        lastY = e.clientY;
    }
}

function onMouseDown(e)
{
    try { listenerElement.setPointerCapture(e.pointerId); }
    catch (_e) {}

    pressed = true;
}

function onMouseUp(e)
{
    try { listenerElement.releasePointerCapture(e.pointerId); }
    catch (e) {}

    pressed = false;
    outDragging.set(false);
    lastX = 0;
    lastY = 0;
    firstMove = true;
}

function updateArea()
{
    removeListener();

    if (area.get() == "Document") listenerElement = document;
    else listenerElement = op.patch.cgl.canvas;

    if (active.get())addListener();
}

function addListener()
{
    if (!listenerElement)updateArea();

    if (inputType.get() == "All" || inputType.get() == "Mouse")
    {
        listenerElement.addEventListener("mousemove", onMouseMove);
        listenerElement.addEventListener("mousedown", onMouseDown);
        listenerElement.addEventListener("mouseup", onMouseUp);
        listenerElement.addEventListener("mouseenter", onMouseUp);
        listenerElement.addEventListener("mouseleave", onMouseUp);
    }

    if (inputType.get() == "All" || inputType.get() == "Touch")
    {
        listenerElement.addEventListener("touchmove", onMouseMove);
        listenerElement.addEventListener("touchend", onMouseUp);
        listenerElement.addEventListener("touchstart", onMouseDown);
    }
}

function removeListener()
{
    if (!listenerElement) return;
    listenerElement.removeEventListener("mousemove", onMouseMove);
    listenerElement.removeEventListener("mousedown", onMouseDown);
    listenerElement.removeEventListener("mouseup", onMouseUp);
    listenerElement.removeEventListener("mouseenter", onMouseUp);
    listenerElement.removeEventListener("mouseleave", onMouseUp);

    listenerElement.removeEventListener("touchmove", onMouseMove);
    listenerElement.removeEventListener("touchend", onMouseUp);
    listenerElement.removeEventListener("touchstart", onMouseDown);
}

active.onChange = function ()
{
    if (active.get())addListener();
    else removeListener();
};

op.onDelete = function ()
{
    removeListener();
};


};

Ops.Devices.Mouse.MouseDrag.prototype = new CABLES.Op();
CABLES.OPS["5103d14e-2f21-4f43-ae91-c1b55a944226"]={f:Ops.Devices.Mouse.MouseDrag,objName:"Ops.Devices.Mouse.MouseDrag"};




// **************************************************************
// 
// Ops.Devices.Mouse.MouseWheel_v2
// 
// **************************************************************

Ops.Devices.Mouse.MouseWheel_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    speed = op.inValue("Speed", 1),
    preventScroll = op.inValueBool("prevent scroll", true),
    flip = op.inValueBool("Flip Direction"),
    inSimpleIncrement = op.inBool("Simple Delta", true),
    area = op.inSwitch("Area", ["Canvas", "Document", "Parent"], "Document"),
    active = op.inValueBool("active", true),
    delta = op.outNumber("delta", 0),
    deltaX = op.outNumber("delta X", 0),
    deltaOrig = op.outNumber("browser event delta", 0),
    trigger = op.outTrigger("Wheel Action");

const cgl = op.patch.cgl;
const value = 0;

const startTime = CABLES.now() / 1000.0;
const v = 0;

let dir = 1;

let listenerElement = null;

area.onChange = updateArea;
const vOut = 0;

addListener();

const isChromium = window.chrome,
    winNav = window.navigator,
    vendorName = winNav.vendor,
    isOpera = winNav.userAgent.indexOf("OPR") > -1,
    isIEedge = winNav.userAgent.indexOf("Edge") > -1,
    isIOSChrome = winNav.userAgent.match("CriOS");

const isWindows = window.navigator.userAgent.indexOf("Windows") != -1;
const isLinux = window.navigator.userAgent.indexOf("Linux") != -1;
const isMac = window.navigator.userAgent.indexOf("Mac") != -1;

const isChrome = (isChromium !== null && isChromium !== undefined && vendorName === "Google Inc." && isOpera === false && isIEedge === false);
const isFirefox = navigator.userAgent.search("Firefox") > 1;

flip.onChange = function ()
{
    if (flip.get())dir = -1;
    else dir = 1;
};

function normalizeWheel(event)
{
    let sY = 0;

    if ("detail" in event) { sY = event.detail; }

    if ("deltaY" in event)
    {
        sY = event.deltaY;
        if (event.deltaY > 20)sY = 20;
        else if (event.deltaY < -20)sY = -20;
    }
    return sY * dir;
}

function normalizeWheelX(event)
{
    let sX = 0;

    if ("deltaX" in event)
    {
        sX = event.deltaX;
        if (event.deltaX > 20)sX = 20;
        else if (event.deltaX < -20)sX = -20;
    }
    return sX;
}

let lastEvent = 0;

function onMouseWheel(e)
{
    if (Date.now() - lastEvent < 10) return;
    lastEvent = Date.now();

    deltaOrig.set(e.wheelDelta || e.deltaY);

    if (e.deltaY)
    {
        let d = normalizeWheel(e);
        if (inSimpleIncrement.get())
        {
            if (d > 0)d = speed.get();
            else d = -speed.get();
        }
        else d *= 0.01 * speed.get();

        delta.set(0);
        delta.set(d);
    }

    if (e.deltaX)
    {
        let dX = normalizeWheelX(e);
        dX *= 0.01 * speed.get();

        deltaX.set(0);
        deltaX.set(dX);
    }

    if (preventScroll.get()) e.preventDefault();
    trigger.trigger();
}

function updateArea()
{
    removeListener();

    if (area.get() == "Document") listenerElement = document;
    if (area.get() == "Parent") listenerElement = cgl.canvas.parentElement;
    else listenerElement = cgl.canvas;

    if (active.get())addListener();
}

function addListener()
{
    if (!listenerElement)updateArea();
    listenerElement.addEventListener("wheel", onMouseWheel, { "passive": false });
}

function removeListener()
{
    if (listenerElement) listenerElement.removeEventListener("wheel", onMouseWheel);
}

active.onChange = function ()
{
    updateArea();
};


};

Ops.Devices.Mouse.MouseWheel_v2.prototype = new CABLES.Op();
CABLES.OPS["7b9626db-536b-4bb4-85c3-95401bc60d1b"]={f:Ops.Devices.Mouse.MouseWheel_v2,objName:"Ops.Devices.Mouse.MouseWheel_v2"};




// **************************************************************
// 
// Ops.Devices.Mouse.Mouse_v3
// 
// **************************************************************

Ops.Devices.Mouse.Mouse_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inCoords = op.inSwitch("Coordinates", ["Pixel", "Pixel Display", "-1 to 1", "0 to 1"], "-1 to 1"),
    area = op.inValueSelect("Area", ["Canvas", "Document", "Parent Element"], "Canvas"),
    flipY = op.inValueBool("flip y", true),
    rightClickPrevDef = op.inBool("right click prevent default", true),
    touchscreen = op.inValueBool("Touch support", true),
    active = op.inValueBool("Active", true),
    outMouseX = op.outNumber("x", 0),
    outMouseY = op.outNumber("y", 0),
    mouseClick = op.outTrigger("click"),
    mouseClickRight = op.outTrigger("click right"),
    mouseDown = op.outBoolNum("Button is down"),
    mouseOver = op.outBoolNum("Mouse is hovering");

const cgl = op.patch.cgl;
let normalize = 1;
let listenerElement = null;
let mouseX = cgl.canvas.width / 2;
let mouseY = cgl.canvas.height / 2;
area.onChange = addListeners;

outMouseX.set(mouseX);
outMouseY.set(mouseY);

inCoords.onChange = updateCoordNormalizing;
op.onDelete = removeListeners;

addListeners();

function setValue(x, y)
{
    x = x || 0;
    y = y || 0;

    if (normalize == 0)
    {
        outMouseX.set(x);
        outMouseY.set(y);
    }
    else
    if (normalize == 3)
    {
        outMouseX.set(x * cgl.pixelDensity);
        outMouseY.set(y * cgl.pixelDensity);
    }
    else
    {
        let w = cgl.canvas.width / cgl.pixelDensity;
        let h = cgl.canvas.height / cgl.pixelDensity;
        if (listenerElement == document.body)
        {
            w = listenerElement.clientWidth / cgl.pixelDensity;
            h = listenerElement.clientHeight / cgl.pixelDensity;
        }

        if (normalize == 1)
        {
            outMouseX.set(x / w * 2.0 - 1.0);
            outMouseY.set(y / h * 2.0 - 1.0);
        }
        if (normalize == 2)
        {
            outMouseX.set(x / w);
            outMouseY.set(y / h);
        }
    }
}

touchscreen.onChange = function ()
{
    removeListeners();
    addListeners();
};

active.onChange = function ()
{
    if (listenerElement)removeListeners();
    if (active.get())addListeners();
};

function updateCoordNormalizing()
{
    mouseX = 0;
    mouseY = 0;
    setValue(mouseX, mouseY);

    if (inCoords.get() == "Pixel")normalize = 0;
    else if (inCoords.get() == "-1 to 1")normalize = 1;
    else if (inCoords.get() == "0 to 1")normalize = 2;
    else if (inCoords.get() == "Pixel CSS")normalize = 3;
}

function onMouseEnter(e)
{
    mouseDown.set(false);
    mouseOver.set(true);
}

function onMouseDown(e)
{
    mouseDown.set(true);
}

function onMouseUp(e)
{
    mouseDown.set(false);
}

function onClickRight(e)
{
    mouseClickRight.trigger();
    if (rightClickPrevDef.get()) e.preventDefault();
}

function onmouseclick(e)
{
    mouseClick.trigger();
}

function onMouseLeave(e)
{
    mouseOver.set(false);
    mouseDown.set(false);
}

function setCoords(e)
{
    let x = e.clientX;
    let y = e.clientY;

    if (area.get() != "Document")
    {
        x = e.offsetX;
        y = e.offsetY;
    }

    if (flipY.get()) setValue(x, listenerElement.clientHeight - y);
    else setValue(x, y);
}

function onmousemove(e)
{
    mouseOver.set(true);
    setCoords(e);
}

function ontouchmove(e)
{
    if (event.touches && event.touches.length > 0) setCoords(e.touches[0]);
}

function ontouchstart(event)
{
    mouseDown.set(true);

    if (event.touches && event.touches.length > 0) onMouseDown(event.touches[0]);
}

function ontouchend(event)
{
    mouseDown.set(false);
    onMouseUp();
}

function removeListeners()
{
    if (!listenerElement) return;
    listenerElement.removeEventListener("touchend", ontouchend);
    listenerElement.removeEventListener("touchstart", ontouchstart);
    listenerElement.removeEventListener("touchmove", ontouchmove);

    listenerElement.removeEventListener("click", onmouseclick);
    listenerElement.removeEventListener("mousemove", onmousemove);
    listenerElement.removeEventListener("mouseleave", onMouseLeave);
    listenerElement.removeEventListener("mousedown", onMouseDown);
    listenerElement.removeEventListener("mouseup", onMouseUp);
    listenerElement.removeEventListener("mouseenter", onMouseEnter);
    listenerElement.removeEventListener("contextmenu", onClickRight);
    listenerElement = null;
}

function addListeners()
{
    if (listenerElement || !active.get())removeListeners();
    if (!active.get()) return;

    listenerElement = cgl.canvas;
    if (area.get() == "Document") listenerElement = document.body;
    if (area.get() == "Parent Element") listenerElement = cgl.canvas.parentElement;

    if (touchscreen.get())
    {
        listenerElement.addEventListener("touchend", ontouchend);
        listenerElement.addEventListener("touchstart", ontouchstart);
        listenerElement.addEventListener("touchmove", ontouchmove);
    }

    listenerElement.addEventListener("mousemove", onmousemove);
    listenerElement.addEventListener("mouseleave", onMouseLeave);
    listenerElement.addEventListener("mousedown", onMouseDown);
    listenerElement.addEventListener("mouseup", onMouseUp);
    listenerElement.addEventListener("mouseenter", onMouseEnter);
    listenerElement.addEventListener("contextmenu", onClickRight);
    listenerElement.addEventListener("click", onmouseclick);
}


};

Ops.Devices.Mouse.Mouse_v3.prototype = new CABLES.Op();
CABLES.OPS["6d1edbc0-088a-43d7-9156-918fb3d7f24b"]={f:Ops.Devices.Mouse.Mouse_v3,objName:"Ops.Devices.Mouse.Mouse_v3"};




// **************************************************************
// 
// Ops.Devices.TouchGesture
// 
// **************************************************************

Ops.Devices.TouchGesture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
const inEnabled = op.inBool("Active", true);
let enableVerticalSwipePort = op.inValueBool("Vertical Swipe", true);
let enableVerticalPanPort = op.inValueBool("Vertical Pan", true);

// outputs
let pressPort = op.outTrigger("Press");
let pressUpPort = op.outTrigger("Press Up");
let panLeftPort = op.outTrigger("Pan Left");
let panRightPort = op.outTrigger("Pan Right");
let swipeLeftPort = op.outTrigger("Swipe Left");
let swipeRightPort = op.outTrigger("Swipe Right");
let swipeUpPort = op.outTrigger("Swipe Up");
let swipeDownPort = op.outTrigger("Swipe Down");
let eventPort = op.outObject("Event");

let canvas = op.patch.cgl.canvas;

// create a simple instance
// by default, it only adds horizontal recognizers
let mc = new Hammer(canvas);

// change listeners
enableVerticalSwipePort.onChange = onEnableVerticalSwipePortChange;
enableVerticalPanPort.onChange = onEnableVerticalPanPortChange;

// init
onEnableVerticalSwipePortChange();
onEnableVerticalPanPortChange();

function onEnableVerticalSwipePortChange()
{
    let direction = Hammer.DIRECTION_HORIZONTAL;
    if (enableVerticalSwipePort.get())
    {
        direction = Hammer.DIRECTION_ALL;
    }
    mc.get("swipe").set({ "direction": direction });
}

function onEnableVerticalPanPortChange()
{
    let direction = Hammer.DIRECTION_HORIZONTAL;
    if (enableVerticalPanPort.get())
    {
        direction = Hammer.DIRECTION_ALL;
    }
    mc.get("pan").set({ "direction": direction });
}

/*
mc.on("panleft panright tap press", function(ev) {
    myElement.textContent = ev.type +" gesture detected.";
});
*/

mc.on("panleft", onPanLeft);
mc.on("panright", onPanRight);
mc.on("swipeleft", onSwipeLeft);
mc.on("swiperight", onSwipeRight);
mc.on("swipeup", onSwipeUp);
mc.on("swipedown", onSwipeDown);
mc.on("press", onPress);
mc.on("pressup", onPressUp);

function onPress(ev)
{
    if (!inEnabled.get()) return;
    eventPort.set(ev);
    pressPort.trigger();
}

function onPressUp(ev)
{
    if (!inEnabled.get()) return;
    eventPort.set(ev);
    pressUpPort.trigger();
}

function onPanLeft(ev)
{
    if (!inEnabled.get()) return;
    eventPort.set(ev);
    panLeftPort.trigger();
}

function onPanRight(ev)
{
    if (!inEnabled.get()) return;
    eventPort.set(ev);
    panRightPort.trigger();
}

function onSwipeLeft(ev)
{
    if (!inEnabled.get()) return;
    eventPort.set(ev);
    swipeLeftPort.trigger();
}

function onSwipeRight(ev)
{
    if (!inEnabled.get()) return;
    eventPort.set(ev);
    swipeRightPort.trigger();
}

function onSwipeUp(ev)
{
    if (!inEnabled.get()) return;
    eventPort.set(ev);
    swipeUpPort.trigger();
}

function onSwipeDown(ev)
{
    if (!inEnabled.get()) return;
    eventPort.set(ev);
    swipeDownPort.trigger();
}

/*
// By default it adds a set of tap, doubletap, press,
// horizontal pan and swipe, and the multi-touch pinch
// and rotate recognizers. The pinch and rotate recognizers
// are disabled by default because they would make the
// element blocking, but you can enable them by calling:
hammertime.get('pinch').set({ enable: true });
hammertime.get('rotate').set({ enable: true });

// Enabling vertical or all directions for the pan and swipe recognizers:
hammertime.get('pan').set({ direction: Hammer.DIRECTION_ALL });
hammertime.get('swipe').set({ direction: Hammer.DIRECTION_VERTICAL });
*/


};

Ops.Devices.TouchGesture.prototype = new CABLES.Op();
CABLES.OPS["08c5d91e-32d2-4852-ac18-d4cae543dd37"]={f:Ops.Devices.TouchGesture,objName:"Ops.Devices.TouchGesture"};




// **************************************************************
// 
// Ops.Devices.TouchScreen
// 
// **************************************************************

Ops.Devices.TouchScreen = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    disableScaleWeb = op.inValueBool("Disable Scaling", true),
    disableDefault = op.inValueBool("Disable Scroll", true),
    hdpi = op.inValueBool("HDPI Coordinates", false),
    active = op.inValueBool("Active", true),

    outTouched = op.outNumber("Touched", false),
    numFingers = op.outNumber("Fingers", 0),

    f1x = op.outNumber("Finger 1 X", 0),
    f1y = op.outNumber("Finger 1 Y", 0),
    f1f = op.outNumber("Finger 1 Force", 0),

    f2x = op.outNumber("Finger 2 X", 0),
    f2y = op.outNumber("Finger 2 Y", 0),
    area = op.inSwitch("Area", ["Canvas", "Document"], "Canvas"),

    outEvents = op.outArray("Events"),
    normalize = op.inValueBool("Normalize Coordinates"),
    flipY = op.inValueBool("Flip Y"),
    outTouchStart = op.outTrigger("Touch Start"),
    outTouchEnd = op.outTrigger("Touch End");

area.onChange = updateArea;

function setPos(event)
{
    if (event.touches && event.touches.length > 0)
    {
        var rect = event.target.getBoundingClientRect();
        var x = event.touches[0].clientX - event.touches[0].target.offsetLeft;
        var y = event.touches[0].clientY - event.touches[0].target.offsetTop;

        if (flipY.get()) y = rect.height - y;

        if (hdpi.get())
        {
            x *= (op.patch.cgl.pixelDensity || 1);
            y *= (op.patch.cgl.pixelDensity || 1);
        }

        if (normalize.get())
        {
            x = (x / rect.width * 2.0 - 1.0);
            y = (y / rect.height * 2.0 - 1.0);
        }

        f1x.set(x);
        f1y.set(y);

        if (event.touches[0].force)f1f.set(event.touches[0].force);
    }

    if (event.touches && event.touches.length > 1)
    {
        var rect = event.target.getBoundingClientRect();
        var x = event.touches[1].clientX - event.touches[1].target.offsetLeft;
        var y = event.touches[1].clientY - event.touches[1].target.offsetTop;

        if (hdpi.get())
        {
            x *= (op.patch.cgl.pixelDensity || 1);
            y *= (op.patch.cgl.pixelDensity || 1);
        }

        f2x.set(x);
        f2y.set(y);
    }
    outEvents.set(event.touches);
}

const ontouchstart = function (event)
{
    outTouched.set(true);
    setPos(event);
    numFingers.set(event.touches.length);
    outTouchStart.trigger();
};

const ontouchend = function (event)
{
    outTouched.set(false);
    f1f.set(0);
    setPos(event);

    numFingers.set(event.touches.length);
    outTouchEnd.trigger();
};

const ontouchmove = function (event)
{
    setPos(event);
    numFingers.set(event.touches.length);
    if (disableDefault.get() || (disableScaleWeb.get() && event.scale !== 1))
    {
        event.preventDefault();
        document.body.style["touch-action"] = "none";
    }
    else
    {
        document.body.style["touch-action"] = "initial";
    }
};

const cgl = op.patch.cgl;
let listenerElement = null;
function addListeners()
{
    listenerElement.addEventListener("touchmove", ontouchmove, { "passive": true });
    listenerElement.addEventListener("touchstart", ontouchstart, { "passive": true });
    listenerElement.addEventListener("touchend", ontouchend, { "passive": true });
}

function updateArea()
{
    removeListeners();

    if (area.get() == "Document") listenerElement = document;
    else listenerElement = cgl.canvas;

    if (active.get()) addListeners();
}

function removeListeners()
{
    if (listenerElement)
    {
        listenerElement.removeEventListener("touchmove", ontouchmove);
        listenerElement.removeEventListener("touchstart", ontouchstart);
        listenerElement.removeEventListener("touchend", ontouchend);
    }
    listenerElement = null;
}

active.onChange = function ()
{
    updateArea();
};

updateArea();


};

Ops.Devices.TouchScreen.prototype = new CABLES.Op();
CABLES.OPS["cedffacf-0f09-4342-bd21-540bd9c8037d"]={f:Ops.Devices.TouchScreen,objName:"Ops.Devices.TouchScreen"};




// **************************************************************
// 
// Ops.Game.PersonController
// 
// **************************************************************

Ops.Game.PersonController = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Exe"),
    speed = op.inValue("Speed", 1),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outDir = op.outNumber("Dir"),
    goNorth = op.inBool("North"),
    goEast = op.inBool("East"),
    goSouth = op.inBool("South"),
    goWest = op.inBool("West");

let lastTime = performance.now();
let dir = 0;

exe.onTriggered = function ()
{
    let ago = (performance.now() - lastTime) / 1000;
    let x = 0;
    let y = 0;
    if (goEast.get())x += ago * speed.get();
    if (goWest.get())x -= ago * speed.get();
    if (goNorth.get())y += ago * speed.get();
    if (goSouth.get())y -= ago * speed.get();

    if (goEast.get())dir = 90;
    if (goWest.get())dir = 270;
    if (goNorth.get())dir = 0;
    if (goSouth.get())dir = 180;

    outDir.set(dir);
    outX.set(outX.get() + x);
    outY.set(outY.get() + y);
    lastTime = performance.now();
};


};

Ops.Game.PersonController.prototype = new CABLES.Op();
CABLES.OPS["7b08dea1-a05b-422e-a1de-7832058bee51"]={f:Ops.Game.PersonController,objName:"Ops.Game.PersonController"};




// **************************************************************
// 
// Ops.Geometry.BoundingBox
// 
// **************************************************************

Ops.Geometry.BoundingBox = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inW = op.inFloat("Width", 1),
    inH = op.inFloat("Height", 1),
    inD = op.inFloat("Depth", 1),
    result = op.outObject("Result");

inW.onChange =
inH.onChange =
inD.onChange = update;
update();

function update()
{
    result.set(
        {
            "_max": [inW.get() / 2, inH.get() / 2, inD.get() / 2],
            "_min": [-inW.get() / 2, -inH.get() / 2, -inD.get() / 2],
            "_center": [0, 0, 0]
        });
}


};

Ops.Geometry.BoundingBox.prototype = new CABLES.Op();
CABLES.OPS["73dc3511-7c1d-4e42-9e00-f86bc952058a"]={f:Ops.Geometry.BoundingBox,objName:"Ops.Geometry.BoundingBox"};




// **************************************************************
// 
// Ops.Geometry.CalculateNormals
// 
// **************************************************************

Ops.Geometry.CalculateNormals = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    geometry = op.inObject("Geometry"),
    smoothNormals = op.inValueBool("Smooth"),
    forceZUp = op.inValueBool("Force Z Up"),
    geomOut = op.outObject("Geometry Out");

geomOut.ignoreValueSerialize = true;
geometry.ignoreValueSerialize = true;

geometry.onChange = calc;
smoothNormals.onChange = calc;
forceZUp.onChange = calc;

let geom = null;

function calc()
{
    if (!geometry.get()) return;

    let geom = geometry.get().copy();

    if (!smoothNormals.get())geom.unIndex();

    geom.calculateNormals({
        "forceZUp": forceZUp.get()
    });

    geomOut.set(geom);
}


};

Ops.Geometry.CalculateNormals.prototype = new CABLES.Op();
CABLES.OPS["c90c70e5-59eb-4b19-9c15-962e3e2f236b"]={f:Ops.Geometry.CalculateNormals,objName:"Ops.Geometry.CalculateNormals"};




// **************************************************************
// 
// Ops.Geometry.GeometryToWireframeArray3
// 
// **************************************************************

Ops.Geometry.GeometryToWireframeArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inGeom = op.inObject("Geometry"),
    outArr = op.outArray("Array");


inGeom.onChange = function ()
{
    const g = inGeom.get();

    outArr.set(null);

    if (!g) return;

    const arr = [];

    for (let i = 0; i < g.verticesIndices.length; i += 3)
    {
        arr.push(
            g.vertices[g.verticesIndices[i + 0] * 3 + 0],
            g.vertices[g.verticesIndices[i + 0] * 3 + 1],
            g.vertices[g.verticesIndices[i + 0] * 3 + 2],

            g.vertices[g.verticesIndices[i + 1] * 3 + 0],
            g.vertices[g.verticesIndices[i + 1] * 3 + 1],
            g.vertices[g.verticesIndices[i + 1] * 3 + 2],


            g.vertices[g.verticesIndices[i + 1] * 3 + 0],
            g.vertices[g.verticesIndices[i + 1] * 3 + 1],
            g.vertices[g.verticesIndices[i + 1] * 3 + 2],

            g.vertices[g.verticesIndices[i + 2] * 3 + 0],
            g.vertices[g.verticesIndices[i + 2] * 3 + 1],
            g.vertices[g.verticesIndices[i + 2] * 3 + 2],


            g.vertices[g.verticesIndices[i + 2] * 3 + 0],
            g.vertices[g.verticesIndices[i + 2] * 3 + 1],
            g.vertices[g.verticesIndices[i + 2] * 3 + 2],

            g.vertices[g.verticesIndices[i + 0] * 3 + 0],
            g.vertices[g.verticesIndices[i + 0] * 3 + 1],
            g.vertices[g.verticesIndices[i + 0] * 3 + 2]);
    }

    outArr.set(arr);
};


};

Ops.Geometry.GeometryToWireframeArray3.prototype = new CABLES.Op();
CABLES.OPS["d6d0f3ce-5670-49bb-893a-7c9b0262b991"]={f:Ops.Geometry.GeometryToWireframeArray3,objName:"Ops.Geometry.GeometryToWireframeArray3"};




// **************************************************************
// 
// Ops.Geometry.Triangulate2dPath
// 
// **************************************************************

Ops.Geometry.Triangulate2dPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTriggerButton("Update"),
    inWinding = op.inDropDown("Combine", ["Positive", "Odd", "Intersect", "Negative"], "Positive"),
    inPath = op.inArray("2d Point Path"),
    inPath2 = op.inArray("Path 2"),
    inPath3 = op.inArray("Path 3"),
    next = op.outTrigger("Next"),
    outGeom = op.outObject("Geometry");

inExec.onTriggered = tess;
let geom = null;
function tess()
{
    // var Tess2 = require('tess2');

    // Define input
    // var ca = [0,0, 10,0, 5,10];
    // var cb = [0,2, 10,2, 10,6, 0,6];
    // var contours = [ca,cb];

    let points = inPath.get();

    if (!points || points.length === 0)
    {
        outGeom.set(null);
        return;
    }

    let contours = [points];

    let points2 = inPath2.get();
    if (points2 && points2.length > 0) contours.push(points2);

    let points3 = inPath3.get();
    if (points3 && points3.length > 0) contours.push(points3);

    let winding = Tess2.WINDING_ODD;
    if (inWinding.get() == "Positive")
    {
        winding = Tess2.WINDING_POSITIVE;
    }
    if (inWinding.get() == "Negative")
    {
        winding = Tess2.WINDING_NEGATIVE;
    }
    if (inWinding.get() == "Intersect")
    {
        winding = Tess2.WINDING_ABS_GEQ_TWO;
    }

    let res = null;
    try
    {
        // Tesselate
        res = Tess2.tesselate({
        	"contours": contours,
        	"windingRule": winding,
        	"elementType": Tess2.POLYGONS,
        	"polySize": 3,
        	"vertexSize": 2
        });
    }
    catch (e) {}

    if (res)
    {
        let changed = true;

        if (geom) changed = geom.vertices.length / 3 != res.vertices.length / 2;

        if (changed)
        {
            geom = new CGL.Geometry("tess2geom");
        }

        let verts3 = [];
        for (let i = 0; i < res.vertices.length; i += 2)
        {
            verts3.push(res.vertices[i + 0], res.vertices[i + 1], 0);
        }

        geom.vertices = verts3;
        geom.verticesIndices = res.elements;
        geom.calculateNormals();
        geom.mapTexCoords2d();
        geom.flipVertDir();

        outGeom.set(null);
        outGeom.set(geom);
    }

    next.trigger();
}


};

Ops.Geometry.Triangulate2dPath.prototype = new CABLES.Op();
CABLES.OPS["6165a15f-abf3-4398-87f7-541bedc109e5"]={f:Ops.Geometry.Triangulate2dPath,objName:"Ops.Geometry.Triangulate2dPath"};




// **************************************************************
// 
// Ops.Gl.AspectRatio
// 
// **************************************************************

Ops.Gl.AspectRatio = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let aspects = [
    { "title": "1:2", "v": 1 / 2 },
    { "title": "1", "v": 1 },
    { "title": "5:4", "v": 5 / 4 },
    { "title": "4:3", "v": 4 / 3 },
    { "title": "3:2", "v": 3 / 2 },
    { "title": "11:8", "v": 11 / 8 },
    { "title": "16:9", "v": 16 / 9 },
    { "title": "2:1", "v": 2 },
    { "title": "21:9", "v": 21 / 9 },
    { "title": "custom", "v": 0 },
];
let aspectTitles = [];
for (let i = 0; i < aspects.length; i++) aspectTitles.push(aspects[i].title);

const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    outWidth = op.outNumber("Width"),
    outHeight = op.outNumber("Height"),
    inAspect = op.inValueSelect("Aspect Ratio", aspectTitles, aspects[0].title),
    inCustom = op.inValueFloat("Custom", 1.777777);

const
    useVPSize = op.inValueBool("use viewport size", true),
    width = op.inValueInt("texture width", 512),
    height = op.inValueInt("texture height", 512);

op.setPortGroup("Size", [useVPSize, width, height]);
useVPSize.onChange = updateVpSize;
function updateVpSize()
{
    width.setUiAttribs({ "greyout": useVPSize.get() });
    height.setUiAttribs({ "greyout": useVPSize.get() });
}

const prevViewPort = [];
const cgl = op.patch.cgl;
let w = 1000, h = 1000, x, y;
let ratio = 1;

inAspect.onChange = changedRatio;
inCustom.onChange = changedRatio;

changedRatio();

function changedRatio()
{
    let selected = inAspect.get();
    if (selected == "custom")
    {
        if (inCustom.uiAttribs.greyout) inCustom.setUiAttribs({ "greyout": false });
        ratio = Math.abs(inCustom.get());
    }
    else
    {
        if (!inCustom.uiAttribs.greyout) inCustom.setUiAttribs({ "greyout": true });

        for (let i = 0; i < aspects.length; i++)
        {
            if (aspects[i].title == selected)
            {
                ratio = aspects[i].v;
                break;
            }
        }
    }
}

function resize()
{
    let theWidth = cgl.canvasWidth;
    let theHeight = cgl.canvasHeight;

    if (!useVPSize.get())
    {
        theWidth = width.get();
        theHeight = height.get();
    }

    let _w = theHeight * ratio;
    let _h = theHeight;
    let _x = 0;
    let _y = 0;
    if (_w > theWidth)
    {
        _w = theWidth;
        _h = theWidth / ratio;
    }

    if (_w < theWidth) _x = (theWidth - _w) / 2;
    if (_h < theHeight) _y = (theHeight - _h) / 2;

    _w = Math.ceil(_w);
    _h = Math.ceil(_h);
    _x = Math.ceil(_x);
    _y = Math.ceil(_y);

    if (_w != w || _h != h || _x != x || _y != y)
    {
        w = _w;
        h = _h;
        x = _x;
        y = _y;

        cgl.setViewPort(x, y, w, h);

        for (let i = 0; i < op.patch.ops.length; i++)
            if (op.patch.ops[i].onResize)op.patch.ops[i].onResize();
    }

    outWidth.set(w);
    outHeight.set(h);
}

op.onDelete = function ()
{
    cgl.resetViewPort();
};

render.onTriggered = function ()
{
    let vp = cgl.getViewPort();
    prevViewPort[0] = vp[0];
    prevViewPort[1] = vp[1];
    prevViewPort[2] = vp[2];
    prevViewPort[3] = vp[3];

    resize();
    x = Math.ceil(x);
    y = Math.ceil(y);
    w = Math.ceil(w);
    h = Math.ceil(h);

    cgl.setViewPort(x, y, w, h);

    mat4.perspective(cgl.pMatrix, 45, ratio, 0.1, 1100.0);

    trigger.trigger();

    cgl.setViewPort(prevViewPort[0], prevViewPort[1], prevViewPort[2], prevViewPort[3]);
};


};

Ops.Gl.AspectRatio.prototype = new CABLES.Op();
CABLES.OPS["b4f17994-3028-4203-9a8d-d5e5377a58fc"]={f:Ops.Gl.AspectRatio,objName:"Ops.Gl.AspectRatio"};




// **************************************************************
// 
// Ops.Gl.BlendMode
// 
// **************************************************************

Ops.Gl.BlendMode = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Render"),
    inBlend = op.inValueSelect("Blendmode", ["None", "Normal", "Add", "Subtract", "Multiply"], "Normal"),
    inPremul = op.inValueBool("Premultiplied"),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;
let blendMode = 0;
inBlend.onChange = update;
update();

function update()
{
    if (inBlend.get() == "Normal")blendMode = CGL.BLEND_NORMAL;
    else if (inBlend.get() == "Add")blendMode = CGL.BLEND_ADD;
    else if (inBlend.get() == "Subtract")blendMode = CGL.BLEND_SUB;
    else if (inBlend.get() == "Multiply")blendMode = CGL.BLEND_MUL;
    else blendMode = CGL.BLEND_NONE;

    if (CABLES.UI)
    {
        let blstr = "";
        if (inBlend.get() == "Normal")blstr = "";
        else if (inBlend.get() == "Add")blstr = "Add";
        else if (inBlend.get() == "Subtract")blstr = "Sub";
        else if (inBlend.get() == "Multiply")blstr = "Mul";
        else blstr = "None";

        op.setUiAttrib({ "extendTitle": blstr });
    }
}

exec.onTriggered = function ()
{
    cgl.pushBlendMode(blendMode, inPremul.get());
    cgl.pushBlend(blendMode != CGL.BLEND_NONE);
    next.trigger();
    cgl.popBlend();
    cgl.popBlendMode();
    cgl.gl.blendEquationSeparate(cgl.gl.FUNC_ADD, cgl.gl.FUNC_ADD);
    cgl.gl.blendFuncSeparate(cgl.gl.SRC_ALPHA, cgl.gl.ONE_MINUS_SRC_ALPHA, cgl.gl.ONE, cgl.gl.ONE_MINUS_SRC_ALPHA);
};


};

Ops.Gl.BlendMode.prototype = new CABLES.Op();
CABLES.OPS["ce0fff72-1438-4373-924f-e1d0f78b053f"]={f:Ops.Gl.BlendMode,objName:"Ops.Gl.BlendMode"};




// **************************************************************
// 
// Ops.Gl.Canvas2Texture
// 
// **************************************************************

Ops.Gl.Canvas2Texture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    cgl = op.patch.cgl,
    inCanvas = op.inObject("canvas"),
    inTextureFilter = op.inValueSelect("filter", ["nearest", "linear", "mipmap"]),
    inTextureWrap = op.inValueSelect("wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"),
    inTextureFlip = op.inValueBool("flip"),
    inUnpackAlpha = op.inValueBool("unpackPreMultipliedAlpha"),
    outTexture = op.outTexture("texture"),
    outWidth = op.outNumber("width"),
    outHeight = op.outNumber("height"),
    canvasTexture = new CGL.Texture(cgl);

let cgl_filter = null;
let cgl_wrap = null;

inTextureFlip.set(false);
inUnpackAlpha.set(false);

inTextureFlip.setUiAttribs({ "hidePort": true });
inUnpackAlpha.setUiAttribs({ "hidePort": true });

inTextureFilter.onChange = onFilterChange;
inTextureWrap.onChange = onWrapChange;

inTextureFlip.onChange =
inCanvas.onChange =
inUnpackAlpha.onChange = reload;

function reload()
{
    let canvas = inCanvas.get();
    if (!canvas) return;

    canvasTexture.unpackAlpha = inUnpackAlpha.get();
    canvasTexture.flip = inTextureFlip.get();
    canvasTexture.wrap = cgl_wrap;
    canvasTexture.image = canvas;
    canvasTexture.initTexture(canvas, cgl_filter);
    outWidth.set(canvasTexture.width);
    outHeight.set(canvasTexture.height);

    outTexture.set(CGL.Texture.getEmptyTexture(cgl));
    outTexture.set(canvasTexture);
}

function onFilterChange()
{
    switch (inTextureFilter.get())
    {
    case "nearest": cgl_filter = CGL.Texture.FILTER_NEAREST; break;
    case "mipmap": cgl_filter = CGL.Texture.FILTER_MIPMAP; break;
    case "linear":
    default: cgl_filter = CGL.Texture.FILTER_LINEAR;
    }
    reload();
}

function onWrapChange()
{
    switch (inTextureWrap.get())
    {
    case "repeat": cgl_wrap = CGL.Texture.WRAP_REPEAT; break;
    case "mirrored repeat": cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT; break;
    case "clamp to edge":
    default: cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    }
    reload();
}

inTextureFilter.set("linear");
inTextureWrap.set("repeat");

outTexture.set(CGL.Texture.getEmptyTexture(cgl));


};

Ops.Gl.Canvas2Texture.prototype = new CABLES.Op();
CABLES.OPS["2fbada6b-70fa-4b43-87db-8b0d9293990b"]={f:Ops.Gl.Canvas2Texture,objName:"Ops.Gl.Canvas2Texture"};




// **************************************************************
// 
// Ops.Gl.CanvasFocus
// 
// **************************************************************

Ops.Gl.CanvasFocus = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inFocus = op.inTriggerButton("Focus"),
    hasFocus = op.outBool("has focus");

op.onDelete = removeListeners;
addListeners();

inFocus.onTriggered = () =>
{
    op.patch.cgl.canvas.focus();
};

function onFocus()
{
    hasFocus.set(true);
}

function onBlur()
{
    hasFocus.set(false);
}

function addListeners()
{
    op.patch.cgl.canvas.addEventListener("focus", onFocus);
    op.patch.cgl.canvas.addEventListener("blur", onBlur);
}

function removeListeners()
{
    op.patch.cgl.canvas.removeEventListener("focus", onFocus);
    op.patch.cgl.canvas.removeEventListener("blur", onBlur);
}


};

Ops.Gl.CanvasFocus.prototype = new CABLES.Op();
CABLES.OPS["e235ea77-f697-475a-8799-d5e4deed7204"]={f:Ops.Gl.CanvasFocus,objName:"Ops.Gl.CanvasFocus"};




// **************************************************************
// 
// Ops.Gl.CanvasInBrowserViewport
// 
// **************************************************************

Ops.Gl.CanvasInBrowserViewport = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpdate = op.inTriggerButton("Update"),
    outResult = op.outBoolNum("Fully Visible"),
    outResultPartly = op.outBoolNum("Partly Visible");

inUpdate.onTriggered = update;

window.addEventListener("DOMContentLoaded load", update);
window.addEventListener("resize", update);
window.addEventListener("scroll", update);

// from: https://stackoverflow.com/questions/19669786/check-if-element-is-visible-in-dom

function pointInViewport(x, y)
{
    return (
        y >= 0 &&
        x >= 0 &&
        y <= (window.innerHeight || document.documentElement.clientHeight) &&
        x <= (window.innerWidth || document.documentElement.clientWidth)
    );
}

function elementInViewport(el)
{
    let rect = el.getBoundingClientRect();

    return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
}

function elementInViewportPartly(el)
{
    let rect = el.getBoundingClientRect();

    return (
        pointInViewport(rect.left, rect.top) ||
        pointInViewport(rect.left, rect.bottom) ||
        pointInViewport(rect.right, rect.top) ||
        pointInViewport(rect.right, rect.bottom)
    );
}

function update()
{
    let visible = elementInViewport(op.patch.cgl.canvas);
    let visiblePartly = elementInViewportPartly(op.patch.cgl.canvas);

    outResultPartly.set(visiblePartly);
    outResult.set(visible);
}

update();


};

Ops.Gl.CanvasInBrowserViewport.prototype = new CABLES.Op();
CABLES.OPS["2721f83b-246c-46fa-9ad9-d8c829adb94d"]={f:Ops.Gl.CanvasInBrowserViewport,objName:"Ops.Gl.CanvasInBrowserViewport"};




// **************************************************************
// 
// Ops.Gl.CanvasInfo
// 
// **************************************************************

Ops.Gl.CanvasInfo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    width = op.outNumber("width"),
    height = op.outNumber("height"),
    inUnit = op.inSwitch("Pixel Unit", ["Display", "CSS"], "Display"),
    pixelRatio = op.outNumber("Pixel Ratio"),
    aspect = op.outNumber("Aspect Ratio"),
    landscape = op.outBool("Landscape");

let cgl = op.patch.cgl;

cgl.on("resize", update);

inUnit.onChange = update;
update();

function update()
{
    let div = 1;
    if (inUnit.get() == "CSS")div = op.patch.cgl.pixelDensity;
    height.set(cgl.canvasHeight / div);
    width.set(cgl.canvasWidth / div);

    pixelRatio.set(op.patch.cgl.pixelDensity); // window.devicePixelRatio

    aspect.set(cgl.canvasWidth / cgl.canvasHeight);
    landscape.set(cgl.canvasWidth > cgl.canvasHeight ? 1 : 0);
}


};

Ops.Gl.CanvasInfo.prototype = new CABLES.Op();
CABLES.OPS["94e499e5-b4ee-4861-ab48-6ab5098b2cc3"]={f:Ops.Gl.CanvasInfo,objName:"Ops.Gl.CanvasInfo"};




// **************************************************************
// 
// Ops.Gl.ClearColor
// 
// **************************************************************

Ops.Gl.ClearColor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    r = op.inFloatSlider("r", 0.1),
    g = op.inFloatSlider("g", 0.1),
    b = op.inFloatSlider("b", 0.1),
    a = op.inFloatSlider("a", 1);

r.setUiAttribs({ "colorPick": true });

const cgl = op.patch.cgl;

render.onTriggered = function ()
{
    cgl.gl.clearColor(r.get(), g.get(), b.get(), a.get());
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
    trigger.trigger();
};


};

Ops.Gl.ClearColor.prototype = new CABLES.Op();
CABLES.OPS["19b441eb-9f63-4f35-ba08-b87841517c4d"]={f:Ops.Gl.ClearColor,objName:"Ops.Gl.ClearColor"};




// **************************************************************
// 
// Ops.Gl.ClearDepth
// 
// **************************************************************

Ops.Gl.ClearDepth = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

const
    render=op.inTrigger('render'),
    trigger=op.outTrigger('trigger'),
    cgl=op.patch.cgl;

render.onTriggered=function()
{
    cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);
    trigger.trigger();
};




};

Ops.Gl.ClearDepth.prototype = new CABLES.Op();
CABLES.OPS["9e8a4b73-4ba7-4c4f-b266-81c5f9db9b7a"]={f:Ops.Gl.ClearDepth,objName:"Ops.Gl.ClearDepth"};




// **************************************************************
// 
// Ops.Gl.ColorMask
// 
// **************************************************************

Ops.Gl.ColorMask = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Execute"),
    inR = op.inValueBool("Red", true),
    inG = op.inValueBool("Green", true),
    inB = op.inValueBool("Blue", true),
    inA = op.inValueBool("Alpha", true),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;

// var old=cgl.gl.getParameter(cgl.gl.COLOR_WRITEMASK);

exec.onTriggered = function ()
{
    cgl.gl.colorMask(inR.get(), inG.get(), inB.get(), inA.get());
    next.trigger();
    op.patch.cgl.gl.colorMask(true, true, true, true);
};


};

Ops.Gl.ColorMask.prototype = new CABLES.Op();
CABLES.OPS["44433419-dcf4-46e6-8f40-d331598029ac"]={f:Ops.Gl.ColorMask,objName:"Ops.Gl.ColorMask"};




// **************************************************************
// 
// Ops.Gl.ColorPick
// 
// **************************************************************

Ops.Gl.ColorPick = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    x = op.inValueFloat("x"),
    y = op.inValueFloat("y"),
    r = op.outNumber("r"),
    g = op.outNumber("g"),
    b = op.outNumber("b"),
    a = op.outNumber("a");

const cgl = op.patch.cgl;
let pixelValues = new Uint8Array(4);
render.onTriggered = doRender;

function doRender()
{
    cgl.gl.readPixels(x.get(), cgl.canvas.height - y.get(), 1, 1, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, pixelValues);
    r.set(pixelValues[0] / 255);
    g.set(pixelValues[1] / 255);
    b.set(pixelValues[2] / 255);
    a.set(pixelValues[3] / 255);
}


};

Ops.Gl.ColorPick.prototype = new CABLES.Op();
CABLES.OPS["12de35ad-3f76-496c-9585-b77a87530de3"]={f:Ops.Gl.ColorPick,objName:"Ops.Gl.ColorPick"};




// **************************************************************
// 
// Ops.Gl.CubeMap.CubeMapFromTextures_v2
// 
// **************************************************************

Ops.Gl.CubeMap.CubeMapFromTextures_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let loadingId = 0;
let skyboxCubemap = null;
const gl = op.patch.cgl.gl;
const cgl = op.patch.cgl;


const inFilenames = [];

const titles = [
    "posx", "negx",
    "posy", "negy",
    "posz", "negz"
];

titles.forEach(function (title)
{ // create inlet ports
    const inFilename = op.inUrl(title, "image");
    inFilename.onChange = loadImagesLater; // assign on change handlers
    inFilenames.push(inFilename);
});

const inFlipY = op.inBool("Flip Y", false);
let outTex = op.outObject("cubemap");
inFlipY.onChange = loadImagesLater;

let timeoutLater = null;

function loadImagesLater()
{
    clearTimeout(timeoutLater);
    timeoutLater = setTimeout(loadImages, 100);
}

function loadImage(src)
{
    return new Promise((resolve, reject) =>
    {
        const image = new Image();
        image.crossOrigin = "";
        image.addEventListener("load", () => { return resolve(image); });
        image.addEventListener("error", (err) => { return reject(err); });
        image.src = src;
    });
}

function loadImages()
{
    op.setUiError("loadingerror", null);
    op.setUiError("loading", "Loading images...", 0);

    skyboxCubemap = null;
    loadingId = cgl.patch.loading.start("cubemap texture", "");

    const images = Promise.all(
        inFilenames.map((inFile) => { return inFile.get(); }) // get file address
            .filter(Boolean) // remove all 0's (empty file adresses) so we only resolve
            .map((filename) => { return loadImage(filename); })) // map to resolver function
        .then((images) =>
        { // wait for all images to be loaded and only then continue
            if (images.length === 6)
            {
                cgl.gl.pixelStorei(
                    cgl.gl.UNPACK_FLIP_Y_WEBGL,
                    inFlipY.get()
                );
                skyboxCubemap = cgl.gl.createTexture(cgl.gl.TEXTURE_CUBE_MAP);
                cgl.gl.bindTexture(cgl.gl.TEXTURE_CUBE_MAP, skyboxCubemap);

                cgl.gl.texParameteri(cgl.gl.TEXTURE_CUBE_MAP, cgl.gl.TEXTURE_WRAP_S, cgl.gl.CLAMP_TO_EDGE);
                cgl.gl.texParameteri(cgl.gl.TEXTURE_CUBE_MAP, cgl.gl.TEXTURE_WRAP_T, cgl.gl.CLAMP_TO_EDGE);
                cgl.gl.texParameteri(cgl.gl.TEXTURE_CUBE_MAP, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.LINEAR_MIPMAP_LINEAR);
                cgl.gl.texParameteri(cgl.gl.TEXTURE_CUBE_MAP, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.LINEAR);

                if (inFlipY.get())
                {
                    const temp = images[2];
                    images[2] = images[3];
                    images[3] = temp;
                }

                images.forEach((img, index) =>
                {
                    cgl.gl.bindTexture(
                        cgl.gl.TEXTURE_CUBE_MAP,
                        skyboxCubemap
                    );

                    cgl.gl.texImage2D(
                        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X + index,
                        0,
                        cgl.gl.RGBA,
                        cgl.gl.RGBA,
                        cgl.gl.UNSIGNED_BYTE,
                        img
                    );
                });

                cgl.gl.generateMipmap(cgl.gl.TEXTURE_CUBE_MAP);

                outTex.set({ "cubemap": skyboxCubemap });

                cgl.gl.bindTexture(cgl.gl.TEXTURE_CUBE_MAP, null);
                cgl.patch.loading.finished(loadingId);

                op.setUiError("loading", null);
            }
        })
        .catch((err) =>
        {
            op.error("error", err);
            op.setUiError("loadingerror", "Could not load textures!", 2);
        });
}


};

Ops.Gl.CubeMap.CubeMapFromTextures_v2.prototype = new CABLES.Op();
CABLES.OPS["44e837c5-ecd8-42cf-9be6-4db2283b9cbf"]={f:Ops.Gl.CubeMap.CubeMapFromTextures_v2,objName:"Ops.Gl.CubeMap.CubeMapFromTextures_v2"};




// **************************************************************
// 
// Ops.Gl.CubeMap.CubeMapMaterial_v2
// 
// **************************************************************

Ops.Gl.CubeMap.CubeMapMaterial_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"cubemap_frag":"{{MODULES_HEAD}}\n\n#define PI 3.14159265358\n#define PI_TWO 2.*PI\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n\nIN vec3 vCoords;\nIN vec3 v_normal;\nIN vec3 v_eyeCoords;\nIN vec3 v_pos;\nIN mat3 normalMatrix;\nIN vec3 texCoords;\nIN vec3 reflectionTexCoords;\nIN vec3 normInterpolated;\nIN vec3 fragPos;\n\nUNI vec3 camPos;\nUNI float inRotation;\nUNI vec3 inColor;\n\n\n#ifdef TEX_FORMAT_CUBEMAP\n    UNI samplerCube skybox;\n    #ifndef WEBGL1\n        #define SAMPLETEX textureLod\n    #endif\n    #ifdef WEBGL1\n        #define SAMPLETEX textureCubeLodEXT\n    #endif\n#endif\n\n#ifndef TEX_FORMAT_CUBEMAP\n    #define TEX_FORMAT_EQUIRECT\n    UNI sampler2D skybox;\n    #ifdef WEBGL1\n        // #extension GL_EXT_shader_texture_lod : enable\n        #ifdef GL_EXT_shader_texture_lod\n            #define textureLod texture2DLodEXT\n        #endif\n        // #define textureLod texture2D\n    #endif\n    #define SAMPLETEX sampleEquirect\n\n#endif\n\n\n\nUNI mat4 modelMatrix;\nUNI mat4 inverseViewMatrix;\nUNI float miplevel;\n\n#ifdef TEX_FORMAT_EQUIRECT\n    const vec2 invAtan = vec2(0.1591, 0.3183);\n    vec4 sampleEquirect(sampler2D tex,vec3 direction,float lod)\n    {\n        #ifndef WEBGL1\n            vec3 newDirection = normalize(direction);\n    \t\tvec2 sampleUV;\n    \t\tsampleUV.x = -1. * (atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.75);\n    \t\tsampleUV.y = asin( clamp(direction.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n        #endif\n\n        #ifdef WEBGL1\n            vec3 newDirection = normalize(direction);\n        \t\tvec2 sampleUV = vec2(atan(newDirection.z, newDirection.x), asin(newDirection.y+1e-6));\n                sampleUV *= vec2(0.1591, 0.3183);\n                sampleUV += 0.5;\n        #endif\n        return textureLod(tex, sampleUV, lod);\n    }\n#endif\n\nvoid main()\n{\n    float rot = inRotation * PI_TWO;\n    float sa = sin(rot);\n    float ca = cos(rot);\n    mat2 matRotation = mat2(ca,sa,-sa,ca);\n\n    {{MODULE_BEGIN_FRAG}}\n\n    vec3 normal = normalize(normInterpolated);\n\n    vec4 col = vec4(1.0,1.0,1.0,1.0);\n    vec3 viewDirection = normalize((camPos - fragPos));\n\n    #ifdef DO_REFLECTION\n        vec3 envMapNormal = normal;\n        vec3 reflectDirection = reflect(-viewDirection, normal);\n\n        if (!gl_FrontFacing) {\n            reflectDirection.yz *= -1.;\n        } else {\n          // reflectDirection.x *= -1.;\n        }\n\n        #ifdef FLIP_X\n            reflectDirection.x *= -1.;\n        #endif\n        #ifdef FLIP_Y\n            reflectDirection.y *= -1.;\n        #endif\n        #ifdef FLIP_Z\n            reflectDirection.z *= -1.;\n        #endif\n\n        reflectDirection.xz *= matRotation;\n        col = SAMPLETEX(skybox, reflectDirection,1. + miplevel*10.0);\n    #endif\n\n    #ifndef DO_REFLECTION\n        if (!gl_FrontFacing) normal.x *= -1.;\n\n        #ifdef FLIP_X\n            normal.x *= -1.;\n        #endif\n        #ifdef FLIP_Y\n            normal.y *= -1.;\n        #endif\n        #ifdef FLIP_Z\n            normal.z *= -1.;\n        #endif\n\n        normal.xz *= matRotation;\n\n        col = SAMPLETEX(skybox, normal, miplevel * 10.0);\n    #endif\n\n    #ifdef COLORIZE\n        col.rgb *= inColor;\n    #endif\n    {{MODULE_COLOR}}\n\n    outColor=col;\n}\n","cubemap_vert":"\n{{MODULES_HEAD}}\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nOUT vec3 v_eyeCoords;\nOUT vec3 v_normal;\nOUT vec3 v_pos;\nOUT mat3 normalMatrix;\nOUT vec3 normInterpolated;\nOUT vec3 norm;\nOUT vec3 texCoords;\nOUT vec3 reflectionTexCoords;\nOUT vec3 fragPos;\nOUT vec4 modelPos;\nIN vec3 vPosition;\nIN vec3 attrVertNormal;\nIN vec3 attrTangent;\nIN vec3 attrBiTangent;\nIN vec2 attrTexCoord;\n\nOUT mat4 mvMatrix;\nOUT vec2 texCoord;\nmat3 transposeMat3(mat3 m)\n{\n    return mat3(m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\nmat3 inverseMat3(mat3 m)\n{\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n        b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n        b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main()\n{\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mMatrix=modelMatrix;\n\n\n    norm=attrVertNormal;\n        texCoord=attrTexCoord;\n    vec3 tangent = attrTangent;\n    vec3 bitangent = attrBiTangent;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat3 mMatrixMat3 = mat3(mMatrix);\n    normalMatrix = transposeMat3(inverseMat3(mMatrixMat3));\n    normInterpolated = vec3(normalMatrix*norm);\n\n\n\n    mvMatrix=viewMatrix*mMatrix;\n    modelPos=mMatrix*pos;\n\n    fragPos = vec3((mMatrix) * pos);\n    gl_Position = projMatrix * mvMatrix * pos;\n\n}",};
// https://jmonkeyengine.github.io/wiki/jme3/advanced/pbr_part3.html
// https://learnopengl.com/PBR/IBL/Diffuse-irradiance

const render = op.inTrigger("render");
const inCubemap = op.inObject("Cubemap");
const inUseReflection = op.inValueBool("Use Reflection", false);
const inMiplevel = op.inValueSlider("Blur", 0.0);
op.setPortGroup("Appearance", [inMiplevel, inUseReflection]);
const inRotation = op.inFloat("Rotation", 0);
const inFlipX = op.inBool("Flip X", false);
const inFlipY = op.inBool("Flip Y", false);
const inFlipZ = op.inBool("Flip Z", false);

op.setPortGroup("Transforms", [inRotation, inFlipX, inFlipY, inFlipZ]);
const inColorize = op.inBool("Colorize", false);
const inR = op.inFloatSlider("R", Math.random());
const inG = op.inFloatSlider("G", Math.random());
const inB = op.inFloatSlider("B", Math.random());
inR.setUiAttribs({ "colorPick": true });

op.setPortGroup("Color", [inColorize, inR, inG, inB]);

inUseReflection.onChange = inCubemap.onChange =
inFlipX.onChange = inFlipY.onChange = inFlipZ.onChange = updateMapping;
inColorize.onChange = function ()
{
    shader.toggleDefine("COLORIZE", inColorize.get());
    inR.setUiAttribs({ "greyout": !inColorize.get() });
    inG.setUiAttribs({ "greyout": !inColorize.get() });
    inB.setUiAttribs({ "greyout": !inColorize.get() });
};
const trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const srcVert = attachments.cubemap_vert;
const srcFrag = attachments.cubemap_frag;

const shader = new CGL.Shader(cgl, "cubemap material");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);

if (cgl.glVersion == 1)
{
    if (!cgl.gl.getExtension("EXT_shader_texture_lod"))
    {
        op.log("no EXT_shader_texture_lod texture extension");
        throw "no EXT_shader_texture_lod texture extension";
    }
    else
    {
        shader.enableExtension("GL_EXT_shader_texture_lod");
        cgl.gl.getExtension("OES_texture_float");
        cgl.gl.getExtension("OES_texture_float_linear");
        cgl.gl.getExtension("OES_texture_half_float");
        cgl.gl.getExtension("OES_texture_half_float_linear");

        shader.enableExtension("GL_OES_standard_derivatives");
        shader.enableExtension("GL_OES_texture_float");
        shader.enableExtension("GL_OES_texture_float_linear");
        shader.enableExtension("GL_OES_texture_half_float");
        shader.enableExtension("GL_OES_texture_half_float_linear");
    }
}

shader.setSource(srcVert, srcFrag);
const inMiplevelUniform = new CGL.Uniform(shader, "f", "miplevel", inMiplevel);
const inRotationUniform = new CGL.Uniform(shader, "f", "inRotation", inRotation);
const inColorUniform = new CGL.Uniform(shader, "3f", "inColor", inR, inG, inB);
const inSkyboxUniform = new CGL.Uniform(shader, "t", "skybox", 0);
render.onTriggered = doRender;
updateMapping();

function doRender()
{
    cgl.pushShader(shader);
    shader.popTextures();
    if (inCubemap.get())
    {
        if (inCubemap.get().cubemap) shader.pushTexture(inSkyboxUniform, inCubemap.get().cubemap, cgl.gl.TEXTURE_CUBE_MAP);
        else shader.pushTexture(inSkyboxUniform, inCubemap.get().tex);

        if (inMiplevel.get() && inCubemap.get().filter != CGL.Texture.FILTER_MIPMAP) op.setUiError("texnomip", "blur needs to be mipmaped texture", 1);
        else op.setUiError("texnomip", null);
    }
    else shader.pushTexture(inSkyboxUniform, CGL.Texture.getTempTexture(cgl).tex);

    trigger.trigger();
    cgl.popShader();
}

function updateMapping()
{
    shader.toggleDefine("FLIP_X", inFlipX.get());
    shader.toggleDefine("FLIP_Y", inFlipY.get());
    shader.toggleDefine("FLIP_Z", inFlipZ.get());
    shader.toggleDefine("DO_REFLECTION", inUseReflection.get());

    if (inCubemap.get() && inCubemap.get().cubemap)
    {
        shader.define("TEX_FORMAT_CUBEMAP");
        shader.removeDefine("TEX_FORMAT_EQUIRECT");
    }
    else
    {
        shader.removeDefine("TEX_FORMAT_CUBEMAP");
        shader.define("TEX_FORMAT_EQUIRECT");
    }
}


};

Ops.Gl.CubeMap.CubeMapMaterial_v2.prototype = new CABLES.Op();
CABLES.OPS["d1fce807-a626-433f-ba61-3f59149fe46e"]={f:Ops.Gl.CubeMap.CubeMapMaterial_v2,objName:"Ops.Gl.CubeMap.CubeMapMaterial_v2"};




// **************************************************************
// 
// Ops.Gl.CubeMap.CubemapToEquirectangularTexture_v2
// 
// **************************************************************

Ops.Gl.CubeMap.CubemapToEquirectangularTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"projection_frag":"IN vec2 texCoord;\nUNI samplerCube cubemap;\n\n#ifdef WEBGL2\n    #define textureCube texture\n#endif\n\nvec4 encodeRGBE8( vec3 rgb )\n{\n    vec4 vEncoded;\n    float maxComponent = max(max(rgb.r, rgb.g), rgb.b );\n    float fExp = ceil( log2(maxComponent) );\n    vEncoded.rgb = rgb / exp2(fExp);\n    vEncoded.a = (fExp + 128.0) / 255.0;\n    return vEncoded;\n}\n\nvoid main() {\n    #ifdef EQUIRECTANGULAR\n\n        float phi=texCoord.s*3.1415*2.;\n        float theta=(-texCoord.t - 0.5)*3.1415;\n        vec3 dir = vec3(cos(phi)*cos(theta),sin(theta),sin(phi)*cos(theta));\n\n        //In this example i use a depthmap with only 1 channel, but the projection should work with a colored cubemap to\n        vec4 col = textureCube(cubemap, dir ).rgba;\n\n        #ifdef RGBE\n            col=encodeRGBE8(col.rgb);\n        #endif\n\n        outColor = col;\n\n    #endif\n    #ifndef EQUIRECTANGULAR\n        vec4 col=vec4(0.);\n        vec2 localST=texCoord;\n        localST.y = 1. - localST.y;\n\n        //Scale Tex coordinates such that each quad has local coordinates from 0,0 to 1,1\n        localST.t = mod(localST.t*3.,1.);\n        localST.s = mod(localST.s*4.,1.);\n\n        //Due to the way my depth-cubemap is rendered, objects to the -x,y,z side is projected to the positive x,y,z side\n        //Inside where tob/bottom is to be drawn?\n        if (texCoord.s*4.> 1. && texCoord.s*4.<2.)\n        {\n            //Bottom (-y) quad\n            if (texCoord.t*3. < 1.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-1.,-localST.t*2.+1.);//Due to the (arbitrary) way I choose as up in my depth-viewmatrix, i her emultiply the latter coordinate with -1\n\n                #ifdef WEBGL2\n                col = textureCube( cubemap, dir );\n                #endif\n\n                #ifdef WEBGL1\n                col = textureCube(cubemap, dir);\n                #endif\n            }\n            //top (+y) quad\n            else if (texCoord.t*3. > 2.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,1.,localST.t*2.-1.);//Get lower y texture, which is projected to the +y part of my cubemap\n                #ifdef WEBGL2\n                col = textureCube( cubemap, dir );\n                #endif\n\n                #ifdef WEBGL1\n                col = textureCube(cubemap, dir);\n                #endif\n            }\n            else//Front (-z) quad\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-localST.t*2.+1.,1.);\n                col = textureCube( cubemap, dir );\n            }\n        }\n        //If not, only these ranges should be drawn\n        else if (texCoord.t*3. > 1. && texCoord.t*3. < 2.)\n        {\n            if (texCoord.x*4. < 1.)//left (-x) quad\n            {\n                vec3 dir=vec3(-1.,-localST.t*2.+1.,localST.s*2.-1.);\n                col = textureCube( cubemap, dir );\n            }\n            else if (texCoord.x*4. < 3.)//right (+x) quad (front was done above)\n            {\n                vec3 dir=vec3(1,-localST.t*2.+1.,-localST.s*2.+1.);\n                col = textureCube(cubemap, dir);\n            }\n            else //back (+z) quad\n            {\n                vec3 dir=vec3(-localST.s*2.+1.,-localST.t*2.+1.,-1.);\n                col = textureCube(cubemap, dir);\n            }\n        }\n        else//Tob/bottom, but outside where we need to put something\n        {\n           discard;//No need to add fancy semi transparant borders for quads, this is just for debugging purpose after all\n        }\n\n        col.a=1.0;\n        #ifdef RGBE\n            col=encodeRGBE8(col.rgb);\n        #endif\n        outColor = col;\n\n\n    #endif\n}","projection_vert":"{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nOUT vec3 worldPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nconst vec2 scale = vec2(0.5, 0.5);\n\nvoid main()\n{\n        texCoord=attrTexCoord;\n        norm=attrVertNormal;\n        vec4 pos=vec4(vPosition,  1.0);\n\n        {{MODULE_VERTEX_POSITION}}\n\n        gl_Position = pos;\n}",};
const
    inTrigger = op.inTrigger("In Trigger"),
    inCubemap = op.inObject("Cubemap"),
    inProj = op.inSwitch("Projection", ["Equirectangular", "Cube unwrap"], "Equirectangular"),
    inFormat = op.inSwitch("Format", ["8bit", "32bit", "RGBE"], "8bit"),
    tfilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"], "linear"),
    inWidth = op.inInt("Width", 1024),
    inHeight = op.inInt("Height", 512),
    outTrigger = op.outTrigger("Out Trigger"),
    outProjection = op.outTexture("Result");

op.setPortGroup("Options", [inWidth, inHeight, inProj, inFormat, tfilter]);
inProj.onChange = updateDefines;

const cgl = op.patch.cgl;
const mesh = CGL.MESHES.getSimpleRect(cgl, "fullscreenRectangle");
const IS_WEBGL_1 = cgl.glVersion == 1;
let sizeChanged = false;
let needsUpdate = true;
let fb = null;
let cgl_filter = CGL.Texture.FILTER_LINEAR;
const projectionShader = new CGL.Shader(cgl, "cubemapProjection");
projectionShader.offScreenPass = true;
const uniformCubemap = new CGL.Uniform(projectionShader, "t", "cubemap", 0);

projectionShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
projectionShader.setSource(attachments.projection_vert, attachments.projection_frag);

tfilter.onChange = createFb;
inFormat.onChange = createFb;
updateDefines();
createFb();

function createFb()
{
    if (fb)fb.dispose();

    cgl_filter = CGL.Texture.FILTER_LINEAR;
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;

    if (IS_WEBGL_1)
    {
        fb = new CGL.Framebuffer(cgl, inWidth.get(), inHeight.get(), {
            "isFloatingPointTexture": inFormat.get() == "32bit",
            "filter": cgl_filter,
            "wrap": CGL.Texture.WRAP_REPEAT
        });
    }
    else
    {
        fb = new CGL.Framebuffer2(cgl, inWidth.get(), inHeight.get(), {
            "isFloatingPointTexture": inFormat.get() == "32bit",
            "filter": cgl_filter,
            "wrap": CGL.Texture.WRAP_REPEAT,
        });
    }
    updateDefines();
    needsUpdate = true;
}

inWidth.onChange = inHeight.onChange = () =>
{
    sizeChanged = true;
};

inCubemap.onChange = () =>
{
    needsUpdate = true;
};

function updateDefines()
{
    projectionShader.toggleDefine("EQUIRECTANGULAR", inProj.get() == "Equirectangular");
    projectionShader.toggleDefine("RGBE", inFormat.get() == "RGBE");
    needsUpdate = true;
}

inTrigger.onTriggered = function ()
{
    if (!inCubemap.get())
    {
        outTrigger.trigger();
        return;
    }

    if (sizeChanged)
    {
        if (fb) fb.setSize(inWidth.get(), inHeight.get());
        sizeChanged = false;
        needsUpdate = true;
    }

    if (needsUpdate)
    {
        projectionShader.popTextures();

        fb.renderStart(cgl);
        projectionShader.pushTexture(uniformCubemap, inCubemap.get().cubemap, cgl.gl.TEXTURE_CUBE_MAP);
        mesh.render(projectionShader);
        fb.renderEnd();

        outProjection.set(CGL.Texture.getEmptyTexture(cgl));
        outProjection.set(fb.getTextureColor());
        needsUpdate = false;
    }
    outTrigger.trigger();
};


};

Ops.Gl.CubeMap.CubemapToEquirectangularTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["5e5fa774-ecb1-44dd-8c47-ce4a592f68f1"]={f:Ops.Gl.CubeMap.CubemapToEquirectangularTexture_v2,objName:"Ops.Gl.CubeMap.CubemapToEquirectangularTexture_v2"};




// **************************************************************
// 
// Ops.Gl.CubeMap.EquirectangularTextureToCubemap
// 
// **************************************************************

Ops.Gl.CubeMap.EquirectangularTextureToCubemap = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"equirect_to_cube_frag":"#define PI 3.14159265358 //97932384626433832795\n#define PI_TWO 2. * PI\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n\nUNI sampler2D equirectangularMap;\nIN vec3 worldPos;\n\nvec4 sampleEquirect(sampler2D tex, vec3 direction) {\nvec2 sampleUV;\nvec3 newDirection = normalize(direction);\n\nsampleUV.x = -1. * (atan( newDirection.z, newDirection.x ) * RECIPROCAL_PI2 + 0.75);\n    sampleUV.y = asin( clamp(newDirection.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n\n    return texture(tex, sampleUV);\n}\n\nvoid main() {\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col = vec4(1.);\n\n    {{MODULE_COLOR}}\n\n     outColor = vec4(1., 0., 0., 1.);\n    vec3 newPos = worldPos;\n    outColor = vec4(sampleEquirect(equirectangularMap, newPos));\n}\n\n","equirect_to_cube_vert":"{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nOUT vec3 worldPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n        texCoord=attrTexCoord;\n        norm=attrVertNormal;\n        vec4 pos=vec4(vPosition,  1.0);\n\n        {{MODULE_VERTEX_POSITION}}\n\n        mat4 mMatrix=modelMatrix;\n        worldPos = vec3(mMatrix * pos);\n        mat4 rotView = mat4(mat3(viewMatrix)); // remove translation from the view matrix\n        vec4 clipPos = projMatrix * rotView * pos;\n\n        gl_Position = clipPos.xyww;\n}",};
const cgl = op.patch.cgl;
const geometry = new CGL.Geometry("unit cube");

const inTrigger = op.inTrigger("Trigger In");
const inTexture = op.inTexture("Equirectangular Map");

const inSize = op.inDropDown("Cubemap Size", [32, 64, 128, 256, 512, 1024, 2048], 512);
const inAdvanced = op.inBool("Advanced", false);
const inTextureFilter = op.inSwitch("Filter", ["Nearest", "Linear"], "Linear");
op.setPortGroup("Cubemap Options", [inSize, inAdvanced, inTextureFilter]);
const outTrigger = op.outTrigger("Trigger Out");
const outCubemap = op.outTexture("Cubemap Projection");

inTextureFilter.setUiAttribs({ "greyout": !inAdvanced.get() });

inAdvanced.onChange = () => { return inTextureFilter.setUiAttribs({ "greyout": !inAdvanced.get() }); };
geometry.vertices = new Float32Array([
    // * NOTE: tex coords not needed for cubemapping
    -1.0, 1.0, -1.0,
    -1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    1.0, 1.0, -1.0,
    -1.0, 1.0, -1.0,

    -1.0, -1.0, 1.0,
    -1.0, -1.0, -1.0,
    -1.0, 1.0, -1.0,
    -1.0, 1.0, -1.0,
    -1.0, 1.0, 1.0,
    -1.0, -1.0, 1.0,

    1.0, -1.0, -1.0,
    1.0, -1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, -1.0,
    1.0, -1.0, -1.0,

    -1.0, -1.0, 1.0,
    -1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, -1.0, 1.0,
    -1.0, -1.0, 1.0,

    -1.0, 1.0, -1.0,
    1.0, 1.0, -1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    -1.0, 1.0, 1.0,
    -1.0, 1.0, -1.0,

    -1.0, -1.0, -1.0,
    -1.0, -1.0, 1.0,
    1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    -1.0, -1.0, 1.0,
    1.0, -1.0, 1.0
]);
const mesh = new CGL.Mesh(cgl, geometry);

// * FRAMEBUFFER *
let fb = null;
const IS_WEBGL_1 = cgl.glVersion == 1;

let cubemap = null;

const equirectToCubeEffect = new CGL.TextureEffect(cgl, { "isFloatingPointTexture": true });
const equiToCubeShader = new CGL.Shader(cgl, "equirectToCube");
const uniformEquirectangularMap = new CGL.Uniform(equiToCubeShader, "t", "equirectangularMap", 0);
equiToCubeShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
equiToCubeShader.setSource(attachments.equirect_to_cube_vert, attachments.equirect_to_cube_frag);
equiToCubeShader.offScreenPass = true;

inTexture.onChange = inSize.onChange = inTextureFilter.onChange = resetCubemap;

let reinitCubemap = true;
function resetCubemap()
{
    reinitCubemap = true;
}

function createCubemap()
{
    if (!inTexture.get())
    {
        return;
    }

    if (cubemap) cubemap.dispose();
    cubemap = null;

    if (fb) fb.delete();

    const textureOptions = {
        "isFloatingPointTexture": true,
        "filter": CGL.Texture.FILTER_LINEAR,
        "wrap": CGL.Texture.WRAP_CLAMP_TO_EDGE,
    };

    if (inAdvanced.get())
    {
        textureOptions.filter = CGL.Texture["FILTER_" + inTextureFilter.get().toUpperCase()];
    }
    if (IS_WEBGL_1)
    {
        fb = new CGL.Framebuffer(cgl, Number(inSize.get()), Number(inSize.get()), textureOptions);
    }
    else
    {
        fb = new CGL.Framebuffer2(cgl, Number(inSize.get()), Number(inSize.get()), textureOptions);
    }

    cubemap = new CGL.CubemapFramebuffer(cgl, Number(inSize.get()), Number(inSize.get()), {});
    reinitCubemap = false;
}

inTrigger.onTriggered = function ()
{
    if (!inTexture.get())
    {
        // outCubemap.set(null);
        outTrigger.trigger();
        return;
    }

    if (reinitCubemap)
    {
        createCubemap();
    }

    equiToCubeShader.popTextures();

    cgl.frameStore.renderOffscreen = true;

    if (inTexture.get() && inTexture.get().tex)
    {
        // fb.renderStart(cgl);

        equiToCubeShader.pushTexture(uniformEquirectangularMap, inTexture.get().tex);

        cgl.pushShader(equiToCubeShader);

        cubemap.renderStart();

        for (let i = 0; i < 6; i += 1)
        {
            cubemap.renderStartCubemapFace(i);
            mesh.render(equiToCubeShader);
            cubemap.renderEndCubemapFace();
        }

        cubemap.renderEnd();

        cgl.popShader();

        // fb.renderEnd();
        cgl.frameStore.renderOffscreen = false;

        outCubemap.set(null);
        outCubemap.set(cubemap.getTextureColor());
    }

    outTrigger.trigger();
};


};

Ops.Gl.CubeMap.EquirectangularTextureToCubemap.prototype = new CABLES.Op();
CABLES.OPS["e4cbae17-10bf-44cd-a4e8-4b16dd849d0c"]={f:Ops.Gl.CubeMap.EquirectangularTextureToCubemap,objName:"Ops.Gl.CubeMap.EquirectangularTextureToCubemap"};




// **************************************************************
// 
// Ops.Gl.CubeMap.RenderToCubemap_v2
// 
// **************************************************************

Ops.Gl.CubeMap.RenderToCubemap_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrigger = op.inTrigger("Render"),
    inFp = op.inBool("32bit float tex", false),
    outTrigger = op.outTrigger("Next"),
    outTex = op.outTexture("cubemap");

const cgl = op.patch.cgl;

const inSize = op.inDropDown("Size", [32, 64, 128, 256, 512, 1024, 2048], 512);
let sizeChanged = true;
inSize.onChange = () => { return sizeChanged = true; };

let fb = null;

inFp.onChange = createFb;

let emptyCubemap = null;

createFb();

function createFb()
{
    if (fb)fb.delete();
    fb = new CGL.CubemapFramebuffer(
        cgl,
        Number(inSize.get()),
        Number(inSize.get()),
        {
            "isFloatingPointTexture": inFp.get()
        });
}

inTrigger.onTriggered = function ()
{
    if (sizeChanged)
    {
        if (fb) fb.setSize(Number(inSize.get()), Number(inSize.get()));
        sizeChanged = false;
    }

    if (fb)
    {
        fb.renderStart();
        for (let i = 0; i < 6; i += 1)
        {
            fb.renderStartCubemapFace(i);
            outTrigger.trigger();
            fb.renderEndCubemapFace();
        }
        fb.renderEnd();
        if (!emptyCubemap)emptyCubemap = CGL.Texture.getEmptyCubemapTexture(cgl);
        outTex.set(emptyCubemap);
        outTex.set(fb.getTextureColor());
    }
    else outTrigger.trigger();
};


};

Ops.Gl.CubeMap.RenderToCubemap_v2.prototype = new CABLES.Op();
CABLES.OPS["2db05f08-ea89-4e56-bba9-8668d963a461"]={f:Ops.Gl.CubeMap.RenderToCubemap_v2,objName:"Ops.Gl.CubeMap.RenderToCubemap_v2"};




// **************************************************************
// 
// Ops.Gl.CubeMap.Skybox
// 
// **************************************************************

Ops.Gl.CubeMap.Skybox = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"skybox_frag":"#define PI 3.14159265358 //97932384626433832795\n#define PI_TWO 2. * PI\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n\nUNI vec2 expGamma;\n\n\n#ifdef TEX_FORMAT_CUBEMAP\n    UNI samplerCube skybox;\n    #ifndef WEBGL1\n        #define SAMPLETEX texture\n    #endif\n    #ifdef WEBGL1\n        #define SAMPLETEX textureCubeLodEXT\n    #endif\n#endif\n\n#ifndef TEX_FORMAT_CUBEMAP\n    #define TEX_FORMAT_EQUIRECT\n    UNI sampler2D skybox;\n    #ifdef WEBGL1\n        #ifdef GL_EXT_shader_texture_lod\n            #define textureLod texture2DLodEXT\n        #endif\n    #endif\n    #define SAMPLETEX sampleEquirect\n\n#endif\n\nIN vec3 worldPos;\n\nvec4 sampleEquirect(sampler2D tex, vec3 direction) {\n    vec2 sampleUV;\n    vec3 newDirection = normalize(direction);\n\n    sampleUV.x = atan( newDirection.z, newDirection.x ) * RECIPROCAL_PI2 + 0.75;\n    sampleUV.y = asin( clamp(newDirection.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n\n    return texture(tex, sampleUV);\n}\n\nhighp vec3 DecodeRGBE8(highp vec4 rgbe)\n{\n    highp vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0-128.0);\n    return vDecoded;\n}\n\nvoid main() {\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col = vec4(1.);\n\n    {{MODULE_COLOR}}\n\n    vec3 newPos = worldPos;\n\n    vec4 finalColor;\n    #ifndef RGBE\n        finalColor = vec4(SAMPLETEX(skybox, newPos));\n    #endif\n\n    #ifdef RGBE\n        finalColor.rgb=DecodeRGBE8(SAMPLETEX(skybox, newPos));\n    #endif\n\n    float gamma=expGamma.x;\n    float exposure=expGamma.y;\n    finalColor.rgb = vec3(1.0) - exp(-finalColor.rgb * exposure);\n\n    finalColor.rgb = pow(finalColor.rgb, vec3(1.0 / gamma));\n    outColor=vec4(finalColor.rgb,1.0);\n\n}\n","skybox_vert":"{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nOUT vec3 worldPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat4 mMatrix=modelMatrix;\n    worldPos = vec3(mMatrix * pos);\n    mat4 rotView = mat4(mat3(viewMatrix)); // remove translation from the view matrix\n    vec4 clipPos = projMatrix * rotView * pos;\n\n    gl_Position = clipPos.xyww;\n}",};
const
    cgl = op.patch.cgl,
    inTrigger = op.inTrigger("Trigger In"),
    inRender = op.inBool("Render", true),
    inTexture = op.inTexture("Skybox"),
    inRot = op.inFloat("Rotate", 0),

    inRGBE = op.inBool("RGBE Format", false),
    inExposure = op.inFloat("Exposure", 1),
    inGamma = op.inFloat("Gamma", 2.2),

    outTrigger = op.outTrigger("Trigger Out");

const geometry = new CGL.Geometry("unit cube");

geometry.vertices = new Float32Array([
    // * NOTE: tex coords not needed for cubemapping
    -1.0, 1.0, -1.0,
    -1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    1.0, 1.0, -1.0,
    -1.0, 1.0, -1.0,

    -1.0, -1.0, 1.0,
    -1.0, -1.0, -1.0,
    -1.0, 1.0, -1.0,
    -1.0, 1.0, -1.0,
    -1.0, 1.0, 1.0,
    -1.0, -1.0, 1.0,

    1.0, -1.0, -1.0,
    1.0, -1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, -1.0,
    1.0, -1.0, -1.0,

    -1.0, -1.0, 1.0,
    -1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, -1.0, 1.0,
    -1.0, -1.0, 1.0,

    -1.0, 1.0, -1.0,
    1.0, 1.0, -1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    -1.0, 1.0, 1.0,
    -1.0, 1.0, -1.0,

    -1.0, -1.0, -1.0,
    -1.0, -1.0, 1.0,
    1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    -1.0, -1.0, 1.0,
    1.0, -1.0, 1.0
]);

const mesh = new CGL.Mesh(cgl, geometry);
const skyboxShader = new CGL.Shader(cgl, "skybox");
const uniformSkybox = new CGL.Uniform(skyboxShader, "t", "skybox", 0);
const uniExposure = new CGL.Uniform(skyboxShader, "2f", "expGamma", inExposure, inGamma);

skyboxShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
skyboxShader.setSource(attachments.skybox_vert, attachments.skybox_frag);
skyboxShader.offScreenPass = true;

inRGBE.onChange = () =>
{
    skyboxShader.toggleDefine("RGBE", inRGBE.get());
};

inTexture.onChange = () =>
{
    const b = inTexture.get() && inTexture.get().cubemap;

    skyboxShader.toggleDefine("TEX_FORMAT_CUBEMAP", b);
    skyboxShader.toggleDefine("TEX_FORMAT_EQUIRECT", !b);
};

inTrigger.onTriggered = () =>
{
    if (!inTexture.get() || !inRender.get())
    {
        outTrigger.trigger();
        return;
    }

    skyboxShader.popTextures();

    cgl.pushModelMatrix();

    if (!inTexture.get().cubemap && inTexture.get().filter !== CGL.Texture.FILTER_LINEAR)
        op.setUiError("linearFilter", "If there is a seam in the skybox, try changing the texture filter to linear!", 0);
    else
        op.setUiError("linearFilter", null);

    mat4.rotateY(cgl.mMatrix, cgl.mMatrix, inRot.get() * CGL.DEG2RAD);

    if (inTexture.get().tex)
        skyboxShader.pushTexture(uniformSkybox, inTexture.get().tex);
    else if (inTexture.get().cubemap)
        skyboxShader.pushTexture(uniformSkybox, inTexture.get().cubemap, cgl.gl.TEXTURE_CUBE_MAP);

    mesh.render(skyboxShader);

    cgl.popModelMatrix();
    cgl.popDepthFunc();

    outTrigger.trigger();
};


};

Ops.Gl.CubeMap.Skybox.prototype = new CABLES.Op();
CABLES.OPS["97ce1d35-bd7a-43cb-a2bf-5b7e37fb8925"]={f:Ops.Gl.CubeMap.Skybox,objName:"Ops.Gl.CubeMap.Skybox"};




// **************************************************************
// 
// Ops.Gl.DepthTest
// 
// **************************************************************

Ops.Gl.DepthTest = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// todo:rename to depthtest

const render = op.inTrigger("Render");
const enable = op.inValueBool("Enable depth testing", true);
const meth = op.inValueSelect("Depth Test Method", ["never", "always", "less", "less or equal", "greater", "greater or equal", "equal", "not equal"], "less or equal");
const write = op.inValueBool("Write to depth buffer", true);
const trigger = op.outTrigger("Next");

const cgl = op.patch.cgl;
let compareMethod = cgl.gl.LEQUAL;

meth.onChange = updateFunc;

function updateFunc()
{
    if (meth.get() == "never") compareMethod = cgl.gl.NEVER;
    else if (meth.get() == "always") compareMethod = cgl.gl.ALWAYS;
    else if (meth.get() == "less") compareMethod = cgl.gl.LESS;
    else if (meth.get() == "less or equal") compareMethod = cgl.gl.LEQUAL;
    else if (meth.get() == "greater") compareMethod = cgl.gl.GREATER;
    else if (meth.get() == "greater or equal") compareMethod = cgl.gl.GEQUAL;
    else if (meth.get() == "equal") compareMethod = cgl.gl.EQUAL;
    else if (meth.get() == "not equal") compareMethod = cgl.gl.NOTEQUAL;
}

render.onTriggered = function ()
{
    cgl.pushDepthTest(enable.get());
    cgl.pushDepthWrite(write.get());
    cgl.pushDepthFunc(compareMethod);

    trigger.trigger();

    cgl.popDepthTest();
    cgl.popDepthWrite();
    cgl.popDepthFunc();
};


};

Ops.Gl.DepthTest.prototype = new CABLES.Op();
CABLES.OPS["3996ed5d-8143-4bec-9cfd-c1b193a295af"]={f:Ops.Gl.DepthTest,objName:"Ops.Gl.DepthTest"};




// **************************************************************
// 
// Ops.Gl.DirectionalTranslate
// 
// **************************************************************

Ops.Gl.DirectionalTranslate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Exec"),
    inMatrix = op.inArray("Center Model Matrix"),
    inAmount = op.inValue("Amount"),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;

let va = vec3.create();
let vb = vec3.create();
let diff = vec3.create();
let mm = mat3.create();

exec.onTriggered = function ()
{
    let matbefore = inMatrix.get();
    if (!matbefore) return;

    mat4.getTranslation(va, matbefore);
    mat4.getTranslation(vb, cgl.modelMatrix());

    mat3.fromMat4(mm, cgl.modelMatrix());
    mat3.invert(mm, mm);

    vec3.sub(diff, vb, va);
    vec3.normalize(diff, diff);
    vec3.transformMat3(diff, diff, mm);
    vec3.normalize(diff, diff);

    diff[0] *= inAmount.get();
    diff[1] *= inAmount.get();
    diff[2] *= inAmount.get();

    cgl.pushModelMatrix();
    mat4.translate(cgl.mMatrix, cgl.mMatrix, diff);
    next.trigger();
    cgl.popModelMatrix();
};


};

Ops.Gl.DirectionalTranslate.prototype = new CABLES.Op();
CABLES.OPS["d0f3dbca-7457-44b5-987a-9d49e5310d98"]={f:Ops.Gl.DirectionalTranslate,objName:"Ops.Gl.DirectionalTranslate"};




// **************************************************************
// 
// Ops.Gl.DownloadTexture_v2
// 
// **************************************************************

Ops.Gl.DownloadTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTex = op.inTexture("Texture"),
    start = op.inTriggerButton("Download"),
    fileName = op.inString("Filename", "screenshot"),
    outFinished = op.outBoolNum("Finished");

const gl = op.patch.cgl.gl;
let fb = null;

start.onTriggered = function ()
{
    if (!inTex.get() || !inTex.get().tex) return;
    outFinished.set(false);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    const width = inTex.get().width;
    const height = inTex.get().height;

    if (inTex.get().textureType == CGL.Texture.TYPE_FLOAT) op.setUiError("fptex", "Texture is more than 8 bit, not possible to create files with high precision");
    else op.setUiError("fptex", null);

    if (!fb)fb = gl.createFramebuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, inTex.get().tex, 0);

    const canRead = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    if (!canRead)
    {
        outFinished.set(true);
        op.logError("cannot read texture!");
        return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    const data = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    // Create a 2D canvas to store the result
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");

    // Copy the pixels to a 2D canvas
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);

    const data2 = imageData.data;

    // flip image
    Array.from({ "length": height }, (val, i) => { return data2.slice(i * width * 4, (i + 1) * width * 4); })
        .forEach((val, i) => { return data2.set(val, (height - i - 1) * width * 4); });

    context.putImageData(imageData, 0, 0);

    dataURIToBlob(canvas.toDataURL(),
        function (blob)
        {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;

            if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream)
            {
                const reader = new FileReader();
                // var out = new Blob([byte], {type: "application/pdf"});
                reader.onload = function (e)
                {
                    window.location.href = reader.result;
                //   window.open(reader.result);
                };
                reader.readAsDataURL(blob);
            }
            else
            {
                const anchor = document.createElement("a");
                anchor.download = fileName.get() + ".png";
                // anchor.target='_blank';
                anchor.href = URL.createObjectURL(blob);
                document.body.appendChild(anchor);
                anchor.click();
            }
            outFinished.set(true);
        });
};

function dataURIToBlob(dataURI, callback)
{
    const binStr = atob(dataURI.split(",")[1]),
        len = binStr.length,
        arr = new Uint8Array(len);
    for (let i = 0; i < len; i++) arr[i] = binStr.charCodeAt(i);
    callback(new Blob([arr], { "type": "image/png" }));
}


};

Ops.Gl.DownloadTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["00d2a6ea-5843-43d0-9428-dbc47c112e6e"]={f:Ops.Gl.DownloadTexture_v2,objName:"Ops.Gl.DownloadTexture_v2"};




// **************************************************************
// 
// Ops.Gl.DrawTextureMapping
// 
// **************************************************************

Ops.Gl.DrawTextureMapping = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    inGeom = op.inObject("Geometry", null, "geometry"),
    numPoints = op.inValue("Num Points"),
    next = op.outTrigger("Next");

let cgl = op.patch.cgl;

let mesh = null;
let attr = null;
let points = [];

inGeom.onChange = function ()
{
    let geom = inGeom.get();

    if (!geom || !geom.verticesIndices) return;

    points.length = 0;
    let newgeom = new CGL.Geometry("texturemapping");

    for (let i = 0; i < geom.verticesIndices.length; i += 3)
    {
        var index;

        index = geom.verticesIndices[i + 0];
        points.push(geom.texCoords[index * 2 + 0]);
        points.push(geom.texCoords[index * 2 + 1]);
        points.push(0);

        index = geom.verticesIndices[i + 1];
        points.push(geom.texCoords[index * 2 + 0]);
        points.push(geom.texCoords[index * 2 + 1]);
        points.push(0);

        index = geom.verticesIndices[i + 1];
        points.push(geom.texCoords[index * 2 + 0]);
        points.push(geom.texCoords[index * 2 + 1]);
        points.push(0);

        index = geom.verticesIndices[i + 2];
        points.push(geom.texCoords[index * 2 + 0]);
        points.push(geom.texCoords[index * 2 + 1]);
        points.push(0);

        index = geom.verticesIndices[i + 2];
        points.push(geom.texCoords[index * 2 + 0]);
        points.push(geom.texCoords[index * 2 + 1]);
        points.push(0);

        index = geom.verticesIndices[i + 0];
        points.push(geom.texCoords[index * 2 + 0]);
        points.push(geom.texCoords[index * 2 + 1]);
        points.push(0);
    }

    newgeom.vertices = points;

    // if(!mesh)
    mesh = new CGL.Mesh(cgl, newgeom);

    // else mesh.setGeom(geom );
    // if(!(points instanceof Float32Array))
    // {
    //     if(points.length!=buff.length)
    //     {
    //         buff=new Float32Array(points.length);
    //         buff.set(points);
    //     }
    //     else
    //     {
    //         buff.set(points);
    //     }
    // }
    // else
    // {
    //     buff=points;
    // }
    // attr=mesh.setAttribute(CGL.SHADERVAR_VERTEX_POSITION,buff,3);
};

render.onTriggered = function ()
{
    if (points.length === 0) return;
    if (!mesh) return;
    if (op.instanced(render)) return;

    let shader = cgl.getShader();
    if (!shader) return;

    let oldPrim = shader.glPrimitive;

    shader.glPrimitive = cgl.gl.LINES;

    // if(numPoints.get()<=0)attr.numItems=buff.length/3;
    // else attr.numItems=Math.min(numPoints.get(),buff.length/3);

    mesh.render(shader);

    shader.glPrimitive = oldPrim;

    next.trigger();
};


};

Ops.Gl.DrawTextureMapping.prototype = new CABLES.Op();
CABLES.OPS["f61e47de-9156-4243-9a83-79002aeaf7be"]={f:Ops.Gl.DrawTextureMapping,objName:"Ops.Gl.DrawTextureMapping"};




// **************************************************************
// 
// Ops.Gl.FaceCulling_v2
// 
// **************************************************************

Ops.Gl.FaceCulling_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    STR_FRONT = "Front Sides",
    STR_BACK = "Back Sides",
    STR_BOTH = "All",
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    facing = op.inSwitch("Discard", [STR_BACK, STR_FRONT, STR_BOTH], STR_BACK),
    enable = op.inValueBool("Active", true),
    cgl = op.patch.cgl;

op.setPortGroup("Face Fulling", [enable, facing]);
let whichFace = cgl.gl.BACK;

render.onTriggered = function ()
{
    cgl.pushCullFace(enable.get());
    cgl.pushCullFaceFacing(whichFace);

    trigger.trigger();

    cgl.popCullFace();
    cgl.popCullFaceFacing();
};

facing.onChange = function ()
{
    whichFace = cgl.gl.BACK;
    if (facing.get() == STR_FRONT) whichFace = cgl.gl.FRONT;
    else if (facing.get() == STR_BOTH) whichFace = cgl.gl.FRONT_AND_BACK;
};


};

Ops.Gl.FaceCulling_v2.prototype = new CABLES.Op();
CABLES.OPS["9dfd0ee4-81e1-438c-8a99-4894c64f41cb"]={f:Ops.Gl.FaceCulling_v2,objName:"Ops.Gl.FaceCulling_v2"};




// **************************************************************
// 
// Ops.Gl.FontMSDF_v2
// 
// **************************************************************

Ops.Gl.FontMSDF_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUUID = op.inString("Font Name", CABLES.uuid()),
    urlData = op.inUrl("Font Data"),
    urlTex = op.inUrl("Font Image"),
    urlTex1 = op.inUrl("Font Image 1"),
    urlTex2 = op.inUrl("Font Image 2"),
    urlTex3 = op.inUrl("Font Image 3"),
    outLoaded = op.outBool("Loaded"),
    outNumChars = op.outNumber("Total Chars"),
    outChars = op.outString("Chars"),
    cgl = op.patch.cgl;

let
    loadedData = false,
    loadedTex = false,
    loadingId = 0;

inUUID.onChange =
urlData.onChange =
    urlTex.onChange =
    urlTex1.onChange =
    urlTex2.onChange =
    urlTex3.onChange = load;

const textures = [];

function updateLoaded()
{
    const l = loadedData && loadedTex;
    if (!outLoaded.get() && l) op.patch.emitEvent("FontLoadedMSDF");
    outLoaded.set(l);
}

op.onFileChanged = function (fn)
{
    if (
        (urlTex.get() && urlTex.get().indexOf(fn) > -1) ||
        (urlTex1.get() && urlTex1.get().indexOf(fn) > -1) ||
        (urlTex2.get() && urlTex2.get().indexOf(fn) > -1) ||
        (urlTex3.get() && urlTex3.get().indexOf(fn) > -1))
    {
        load();
    }
};

let oldUUID = "";

function load()
{
    if (!urlData.get() || !urlTex.get()) return;

    textures.length = 0;
    op.patch.deleteVar("font_data_" + oldUUID);
    op.patch.deleteVar("font_tex_" + oldUUID);
    oldUUID = inUUID.get();

    const varNameData = "font_data_" + inUUID.get();
    const varNameTex = "font_tex_" + inUUID.get();

    op.patch.setVarValue(varNameData, {});
    op.patch.setVarValue(varNameTex, textures);

    op.patch.getVar(varNameData).type = "fontData";
    op.patch.getVar(varNameTex).type = "fontTexture";

    loadedData = loadedTex = false;
    updateLoaded();

    op.patch.loading.finished(loadingId);
    loadingId = op.patch.loading.start("jsonFile", "" + urlData.get());

    op.setUiError("invaliddata", null);
    op.setUiError("jsonerr", null);
    op.setUiError("texurlerror", null);

    const urlDatastr = op.patch.getFilePath(String(urlData.get()));

    // load font data json
    cgl.patch.loading.addAssetLoadingTask(() =>
    {
        CABLES.ajax(urlDatastr, (err, _data, xhr) =>
        {
            if (err)
            {
                op.logError(err);
                return;
            }
            try
            {
                let data = _data;
                if (typeof data === "string") data = JSON.parse(_data);
                if (!data.chars || !data.info || !data.info.face)
                {
                    op.setUiError("invaliddata", "data file is invalid");
                    return;
                }

                outNumChars.set(data.chars.length);
                let allChars = "";
                for (let i = 0; i < data.chars.length; i++)allChars += data.chars[i].char;
                outChars.set(allChars);

                op.setUiAttrib({ "extendTitle": data.info.face });
                op.patch.setVarValue(varNameData, null);
                op.patch.setVarValue(varNameData,
                    {
                        "name": CABLES.basename(urlData.get()),
                        "basename": inUUID.get(),
                        "data": data
                    });

                op.patch.loading.finished(loadingId);
                loadedData = true;
                updateLoaded();
            }
            catch (e)
            {
                op.patch.setVarValue(varNameData, null);
                op.patch.setVarValue(varNameTex, null);

                op.logError(e);
                op.setUiError("jsonerr", "Problem while loading json:<br/>" + e);
                op.patch.loading.finished(loadingId);
                updateLoaded();
                outLoaded.set(false);
            }
        });
    });

    // load font texture

    for (let i = 0; i < 4; i++)
    {
        const num = i;

        let texPort = urlTex;
        if (i == 1)texPort = urlTex1;
        if (i == 2)texPort = urlTex2;
        if (i == 3)texPort = urlTex3;

        if (!texPort.get()) continue;

        const loadingIdTex = cgl.patch.loading.start("textureOp", texPort.get());
        const urlTexstr = op.patch.getFilePath(String(texPort.get()));

        CGL.Texture.load(cgl, urlTexstr,
            function (err, tex)
            {
                if (err)
                {
                    op.setUiError("texurlerror", "could not load texture");
                    cgl.patch.loading.finished(loadingIdTex);
                    loadedTex = false;
                    return;
                }
                textures[num] = tex;
                op.patch.setVarValue(varNameTex, null);
                op.patch.setVarValue(varNameTex, textures);

                loadedTex = true;
                cgl.patch.loading.finished(loadingIdTex);
                updateLoaded();
            }, {
                "filter": CGL.Texture.FILTER_LINEAR,
                "flip": false
            });
    }
}


};

Ops.Gl.FontMSDF_v2.prototype = new CABLES.Op();
CABLES.OPS["6cbd5d67-25d5-4936-a2ad-3ee8ed478570"]={f:Ops.Gl.FontMSDF_v2,objName:"Ops.Gl.FontMSDF_v2"};




// **************************************************************
// 
// Ops.Gl.ForceCanvasSize
// 
// **************************************************************

Ops.Gl.ForceCanvasSize = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrigger = op.inTrigger("Trigger"),
    inActive = op.inBool("Active", true),
    inWhat = op.inSwitch("Force", ["Resolution", "Aspect Ratio"], "Resolution"),
    inCenter = op.inBool("Center In Parent", true),
    inScaleFit = op.inBool("Scale to fit Parent", false),
    inWidth = op.inInt("Set Width", 300),
    inHeight = op.inInt("Set Height", 200),
    inPresets = op.inDropDown("Aspect Ratio", ["Custom", "21:9", "2:1", "16:9", "16:10", "4:3", "1:1", "9:16", "1:2", "iPhoneXr Vert"], "16:9"),
    inRatio = op.inFloat("Ratio", 0),
    inStretch = op.inDropDown("Fill Parent", ["Auto", "Width", "Height", "Both"], "Auto"),
    next = op.outTrigger("Next"),
    outWidth = op.outNumber("Width"),
    outHeight = op.outNumber("Height"),
    outMarginLeft = op.outNumber("Margin Left"),
    outMarginTop = op.outNumber("Margin Top");

op.setPortGroup("Size", [inWidth, inHeight]);
op.setPortGroup("Proportions", [inRatio, inStretch, inPresets]);

let align = 0;
const ALIGN_NONE = 0;
const ALIGN_WIDTH = 1;
const ALIGN_HEIGHT = 2;
const ALIGN_BOTH = 3;
const ALIGN_AUTO = 4;

inStretch.onChange = updateUi;
inWhat.onChange = updateMethod;
inCenter.onChange =
    inTrigger.onLinkChanged = removeStyles;

inPresets.onChange = updateRatioPreset;

const cgl = op.patch.cgl;

if (window.getComputedStyle(cgl.canvas).position === "absolute")
{
    cgl.canvas.style.position = "initial";
    op.warn("[cables forceCanvasSize] - canvas was positioned absolute, not compatible with Ops.Gl.ForceCanvasSize");
}

updateUi();

function updateMethod()
{
    if (inWhat.get() == "Aspect Ratio")
    {
        inRatio.set(100);
        updateRatioPreset();
    }
    updateUi();
}

function updateRatioPreset()
{
    const pr = inPresets.get();
    if (pr == "Custom") return;
    else if (pr == "16:9")inRatio.set(16 / 9);
    else if (pr == "4:3")inRatio.set(4 / 3);
    else if (pr == "16:10")inRatio.set(16 / 10);
    else if (pr == "21:9")inRatio.set(21 / 9);
    else if (pr == "2:1")inRatio.set(2);
    else if (pr == "1:1")inRatio.set(1);
    else if (pr == "9:16")inRatio.set(9 / 16);
    else if (pr == "1:2")inRatio.set(0.5);
    else if (pr == "iPhoneXr Vert")inRatio.set(9 / 19.5);
}

inRatio.onChange = () =>
{
    removeStyles();
};

inActive.onChange = function ()
{
    if (!inActive.get())removeStyles();
};

function updateUi()
{
    const forceRes = inWhat.get() == "Resolution";
    inWidth.setUiAttribs({ "greyout": !forceRes });
    inHeight.setUiAttribs({ "greyout": !forceRes });

    inPresets.setUiAttribs({ "greyout": forceRes });
    inStretch.setUiAttribs({ "greyout": forceRes });
    inRatio.setUiAttribs({ "greyout": forceRes });

    align = 0;

    if (!forceRes)
    {
        const strAlign = inStretch.get();
        if (strAlign == "Width")align = ALIGN_WIDTH;
        else if (strAlign == "Height")align = ALIGN_HEIGHT;
        else if (strAlign == "Both")align = ALIGN_BOTH;
        else if (strAlign == "Auto")align = ALIGN_AUTO;
    }
}

function removeStyles()
{
    cgl.canvas.style["margin-top"] = "";
    cgl.canvas.style["margin-left"] = "";

    outMarginLeft.set(0);
    outMarginTop.set(0);

    const rect = cgl.canvas.parentNode.getBoundingClientRect();
    cgl.setSize(rect.width, rect.height);
}

inTrigger.onTriggered = function ()
{
    if (!inActive.get()) return next.trigger();

    let w = inWidth.get();
    let h = inHeight.get();

    let clientRect = cgl.canvas.parentNode.getBoundingClientRect();
    if (clientRect.height == 0)
    {
        cgl.canvas.parentNode.style.height = "100%";
        clientRect = cgl.canvas.parentNode.getBoundingClientRect();
    }
    if (clientRect.width == 0)
    {
        cgl.canvas.parentNode.style.width = "100%";
        clientRect = cgl.canvas.parentNode.getBoundingClientRect();
    }

    if (align == ALIGN_WIDTH)
    {
        w = clientRect.width;
        h = w * 1 / inRatio.get();
    }
    else if (align == ALIGN_HEIGHT)
    {
        h = clientRect.height;
        w = h * inRatio.get();
    }
    else if (align == ALIGN_AUTO)
    {
        const rect = clientRect;

        h = rect.height;
        w = h * inRatio.get();

        if (w > rect.width)
        {
            w = rect.width;
            h = w * 1 / inRatio.get();
        }
    }
    else if (align == ALIGN_BOTH)
    {
        const rect = clientRect;
        h = rect.height;
        w = h * inRatio.get();

        if (w < rect.width)
        {
            w = rect.width;
            h = w * 1 / inRatio.get();
        }
    }

    w = Math.ceil(w);
    h = Math.ceil(h);

    if (inCenter.get())
    {
        const rect = clientRect;

        const t = (rect.height - h) / 2;
        const l = (rect.width - w) / 2;

        outMarginLeft.set(l);
        outMarginTop.set(t);

        cgl.canvas.style["margin-top"] = t + "px";
        cgl.canvas.style["margin-left"] = l + "px";
    }
    else
    {
        cgl.canvas.style["margin-top"] = "0";
        cgl.canvas.style["margin-left"] = "0";

        outMarginLeft.set(0);
        outMarginTop.set(0);
    }

    if (inScaleFit.get())
    {
        const rect = clientRect;
        const scX = rect.width / inWidth.get();
        const scY = rect.height / inHeight.get();
        cgl.canvas.style.transform = "scale(" + Math.min(scX, scY) + ")";
    }
    else
    {
        cgl.canvas.style.transform = "scale(1)";
    }

    if (cgl.canvas.width / cgl.pixelDensity != w || cgl.canvas.height / cgl.pixelDensity != h)
    {
        outWidth.set(w);
        outHeight.set(h);
        cgl.setSize(w, h);
    }
    // else
    next.trigger();
};


};

Ops.Gl.ForceCanvasSize.prototype = new CABLES.Op();
CABLES.OPS["a8b3380e-cd4a-4000-9ee9-1c65a11027dd"]={f:Ops.Gl.ForceCanvasSize,objName:"Ops.Gl.ForceCanvasSize"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfAnimationArray
// 
// **************************************************************

Ops.Gl.GLTF.GltfAnimationArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Render"),
    inNodeName = op.inString("Node Name"),
    inNum = op.inInt("Steps", 100),
    inFullAnim = op.inBool("Full Animation", true),
    inAnimStart = op.inFloat("Start", 0),
    inAnimLen = op.inFloat("Length", 10),
    next = op.outTrigger("Next"),
    outFound = op.outBool("Found"),
    outArr = op.outArray("Positions");

const cgl = op.patch.cgl;

op.setPortGroup("Timing", [inFullAnim, inAnimStart, inAnimLen]);
let node = null;

inFullAnim.onChange = function ()
{
    inAnimStart.setUiAttribs({ "greyout": inFullAnim.get() });
    inAnimLen.setUiAttribs({ "greyout": inFullAnim.get() });
};

inNodeName.onChange = function ()
{
    outArr.set(null);
    node = null;
    outFound.set(false);
};

inExec.onTriggered = function ()
{
    if (!cgl.frameStore.currentScene) return;

    if (!node)
    {
        const name = inNodeName.get();

        if (!cgl.frameStore || !cgl.frameStore.currentScene || !cgl.frameStore.currentScene.nodes)
        {
            return;
        }

        for (var i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
        {
            if (cgl.frameStore.currentScene.nodes[i].name == name)
            {
                node = cgl.frameStore.currentScene.nodes[i];
                outFound.set(true);
            }
        }
    }

    // var idx=inNode.get();
    // idx=Math.max(0,idx);
    // idx=Math.min(cgl.frameStore.currentScene.nodes.length-1,idx);

    const n = node;
    const arr = [];

    if (n && n._animTrans && n._animTrans.length)
    {
        outArr.set(null);

        const num = inNum.get();
        let len = n._animTrans[0].getLength();
        let add = 0;

        if (!inFullAnim.get())
        {
            len = inAnimLen.get();
            add = inAnimStart.get();
        }

        for (var i = 0; i < num; i++)
        {
            const t = len * i / num + add;

            arr[i * 3 + 0] = n._animTrans[0].getValue(t);
            arr[i * 3 + 1] = n._animTrans[1].getValue(t);
            arr[i * 3 + 2] = n._animTrans[2].getValue(t);
        }

        outArr.set(arr);
    }

    next.trigger();
};


};

Ops.Gl.GLTF.GltfAnimationArray.prototype = new CABLES.Op();
CABLES.OPS["568ce7cd-a938-4498-9109-482564757a0e"]={f:Ops.Gl.GLTF.GltfAnimationArray,objName:"Ops.Gl.GLTF.GltfAnimationArray"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfCameraViewMatrix
// 
// **************************************************************

Ops.Gl.GLTF.GltfCameraViewMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Update"),
    inName = op.inString("Node Name", "default"),
    outArr = op.outArray("Matrix"),
    outFound = op.outBool("Found");

let camNode = null;

inExec.onTriggered = () =>
{
    if (!camNode) findCam();

    if (camNode)
    {
        camNode.start(0);
        camNode.end();
        outArr.set(camNode.vMat);
    }
};

inName.onChange = () => { camNode = null; };

function findCam()
{
    const gltf = op.patch.cgl.frameStore.currentScene;

    if (gltf)
    {
        gltf.cameras = gltf.cameras || [];
        for (let i = 0; i < gltf.cameras.length; i++)
        {
            if (gltf.cameras[i].name == inName.get())
            {
                camNode = gltf.cameras[i];
                outFound.set(true);
                return;
            }
        }
    }

    outFound.set(false);
}


};

Ops.Gl.GLTF.GltfCameraViewMatrix.prototype = new CABLES.Op();
CABLES.OPS["ab3c43f7-3d73-4f46-8034-454e9c4d51c5"]={f:Ops.Gl.GLTF.GltfCameraViewMatrix,objName:"Ops.Gl.GLTF.GltfCameraViewMatrix"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfDracoCompression
// 
// **************************************************************

Ops.Gl.GLTF.GltfDracoCompression = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
class DracoDecoderClass
{
    constructor()
    {
        this.workerLimit = 4;
        this.workerPool = [];
        this.workerNextTaskID = 1;
        this.workerSourceURL = "";

        this.config = {
            "wasm": Uint8Array.from(atob(DracoDecoderWASM), (c) => { return c.charCodeAt(0); }),
            "wrapper": DracoWASMWrapperCode,
            "decoderSettings": {},
        };

        const dracoWorker = this._DracoWorker.toString();
        const workerCode = dracoWorker.substring(dracoWorker.indexOf("{") + 1, dracoWorker.lastIndexOf("}"));

        const jsContent = this.config.wrapper;
        const body = [
            "/* draco decoder */",
            jsContent,
            "",
            "/* worker */",
            workerCode
        ].join("\n");

        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    }

    _getWorker(taskID, taskCost)
    {
        if (this.workerPool.length < this.workerLimit)
        {
            const worker = new Worker(this.workerSourceURL);
            worker._callbacks = {};
            worker._taskCosts = {};
            worker._taskLoad = 0;
            worker.postMessage({ "type": "init", "decoderConfig": this.config });
            worker.onmessage = (e) =>
            {
                const message = e.data;

                switch (message.type)
                {
                case "done":
                    worker._callbacks[message.taskID].finishedCallback(message.geometry);
                    break;

                case "error":
                    worker._callbacks[message.taskID].errorCallback(message);
                    break;

                default:
                    op.error("THREE.DRACOLoader: Unexpected message, \"" + message.type + "\"");
                }
                this._releaseTask(worker, message.taskID);
            };
            this.workerPool.push(worker);
        }
        else
        {
            this.workerPool.sort(function (a, b)
            {
                return a._taskLoad > b._taskLoad ? -1 : 1;
            });
        }

        const worker = this.workerPool[this.workerPool.length - 1];
        worker._taskCosts[taskID] = taskCost;
        worker._taskLoad += taskCost;
        return worker;
    }

    decodeGeometry(buffer, finishedCallback, errorCallback = null)
    {
        const taskID = this.workerNextTaskID++;
        const taskCost = buffer.byteLength;

        const worker = this._getWorker(taskID, taskCost);
        worker._callbacks[taskID] = { finishedCallback, errorCallback };
        worker.postMessage({ "type": "decode", "taskID": taskID, buffer }, [buffer]);
    }

    _releaseTask(worker, taskID)
    {
        worker._taskLoad -= worker._taskCosts[taskID];
        delete worker._callbacks[taskID];
        delete worker._taskCosts[taskID];
    }

    _DracoWorker()
    {
        let pendingDecoder;

        onmessage = function (e)
        {
            const message = e.data;
            switch (message.type)
            {
            case "init":
                const decoderConfig = message.decoderConfig;
                const moduleConfig = decoderConfig.decoderSettings;
                pendingDecoder = new Promise(function (resolve)
                {
                    moduleConfig.onModuleLoaded = function (draco)
                    {
                        // Module is Promise-like. Wrap before resolving to avoid loop.
                        resolve({ "draco": draco });
                    };
                    moduleConfig.wasmBinary = decoderConfig.wasm;
                    DracoDecoderModule(moduleConfig); // eslint-disable-line no-undef
                });
                break;
            case "decode":
                pendingDecoder.then((module) =>
                {
                    const draco = module.draco;

                    const f = new draco.Decoder();
                    const dataBuff = new Int8Array(message.buffer);

                    const geometryType = f.GetEncodedGeometryType(dataBuff);
                    const buffer = new draco.DecoderBuffer();
                    buffer.Init(dataBuff, dataBuff.byteLength);

                    let outputGeometry = new draco.Mesh();
                    const status = f.DecodeBufferToMesh(buffer, outputGeometry);
                    const attribute = f.GetAttributeByUniqueId(outputGeometry, 1);
                    const geometry = dracoAttributes(draco, f, outputGeometry, geometryType, name);

                    this.postMessage({ "type": "done", "taskID": message.taskID, "geometry": geometry });

                    draco.destroy(f);
                    draco.destroy(buffer);
                });
                break;
            }
        };

        let dracoAttributes = function (draco, decoder, dracoGeometry, geometryType, name)
        {
            const attributeIDs = {
                "position": draco.POSITION,
                "normal": draco.NORMAL,
                "color": draco.COLOR,
                "uv": draco.TEX_COORD,
                "joints": draco.GENERIC,
                "weights": draco.GENERIC,
            };
            const attributeTypes = {
                "position": "Float32Array",
                "normal": "Float32Array",
                "color": "Float32Array",
                "weights": "Float32Array",
                "joints": "Uint8Array",
                "uv": "Float32Array"
            };

            const geometry = {
                "index": null,
                "attributes": []
            };

            let count = 0;
            for (const attributeName in attributeIDs)
            {
                const attributeType = attributeTypes[attributeName];
                let attributeID = decoder.GetAttributeId(dracoGeometry, attributeIDs[attributeName]);

                count++;
                if (attributeID != -1)
                {
                    let attribute = decoder.GetAttribute(dracoGeometry, attributeID);
                    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
                }
            }

            if (geometryType === draco.TRIANGULAR_MESH) geometry.index = decodeIndex(draco, decoder, dracoGeometry);
            else op.warn("unknown draco geometryType", geometryType);

            draco.destroy(dracoGeometry);
            return geometry;
        };

        let decodeIndex = function (draco, decoder, dracoGeometry)
        {
            const numFaces = dracoGeometry.num_faces();
            const numIndices = numFaces * 3;
            const byteLength = numIndices * 4;
            const ptr = draco._malloc(byteLength);

            decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
            const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();

            draco._free(ptr);

            return {
                "array": index,
                "itemSize": 1
            };
        };

        let decodeAttribute = function (draco, decoder, dracoGeometry, attributeName, attributeType, attribute)
        {
            let bytesPerElement = 4;
            if (attributeType === "Float32Array") bytesPerElement = 4;
            else if (attributeType === "Uint8Array") bytesPerElement = 1;
            else op.warn("unknown attrtype bytesPerElement", attributeType);

            const numComponents = attribute.num_components();
            const numPoints = dracoGeometry.num_points();
            const numValues = numPoints * numComponents;
            const byteLength = numValues * bytesPerElement;
            const dataType = getDracoDataType(draco, attributeType);
            const ptr = draco._malloc(byteLength);
            let array = null;

            decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);

            if (attributeType === "Float32Array") array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();
            else if (attributeType === "Uint8Array") array = new Uint8Array(draco.HEAPF32.buffer, ptr, numValues).slice();
            else op.warn("unknown attrtype", attributeType);

            draco._free(ptr);

            return {
                "name": attributeName,
                "array": array,
                "itemSize": numComponents
            };
        };

        let getDracoDataType = function (draco, attributeType)
        {
            switch (attributeType)
            {
            case "Float32Array": return draco.DT_FLOAT32;
            case "Int8Array": return draco.DT_INT8;
            case "Int16Array": return draco.DT_INT16;
            case "Int32Array": return draco.DT_INT32;
            case "Uint8Array": return draco.DT_UINT8;
            case "Uint16Array": return draco.DT_UINT16;
            case "Uint32Array": return draco.DT_UINT32;
            }
        };
    }
}

window.DracoDecoder = new DracoDecoderClass();


};

Ops.Gl.GLTF.GltfDracoCompression.prototype = new CABLES.Op();
CABLES.OPS["4ecdc2ef-a242-4548-ad74-13f617119a64"]={f:Ops.Gl.GLTF.GltfDracoCompression,objName:"Ops.Gl.GLTF.GltfDracoCompression"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfGeometry
// 
// **************************************************************

Ops.Gl.GLTF.GltfGeometry = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Update"),
    inNodeName = op.inString("Name", "default"),
    inSubmesh = op.inInt("Submesh", 0),
    next = op.outTrigger("Next"),
    outGeom = op.outObject("Geometry", null, "geometry"),
    outFound = op.outBoolNum("Found");

const cgl = op.patch.cgl;
let mesh = null;
let currentSceneLoaded = null;

inSubmesh.onChange =
inNodeName.onChange = function ()
{
    outGeom.set(null);
    mesh = null;
    outFound.set(false);
    op.setUiAttrib({ "extendTitle": inNodeName.get() + "." + inSubmesh.get() });
};

exec.onTriggered = () =>
{
    if (!cgl.frameStore.currentScene) return;
    if (currentSceneLoaded != cgl.frameStore.currentScene.loaded) mesh = null;

    if (!mesh)
    {
        if (!cgl.frameStore || !cgl.frameStore.currentScene || !cgl.frameStore.currentScene.nodes || !cgl.frameStore.currentScene.loaded)
        {
            return;
        }
        outFound.set(false);
        outGeom.set(null);
        const name = inNodeName.get();

        currentSceneLoaded = cgl.frameStore.currentScene.loaded;

        for (let i = 0; i < cgl.frameStore.currentScene.meshes.length; i++)
        {
            if (cgl.frameStore.currentScene.meshes[i].name == name)
            {
                mesh = cgl.frameStore.currentScene.meshes[i];

                const idx = Math.abs(inSubmesh.get());
                if (mesh.meshes[idx] && mesh.meshes[idx].geom)
                {
                    outFound.set(true);
                    outGeom.set(mesh.meshes[idx].geom);
                }
            }
        }
    }

    next.trigger();
};


};

Ops.Gl.GLTF.GltfGeometry.prototype = new CABLES.Op();
CABLES.OPS["2e59da07-455a-457c-99d8-1c23a1ddeea2"]={f:Ops.Gl.GLTF.GltfGeometry,objName:"Ops.Gl.GLTF.GltfGeometry"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfHierarchy
// 
// **************************************************************

Ops.Gl.GLTF.GltfHierarchy = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec=op.inTrigger("Trigger"),
    inNodeName=op.inString("Node name","default"),
    next=op.outTrigger("Next"),
    outArr=op.outArray("Bones Lines");

exec.onTriggered=update;

const cgl=op.patch.cgl;


let node=null;
const tr = vec3.create();



inNodeName.onChange=()=>
{
    node=null;
    update();
};

function addChild(gltf,arr,parent,child)
{

    if(parent)
    {

        mat4.getTranslation(tr, parent.modelMatAbs());
        arr.push(tr[0], tr[1], tr[2]);

        mat4.getTranslation(tr, child.modelMatAbs());
        arr.push(tr[0], tr[1], tr[2]);

    }

    if(child && child.children)
    {
        for(let i=0;i<child.children.length;i++)
        {
            addChild(gltf,arr,child,gltf.nodes[child.children[i]]);
        }
    }

}

function update()
{
    if (!cgl.frameStore.currentScene) return;

    let arr=[];
    let found=false;
    const idx=0;
    const gltf=cgl.frameStore.currentScene;

    if (!node)
    {
        const name = inNodeName.get();

        for (let i = 0; i < gltf.nodes.length; i++)
        {
            if (gltf.nodes[i].name == name)
            {
                node = gltf.nodes[i];
                found = true;
                break;
            }
        }
    }
    else
    {
        found = true;
    }


    if(found && node)
    {
        for(let i=0;i<node.children.length;i++)
        {
            addChild(gltf,arr,null,gltf.nodes[node.children[i]]);
        }

        outArr.set(null);
        outArr.set(arr);
    }
    else
    {
        outArr.set(null);
        return;
    }

    next.trigger();

}


};

Ops.Gl.GLTF.GltfHierarchy.prototype = new CABLES.Op();
CABLES.OPS["a66e2532-3bfd-424f-8465-6f55c5558ccb"]={f:Ops.Gl.GLTF.GltfHierarchy,objName:"Ops.Gl.GLTF.GltfHierarchy"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfMeshSequence
// 
// **************************************************************

Ops.Gl.GLTF.GltfMeshSequence = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Render"),
    inIndex = op.inInt("Index", 0),
    inNodeName = op.inString("Node Name"),
    inTrans = op.inBool("Transformation", true),
    inIgnMaterial = op.inBool("Ignore Material", true),
    next = op.outTrigger("Next"),
    outFound = op.outNumber("Found"),
    outIndex = op.outNumber("Current Index");

const cgl = op.patch.cgl;

const nodes = [];
let currentSceneLoaded = null;
let oldScene = null;

inNodeName.onChange = function ()
{
    nodes.length = 0;
    outFound.set(false);
    op.setUiAttrib({ "extendTitle": inNodeName.get() });
};

inExec.onTriggered = function ()
{
    if (!cgl.frameStore.currentScene) return;
    if (
        cgl.frameStore.currentScene != oldScene ||
        currentSceneLoaded != cgl.frameStore.currentScene.loaded) nodes.length = 0;

    if (!nodes.length)
    {
        const name = inNodeName.get();

        if (!cgl.frameStore || !cgl.frameStore.currentScene || !cgl.frameStore.currentScene.nodes)
        {
            return;
        }

        oldScene = cgl.frameStore.currentScene;
        currentSceneLoaded = cgl.frameStore.currentScene.loaded;

        for (let i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
        {
            if (cgl.frameStore.currentScene.nodes[i].name.indexOf(name))
            {
                nodes.push(cgl.frameStore.currentScene.nodes[i]);
                cgl.frameStore.currentScene.nodes[i].render(cgl, !inTrans.get(), false, inIgnMaterial.get(), true, true);
                outFound.set(true);
            }
        }
        outFound.set(nodes.length);
    }

    cgl.pushModelMatrix();

    const index = Math.floor(inIndex.get() % nodes.length);
    const node = nodes[index];

    if (node)
    {
        if (inTrans.get())
        {
            cgl.pushModelMatrix();
            node.transform(cgl);
        }

        outIndex.set(index);
        node.render(cgl, !inTrans.get(), false, inIgnMaterial.get(), true, true);
    }

    next.trigger();

    if (node)
    {
        if (inTrans.get()) cgl.popModelMatrix();
    }

    cgl.popModelMatrix();
};


};

Ops.Gl.GLTF.GltfMeshSequence.prototype = new CABLES.Op();
CABLES.OPS["3faa0691-66e8-4318-838c-c2d00dff0344"]={f:Ops.Gl.GLTF.GltfMeshSequence,objName:"Ops.Gl.GLTF.GltfMeshSequence"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfNodeSineAnim
// 
// **************************************************************

Ops.Gl.GLTF.GltfNodeSineAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Update"),
    inFilter = op.inString("Filter", ""),
    inTime = op.inFloat("Time", 0),
    inOffset = op.inFloat("Offset", 0),
    inAmplitude = op.inFloat("Amplitude", 10),
    axisX = op.inFloatSlider("Axis X", 1.0),
    axisY = op.inFloatSlider("Axis Y", 1.0),
    axisZ = op.inFloatSlider("Axis Z", 1.0),
    next = op.outTrigger("Next"),
    outNum = op.outNumber("Found");

const cgl = op.patch.cgl;
let scene = null;

op.onDelete =
inExec.onLinkChanged = remove;

function remove()
{
    if (scene)
        for (let i = 0; i < scene.nodes.length; i++)
        {
            if (scene.nodes[i].name.indexOf(inFilter.get()) >= 0)
            {
                scene.nodes[i].addTranslate = null;
            }
        }
}

inExec.onTriggered = function ()
{
    if (!cgl.frameStore.currentScene) return;

    scene = cgl.frameStore.currentScene;

    let node = null;

    const ampl = inAmplitude.get();
    const offs = inOffset.get();
    const time = inTime.get();
    const ax = axisX.get();
    const ay = axisY.get();
    const az = axisZ.get();

    Math.randomSeed = 5711;
    let found = 0;

    for (let i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
    {
        if (cgl.frameStore.currentScene.nodes[i].name.indexOf(inFilter.get()) >= 0)
        {
            node = cgl.frameStore.currentScene.nodes[i];

            found++;

            const v = Math.sin(time + (Math.seededRandom() * offs)) * ampl;
            node.addTranslate = [v * ax, v * ay, v * az];
        }
    }

    outNum.set(found);

    next.trigger();
};


};

Ops.Gl.GLTF.GltfNodeSineAnim.prototype = new CABLES.Op();
CABLES.OPS["b4608e38-cc48-4748-a640-d653f53fc950"]={f:Ops.Gl.GLTF.GltfNodeSineAnim,objName:"Ops.Gl.GLTF.GltfNodeSineAnim"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfNodeTransform_v2
// 
// **************************************************************

Ops.Gl.GLTF.GltfNodeTransform_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Render"),
    inNodeName = op.inString("Node Name"),
    next = op.outTrigger("Next"),
    inApply = op.inBool("Set Matrix", true),
    outFound = op.outBool("Found"),
    outMat = op.outArray("Matrix");

const cgl = op.patch.cgl;
const translate = vec3.create();
let node = null;
let currentSceneLoaded = null;
const m = mat4.create();

inNodeName.onChange = function ()
{
    node = null;
    outFound.set(false);
    op.setUiAttrib({ "extendTitle": inNodeName.get() });
};

inExec.onTriggered = function ()
{
    if (!cgl.frameStore.currentScene) return;
    if (currentSceneLoaded != cgl.frameStore.currentScene.loaded) node = null;
    let found = false;

    if (!node)
    {
        const name = inNodeName.get();

        if (!cgl.frameStore || !cgl.frameStore.currentScene || !cgl.frameStore.currentScene.nodes) return;

        currentSceneLoaded = cgl.frameStore.currentScene.loaded;

        for (let i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
        {
            if (cgl.frameStore.currentScene.nodes[i].name == name)
            {
                node = cgl.frameStore.currentScene.nodes[i];
                found = true;
                break;
            }
        }
    }
    else
    {
        found = true;
    }

    outFound.set(found);
    cgl.pushModelMatrix();

    if (node)
    {
        mat4.copy(m, node.modelMatAbs());

        mat4.multiply(cgl.mMatrix, cgl.mMatrix, m);

        outMat.set(null);
        outMat.set(m);
    }

    next.trigger();
    cgl.popModelMatrix();
};


};

Ops.Gl.GLTF.GltfNodeTransform_v2.prototype = new CABLES.Op();
CABLES.OPS["5a36a0f2-a4cb-4ac4-a7af-95924f2a9558"]={f:Ops.Gl.GLTF.GltfNodeTransform_v2,objName:"Ops.Gl.GLTF.GltfNodeTransform_v2"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfNodeTransforms_v2
// 
// **************************************************************

Ops.Gl.GLTF.GltfNodeTransforms_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Render"),
    inStr = op.inString("Search", ""),
    inSort = op.inSwitch("Order", ["None", "AlphaNumerical"], "None"),
    inSpace = op.inSwitch("Space", ["GLTF", "World"], "GLTF"),
    outPos = op.outArray("Positions"),
    next = op.outTrigger("Next"),
    outScale = op.outArray("Scale"),
    outNames = op.outArray("Names"),
    outRot = op.outArray("Rotation");

const cgl = op.patch.cgl;
let needsupdate = true;
outPos.onChange = function () { needsupdate = true; };
inExec.onTriggered = exec;

inStr.onChange = function ()
{
    needsupdate = true;
};
function exec()
{
    // if (needsupdate)
    update();
    next.trigger();
}

function update()
{
    outPos.set(null);
    outScale.set(null);
    outNames.set(null);
    // outRot.set(null);

    if (!cgl.frameStore.currentScene) return;

    const arrPos = [];
    const arrRot = [];
    const arrScale = [];
    const arrNames = [];

    const worldspace = inSpace.get() == "World";

    for (let i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
    {
        if (cgl.frameStore.currentScene.nodes[i].name.indexOf(inStr.get()) == 0)
        {
            const n = cgl.frameStore.currentScene.nodes[i]._node;
            const node = cgl.frameStore.currentScene.nodes[i];
            arrNames.push(n.name);

            const tr = vec3.create();

            let m = node.modelMatAbs();
            // const m=node.modelMatLocal();

            if (!worldspace)
            {
                m = node.modelMatLocal();
            }

            mat4.getTranslation(tr, m);

            // const empty=vec3.create();
            // vec3.transformMat4(tr, empty, m);

            arrPos.push(tr[0], tr[1], tr[2]);

            const q = quat.create();
            mat4.getRotation(q, m);
            arrRot.push(q[0], q[1], q[2], q[3]);

            if (node._tempAnimScale) arrScale.push(node._tempAnimScale[0], node._tempAnimScale[1], node._tempAnimScale[2]);
            else if (n.scale) arrScale.push(n.scale[0], n.scale[1], n.scale[2]);
            else arrScale.push(1, 1, 1);
        }
    }

    if (inSort.get())
    {
        let list = [];
        for (let j = 0; j < arrNames.length; j++)
            list.push({
                "name": arrNames[j],
                "pos": [arrPos[j * 3 + 0], arrPos[j * 3 + 1], arrPos[j * 3 + 2]],
                "scale": [arrScale[j * 3 + 0], arrScale[j * 3 + 1], arrScale[j * 3 + 2]]
            });

        list.sort(function (a, b)
        {
            return ((a.name < b.name) ? -1 : ((a.name == b.name) ? 0 : 1));
            // Sort could be modified to, for example, sort on the age
            // if the name is the same.
        });

        // 3) separate them back out:
        for (let k = 0; k < list.length; k++)
        {
            arrNames[k] = list[k].name;
            arrPos[k * 3 + 0] = list[k].pos[0];
            arrPos[k * 3 + 1] = list[k].pos[1];
            arrPos[k * 3 + 2] = list[k].pos[2];
            arrScale[k * 3 + 0] = list[k].scale[0];
            arrScale[k * 3 + 1] = list[k].scale[1];
            arrScale[k * 3 + 2] = list[k].scale[2];
        }
    }

    outPos.set(arrPos);
    outScale.set(arrScale);
    outNames.set(arrNames);
    outRot.set(arrRot);

    needsupdate = false;
}


};

Ops.Gl.GLTF.GltfNodeTransforms_v2.prototype = new CABLES.Op();
CABLES.OPS["02247569-4a2d-4a1b-952d-3585b1c677a8"]={f:Ops.Gl.GLTF.GltfNodeTransforms_v2,objName:"Ops.Gl.GLTF.GltfNodeTransforms_v2"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfNode_v2
// 
// **************************************************************

Ops.Gl.GLTF.GltfNode_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Render"),
    inNodeName = op.inString("Node Name"),
    inTrans = op.inBool("Transformation", true),
    inDraw = op.inBool("Draw Mesh", true),
    inChilds = op.inBool("Draw Childs", true),
    inIgnMaterial = op.inBool("Ignore Material", true),

    inSceneTime = op.inBool("Use Scene Time", true),
    inTime = op.inFloat("Time", 0),

    next = op.outTrigger("Next"),
    outGeom = op.outObject("Geometry", null, "geometry"),
    outFound = op.outBool("Found");
const cgl = op.patch.cgl;

let node = null;
let currentSceneLoaded = null;

inNodeName.onChange = function ()
{
    outGeom.set(null);
    node = null;
    outFound.set(false);
    if (!inNodeName.isLinked())op.setUiAttrib({ "extendTitle": inNodeName.get() });
};

inSceneTime.onChange = updateTimeInputs;

updateTimeInputs();

function updateTimeInputs()
{
    inTime.setUiAttribs({ "greyout": inSceneTime.get() });
}

inExec.onTriggered = function ()
{
    if (!cgl.frameStore.currentScene) return;
    if (currentSceneLoaded != cgl.frameStore.currentScene.loaded) node = null;

    if (!node)
    {
        const name = inNodeName.get();

        if (!cgl.frameStore || !cgl.frameStore.currentScene || !cgl.frameStore.currentScene.nodes)
        {
            return;
        }
        currentSceneLoaded = cgl.frameStore.currentScene.loaded;

        for (let i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
        {
            if (cgl.frameStore.currentScene.nodes[i].name == name)
            {
                node = cgl.frameStore.currentScene.nodes[i];
                outFound.set(true);

                if (node && node.mesh && node.mesh.meshes && node.mesh.meshes[0].geom) outGeom.set(node.mesh.meshes[0].geom);
                else outGeom.set(null);
            }
        }
    }

    cgl.pushModelMatrix();

    if (node)
    {
        if (inTrans.get())
        {
            cgl.pushModelMatrix();
            node.transform(cgl);
        }

        // node.updateMatrix();

        // render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time)

        let time;
        if (!inSceneTime.get()) time = inTime.get();

        node.render(cgl, !inTrans.get(), !inDraw.get(), inIgnMaterial.get(), !inChilds.get(), true, time);
    }

    next.trigger();

    if (node)
    {
        if (inTrans.get()) cgl.popModelMatrix();
    }

    cgl.popModelMatrix();
};


};

Ops.Gl.GLTF.GltfNode_v2.prototype = new CABLES.Op();
CABLES.OPS["10d09387-0085-4162-ab5b-b89eebbf3cf4"]={f:Ops.Gl.GLTF.GltfNode_v2,objName:"Ops.Gl.GLTF.GltfNode_v2"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfScene_v3
// 
// **************************************************************

Ops.Gl.GLTF.GltfScene_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"inc_camera_js":"const gltfCamera = class\n{\n    constructor(gltf, node)\n    {\n        this.node=node;\n        this.name=node.name;\n        // console.log(gltf);\n        this.config=gltf.json.cameras[node.camera];\n\n        this.pos = vec3.create();\n        this.quat = quat.create();\n        this.quatOr = quat.create();\n        this.vCenter = vec3.create();\n        this.vUp = vec3.create();\n        this.vMat = mat4.create();\n\n    }\n\n    updateAnim(time)\n    {\n        if (this.node && this.node._animTrans)\n        {\n\n            vec3.set(this.pos,\n                this.node._animTrans[0].getValue(time),\n                this.node._animTrans[1].getValue(time),\n                this.node._animTrans[2].getValue(time));\n\n            quat.set(this.quat,\n                this.node._animRot[0].getValue(time),\n                this.node._animRot[1].getValue(time),\n                this.node._animRot[2].getValue(time),\n                this.node._animRot[3].getValue(time));\n        }\n    }\n\n    start(time)\n    {\n        if (cgl.frameStore.shadowPass) return;\n\n        this.updateAnim(time);\n        const asp = cgl.getViewPort()[2] / cgl.getViewPort()[3];\n\n        cgl.pushPMatrix();\n        // mat4.perspective(\n        //     cgl.pMatrix,\n        //     this.config.perspective.yfov*0.5,\n        //     asp,\n        //     this.config.perspective.znear,\n        //     this.config.perspective.zfar);\n\n        cgl.pushViewMatrix();\n        // mat4.identity(cgl.vMatrix);\n\n        // if(this.node && this.node.parent)\n        // {\n        //     console.log(this.node.parent)\n            // vec3.add(this.pos,this.pos,this.node.parent._node.translation);\n            // vec3.sub(this.vCenter,this.vCenter,this.node.parent._node.translation);\n            // mat4.translate(cgl.vMatrix,cgl.vMatrix,\n            // [\n            //     -this.node.parent._node.translation[0],\n            //     -this.node.parent._node.translation[1],\n            //     -this.node.parent._node.translation[2]\n            // ])\n        // }\n\n\n\n        // vec3.set(this.vUp, 0, 1, 0);\n        // vec3.set(this.vCenter, 0, -1, 0);\n        // // vec3.set(this.vCenter, 0, 1, 0);\n        // vec3.transformQuat(this.vCenter, this.vCenter, this.quat);\n        // vec3.normalize(this.vCenter, this.vCenter);\n        // vec3.add(this.vCenter, this.vCenter, this.pos);\n\n\n        // mat4.lookAt(cgl.vMatrix, this.pos, this.vCenter, this.vUp);\n\n\n        let mv=mat4.create();\n        mat4.invert(mv,this.node.modelMatAbs());\n\n        // console.log(this.node.modelMatAbs());\n\n        this.vMat=mv;\n\n        mat4.identity(cgl.vMatrix);\n        // console.log(mv);\n        mat4.mul(cgl.vMatrix,cgl.vMatrix,mv);\n\n\n    }\n\n    end()\n    {\n        if (cgl.frameStore.shadowPass) return;\n        cgl.popPMatrix();\n        cgl.popViewMatrix();\n    }\n};\n\n","inc_gltf_js":"const CHUNK_HEADER_SIZE = 8;\n\nconst Gltf = class\n{\n    constructor()\n    {\n        this.json = {};\n        this.accBuffers = [];\n        this.meshes = [];\n        this.nodes = [];\n        this.shaders = [];\n        this.timing = [];\n        this.cams = [];\n        this.startTime = performance.now();\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.loaded = Date.now();\n        this.accBuffersDelete = [];\n    }\n\n    getNode(n)\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            if (this.nodes[i].name == n) return this.nodes[i];\n        }\n    }\n\n    unHideAll()\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            this.nodes[i].unHide();\n        }\n    }\n};\n\nfunction Utf8ArrayToStr(array)\n{\n    if (window.TextDecoder) return new TextDecoder(\"utf-8\").decode(array);\n\n    let out, i, len, c;\n    let char2, char3;\n\n    out = \"\";\n    len = array.length;\n    i = 0;\n    while (i < len)\n    {\n        c = array[i++];\n        switch (c >> 4)\n        {\n        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n        case 12: case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[i++];\n            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n            break;\n        case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[i++];\n            char3 = array[i++];\n            out += String.fromCharCode(((c & 0x0F) << 12) |\n                    ((char2 & 0x3F) << 6) |\n                    ((char3 & 0x3F) << 0));\n            break;\n        }\n    }\n\n    return out;\n}\n\nfunction readChunk(dv, bArr, arrayBuffer, offset)\n{\n    const chunk = {};\n\n    if (offset >= dv.byteLength)\n    {\n        op.log(\"could not read chunk...\");\n        return;\n    }\n    chunk.size = dv.getUint32(offset + 0, le);\n\n    // chunk.type = new TextDecoder(\"utf-8\").decode(bArr.subarray(offset+4, offset+4+4));\n    chunk.type = Utf8ArrayToStr(bArr.subarray(offset + 4, offset + 4 + 4));\n\n    if (chunk.type == \"BIN\\0\")\n    {\n        // console.log(chunk.size,arrayBuffer.length,offset);\n        // try\n        // {\n        chunk.dataView = new DataView(arrayBuffer, offset + 8, chunk.size);\n        // }\n        // catch(e)\n        // {\n        //     chunk.dataView = null;\n        //     console.log(e);\n        // }\n    }\n    else\n    if (chunk.type == \"JSON\")\n    {\n        const json = Utf8ArrayToStr(bArr.subarray(offset + 8, offset + 8 + chunk.size));\n\n        try\n        {\n            const obj = JSON.parse(json);\n            chunk.data = obj;\n            outGenerator.set(obj.asset.generator);\n        }\n        catch (e)\n        {\n        }\n    }\n    else\n    {\n        op.warn(\"unknown type\", chunk.type);\n    }\n\n    return chunk;\n}\n\nfunction loadAnims(gltf)\n{\n    const uniqueAnimNames = {};\n\n    for (let i = 0; i < gltf.json.animations.length; i++)\n    {\n        const an = gltf.json.animations[i];\n\n        for (let ia = 0; ia < an.channels.length; ia++)\n        {\n            const chan = an.channels[ia];\n\n            const node = gltf.nodes[chan.target.node];\n            const sampler = an.samplers[chan.sampler];\n\n            const acc = gltf.json.accessors[sampler.input];\n            const bufferIn = gltf.accBuffers[sampler.input];\n\n            const accOut = gltf.json.accessors[sampler.output];\n            const bufferOut = gltf.accBuffers[sampler.output];\n\n            gltf.accBuffersDelete.push(sampler.output, sampler.input);\n\n            if (bufferIn && bufferOut)\n            {\n                let numComps = 1;\n                if (accOut.type == \"VEC2\")numComps = 2;\n                else if (accOut.type == \"VEC3\")numComps = 3;\n                else if (accOut.type == \"VEC4\")numComps = 4;\n                else op.warn(\"unknown accOut.type\", accOut.type);\n\n                const anims = [];\n\n                uniqueAnimNames[an.name] = true;\n\n                for (let k = 0; k < numComps; k++)\n                {\n                    const newAnim = new CABLES.TL.Anim();\n                    // newAnim.name=an.name;\n                    anims.push(newAnim);\n                }\n\n                if (sampler.interpolation == \"LINEAR\") {}\n                else if (sampler.interpolation == \"STEP\") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_ABSOLUTE;\n                else if (sampler.interpolation == \"CUBICSPLINE\") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_CUBICSPLINE;\n                else op.warn(\"unknown interpolation\", sampler.interpolation);\n\n                // console.log(bufferOut)\n\n                // if there is no keyframe for time 0 copy value of first keyframe at time 0\n                if (bufferIn[0] !== 0.0)\n                    for (let k = 0; k < numComps; k++)\n                        anims[k].setValue(0, bufferOut[0 * numComps + k]);\n\n                // console.log(sampler.interpolation,bufferOut.length/numComps)\n\n                for (let j = 0; j < bufferIn.length; j++)\n                {\n                    maxTime = Math.max(bufferIn[j], maxTime);\n\n                    for (let k = 0; k < numComps; k++)\n                    {\n                        if (anims[k].defaultEasing === CABLES.EASING_CUBICSPLINE)\n                        {\n                            const idx = ((j * numComps) * 3 + k);\n\n                            const key = anims[k].setValue(bufferIn[j], bufferOut[idx + numComps]);\n                            key.bezTangIn = bufferOut[idx];\n                            key.bezTangOut = bufferOut[idx + (numComps * 2)];\n\n                            // console.log(an.name,k,bufferOut[idx+1]);\n                        }\n                        else\n                        {\n                            // console.log(an.name,k,bufferOut[j * numComps + k]);\n                            anims[k].setValue(bufferIn[j], bufferOut[j * numComps + k]);\n                        }\n                    }\n                }\n\n                node.setAnim(chan.target.path, an.name, anims);\n            }\n            else\n            {\n                op.warn(\"loadAmins bufferIn undefined \", bufferIn === undefined);\n                op.warn(\"loadAmins bufferOut undefined \", bufferOut === undefined);\n                op.warn(\"loadAmins \", sampler, accOut);\n                op.warn(\"loadAmins num accBuffers\", gltf.accBuffers.length);\n                op.warn(\"loadAmins num accessors\", gltf.json.accessors.length);\n            }\n        }\n    }\n\n    gltf.uniqueAnimNames = uniqueAnimNames;\n\n    outAnims.set(null);\n    outAnims.set(Object.keys(uniqueAnimNames));\n}\n\nfunction loadCams(gltf)\n{\n    if (!gltf || !gltf.json.cameras) return;\n\n    gltf.cameras = gltf.cameras || [];\n\n    for (let i = 0; i < gltf.nodes.length; i++)\n    {\n        if (gltf.nodes[i].hasOwnProperty(\"camera\"))\n        {\n            const cam = new gltfCamera(gltf, gltf.nodes[i]);\n            gltf.cameras.push(cam);\n        }\n    }\n}\n\nfunction loadAfterDraco()\n{\n    if (!window.DracoDecoder)\n    {\n        setTimeout(() =>\n        {\n            loadAfterDraco();\n        }, 100);\n    }\n\n    reloadSoon();\n}\n\nfunction parseGltf(arrayBuffer)\n{\n    let j = 0, i = 0;\n\n    const gltf = new Gltf();\n    gltf.timing.push(\"Start parsing\", Math.round((performance.now() - gltf.startTime)));\n\n    if (!arrayBuffer) return;\n    const byteArray = new Uint8Array(arrayBuffer);\n    let pos = 0;\n\n    // var string = new TextDecoder(\"utf-8\").decode(byteArray.subarray(pos, 4));\n    const string = Utf8ArrayToStr(byteArray.subarray(pos, 4));\n    pos += 4;\n    if (string != \"glTF\") return;\n\n    gltf.timing.push(\"dataview\", Math.round((performance.now() - gltf.startTime)));\n\n    const dv = new DataView(arrayBuffer);\n    const version = dv.getUint32(pos, le);\n    pos += 4;\n    const size = dv.getUint32(pos, le);\n    pos += 4;\n\n    outVersion.set(version);\n\n    const chunks = [];\n    gltf.chunks = chunks;\n\n    chunks.push(readChunk(dv, byteArray, arrayBuffer, pos));\n    pos += chunks[0].size + CHUNK_HEADER_SIZE;\n    gltf.json = chunks[0].data;\n    outJson.set(gltf.json);\n    outExtensions.set(gltf.json.extensionsUsed || []);\n\n    let ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    while (ch)\n    {\n        chunks.push(ch);\n        pos += ch.size + CHUNK_HEADER_SIZE;\n        ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    }\n\n    gltf.chunks = chunks;\n\n    const views = chunks[0].data.bufferViews;\n    const accessors = chunks[0].data.accessors;\n\n    gltf.timing.push(\"Parse buffers\", Math.round((performance.now() - gltf.startTime)));\n\n    if (gltf.json.extensionsUsed && gltf.json.extensionsUsed.indexOf(\"KHR_draco_mesh_compression\") > -1)\n    {\n        if (!window.DracoDecoder)\n        {\n            op.setUiError(\"gltfdraco\", \"GLTF draco compression lib not found / add draco op to your patch!\");\n\n            loadAfterDraco();\n            return gltf;\n        }\n        else\n        {\n            gltf.useDraco = true;\n        }\n    }\n\n    op.setUiError(\"gltfdraco\", null);\n    // let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n\n    if (views)\n    {\n        for (i = 0; i < accessors.length; i++)\n        {\n            const acc = accessors[i];\n            const view = views[acc.bufferView];\n\n            let numComps = 0;\n            if (acc.type == \"SCALAR\")numComps = 1;\n            else if (acc.type == \"VEC2\")numComps = 2;\n            else if (acc.type == \"VEC3\")numComps = 3;\n            else if (acc.type == \"VEC4\")numComps = 4;\n            else if (acc.type == \"MAT4\")numComps = 16;\n            else console.error(\"unknown accessor type\", acc.type);\n\n            //   const decoder = new decoderModule.Decoder();\n            //   const decodedGeometry = decodeDracoData(data, decoder);\n            //   // Encode mesh\n            //   encodeMeshToFile(decodedGeometry, decoder);\n\n            //   decoderModule.destroy(decoder);\n            //   decoderModule.destroy(decodedGeometry);\n\n            // 5120 (BYTE)\t1\n            // 5121 (UNSIGNED_BYTE)\t1\n            // 5122 (SHORT)\t2\n\n            if (chunks[1].dataView)\n            {\n                if (view)\n                {\n                    const num = acc.count * numComps;\n                    let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n                    let stride = view.byteStride || 0;\n                    let dataBuff = null;\n\n                    if (acc.componentType == 5126 || acc.componentType == 5125) // 4byte FLOAT or INT\n                    {\n                        stride = stride || 4;\n\n                        const isInt = acc.componentType == 5125;\n                        if (isInt)dataBuff = new Uint32Array(num);\n                        else dataBuff = new Float32Array(num);\n\n                        for (j = 0; j < num; j++)\n                        {\n                            if (isInt) dataBuff[j] = chunks[1].dataView.getUint32(accPos, le);\n                            else dataBuff[j] = chunks[1].dataView.getFloat32(accPos, le);\n\n                            if (stride != 4 && (j + 1) % numComps === 0)accPos += stride - (numComps * 4);\n                            accPos += 4;\n                        }\n                    }\n                    else if (acc.componentType == 5123) // UNSIGNED_SHORT\n                    {\n                        stride = stride || 2;\n\n                        dataBuff = new Uint16Array(num);\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint16(accPos, le);\n\n                            if (stride != 2 && (j + 1) % numComps === 0) accPos += stride - (numComps * 2);\n\n                            accPos += 2;\n                        }\n                    }\n                    else if (acc.componentType == 5121) // UNSIGNED_BYTE\n                    {\n                        stride = stride || 1;\n\n                        dataBuff = new Uint8Array(num);\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint8(accPos, le);\n\n                            if (stride != 1 && (j + 1) % numComps === 0) accPos += stride - (numComps * 1);\n\n                            accPos += 1;\n                        }\n                    }\n\n                    else\n                    {\n                        console.error(\"unknown component type\", acc.componentType);\n                    }\n\n                    gltf.accBuffers.push(dataBuff);\n                }\n                else\n                {\n                    // console.log(\"has no dataview\");\n                }\n            }\n        }\n    }\n\n    gltf.timing.push(\"Parse mesh groups\", Math.round((performance.now() - gltf.startTime)));\n\n    gltf.json.meshes = gltf.json.meshes || [];\n\n    if (gltf.json.meshes)\n    {\n        for (i = 0; i < gltf.json.meshes.length; i++)\n        {\n            const mesh = new gltfMeshGroup(gltf, gltf.json.meshes[i]);\n            gltf.meshes.push(mesh);\n        }\n    }\n\n    gltf.timing.push(\"Parse nodes\", Math.round((performance.now() - gltf.startTime)));\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        if (gltf.json.nodes[i].children)\n            for (j = 0; j < gltf.json.nodes[i].children.length; j++)\n            {\n                gltf.json.nodes[gltf.json.nodes[i].children[j]].isChild = true;\n            }\n    }\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        const node = new gltfNode(gltf.json.nodes[i], gltf);\n        gltf.nodes.push(node);\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        const node = gltf.nodes[i];\n\n        if (!node.children) continue;\n        for (let j = 0; j < node.children.length; j++)\n        {\n            gltf.nodes[node.children[j]].parent = node;\n        }\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        gltf.nodes[i].initSkin();\n    }\n\n    needsMatUpdate = true;\n\n    gltf.timing.push(\"load anims\", Math.round((performance.now() - gltf.startTime)));\n\n    if (gltf.json.animations) loadAnims(gltf);\n\n    gltf.timing.push(\"load cameras\", Math.round((performance.now() - gltf.startTime)));\n\n    if (gltf.json.cameras) loadCams(gltf);\n\n    gltf.timing.push(\"finished\", Math.round((performance.now() - gltf.startTime)));\n\n    return gltf;\n}\n","inc_mesh_js":"let gltfMesh = class\n{\n    constructor(name, prim, gltf, finished)\n    {\n        this.POINTS = 0;\n        this.LINES = 1;\n        this.LINE_LOOP = 2;\n        this.LINE_STRIP = 3;\n        this.TRIANGLES = 4;\n        this.TRIANGLE_STRIP = 5;\n        this.TRIANGLE_FAN = 6;\n\n        this.test = 0;\n        this.name = name;\n        this.submeshIndex = 0;\n        this.material = prim.material;\n        this.mesh = null;\n        this.geom = new CGL.Geometry(\"gltf_\" + this.name);\n        this.geom.verticesIndices = [];\n        this.bounds = null;\n        this.primitive = 4;\n        if (prim.hasOwnProperty(\"mode\")) this.primitive = prim.mode;\n\n        if (prim.hasOwnProperty(\"indices\")) this.geom.verticesIndices = gltf.accBuffers[prim.indices];\n\n        gltf.loadingMeshes = gltf.loadingMeshes || 0;\n        gltf.loadingMeshes++;\n\n        this.materialJson =\n            this._matPbrMetalness =\n            this._matPbrRoughness =\n            this._matDiffuseColor = null;\n\n        if (gltf.json.materials)\n        {\n            if (this.material != -1) this.materialJson = gltf.json.materials[this.material];\n\n            if (this.materialJson && this.materialJson.pbrMetallicRoughness)\n            {\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty(\"baseColorFactor\"))\n                {\n                    this._matDiffuseColor = [1, 1, 1, 1];\n                }\n                else\n                {\n                    this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n                }\n\n                this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty(\"metallicFactor\"))\n                {\n                    this._matPbrMetalness = 1.0;\n                }\n                else\n                {\n                    this._matPbrMetalness = this.materialJson.pbrMetallicRoughness.metallicFactor || null;\n                }\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty(\"roughnessFactor\"))\n                {\n                    this._matPbrRoughness = 1.0;\n                }\n                else\n                {\n                    this._matPbrRoughness = this.materialJson.pbrMetallicRoughness.roughnessFactor || null;\n                }\n            }\n        }\n\n        if (gltf.useDraco && prim.extensions.KHR_draco_mesh_compression)\n        {\n            const view = gltf.chunks[0].data.bufferViews[prim.extensions.KHR_draco_mesh_compression.bufferView];\n            const num = view.byteLength;\n            const dataBuff = new Int8Array(num);\n            let accPos = (view.byteOffset || 0);// + (acc.byteOffset || 0);\n            for (let j = 0; j < num; j++)\n            {\n                dataBuff[j] = gltf.chunks[1].dataView.getInt8(accPos, le);\n                accPos++;\n            }\n\n            const dracoDecoder = window.DracoDecoder;\n            dracoDecoder.decodeGeometry(dataBuff.buffer, (geometry) =>\n            {\n                const geom = new CGL.Geometry(\"draco mesh \" + name);\n\n                for (let i = 0; i < geometry.attributes.length; i++)\n                {\n                    const attr = geometry.attributes[i];\n\n                    if (attr.name === \"position\") geom.vertices = attr.array;\n                    else if (attr.name === \"normal\") geom.vertexNormals = attr.array;\n                    else if (attr.name === \"uv\") geom.texCoords = attr.array;\n                    else if (attr.name === \"color\") geom.vertexColors = this.calcVertexColors(attr.array);\n                    else if (attr.name === \"joints\") geom.setAttribute(\"attrJoints\", Array.from(attr.array), 4);\n                    else if (attr.name === \"weights\")\n                    {\n                        const arr4 = new Float32Array(attr.array.length / attr.itemSize * 4);\n\n                        for (let k = 0; k < attr.array.length / attr.itemSize; k++)\n                        {\n                            arr4[k * 4] = arr4[k * 4 + 1] = arr4[k * 4 + 2] = arr4[k * 4 + 3] = 0;\n                            for (let j = 0; j < attr.itemSize; j++)\n                                arr4[k * 4 + j] = attr.array[k * attr.itemSize + j];\n                        }\n                        geom.setAttribute(\"attrWeights\", arr4, 4);\n                    }\n                    else op.logWarn(\"unknown draco attrib\", attr);\n                }\n\n                geometry.attributes = null;\n                geom.verticesIndices = geometry.index.array;\n\n                this.setGeom(geom);\n\n                this.mesh = null;\n                gltf.loadingMeshes--;\n                if (finished)finished(this);\n            }, (error) => { op.logError(error); });\n        }\n        else\n        {\n            gltf.loadingMeshes--;\n            this.fillGeomAttribs(gltf, this.geom, prim.attributes);\n\n            if (prim.targets)\n            {\n                console.log(\"prim.targets\", prim.targets.length);\n                for (let j = 0; j < prim.targets.length; j++)\n                {\n                    // var tgeom=new CGL.Geometry(\"gltf_\"+this.name);\n                    let tgeom = this.geom.copy();\n\n                    if (prim.hasOwnProperty(\"indices\")) tgeom.verticesIndices = gltf.accBuffers[prim.indices];\n\n                    this.fillGeomAttribs(gltf, tgeom, prim.targets[j], false);\n\n                    { // calculate normals for final position of morphtarget for later...\n                        for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] += this.geom.vertices[i];\n                        tgeom.calculateNormals();\n                        for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] -= this.geom.vertices[i];\n                    }\n\n                    this.geom.morphTargets.push(tgeom);\n                }\n            }\n            if (finished)finished(this);\n        }\n    }\n\n    _linearToSrgb(x)\n    {\n        if (x <= 0)\n            return 0;\n        else if (x >= 1)\n            return 1;\n        else if (x < 0.0031308)\n            return x * 12.92;\n        else\n            return Math.pow(x, 1 / 2.2) * 1.055 - 0.055;\n    }\n\n    calcVertexColors(arr)\n    {\n        let vertexColors = null;\n        if (arr instanceof Float32Array)\n        {\n            let div = false;\n            for (let i = 0; i < arr.length; i++)\n            {\n                if (arr[i] > 1)\n                {\n                    div = true;\n                    continue;\n                }\n            }\n\n            if (div)\n                for (let i = 0; i < arr.length; i++) arr[i] /= 65535;\n\n            vertexColors = arr;\n        }\n\n        else if (arr instanceof Uint16Array)\n        {\n            const fb = new Float32Array(arr.length);\n            for (let i = 0; i < arr.length; i++) fb[i] = arr[i] / 65535;\n\n            vertexColors = fb;\n        }\n        else vertexColors = arr;\n\n        for (let i = 0; i < vertexColors.length; i++)\n        {\n            vertexColors[i] = this._linearToSrgb(vertexColors[i]);\n        }\n\n        return vertexColors;\n    }\n\n    fillGeomAttribs(gltf, tgeom, attribs, setGeom)\n    {\n        if (attribs.hasOwnProperty(\"POSITION\")) tgeom.vertices = gltf.accBuffers[attribs.POSITION];\n        if (attribs.hasOwnProperty(\"NORMAL\")) tgeom.vertexNormals = gltf.accBuffers[attribs.NORMAL];\n        if (attribs.hasOwnProperty(\"TANGENT\")) tgeom.tangents = gltf.accBuffers[attribs.TANGENT];\n\n        if (attribs.hasOwnProperty(\"COLOR_0\")) tgeom.vertexColors = this.calcVertexColors(gltf.accBuffers[attribs.COLOR_0]);\n        if (attribs.hasOwnProperty(\"COLOR_1\")) tgeom.setAttribute(\"attrVertColor1\", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_1]), 4);\n        if (attribs.hasOwnProperty(\"COLOR_2\")) tgeom.setAttribute(\"attrVertColor2\", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_2]), 4);\n        if (attribs.hasOwnProperty(\"COLOR_3\")) tgeom.setAttribute(\"attrVertColor3\", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_3]), 4);\n        if (attribs.hasOwnProperty(\"COLOR_4\")) tgeom.setAttribute(\"attrVertColor4\", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_4]), 4);\n\n        if (attribs.hasOwnProperty(\"TEXCOORD_0\"))tgeom.texCoords = gltf.accBuffers[attribs.TEXCOORD_0];\n        if (attribs.hasOwnProperty(\"TEXCOORD_1\"))tgeom.setAttribute(\"attrTexCoord1\", gltf.accBuffers[attribs.TEXCOORD_1], 2);\n        if (attribs.hasOwnProperty(\"TEXCOORD_2\"))tgeom.setAttribute(\"attrTexCoord2\", gltf.accBuffers[attribs.TEXCOORD_2], 2);\n        if (attribs.hasOwnProperty(\"TEXCOORD_3\"))tgeom.setAttribute(\"attrTexCoord3\", gltf.accBuffers[attribs.TEXCOORD_3], 2);\n        if (attribs.hasOwnProperty(\"TEXCOORD_4\"))tgeom.setAttribute(\"attrTexCoord4\", gltf.accBuffers[attribs.TEXCOORD_4], 2);\n\n        if (attribs.hasOwnProperty(\"WEIGHTS_0\"))\n        {\n            tgeom.setAttribute(\"attrWeights\", gltf.accBuffers[attribs.WEIGHTS_0], 4);\n        }\n        if (attribs.hasOwnProperty(\"JOINTS_0\"))\n        {\n            if (!gltf.accBuffers[attribs.JOINTS_0])console.log(\"no !gltf.accBuffers[attribs.JOINTS_0]\");\n            tgeom.setAttribute(\"attrJoints\", gltf.accBuffers[attribs.JOINTS_0], 4);\n        }\n\n        if (attribs.hasOwnProperty(\"POSITION\")) gltf.accBuffersDelete.push(attribs.POSITION);\n        if (attribs.hasOwnProperty(\"NORMAL\")) gltf.accBuffersDelete.push(attribs.NORMAL);\n        if (attribs.hasOwnProperty(\"TEXCOORD_0\")) gltf.accBuffersDelete.push(attribs.TEXCOORD_0);\n        if (attribs.hasOwnProperty(\"TANGENT\")) gltf.accBuffersDelete.push(attribs.TANGENT);\n        if (attribs.hasOwnProperty(\"COLOR_0\"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty(\"COLOR_0\"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty(\"COLOR_1\"))gltf.accBuffersDelete.push(attribs.COLOR_1);\n        if (attribs.hasOwnProperty(\"COLOR_2\"))gltf.accBuffersDelete.push(attribs.COLOR_2);\n        if (attribs.hasOwnProperty(\"COLOR_3\"))gltf.accBuffersDelete.push(attribs.COLOR_3);\n\n        if (attribs.hasOwnProperty(\"TEXCOORD_1\")) gltf.accBuffersDelete.push(attribs.TEXCOORD_1);\n        if (attribs.hasOwnProperty(\"TEXCOORD_2\")) gltf.accBuffersDelete.push(attribs.TEXCOORD_2);\n        if (attribs.hasOwnProperty(\"TEXCOORD_3\")) gltf.accBuffersDelete.push(attribs.TEXCOORD_3);\n        if (attribs.hasOwnProperty(\"TEXCOORD_4\")) gltf.accBuffersDelete.push(attribs.TEXCOORD_4);\n\n        if (setGeom !== false) if (tgeom && tgeom.verticesIndices) this.setGeom(tgeom);\n    }\n\n    setGeom(geom)\n    {\n        if (inNormFormat.get() == \"X-ZY\")\n        {\n            for (let i = 0; i < geom.vertexNormals.length; i += 3)\n            {\n                let t = geom.vertexNormals[i + 2];\n                geom.vertexNormals[i + 2] = geom.vertexNormals[i + 1];\n                geom.vertexNormals[i + 1] = -t;\n            }\n        }\n\n        if (inVertFormat.get() == \"XZ-Y\")\n        {\n            for (let i = 0; i < geom.vertices.length; i += 3)\n            {\n                let t = geom.vertices[i + 2];\n                geom.vertices[i + 2] = -geom.vertices[i + 1];\n                geom.vertices[i + 1] = t;\n            }\n        }\n\n        if (this.primitive == this.TRIANGLES)\n        {\n            if (!geom.vertexNormals.length || inCalcNormals.get()) geom.calculateNormals();\n\n            if ((!geom.biTangents || geom.biTangents.length == 0) && geom.tangents)\n            {\n                const bitan = vec3.create();\n                const tan = vec3.create();\n\n                const tangents = geom.tangents;\n                geom.tangents = new Float32Array(tangents.length / 4 * 3);\n                geom.biTangents = new Float32Array(tangents.length / 4 * 3);\n\n                for (let i = 0; i < tangents.length; i += 4)\n                {\n                    const idx = i / 4 * 3;\n\n                    vec3.cross(\n                        bitan,\n                        [geom.vertexNormals[idx], geom.vertexNormals[idx + 1], geom.vertexNormals[idx + 2]],\n                        [tangents[i], tangents[i + 1], tangents[i + 2]]\n                    );\n\n                    vec3.div(bitan, bitan, [tangents[i + 3], tangents[i + 3], tangents[i + 3]]);\n                    vec3.normalize(bitan, bitan);\n\n                    geom.biTangents[idx + 0] = bitan[0];\n                    geom.biTangents[idx + 1] = bitan[1];\n                    geom.biTangents[idx + 2] = bitan[2];\n\n                    geom.tangents[idx + 0] = tangents[i + 0];\n                    geom.tangents[idx + 1] = tangents[i + 1];\n                    geom.tangents[idx + 2] = tangents[i + 2];\n                }\n            }\n\n            if (geom.tangents.length === 0 || inCalcNormals.get()) geom.calcTangentsBitangents();\n        }\n\n        this.geom = geom;\n\n        this.bounds = geom.getBounds();\n    }\n\n    render(cgl, ignoreMaterial, skinRenderer)\n    {\n        if (!this.mesh && this.geom && this.geom.verticesIndices)\n        {\n            let g = this.geom;\n            if (this.geom.vertices.length / 3 > 64000)\n            {\n                g = this.geom.copy();\n                g.unIndex(false, true);\n            }\n\n            let glprim;\n            if (this.primitive == this.TRIANGLES)glprim = cgl.gl.TRIANGLES;\n            else if (this.primitive == this.LINES)glprim = cgl.gl.LINES;\n            else if (this.primitive == this.LINE_STRIP)glprim = cgl.gl.LINE_STRIP;\n            else if (this.primitive == this.POINTS)glprim = cgl.gl.POINTS;\n            else\n            {\n                op.logWarn(\"unknown primitive type\", this);\n            }\n\n            this.mesh = new CGL.Mesh(cgl, g, glprim);\n            // this.mesh._geom = null;\n        }\n        else\n        {\n            // update morphTargets\n            if (this.geom && this.geom.morphTargets.length)\n            {\n                this.morphGeom = this.geom.copy();\n\n                this.test = time * 11.7;\n\n                if (this.test >= this.geom.morphTargets.length - 1) this.test = 0;\n\n                const mt = this.geom.morphTargets[Math.floor(this.test)];\n                const mt2 = this.geom.morphTargets[Math.floor(this.test + 1)];\n\n                if (mt && mt.vertices && mt2)\n                {\n                    if (this.morphGeom.vertexNormals.length != mt.vertexNormals.length)\n                        this.morphGeom.vertexNormals = new Float32Array(mt.vertexNormals.length);\n\n                    const fract = this.test % 1;\n                    for (let i = 0; i < this.morphGeom.vertices.length; i++)\n                    {\n                        this.morphGeom.vertices[i] =\n                            this.geom.vertices[i] +\n                            (1.0 - fract) * mt.vertices[i] +\n                            fract * mt2.vertices[i];\n\n                        this.morphGeom.vertexNormals[i] =\n                            (1.0 - fract) * mt.vertexNormals[i] +\n                            fract * mt2.vertexNormals[i];\n                    }\n\n                    this.mesh.updateNormals(this.morphGeom);\n                    this.mesh.updateVertices(this.morphGeom);\n                }\n            }\n\n            let useMat = !ignoreMaterial && this.material != -1 && gltf.shaders[this.material];\n            if (skinRenderer)useMat = false;\n\n            if (useMat) cgl.pushShader(gltf.shaders[this.material]);\n\n            const currentShader = cgl.getShader() || {};\n            const uniDiff = currentShader.uniformColorDiffuse;\n\n            const uniPbrMetalness = currentShader.uniformPbrMetalness;\n            const uniPbrRoughness = currentShader.uniformPbrRoughness;\n\n            if (!gltf.shaders[this.material] && inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor)\n                {\n                    this._matDiffuseColorOrig = [uniDiff.getValue()[0], uniDiff.getValue()[1], uniDiff.getValue()[2], uniDiff.getValue()[3]];\n                    uniDiff.setValue(this._matDiffuseColor);\n                }\n\n                if (uniPbrMetalness)\n                    if (this._matPbrMetalness != null)\n                    {\n                        this._matPbrMetalnessOrig = uniPbrMetalness.getValue();\n                        uniPbrMetalness.setValue(this._matPbrMetalness);\n                    }\n                    else\n                        uniPbrMetalness.setValue(0);\n\n                if (uniPbrRoughness)\n                    if (this._matPbrRoughness != null)\n                    {\n                        this._matPbrRoughnessOrig = uniPbrRoughness.getValue();\n                        uniPbrRoughness.setValue(this._matPbrRoughness);\n                    }\n                    else\n                    {\n                        uniPbrRoughness.setValue(0);\n                    }\n            }\n\n            if (this.mesh) this.mesh.render(cgl.getShader(), ignoreMaterial);\n\n            if (inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor) uniDiff.setValue(this._matDiffuseColorOrig);\n                if (uniPbrMetalness && this._matPbrMetalnessOrig != undefined) uniPbrMetalness.setValue(this._matPbrMetalnessOrig);\n                if (uniPbrRoughness && this._matPbrRoughnessOrig != undefined) uniPbrRoughness.setValue(this._matPbrRoughnessOrig);\n            }\n\n            if (useMat) cgl.popShader();\n        }\n    }\n};\n","inc_meshGroup_js":"const gltfMeshGroup = class\n{\n    constructor(gltf, m)\n    {\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.meshes = [];\n        this.name = m.name;\n        const prims = m.primitives;\n\n        for (let i = 0; i < prims.length; i++)\n        {\n            const mesh = new gltfMesh(this.name, prims[i], gltf,\n                (mesh) =>\n                {\n                    this.bounds.apply(mesh.bounds);\n                });\n\n            mesh.submeshIndex = i;\n            this.meshes.push(mesh);\n        }\n    }\n\n    render(cgl, ignoreMat, skinRenderer, _time)\n    {\n        for (let i = 0; i < this.meshes.length; i++)\n        {\n            const useMat = gltf.shaders[this.meshes[i].material];\n\n            if (!ignoreMat && useMat) cgl.pushShader(gltf.shaders[this.meshes[i].material]);\n            // console.log(gltf.shaders[this.meshes[i].material],this.meshes[i].material)\n            if (skinRenderer)skinRenderer.renderStart(cgl, _time);\n\n            this.meshes[i].render(cgl, ignoreMat, skinRenderer, _time);\n            if (skinRenderer)skinRenderer.renderFinish(cgl);\n            if (!ignoreMat && useMat) cgl.popShader();\n        }\n    }\n};\n","inc_node_js":"const gltfNode = class\n{\n    constructor(node, gltf)\n    {\n        this.isChild = node.isChild || false;\n        this.name = node.name;\n        if (node.hasOwnProperty(\"camera\")) this.camera = node.camera;\n        this.hidden = false;\n        this.mat = mat4.create();\n        this._animMat = mat4.create();\n        this._tempMat = mat4.create();\n        this._tempQuat = quat.create();\n        this._tempRotmat = mat4.create();\n        this.mesh = null;\n        this.children = [];\n        this._node = node;\n        this._gltf = gltf;\n        this.absMat = mat4.create();\n        this.addTranslate = null;\n        this._tempAnimScale = null;\n        this.addMulMat = null;\n        this.updateMatrix();\n        this._animActions = {};\n        this.skinRenderer = null;\n        this.copies = [];\n    }\n\n    get skin()\n    {\n        if (this._node.hasOwnProperty(\"skin\")) return this._node.skin;\n        else return -1;\n    }\n\n    copy()\n    {\n        this.isCopy = true;\n        const n = new gltfNode(this._node, this._gltf);\n        n.copyOf = this;\n\n        n._animActions = this._animActions;\n        n.children = this.children;\n        n.skinRenderer = new GltfSkin(n);\n\n        this.updateMatrix();\n        return n;\n    }\n\n    hasSkin()\n    {\n        if (this._node.hasOwnProperty(\"skin\")) return this._gltf.json.skins[this._node.skin].name || \"unknown\";\n        return false;\n    }\n\n    initSkin()\n    {\n        if (this.skin > -1)\n        {\n            this.skinRenderer = new GltfSkin(this);\n        }\n    }\n\n    updateMatrix()\n    {\n        mat4.identity(this.mat);\n        if (this._node.translation) mat4.translate(this.mat, this.mat, this._node.translation);\n\n        if (this._node.rotation)\n        {\n            const rotmat = mat4.create();\n            this._rot = this._node.rotation;\n\n            mat4.fromQuat(rotmat, this._node.rotation);\n            mat4.mul(this.mat, this.mat, rotmat);\n        }\n\n        if (this._node.scale)\n        {\n            this._scale = this._node.scale;\n            mat4.scale(this.mat, this.mat, this._scale);\n        }\n\n        if (this._node.hasOwnProperty(\"mesh\"))\n        {\n            this.mesh = this._gltf.meshes[this._node.mesh];\n            if (this.isCopy)\n            {\n                console.log(this.mesh);\n            }\n        }\n\n        if (this._node.children)\n        {\n            for (let i = 0; i < this._node.children.length; i++)\n            {\n                this._gltf.json.nodes[i].isChild = true;\n                if (this._gltf.nodes[this._node.children[i]]) this._gltf.nodes[this._node.children[i]].isChild = true;\n                this.children.push(this._node.children[i]);\n            }\n        }\n    }\n\n    unHide()\n    {\n        this.hidden = false;\n        for (let i = 0; i < this.children.length; i++)\n            if (this.children[i].unHide) this.children[i].unHide();\n    }\n\n    calcBounds(gltf, mat, bounds)\n    {\n        const localMat = mat4.create();\n\n        if (mat) mat4.copy(localMat, mat);\n        if (this.mat) mat4.mul(localMat, localMat, this.mat);\n\n        if (this.mesh)\n        {\n            const bb = this.mesh.bounds.copy();\n            bb.mulMat4(localMat);\n            bounds.apply(bb);\n\n            if (bounds.changed)\n            {\n                boundingPoints.push(\n                    bb._min[0] || 0, bb._min[1] || 0, bb._min[2] || 0,\n                    bb._max[0] || 0, bb._max[1] || 0, bb._max[2] || 0);\n            }\n        }\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            if (gltf.nodes[this.children[i]] && gltf.nodes[this.children[i]].calcBounds)\n            {\n                const b = gltf.nodes[this.children[i]].calcBounds(gltf, localMat, bounds);\n\n                bounds.apply(b);\n            }\n        }\n\n        if (bounds.changed) return bounds;\n        else return null;\n    }\n\n    setAnimAction(name)\n    {\n        // console.log(\"setAnimAction:\", name);\n        if (!name) return;\n\n        this._currentAnimaction = name;\n\n        if (name && !this._animActions[name])\n        {\n            // console.log(\"no action found:\", name,this._animActions);\n            return null;\n        }\n\n        // else console.log(\"YES action found:\", name);\n        // console.log(this._animActions);\n\n        for (let path in this._animActions[name])\n        {\n            if (path == \"translation\") this._animTrans = this._animActions[name][path];\n            else if (path == \"rotation\") this._animRot = this._animActions[name][path];\n            else if (path == \"scale\") this._animScale = this._animActions[name][path];\n            else console.warn(\"unknown anim path\", path, this._animActions[name][path]);\n        }\n    }\n\n    setAnim(path, name, anims)\n    {\n        if (!path || !name || !anims) return;\n\n        // console.log(\"setanim\", this._node.name, path, name, anims);\n\n        this._animActions[name] = this._animActions[name] || {};\n\n        // console.log(this._animActions);\n        // debugger;\n\n        // for (let i = 0; i < this.copies.length; i++) this.copies[i]._animActions = this._animActions;\n\n        if (this._animActions[name][path]) op.warn(\"animation action path already exists\", name, path, this._animActions[name][path]);\n\n        this._animActions[name][path] = anims;\n\n        if (path == \"translation\") this._animTrans = anims;\n        else if (path == \"rotation\") this._animRot = anims;\n        else if (path == \"scale\") this._animScale = anims;\n        else console.warn(\"unknown anim path\", path, anims);\n    }\n\n    modelMatLocal()\n    {\n        return this._animMat || this.mat;\n    }\n\n    modelMatAbs()\n    {\n        return this.absMat;\n    }\n\n    transform(cgl, _time)\n    {\n        if (!_time && _time != 0)_time = time;\n\n        this._lastTimeTrans = _time;\n\n        // console.log(this._rot)\n\n        gltfTransforms++;\n\n        if (!this._animTrans && !this._animRot && !this._animScale)\n        {\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this.mat);\n            this._animMat = null;\n        }\n        else\n        {\n            this._animMat = this._animMat || mat4.create();\n            mat4.identity(this._animMat);\n\n            const playAnims = true;\n\n            if (playAnims && this._animTrans)\n            {\n                mat4.translate(this._animMat, this._animMat, [\n                    this._animTrans[0].getValue(_time),\n                    this._animTrans[1].getValue(_time),\n                    this._animTrans[2].getValue(_time)]);\n            }\n            else\n            if (this._node.translation) mat4.translate(this._animMat, this._animMat, this._node.translation);\n\n            if (playAnims && this._animRot)\n            {\n                if (this._animRot[0].defaultEasing == CABLES.EASING_LINEAR) CABLES.TL.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_ABSOLUTE)\n                {\n                    this._tempQuat[0] = this._animRot[0].getValue(_time);\n                    this._tempQuat[1] = this._animRot[1].getValue(_time);\n                    this._tempQuat[2] = this._animRot[2].getValue(_time);\n                    this._tempQuat[3] = this._animRot[3].getValue(_time);\n                }\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_CUBICSPLINE)\n                {\n                    CABLES.TL.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                }\n\n                mat4.fromQuat(this._tempMat, this._tempQuat);\n                mat4.mul(this._animMat, this._animMat, this._tempMat);\n            }\n            else if (this._rot)\n            {\n                mat4.fromQuat(this._tempRotmat, this._rot);\n                mat4.mul(this._animMat, this._animMat, this._tempRotmat);\n            }\n\n            if (playAnims && this._animScale)\n            {\n                if (!this._tempAnimScale) this._tempAnimScale = [1, 1, 1];\n                this._tempAnimScale[0] = this._animScale[0].getValue(_time);\n                this._tempAnimScale[1] = this._animScale[1].getValue(_time);\n                this._tempAnimScale[2] = this._animScale[2].getValue(_time);\n                mat4.scale(this._animMat, this._animMat, this._tempAnimScale);\n            }\n            else if (this._scale) mat4.scale(this._animMat, this._animMat, this._scale);\n\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this._animMat);\n        }\n\n        if (this.addTranslate) mat4.translate(cgl.mMatrix, cgl.mMatrix, this.addTranslate);\n\n        if (this.addMulMat) mat4.mul(cgl.mMatrix, cgl.mMatrix, this.addMulMat);\n\n        mat4.copy(this.absMat, cgl.mMatrix);\n    }\n\n    render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time)\n    {\n        if (!dontTransform) cgl.pushModelMatrix();\n\n        if (_time === undefined) _time = gltf.time;\n\n        if (!dontTransform || this.skinRenderer) this.transform(cgl, _time);\n\n        if (this.hidden && !drawHidden)\n        {\n        }\n        else\n        {\n            if (this.skinRenderer)\n            {\n                this.skinRenderer.time = _time;\n                if (!dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, this.skinRenderer, _time);\n            }\n            else\n            {\n                if (this.mesh && !dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, null, _time);\n            }\n        }\n\n        if (!ignoreChilds && !this.hidden)\n            for (let i = 0; i < this.children.length; i++)\n                if (gltf.nodes[this.children[i]])\n                    gltf.nodes[this.children[i]].render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time);\n\n        if (!dontTransform)cgl.popModelMatrix();\n    }\n};\n","inc_print_js":"let tab = null;\n\nfunction closeTab()\n{\n    if (tab)gui.mainTabs.closeTab(tab.id);\n    tab = null;\n}\n\nfunction formatVec(arr)\n{\n    const nums = [];\n    for (let i = 0; i < arr.length; i++)\n    {\n        nums.push(Math.round(arr[i] * 1000) / 1000);\n    }\n\n    return nums.join(\",\");\n}\n\nfunction printNode(html, node, level)\n{\n    if (!gltf) return;\n\n    html += \"<tr class=\\\"row\\\">\";\n\n    let ident = \"\";\n    let identSpace = \"\";\n\n    for (let i = 1; i < level; i++)\n    {\n        identSpace += \"&nbsp;&nbsp;&nbsp;\";\n        let identClass = \"identBg\";\n        if (i == 1)identClass = \"identBgLevel0\";\n        ident += \"<td class=\\\"ident \" + identClass + \"\\\" ><div style=\\\"\\\"></div></td>\";\n    }\n    let id = CABLES.uuid();\n    html += ident;\n    html += \"<td colspan=\\\"\" + (21 - level) + \"\\\">\";\n    // html+='<div style=\"display:inline-block;border:0px solid red;height:10px;width:'+level*10+'px\"></div>';\n\n    if (node.mesh && node.mesh.meshes.length)html += \"<span class=\\\"icon icon-cube\\\"></span>&nbsp;\";\n    else html += \"<span class=\\\"icon icon-box-select\\\"></span> &nbsp;\";\n\n    html += node.name + \"</td><td></td>\";\n\n    if (node.mesh)\n    {\n        html += \"<td>\";\n        for (let i = 0; i < node.mesh.meshes.length; i++)\n        {\n            if (i > 0)html += \", \";\n            html += node.mesh.meshes[i].name;\n        }\n\n        html += \"</td>\";\n\n        html += \"<td>\";\n        html += node.hasSkin() || \"-\";\n        html += \"</td>\";\n\n        html += \"<td>\";\n        let countMats = 0;\n        for (let i = 0; i < node.mesh.meshes.length; i++)\n        {\n            if (countMats > 0)html += \", \";\n            if (gltf.json.materials && node.mesh.meshes[i].hasOwnProperty(\"material\"))\n            {\n                if (gltf.json.materials[node.mesh.meshes[i].material])\n                {\n                    html += gltf.json.materials[node.mesh.meshes[i].material].name;\n                    countMats++;\n                }\n            }\n        }\n        if (countMats == 0)html += \"none\";\n        html += \"</td>\";\n    }\n    else\n    {\n        html += \"<td>-</td><td>-</td><td>-</td>\";\n    }\n\n    html += \"<td>\";\n\n    if (node._node.translation || node._node.rotation || node._node.scale)\n    {\n        let info = \"\";\n\n        if (node._node.translation)info += \"Translate: `\" + formatVec(node._node.translation) + \"` || \";\n        if (node._node.rotation)info += \"Rotation: `\" + formatVec(node._node.rotation) + \"` || \";\n        if (node._node.scale)info += \"Scale: `\" + formatVec(node._node.scale) + \"` || \";\n\n        html += \"<span class=\\\"icon icon-gizmo info\\\" data-info=\\\"\" + info + \"\\\"></span> &nbsp;\";\n    }\n\n    if (node._animRot || node._animScale || node._animTrans)\n    {\n        let info = \"Animated: \";\n        if (node._animRot) info += \"Rot \";\n        if (node._animScale) info += \"Scale \";\n        if (node._animTrans) info += \"Trans \";\n\n        html += \"<span class=\\\"icon icon-clock info\\\" data-info=\\\"\" + info + \"\\\"></span>&nbsp;\";\n    }\n\n    if (!node._node.translation && !node._node.rotation && !node._node.scale && !node._animRot && !node._animScale && !node._animTrans) html += \"-\";\n\n    html += \"</td>\";\n\n    html += \"<td>\";\n    let hideclass = \"\";\n    if (node.hidden)hideclass = \"node-hidden\";\n\n    // html+='';\n    html += \"<a onclick=\\\"gui.corePatch().getOpById('\" + op.id + \"').exposeNode('\" + node.name + \"','transform')\\\" class=\\\"treebutton\\\">Transform</a>\";\n    html += \" <a onclick=\\\"gui.corePatch().getOpById('\" + op.id + \"').exposeNode('\" + node.name + \"','hierarchy')\\\" class=\\\"treebutton\\\">Hierarchy</a>\";\n    html += \" <a onclick=\\\"gui.corePatch().getOpById('\" + op.id + \"').exposeNode('\" + node.name + \"')\\\" class=\\\"treebutton\\\">Node</a>\";\n\n    if (node.hasSkin())\n        html += \" <a onclick=\\\"gui.corePatch().getOpById('\" + op.id + \"').exposeNode('\" + node.name + \"',false,{skin:true});\\\" class=\\\"treebutton\\\">Skin</a>\";\n\n    html += \"</td><td>\";\n    html += \"&nbsp;<span class=\\\"icon iconhover icon-eye \" + hideclass + \"\\\" onclick=\\\"gui.corePatch().getOpById('\" + op.id + \"').toggleNodeVisibility('\" + node.name + \"');this.classList.toggle('node-hidden');\\\"></span>\";\n    html += \"</td>\";\n\n    html += \"</tr>\";\n\n    if (node.children)\n    {\n        for (let i = 0; i < node.children.length; i++)\n            html = printNode(html, gltf.nodes[node.children[i]], level + 1);\n    }\n\n    return html;\n}\n\nfunction printMaterial(mat, idx)\n{\n    let html = \"<tr>\";\n    html += \" <td>\" + idx + \"</td>\";\n    html += \" <td>\" + mat.name + \"</td>\";\n    // html+=' <td><a onclick=\"\" class=\"treebutton\">Assign</a><td>';\n\n    html += \" <td>\";\n\n    const info = JSON.stringify(mat, null, 4).replaceAll(\"\\\"\", \"\").replaceAll(\"\\n\", \"<br/>\");\n\n    html += \"<span class=\\\"icon icon-info\\\" onclick=\\\"new CABLES.UI.ModalDialog({ 'html': '<pre>\" + info + \"</pre>', 'title': '\" + mat.name + \"' });\\\"></span>&nbsp;\";\n\n    if (mat.pbrMetallicRoughness && mat.pbrMetallicRoughness.baseColorFactor)\n    {\n        let rgb = \"\";\n        rgb += \"\" + Math.round(mat.pbrMetallicRoughness.baseColorFactor[0] * 255);\n        rgb += \",\" + Math.round(mat.pbrMetallicRoughness.baseColorFactor[1] * 255);\n        rgb += \",\" + Math.round(mat.pbrMetallicRoughness.baseColorFactor[2] * 255);\n\n        html += \"<div style=\\\"width:15px;height:15px;background-color:rgb(\" + rgb + \");display:inline-block\\\">&nbsp;</a>\";\n    }\n    html += \" <td style=\\\"\\\">\" + (gltf.shaders[idx] ? \"-\" : \"<a onclick=\\\"gui.corePatch().getOpById('\" + op.id + \"').assignMaterial('\" + mat.name + \"')\\\" class=\\\"treebutton\\\">Assign</a>\") + \"<td>\";\n    html += \"<td>\";\n\n    html += \"</tr>\";\n    return html;\n}\n\nfunction printInfo()\n{\n    if (!gltf) return;\n\n    const startTime = performance.now();\n    const sizes = {};\n    let html = \"<div style=\\\"overflow:scroll;width:100%;height:100%\\\">\";\n\n    html += \"generator:\" + gltf.json.asset.generator;\n\n    let numNodes = 0;\n    if (gltf.json.nodes)numNodes = gltf.json.nodes.length;\n    html += \"<div id=\\\"groupNodes\\\">Nodes (\" + numNodes + \")</div>\";\n\n    html += \"<table id=\\\"sectionNodes\\\" class=\\\"table treetable\\\">\";\n\n    html += \"<tr>\";\n    html += \" <th colspan=\\\"21\\\">Name</th>\";\n    html += \" <th>Mesh</th>\";\n    html += \" <th>Skin</th>\";\n    html += \" <th>Material</th>\";\n    html += \" <th>Transform</th>\";\n    html += \" <th>Expose</th>\";\n    html += \" <th></th>\";\n    html += \"</tr>\";\n\n    for (let i = 0; i < gltf.nodes.length; i++)\n    {\n        if (!gltf.nodes[i].isChild)\n            html = printNode(html, gltf.nodes[i], 1);\n    }\n    html += \"</table>\";\n\n    // / //////////////////\n\n    let numMaterials = 0;\n    if (gltf.json.materials)numMaterials = gltf.json.materials.length;\n    html += \"<div id=\\\"groupMaterials\\\">Materials (\" + numMaterials + \")</div>\";\n\n    if (!gltf.json.materials || gltf.json.materials.length == 0)\n    {\n    }\n    else\n    {\n        html += \"<table id=\\\"materialtable\\\"  class=\\\"table treetable\\\">\";\n        html += \"<tr>\";\n        html += \" <th>Index</th>\";\n        html += \" <th>Name</th>\";\n        html += \" <th>Color</th>\";\n        html += \" <th>Function</th>\";\n        html += \" <th></th>\";\n        html += \"</tr>\";\n        for (let i = 0; i < gltf.json.materials.length; i++)\n        {\n            html += printMaterial(gltf.json.materials[i], i);\n        }\n        html += \"</table>\";\n    }\n\n    // / ///////////////////////\n\n    html += \"<div id=\\\"groupMeshes\\\">Meshes (\" + gltf.json.meshes.length + \")</div>\";\n\n    html += \"<table id=\\\"meshestable\\\"  class=\\\"table treetable\\\">\";\n    html += \"<tr>\";\n    html += \" <th>Name</th>\";\n    html += \" <th>Node</th>\";\n    html += \" <th>Material</th>\";\n    html += \" <th>Vertices</th>\";\n    html += \" <th>Attributes</th>\";\n    html += \"</tr>\";\n\n    let sizeBufferViews = [];\n    sizes.meshes = 0;\n\n    for (let i = 0; i < gltf.json.meshes.length; i++)\n    {\n        html += \"<tr>\";\n        html += \"<td>\" + gltf.json.meshes[i].name + \"</td>\";\n\n        html += \"<td>\";\n        let count = 0;\n        let nodename = \"\";\n        for (var j = 0; j < gltf.json.nodes.length; j++)\n        {\n            if (gltf.json.nodes[j].mesh == i)\n            {\n                count++;\n                if (count == 1)\n                {\n                    nodename = gltf.json.nodes[j].name;\n                }\n            }\n        }\n        if (count > 1) html += (count) + \" nodes (\" + nodename + \" ...)\";\n        else html += nodename;\n        html += \"</td>\";\n\n        // -------\n\n        html += \"<td>\";\n        for (var j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            if (gltf.json.meshes[i].primitives[j].hasOwnProperty(\"material\"))\n            {\n                if (gltf.json.materials[gltf.json.meshes[i]])\n                {\n                    html += gltf.json.materials[gltf.json.meshes[i].primitives[j].material].name + \" \";\n                }\n            }\n            else html += \"None\";\n        }\n        html += \"</td>\";\n\n        html += \"<td>\";\n        let numVerts = 0;\n        for (var j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            if (gltf.json.meshes[i].primitives[j].attributes.POSITION != undefined)\n            {\n                let v = parseInt(gltf.json.accessors[gltf.json.meshes[i].primitives[j].attributes.POSITION].count);\n                numVerts += v;\n                html += \"\" + v + \"<br/>\";\n            }\n            else html += \"-<br/>\";\n        }\n\n        if (gltf.json.meshes[i].primitives.length > 0)\n            html += \"=\" + numVerts;\n        html += \"</td>\";\n\n        html += \"<td style=\\\"vertical-align:top;\\\">\";\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            html += Object.keys(gltf.json.meshes[i].primitives[j].attributes);\n            html += \" <a onclick=\\\"gui.corePatch().getOpById('\" + op.id + \"').exposeGeom('\" + gltf.json.meshes[i].name + \"',\" + j + \")\\\" class=\\\"treebutton\\\">Geometry</a>\";\n            html += \"<br/>\";\n        }\n        html += \"</td>\";\n        html += \"</tr>\";\n\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            const accessor = gltf.json.accessors[gltf.json.meshes[i].primitives[j].indices];\n            if (accessor)\n            {\n                let bufView = accessor.bufferView;\n\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    if (gltf.json.bufferViews[bufView])sizes.meshes += gltf.json.bufferViews[bufView].byteLength;\n                }\n            }\n\n            for (let k in gltf.json.meshes[i].primitives[j].attributes)\n            {\n                const attr = gltf.json.meshes[i].primitives[j].attributes[k];\n                const bufView2 = gltf.json.accessors[attr].bufferView;\n\n                if (sizeBufferViews.indexOf(bufView2) == -1)\n                {\n                    sizeBufferViews.push(bufView2);\n                    if (gltf.json.bufferViews[bufView2])sizes.meshes += gltf.json.bufferViews[bufView2].byteLength;\n                }\n            }\n        }\n    }\n    html += \"</table>\";\n\n    // / //////////////////////////////////\n\n    let numAnims = 0;\n    if (gltf.json.animations)numAnims = gltf.json.animations.length;\n    html += \"<div id=\\\"groupAnims\\\">Animations (\" + numAnims + \")</div>\";\n\n    if (gltf.json.animations)\n    {\n        html += \"<table id=\\\"sectionAnim\\\" class=\\\"table treetable\\\">\";\n        html += \"<tr>\";\n        html += \"  <th>Name</th>\";\n        html += \"  <th>Target node</th>\";\n        html += \"  <th>Path</th>\";\n        html += \"  <th>Interpolation</th>\";\n        html += \"  <th>Keys</th>\";\n        html += \"</tr>\";\n\n        sizes.animations = 0;\n\n        for (let i = 0; i < gltf.json.animations.length; i++)\n        {\n            for (let j = 0; j < gltf.json.animations[i].samplers.length; j++)\n            {\n                let bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].input].bufferView;\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;\n                }\n\n                bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].output].bufferView;\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;\n                }\n            }\n\n            for (let j = 0; j < gltf.json.animations[i].channels.length; j++)\n            {\n                html += \"<tr>\";\n                html += \"  <td> Anim \" + i + \": \" + gltf.json.animations[i].name + \"</td>\";\n\n                html += \"  <td>\" + gltf.nodes[gltf.json.animations[i].channels[j].target.node].name + \"</td>\";\n                html += \"  <td>\";\n                html += gltf.json.animations[i].channels[j].target.path + \" \";\n                html += \"  </td>\";\n\n                const smplidx = gltf.json.animations[i].channels[j].sampler;\n                const smplr = gltf.json.animations[i].samplers[smplidx];\n\n                html += \"  <td>\" + smplr.interpolation + \"</td>\";\n\n                html += \"  <td>\" + gltf.json.accessors[smplr.output].count;\n\n                html += \"&nbsp;&nbsp;<a onclick=\\\"gui.corePatch().getOpById('\" + op.id + \"').showAnim('\" + i + \"','\" + j + \"')\\\" class=\\\"icon icon-search\\\"></a>\";\n\n                html += \"</td>\";\n\n                html += \"</tr>\";\n            }\n        }\n        html += \"</table>\";\n    }\n    else\n    {\n\n    }\n\n    // / ///////////////////\n\n    let numImages = 0;\n    if (gltf.json.images)numImages = gltf.json.images.length;\n    html += \"<div id=\\\"groupImages\\\">Images (\" + numImages + \")</div>\";\n\n    if (gltf.json.images)\n    {\n        html += \"<table id=\\\"sectionImages\\\" class=\\\"table treetable\\\">\";\n\n        html += \"<tr>\";\n        html += \"  <th>name</th>\";\n        html += \"  <th>type</th>\";\n        html += \"  <th>func</th>\";\n\n        html += \"</tr>\";\n\n        sizes.images = 0;\n\n        for (let i = 0; i < gltf.json.images.length; i++)\n        {\n            if (gltf.json.images[i].bufferView)\n                sizes.images += gltf.json.bufferViews[gltf.json.images[i].bufferView].byteLength;\n\n            html += \"<tr>\";\n            html += \"<td>\" + gltf.json.images[i].name + \"</td>\";\n            html += \"<td>\" + gltf.json.images[i].mimeType + \"</td>\";\n            html += \"<td>\";\n\n            let name = gltf.json.images[i].name;\n            if (name === undefined)name = gltf.json.images[i].bufferView;\n\n            html += \"<a onclick=\\\"gui.corePatch().getOpById('\" + op.id + \"').exposeTexture('\" + name + \"')\\\" class=\\\"treebutton\\\">Expose</a>\";\n            html += \"</td>\";\n\n            html += \"<tr>\";\n        }\n        html += \"</table>\";\n    }\n\n    // / ///////////////////////\n\n    let numCameras = 0;\n    if (gltf.json.cameras)numCameras = gltf.json.cameras.length;\n    html += \"<div id=\\\"groupCameras\\\">Cameras (\" + numCameras + \")</div>\";\n\n    if (gltf.json.cameras)\n    {\n        html += \"<table id=\\\"sectionCameras\\\" class=\\\"table treetable\\\">\";\n\n        html += \"<tr>\";\n        html += \"  <th>name</th>\";\n        html += \"  <th>type</th>\";\n        html += \"  <th>info</th>\";\n        html += \"</tr>\";\n\n        for (let i = 0; i < gltf.json.cameras.length; i++)\n        {\n            html += \"<tr>\";\n            html += \"<td>\" + gltf.json.cameras[i].name + \"</td>\";\n            html += \"<td>\" + gltf.json.cameras[i].type + \"</td>\";\n            html += \"<td>\";\n\n            if (gltf.json.cameras[i].perspective)\n            {\n                html += \"yfov: \" + Math.round(gltf.json.cameras[i].perspective.yfov * 100) / 100;\n                html += \", \";\n                html += \"zfar: \" + Math.round(gltf.json.cameras[i].perspective.zfar * 100) / 100;\n                html += \", \";\n                html += \"znear: \" + Math.round(gltf.json.cameras[i].perspective.znear * 100) / 100;\n            }\n            html += \"</td>\";\n\n            html += \"<tr>\";\n        }\n        html += \"</table>\";\n    }\n\n    // / ////////////////////////////////////\n\n    let numSkins = 0;\n    if (gltf.json.skins)numSkins = gltf.json.skins.length;\n    html += \"<div id=\\\"groupSkins\\\">Skins (\" + numSkins + \")</div>\";\n\n    if (gltf.json.skins)\n    {\n        // html += \"<h3>Skins (\" + gltf.json.skins.length + \")</h3>\";\n        html += \"<table id=\\\"sectionSkins\\\" class=\\\"table treetable\\\">\";\n\n        html += \"<tr>\";\n        html += \"  <th>name</th>\";\n        html += \"  <th></th>\";\n        html += \"  <th>total joints</th>\";\n        html += \"</tr>\";\n\n        for (let i = 0; i < gltf.json.skins.length; i++)\n        {\n            html += \"<tr>\";\n            html += \"<td>\" + gltf.json.skins[i].name + \"</td>\";\n            html += \"<td>\" + \"</td>\";\n            html += \"<td>\" + gltf.json.skins[i].joints.length + \"</td>\";\n            html += \"<td>\";\n            html += \"</td>\";\n            html += \"<tr>\";\n        }\n        html += \"</table>\";\n    }\n\n    // / //////////////////////////\n\n    let sizeBin = 0;\n    if (gltf.json.buffers)\n        sizeBin = gltf.json.buffers[0].byteLength;\n\n    html += \"<div id=\\\"groupBinary\\\">File Size Allocation (\" + Math.round(sizeBin / 1024) + \"k )</div>\";\n\n    html += \"<table id=\\\"sectionBinary\\\" class=\\\"table treetable\\\">\";\n    html += \"<tr>\";\n    html += \"  <th>name</th>\";\n    html += \"  <th>size</th>\";\n    html += \"  <th>%</th>\";\n    html += \"</tr>\";\n    let sizeUnknown = sizeBin;\n    for (let i in sizes)\n    {\n        // html+=i+':'+Math.round(sizes[i]/1024);\n        html += \"<tr>\";\n        html += \"<td>\" + i + \"</td>\";\n        html += \"<td>\" + readableSize(sizes[i]) + \" </td>\";\n        html += \"<td>\" + Math.round(sizes[i] / sizeBin * 100) + \"% </td>\";\n        html += \"<tr>\";\n        sizeUnknown -= sizes[i];\n    }\n\n    if (sizeUnknown != 0)\n    {\n        html += \"<tr>\";\n        html += \"<td>unknown</td>\";\n        html += \"<td>\" + readableSize(sizeUnknown) + \" </td>\";\n        html += \"<td>\" + Math.round(sizeUnknown / sizeBin * 100) + \"% </td>\";\n        html += \"<tr>\";\n    }\n\n    html += \"</table>\";\n    html += \"</div>\";\n\n    tab = new CABLES.UI.Tab(\"GLTF\", { \"icon\": \"cube\", \"infotext\": \"tab_gltf\", \"padding\": true, \"singleton\": true });\n    gui.mainTabs.addTab(tab, true);\n\n    tab.addEventListener(\"onClose\", closeTab);\n    tab.html(html);\n\n    CABLES.UI.Collapsable.setup(ele.byId(\"groupNodes\"), ele.byId(\"sectionNodes\"), false);\n    CABLES.UI.Collapsable.setup(ele.byId(\"groupMaterials\"), ele.byId(\"materialtable\"), true);\n    CABLES.UI.Collapsable.setup(ele.byId(\"groupAnims\"), ele.byId(\"sectionAnim\"), true);\n    CABLES.UI.Collapsable.setup(ele.byId(\"groupMeshes\"), ele.byId(\"meshestable\"), true);\n    CABLES.UI.Collapsable.setup(ele.byId(\"groupCameras\"), ele.byId(\"sectionCameras\"), true);\n    CABLES.UI.Collapsable.setup(ele.byId(\"groupImages\"), ele.byId(\"sectionImages\"), true);\n    CABLES.UI.Collapsable.setup(ele.byId(\"groupSkins\"), ele.byId(\"sectionSkins\"), true);\n    CABLES.UI.Collapsable.setup(ele.byId(\"groupBinary\"), ele.byId(\"sectionBinary\"), true);\n\n    gui.maintabPanel.show(true);\n}\n\nfunction readableSize(n)\n{\n    if (n > 1024) return Math.round(n / 1024) + \" kb\";\n    if (n > 1024 * 500) return Math.round(n / 1024) + \" mb\";\n    else return n + \" bytes\";\n}\n","inc_skin_js":"const GltfSkin = class\n{\n    constructor(node)\n    {\n        this._mod = null;\n        this._node = node;\n        this._lastTime = 0;\n        this._matArr = [];\n        this._m = mat4.create();\n        this._invBindMatrix = mat4.create();\n        this.identity = true;\n    }\n\n    renderFinish(cgl)\n    {\n        cgl.popModelMatrix();\n        this._mod.unbind();\n    }\n\n    renderStart(cgl, time)\n    {\n        if (!this._mod)\n        {\n            this._mod = new CGL.ShaderModifier(cgl, op.name + this._node.name);\n\n            this._mod.addModule({\n                \"priority\": -2,\n                \"name\": \"MODULE_VERTEX_POSITION\",\n                \"srcHeadVert\": attachments.skin_head_vert || \"\",\n                \"srcBodyVert\": attachments.skin_vert || \"\"\n            });\n\n            this._mod.addUniformVert(\"m4[]\", \"MOD_boneMats\", []);// bohnenmatze\n            const tr = vec3.create();\n        }\n\n        const skinIdx = this._node.skin;\n        const arrLength = gltf.json.skins[skinIdx].joints.length * 16;\n\n        // if (this._lastTime != time || !time)\n        {\n            // this._lastTime=inTime.get();\n            if (this._matArr.length != arrLength) this._matArr.length = arrLength;\n\n            for (let i = 0; i < gltf.json.skins[skinIdx].joints.length; i++)\n            {\n                const i16 = i * 16;\n                const jointIdx = gltf.json.skins[skinIdx].joints[i];\n                const nodeJoint = gltf.nodes[jointIdx];\n\n                for (let j = 0; j < 16; j++)\n                    this._invBindMatrix[j] = gltf.accBuffers[gltf.json.skins[skinIdx].inverseBindMatrices][i16 + j];\n\n                mat4.mul(this._m, nodeJoint.modelMatAbs(), this._invBindMatrix);\n\n                for (let j = 0; j < this._m.length; j++) this._matArr[i16 + j] = this._m[j];\n            }\n\n            this._mod.setUniformValue(\"MOD_boneMats\", this._matArr);\n            this._lastTime = time;\n        }\n\n        this._mod.define(\"SKIN_NUM_BONES\", gltf.json.skins[skinIdx].joints.length);\n        this._mod.bind();\n\n        // draw mesh...\n        cgl.pushModelMatrix();\n        if (this.identity)mat4.identity(cgl.mMatrix);\n    }\n};\n","skin_vert":"int index=int(attrJoints.x);\nvec4 newPos = (MOD_boneMats[index] * pos) * attrWeights.x;\nvec3 newNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.x).xyz);\n\nindex=int(attrJoints.y);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.y;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.y).xyz)+newNorm;\n\nindex=int(attrJoints.z);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.z;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.z).xyz)+newNorm;\n\nindex=int(attrJoints.w);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.w ;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.w).xyz)+newNorm;\n\npos=newPos;\n\nnorm=normalize(newNorm.xyz);\n\n\n","skin_head_vert":"\nIN vec4 attrWeights;\nIN vec4 attrJoints;\nUNI mat4 MOD_boneMats[SKIN_NUM_BONES];\n",};
const gltfCamera = class
{
    constructor(gltf, node)
    {
        this.node=node;
        this.name=node.name;
        // console.log(gltf);
        this.config=gltf.json.cameras[node.camera];

        this.pos = vec3.create();
        this.quat = quat.create();
        this.quatOr = quat.create();
        this.vCenter = vec3.create();
        this.vUp = vec3.create();
        this.vMat = mat4.create();

    }

    updateAnim(time)
    {
        if (this.node && this.node._animTrans)
        {

            vec3.set(this.pos,
                this.node._animTrans[0].getValue(time),
                this.node._animTrans[1].getValue(time),
                this.node._animTrans[2].getValue(time));

            quat.set(this.quat,
                this.node._animRot[0].getValue(time),
                this.node._animRot[1].getValue(time),
                this.node._animRot[2].getValue(time),
                this.node._animRot[3].getValue(time));
        }
    }

    start(time)
    {
        if (cgl.frameStore.shadowPass) return;

        this.updateAnim(time);
        const asp = cgl.getViewPort()[2] / cgl.getViewPort()[3];

        cgl.pushPMatrix();
        // mat4.perspective(
        //     cgl.pMatrix,
        //     this.config.perspective.yfov*0.5,
        //     asp,
        //     this.config.perspective.znear,
        //     this.config.perspective.zfar);

        cgl.pushViewMatrix();
        // mat4.identity(cgl.vMatrix);

        // if(this.node && this.node.parent)
        // {
        //     console.log(this.node.parent)
            // vec3.add(this.pos,this.pos,this.node.parent._node.translation);
            // vec3.sub(this.vCenter,this.vCenter,this.node.parent._node.translation);
            // mat4.translate(cgl.vMatrix,cgl.vMatrix,
            // [
            //     -this.node.parent._node.translation[0],
            //     -this.node.parent._node.translation[1],
            //     -this.node.parent._node.translation[2]
            // ])
        // }



        // vec3.set(this.vUp, 0, 1, 0);
        // vec3.set(this.vCenter, 0, -1, 0);
        // // vec3.set(this.vCenter, 0, 1, 0);
        // vec3.transformQuat(this.vCenter, this.vCenter, this.quat);
        // vec3.normalize(this.vCenter, this.vCenter);
        // vec3.add(this.vCenter, this.vCenter, this.pos);


        // mat4.lookAt(cgl.vMatrix, this.pos, this.vCenter, this.vUp);


        let mv=mat4.create();
        mat4.invert(mv,this.node.modelMatAbs());

        // console.log(this.node.modelMatAbs());

        this.vMat=mv;

        mat4.identity(cgl.vMatrix);
        // console.log(mv);
        mat4.mul(cgl.vMatrix,cgl.vMatrix,mv);


    }

    end()
    {
        if (cgl.frameStore.shadowPass) return;
        cgl.popPMatrix();
        cgl.popViewMatrix();
    }
};

const CHUNK_HEADER_SIZE = 8;

const Gltf = class
{
    constructor()
    {
        this.json = {};
        this.accBuffers = [];
        this.meshes = [];
        this.nodes = [];
        this.shaders = [];
        this.timing = [];
        this.cams = [];
        this.startTime = performance.now();
        this.bounds = new CABLES.CG.BoundingBox();
        this.loaded = Date.now();
        this.accBuffersDelete = [];
    }

    getNode(n)
    {
        for (let i = 0; i < this.nodes.length; i++)
        {
            if (this.nodes[i].name == n) return this.nodes[i];
        }
    }

    unHideAll()
    {
        for (let i = 0; i < this.nodes.length; i++)
        {
            this.nodes[i].unHide();
        }
    }
};

function Utf8ArrayToStr(array)
{
    if (window.TextDecoder) return new TextDecoder("utf-8").decode(array);

    let out, i, len, c;
    let char2, char3;

    out = "";
    len = array.length;
    i = 0;
    while (i < len)
    {
        c = array[i++];
        switch (c >> 4)
        {
        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
            // 0xxxxxxx
            out += String.fromCharCode(c);
            break;
        case 12: case 13:
            // 110x xxxx   10xx xxxx
            char2 = array[i++];
            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
            break;
        case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode(((c & 0x0F) << 12) |
                    ((char2 & 0x3F) << 6) |
                    ((char3 & 0x3F) << 0));
            break;
        }
    }

    return out;
}

function readChunk(dv, bArr, arrayBuffer, offset)
{
    const chunk = {};

    if (offset >= dv.byteLength)
    {
        op.log("could not read chunk...");
        return;
    }
    chunk.size = dv.getUint32(offset + 0, le);

    // chunk.type = new TextDecoder("utf-8").decode(bArr.subarray(offset+4, offset+4+4));
    chunk.type = Utf8ArrayToStr(bArr.subarray(offset + 4, offset + 4 + 4));

    if (chunk.type == "BIN\0")
    {
        // console.log(chunk.size,arrayBuffer.length,offset);
        // try
        // {
        chunk.dataView = new DataView(arrayBuffer, offset + 8, chunk.size);
        // }
        // catch(e)
        // {
        //     chunk.dataView = null;
        //     console.log(e);
        // }
    }
    else
    if (chunk.type == "JSON")
    {
        const json = Utf8ArrayToStr(bArr.subarray(offset + 8, offset + 8 + chunk.size));

        try
        {
            const obj = JSON.parse(json);
            chunk.data = obj;
            outGenerator.set(obj.asset.generator);
        }
        catch (e)
        {
        }
    }
    else
    {
        op.warn("unknown type", chunk.type);
    }

    return chunk;
}

function loadAnims(gltf)
{
    const uniqueAnimNames = {};

    for (let i = 0; i < gltf.json.animations.length; i++)
    {
        const an = gltf.json.animations[i];

        for (let ia = 0; ia < an.channels.length; ia++)
        {
            const chan = an.channels[ia];

            const node = gltf.nodes[chan.target.node];
            const sampler = an.samplers[chan.sampler];

            const acc = gltf.json.accessors[sampler.input];
            const bufferIn = gltf.accBuffers[sampler.input];

            const accOut = gltf.json.accessors[sampler.output];
            const bufferOut = gltf.accBuffers[sampler.output];

            gltf.accBuffersDelete.push(sampler.output, sampler.input);

            if (bufferIn && bufferOut)
            {
                let numComps = 1;
                if (accOut.type == "VEC2")numComps = 2;
                else if (accOut.type == "VEC3")numComps = 3;
                else if (accOut.type == "VEC4")numComps = 4;
                else op.warn("unknown accOut.type", accOut.type);

                const anims = [];

                uniqueAnimNames[an.name] = true;

                for (let k = 0; k < numComps; k++)
                {
                    const newAnim = new CABLES.TL.Anim();
                    // newAnim.name=an.name;
                    anims.push(newAnim);
                }

                if (sampler.interpolation == "LINEAR") {}
                else if (sampler.interpolation == "STEP") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_ABSOLUTE;
                else if (sampler.interpolation == "CUBICSPLINE") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_CUBICSPLINE;
                else op.warn("unknown interpolation", sampler.interpolation);

                // console.log(bufferOut)

                // if there is no keyframe for time 0 copy value of first keyframe at time 0
                if (bufferIn[0] !== 0.0)
                    for (let k = 0; k < numComps; k++)
                        anims[k].setValue(0, bufferOut[0 * numComps + k]);

                // console.log(sampler.interpolation,bufferOut.length/numComps)

                for (let j = 0; j < bufferIn.length; j++)
                {
                    maxTime = Math.max(bufferIn[j], maxTime);

                    for (let k = 0; k < numComps; k++)
                    {
                        if (anims[k].defaultEasing === CABLES.EASING_CUBICSPLINE)
                        {
                            const idx = ((j * numComps) * 3 + k);

                            const key = anims[k].setValue(bufferIn[j], bufferOut[idx + numComps]);
                            key.bezTangIn = bufferOut[idx];
                            key.bezTangOut = bufferOut[idx + (numComps * 2)];

                            // console.log(an.name,k,bufferOut[idx+1]);
                        }
                        else
                        {
                            // console.log(an.name,k,bufferOut[j * numComps + k]);
                            anims[k].setValue(bufferIn[j], bufferOut[j * numComps + k]);
                        }
                    }
                }

                node.setAnim(chan.target.path, an.name, anims);
            }
            else
            {
                op.warn("loadAmins bufferIn undefined ", bufferIn === undefined);
                op.warn("loadAmins bufferOut undefined ", bufferOut === undefined);
                op.warn("loadAmins ", sampler, accOut);
                op.warn("loadAmins num accBuffers", gltf.accBuffers.length);
                op.warn("loadAmins num accessors", gltf.json.accessors.length);
            }
        }
    }

    gltf.uniqueAnimNames = uniqueAnimNames;

    outAnims.set(null);
    outAnims.set(Object.keys(uniqueAnimNames));
}

function loadCams(gltf)
{
    if (!gltf || !gltf.json.cameras) return;

    gltf.cameras = gltf.cameras || [];

    for (let i = 0; i < gltf.nodes.length; i++)
    {
        if (gltf.nodes[i].hasOwnProperty("camera"))
        {
            const cam = new gltfCamera(gltf, gltf.nodes[i]);
            gltf.cameras.push(cam);
        }
    }
}

function loadAfterDraco()
{
    if (!window.DracoDecoder)
    {
        setTimeout(() =>
        {
            loadAfterDraco();
        }, 100);
    }

    reloadSoon();
}

function parseGltf(arrayBuffer)
{
    let j = 0, i = 0;

    const gltf = new Gltf();
    gltf.timing.push("Start parsing", Math.round((performance.now() - gltf.startTime)));

    if (!arrayBuffer) return;
    const byteArray = new Uint8Array(arrayBuffer);
    let pos = 0;

    // var string = new TextDecoder("utf-8").decode(byteArray.subarray(pos, 4));
    const string = Utf8ArrayToStr(byteArray.subarray(pos, 4));
    pos += 4;
    if (string != "glTF") return;

    gltf.timing.push("dataview", Math.round((performance.now() - gltf.startTime)));

    const dv = new DataView(arrayBuffer);
    const version = dv.getUint32(pos, le);
    pos += 4;
    const size = dv.getUint32(pos, le);
    pos += 4;

    outVersion.set(version);

    const chunks = [];
    gltf.chunks = chunks;

    chunks.push(readChunk(dv, byteArray, arrayBuffer, pos));
    pos += chunks[0].size + CHUNK_HEADER_SIZE;
    gltf.json = chunks[0].data;
    outJson.set(gltf.json);
    outExtensions.set(gltf.json.extensionsUsed || []);

    let ch = readChunk(dv, byteArray, arrayBuffer, pos);
    while (ch)
    {
        chunks.push(ch);
        pos += ch.size + CHUNK_HEADER_SIZE;
        ch = readChunk(dv, byteArray, arrayBuffer, pos);
    }

    gltf.chunks = chunks;

    const views = chunks[0].data.bufferViews;
    const accessors = chunks[0].data.accessors;

    gltf.timing.push("Parse buffers", Math.round((performance.now() - gltf.startTime)));

    if (gltf.json.extensionsUsed && gltf.json.extensionsUsed.indexOf("KHR_draco_mesh_compression") > -1)
    {
        if (!window.DracoDecoder)
        {
            op.setUiError("gltfdraco", "GLTF draco compression lib not found / add draco op to your patch!");

            loadAfterDraco();
            return gltf;
        }
        else
        {
            gltf.useDraco = true;
        }
    }

    op.setUiError("gltfdraco", null);
    // let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);

    if (views)
    {
        for (i = 0; i < accessors.length; i++)
        {
            const acc = accessors[i];
            const view = views[acc.bufferView];

            let numComps = 0;
            if (acc.type == "SCALAR")numComps = 1;
            else if (acc.type == "VEC2")numComps = 2;
            else if (acc.type == "VEC3")numComps = 3;
            else if (acc.type == "VEC4")numComps = 4;
            else if (acc.type == "MAT4")numComps = 16;
            else console.error("unknown accessor type", acc.type);

            //   const decoder = new decoderModule.Decoder();
            //   const decodedGeometry = decodeDracoData(data, decoder);
            //   // Encode mesh
            //   encodeMeshToFile(decodedGeometry, decoder);

            //   decoderModule.destroy(decoder);
            //   decoderModule.destroy(decodedGeometry);

            // 5120 (BYTE)	1
            // 5121 (UNSIGNED_BYTE)	1
            // 5122 (SHORT)	2

            if (chunks[1].dataView)
            {
                if (view)
                {
                    const num = acc.count * numComps;
                    let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);
                    let stride = view.byteStride || 0;
                    let dataBuff = null;

                    if (acc.componentType == 5126 || acc.componentType == 5125) // 4byte FLOAT or INT
                    {
                        stride = stride || 4;

                        const isInt = acc.componentType == 5125;
                        if (isInt)dataBuff = new Uint32Array(num);
                        else dataBuff = new Float32Array(num);

                        for (j = 0; j < num; j++)
                        {
                            if (isInt) dataBuff[j] = chunks[1].dataView.getUint32(accPos, le);
                            else dataBuff[j] = chunks[1].dataView.getFloat32(accPos, le);

                            if (stride != 4 && (j + 1) % numComps === 0)accPos += stride - (numComps * 4);
                            accPos += 4;
                        }
                    }
                    else if (acc.componentType == 5123) // UNSIGNED_SHORT
                    {
                        stride = stride || 2;

                        dataBuff = new Uint16Array(num);

                        for (j = 0; j < num; j++)
                        {
                            dataBuff[j] = chunks[1].dataView.getUint16(accPos, le);

                            if (stride != 2 && (j + 1) % numComps === 0) accPos += stride - (numComps * 2);

                            accPos += 2;
                        }
                    }
                    else if (acc.componentType == 5121) // UNSIGNED_BYTE
                    {
                        stride = stride || 1;

                        dataBuff = new Uint8Array(num);

                        for (j = 0; j < num; j++)
                        {
                            dataBuff[j] = chunks[1].dataView.getUint8(accPos, le);

                            if (stride != 1 && (j + 1) % numComps === 0) accPos += stride - (numComps * 1);

                            accPos += 1;
                        }
                    }

                    else
                    {
                        console.error("unknown component type", acc.componentType);
                    }

                    gltf.accBuffers.push(dataBuff);
                }
                else
                {
                    // console.log("has no dataview");
                }
            }
        }
    }

    gltf.timing.push("Parse mesh groups", Math.round((performance.now() - gltf.startTime)));

    gltf.json.meshes = gltf.json.meshes || [];

    if (gltf.json.meshes)
    {
        for (i = 0; i < gltf.json.meshes.length; i++)
        {
            const mesh = new gltfMeshGroup(gltf, gltf.json.meshes[i]);
            gltf.meshes.push(mesh);
        }
    }

    gltf.timing.push("Parse nodes", Math.round((performance.now() - gltf.startTime)));

    for (i = 0; i < gltf.json.nodes.length; i++)
    {
        if (gltf.json.nodes[i].children)
            for (j = 0; j < gltf.json.nodes[i].children.length; j++)
            {
                gltf.json.nodes[gltf.json.nodes[i].children[j]].isChild = true;
            }
    }

    for (i = 0; i < gltf.json.nodes.length; i++)
    {
        const node = new gltfNode(gltf.json.nodes[i], gltf);
        gltf.nodes.push(node);
    }

    for (i = 0; i < gltf.nodes.length; i++)
    {
        const node = gltf.nodes[i];

        if (!node.children) continue;
        for (let j = 0; j < node.children.length; j++)
        {
            gltf.nodes[node.children[j]].parent = node;
        }
    }

    for (i = 0; i < gltf.nodes.length; i++)
    {
        gltf.nodes[i].initSkin();
    }

    needsMatUpdate = true;

    gltf.timing.push("load anims", Math.round((performance.now() - gltf.startTime)));

    if (gltf.json.animations) loadAnims(gltf);

    gltf.timing.push("load cameras", Math.round((performance.now() - gltf.startTime)));

    if (gltf.json.cameras) loadCams(gltf);

    gltf.timing.push("finished", Math.round((performance.now() - gltf.startTime)));

    return gltf;
}
let gltfMesh = class
{
    constructor(name, prim, gltf, finished)
    {
        this.POINTS = 0;
        this.LINES = 1;
        this.LINE_LOOP = 2;
        this.LINE_STRIP = 3;
        this.TRIANGLES = 4;
        this.TRIANGLE_STRIP = 5;
        this.TRIANGLE_FAN = 6;

        this.test = 0;
        this.name = name;
        this.submeshIndex = 0;
        this.material = prim.material;
        this.mesh = null;
        this.geom = new CGL.Geometry("gltf_" + this.name);
        this.geom.verticesIndices = [];
        this.bounds = null;
        this.primitive = 4;
        if (prim.hasOwnProperty("mode")) this.primitive = prim.mode;

        if (prim.hasOwnProperty("indices")) this.geom.verticesIndices = gltf.accBuffers[prim.indices];

        gltf.loadingMeshes = gltf.loadingMeshes || 0;
        gltf.loadingMeshes++;

        this.materialJson =
            this._matPbrMetalness =
            this._matPbrRoughness =
            this._matDiffuseColor = null;

        if (gltf.json.materials)
        {
            if (this.material != -1) this.materialJson = gltf.json.materials[this.material];

            if (this.materialJson && this.materialJson.pbrMetallicRoughness)
            {
                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("baseColorFactor"))
                {
                    this._matDiffuseColor = [1, 1, 1, 1];
                }
                else
                {
                    this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;
                }

                this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;

                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("metallicFactor"))
                {
                    this._matPbrMetalness = 1.0;
                }
                else
                {
                    this._matPbrMetalness = this.materialJson.pbrMetallicRoughness.metallicFactor || null;
                }

                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("roughnessFactor"))
                {
                    this._matPbrRoughness = 1.0;
                }
                else
                {
                    this._matPbrRoughness = this.materialJson.pbrMetallicRoughness.roughnessFactor || null;
                }
            }
        }

        if (gltf.useDraco && prim.extensions.KHR_draco_mesh_compression)
        {
            const view = gltf.chunks[0].data.bufferViews[prim.extensions.KHR_draco_mesh_compression.bufferView];
            const num = view.byteLength;
            const dataBuff = new Int8Array(num);
            let accPos = (view.byteOffset || 0);// + (acc.byteOffset || 0);
            for (let j = 0; j < num; j++)
            {
                dataBuff[j] = gltf.chunks[1].dataView.getInt8(accPos, le);
                accPos++;
            }

            const dracoDecoder = window.DracoDecoder;
            dracoDecoder.decodeGeometry(dataBuff.buffer, (geometry) =>
            {
                const geom = new CGL.Geometry("draco mesh " + name);

                for (let i = 0; i < geometry.attributes.length; i++)
                {
                    const attr = geometry.attributes[i];

                    if (attr.name === "position") geom.vertices = attr.array;
                    else if (attr.name === "normal") geom.vertexNormals = attr.array;
                    else if (attr.name === "uv") geom.texCoords = attr.array;
                    else if (attr.name === "color") geom.vertexColors = this.calcVertexColors(attr.array);
                    else if (attr.name === "joints") geom.setAttribute("attrJoints", Array.from(attr.array), 4);
                    else if (attr.name === "weights")
                    {
                        const arr4 = new Float32Array(attr.array.length / attr.itemSize * 4);

                        for (let k = 0; k < attr.array.length / attr.itemSize; k++)
                        {
                            arr4[k * 4] = arr4[k * 4 + 1] = arr4[k * 4 + 2] = arr4[k * 4 + 3] = 0;
                            for (let j = 0; j < attr.itemSize; j++)
                                arr4[k * 4 + j] = attr.array[k * attr.itemSize + j];
                        }
                        geom.setAttribute("attrWeights", arr4, 4);
                    }
                    else op.logWarn("unknown draco attrib", attr);
                }

                geometry.attributes = null;
                geom.verticesIndices = geometry.index.array;

                this.setGeom(geom);

                this.mesh = null;
                gltf.loadingMeshes--;
                if (finished)finished(this);
            }, (error) => { op.logError(error); });
        }
        else
        {
            gltf.loadingMeshes--;
            this.fillGeomAttribs(gltf, this.geom, prim.attributes);

            if (prim.targets)
            {
                console.log("prim.targets", prim.targets.length);
                for (let j = 0; j < prim.targets.length; j++)
                {
                    // var tgeom=new CGL.Geometry("gltf_"+this.name);
                    let tgeom = this.geom.copy();

                    if (prim.hasOwnProperty("indices")) tgeom.verticesIndices = gltf.accBuffers[prim.indices];

                    this.fillGeomAttribs(gltf, tgeom, prim.targets[j], false);

                    { // calculate normals for final position of morphtarget for later...
                        for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] += this.geom.vertices[i];
                        tgeom.calculateNormals();
                        for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] -= this.geom.vertices[i];
                    }

                    this.geom.morphTargets.push(tgeom);
                }
            }
            if (finished)finished(this);
        }
    }

    _linearToSrgb(x)
    {
        if (x <= 0)
            return 0;
        else if (x >= 1)
            return 1;
        else if (x < 0.0031308)
            return x * 12.92;
        else
            return Math.pow(x, 1 / 2.2) * 1.055 - 0.055;
    }

    calcVertexColors(arr)
    {
        let vertexColors = null;
        if (arr instanceof Float32Array)
        {
            let div = false;
            for (let i = 0; i < arr.length; i++)
            {
                if (arr[i] > 1)
                {
                    div = true;
                    continue;
                }
            }

            if (div)
                for (let i = 0; i < arr.length; i++) arr[i] /= 65535;

            vertexColors = arr;
        }

        else if (arr instanceof Uint16Array)
        {
            const fb = new Float32Array(arr.length);
            for (let i = 0; i < arr.length; i++) fb[i] = arr[i] / 65535;

            vertexColors = fb;
        }
        else vertexColors = arr;

        for (let i = 0; i < vertexColors.length; i++)
        {
            vertexColors[i] = this._linearToSrgb(vertexColors[i]);
        }

        return vertexColors;
    }

    fillGeomAttribs(gltf, tgeom, attribs, setGeom)
    {
        if (attribs.hasOwnProperty("POSITION")) tgeom.vertices = gltf.accBuffers[attribs.POSITION];
        if (attribs.hasOwnProperty("NORMAL")) tgeom.vertexNormals = gltf.accBuffers[attribs.NORMAL];
        if (attribs.hasOwnProperty("TANGENT")) tgeom.tangents = gltf.accBuffers[attribs.TANGENT];

        if (attribs.hasOwnProperty("COLOR_0")) tgeom.vertexColors = this.calcVertexColors(gltf.accBuffers[attribs.COLOR_0]);
        if (attribs.hasOwnProperty("COLOR_1")) tgeom.setAttribute("attrVertColor1", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_1]), 4);
        if (attribs.hasOwnProperty("COLOR_2")) tgeom.setAttribute("attrVertColor2", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_2]), 4);
        if (attribs.hasOwnProperty("COLOR_3")) tgeom.setAttribute("attrVertColor3", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_3]), 4);
        if (attribs.hasOwnProperty("COLOR_4")) tgeom.setAttribute("attrVertColor4", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_4]), 4);

        if (attribs.hasOwnProperty("TEXCOORD_0"))tgeom.texCoords = gltf.accBuffers[attribs.TEXCOORD_0];
        if (attribs.hasOwnProperty("TEXCOORD_1"))tgeom.setAttribute("attrTexCoord1", gltf.accBuffers[attribs.TEXCOORD_1], 2);
        if (attribs.hasOwnProperty("TEXCOORD_2"))tgeom.setAttribute("attrTexCoord2", gltf.accBuffers[attribs.TEXCOORD_2], 2);
        if (attribs.hasOwnProperty("TEXCOORD_3"))tgeom.setAttribute("attrTexCoord3", gltf.accBuffers[attribs.TEXCOORD_3], 2);
        if (attribs.hasOwnProperty("TEXCOORD_4"))tgeom.setAttribute("attrTexCoord4", gltf.accBuffers[attribs.TEXCOORD_4], 2);

        if (attribs.hasOwnProperty("WEIGHTS_0"))
        {
            tgeom.setAttribute("attrWeights", gltf.accBuffers[attribs.WEIGHTS_0], 4);
        }
        if (attribs.hasOwnProperty("JOINTS_0"))
        {
            if (!gltf.accBuffers[attribs.JOINTS_0])console.log("no !gltf.accBuffers[attribs.JOINTS_0]");
            tgeom.setAttribute("attrJoints", gltf.accBuffers[attribs.JOINTS_0], 4);
        }

        if (attribs.hasOwnProperty("POSITION")) gltf.accBuffersDelete.push(attribs.POSITION);
        if (attribs.hasOwnProperty("NORMAL")) gltf.accBuffersDelete.push(attribs.NORMAL);
        if (attribs.hasOwnProperty("TEXCOORD_0")) gltf.accBuffersDelete.push(attribs.TEXCOORD_0);
        if (attribs.hasOwnProperty("TANGENT")) gltf.accBuffersDelete.push(attribs.TANGENT);
        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);
        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);
        if (attribs.hasOwnProperty("COLOR_1"))gltf.accBuffersDelete.push(attribs.COLOR_1);
        if (attribs.hasOwnProperty("COLOR_2"))gltf.accBuffersDelete.push(attribs.COLOR_2);
        if (attribs.hasOwnProperty("COLOR_3"))gltf.accBuffersDelete.push(attribs.COLOR_3);

        if (attribs.hasOwnProperty("TEXCOORD_1")) gltf.accBuffersDelete.push(attribs.TEXCOORD_1);
        if (attribs.hasOwnProperty("TEXCOORD_2")) gltf.accBuffersDelete.push(attribs.TEXCOORD_2);
        if (attribs.hasOwnProperty("TEXCOORD_3")) gltf.accBuffersDelete.push(attribs.TEXCOORD_3);
        if (attribs.hasOwnProperty("TEXCOORD_4")) gltf.accBuffersDelete.push(attribs.TEXCOORD_4);

        if (setGeom !== false) if (tgeom && tgeom.verticesIndices) this.setGeom(tgeom);
    }

    setGeom(geom)
    {
        if (inNormFormat.get() == "X-ZY")
        {
            for (let i = 0; i < geom.vertexNormals.length; i += 3)
            {
                let t = geom.vertexNormals[i + 2];
                geom.vertexNormals[i + 2] = geom.vertexNormals[i + 1];
                geom.vertexNormals[i + 1] = -t;
            }
        }

        if (inVertFormat.get() == "XZ-Y")
        {
            for (let i = 0; i < geom.vertices.length; i += 3)
            {
                let t = geom.vertices[i + 2];
                geom.vertices[i + 2] = -geom.vertices[i + 1];
                geom.vertices[i + 1] = t;
            }
        }

        if (this.primitive == this.TRIANGLES)
        {
            if (!geom.vertexNormals.length || inCalcNormals.get()) geom.calculateNormals();

            if ((!geom.biTangents || geom.biTangents.length == 0) && geom.tangents)
            {
                const bitan = vec3.create();
                const tan = vec3.create();

                const tangents = geom.tangents;
                geom.tangents = new Float32Array(tangents.length / 4 * 3);
                geom.biTangents = new Float32Array(tangents.length / 4 * 3);

                for (let i = 0; i < tangents.length; i += 4)
                {
                    const idx = i / 4 * 3;

                    vec3.cross(
                        bitan,
                        [geom.vertexNormals[idx], geom.vertexNormals[idx + 1], geom.vertexNormals[idx + 2]],
                        [tangents[i], tangents[i + 1], tangents[i + 2]]
                    );

                    vec3.div(bitan, bitan, [tangents[i + 3], tangents[i + 3], tangents[i + 3]]);
                    vec3.normalize(bitan, bitan);

                    geom.biTangents[idx + 0] = bitan[0];
                    geom.biTangents[idx + 1] = bitan[1];
                    geom.biTangents[idx + 2] = bitan[2];

                    geom.tangents[idx + 0] = tangents[i + 0];
                    geom.tangents[idx + 1] = tangents[i + 1];
                    geom.tangents[idx + 2] = tangents[i + 2];
                }
            }

            if (geom.tangents.length === 0 || inCalcNormals.get()) geom.calcTangentsBitangents();
        }

        this.geom = geom;

        this.bounds = geom.getBounds();
    }

    render(cgl, ignoreMaterial, skinRenderer)
    {
        if (!this.mesh && this.geom && this.geom.verticesIndices)
        {
            let g = this.geom;
            if (this.geom.vertices.length / 3 > 64000)
            {
                g = this.geom.copy();
                g.unIndex(false, true);
            }

            let glprim;
            if (this.primitive == this.TRIANGLES)glprim = cgl.gl.TRIANGLES;
            else if (this.primitive == this.LINES)glprim = cgl.gl.LINES;
            else if (this.primitive == this.LINE_STRIP)glprim = cgl.gl.LINE_STRIP;
            else if (this.primitive == this.POINTS)glprim = cgl.gl.POINTS;
            else
            {
                op.logWarn("unknown primitive type", this);
            }

            this.mesh = new CGL.Mesh(cgl, g, glprim);
            // this.mesh._geom = null;
        }
        else
        {
            // update morphTargets
            if (this.geom && this.geom.morphTargets.length)
            {
                this.morphGeom = this.geom.copy();

                this.test = time * 11.7;

                if (this.test >= this.geom.morphTargets.length - 1) this.test = 0;

                const mt = this.geom.morphTargets[Math.floor(this.test)];
                const mt2 = this.geom.morphTargets[Math.floor(this.test + 1)];

                if (mt && mt.vertices && mt2)
                {
                    if (this.morphGeom.vertexNormals.length != mt.vertexNormals.length)
                        this.morphGeom.vertexNormals = new Float32Array(mt.vertexNormals.length);

                    const fract = this.test % 1;
                    for (let i = 0; i < this.morphGeom.vertices.length; i++)
                    {
                        this.morphGeom.vertices[i] =
                            this.geom.vertices[i] +
                            (1.0 - fract) * mt.vertices[i] +
                            fract * mt2.vertices[i];

                        this.morphGeom.vertexNormals[i] =
                            (1.0 - fract) * mt.vertexNormals[i] +
                            fract * mt2.vertexNormals[i];
                    }

                    this.mesh.updateNormals(this.morphGeom);
                    this.mesh.updateVertices(this.morphGeom);
                }
            }

            let useMat = !ignoreMaterial && this.material != -1 && gltf.shaders[this.material];
            if (skinRenderer)useMat = false;

            if (useMat) cgl.pushShader(gltf.shaders[this.material]);

            const currentShader = cgl.getShader() || {};
            const uniDiff = currentShader.uniformColorDiffuse;

            const uniPbrMetalness = currentShader.uniformPbrMetalness;
            const uniPbrRoughness = currentShader.uniformPbrRoughness;

            if (!gltf.shaders[this.material] && inUseMatProps.get())
            {
                if (uniDiff && this._matDiffuseColor)
                {
                    this._matDiffuseColorOrig = [uniDiff.getValue()[0], uniDiff.getValue()[1], uniDiff.getValue()[2], uniDiff.getValue()[3]];
                    uniDiff.setValue(this._matDiffuseColor);
                }

                if (uniPbrMetalness)
                    if (this._matPbrMetalness != null)
                    {
                        this._matPbrMetalnessOrig = uniPbrMetalness.getValue();
                        uniPbrMetalness.setValue(this._matPbrMetalness);
                    }
                    else
                        uniPbrMetalness.setValue(0);

                if (uniPbrRoughness)
                    if (this._matPbrRoughness != null)
                    {
                        this._matPbrRoughnessOrig = uniPbrRoughness.getValue();
                        uniPbrRoughness.setValue(this._matPbrRoughness);
                    }
                    else
                    {
                        uniPbrRoughness.setValue(0);
                    }
            }

            if (this.mesh) this.mesh.render(cgl.getShader(), ignoreMaterial);

            if (inUseMatProps.get())
            {
                if (uniDiff && this._matDiffuseColor) uniDiff.setValue(this._matDiffuseColorOrig);
                if (uniPbrMetalness && this._matPbrMetalnessOrig != undefined) uniPbrMetalness.setValue(this._matPbrMetalnessOrig);
                if (uniPbrRoughness && this._matPbrRoughnessOrig != undefined) uniPbrRoughness.setValue(this._matPbrRoughnessOrig);
            }

            if (useMat) cgl.popShader();
        }
    }
};
const gltfMeshGroup = class
{
    constructor(gltf, m)
    {
        this.bounds = new CABLES.CG.BoundingBox();
        this.meshes = [];
        this.name = m.name;
        const prims = m.primitives;

        for (let i = 0; i < prims.length; i++)
        {
            const mesh = new gltfMesh(this.name, prims[i], gltf,
                (mesh) =>
                {
                    this.bounds.apply(mesh.bounds);
                });

            mesh.submeshIndex = i;
            this.meshes.push(mesh);
        }
    }

    render(cgl, ignoreMat, skinRenderer, _time)
    {
        for (let i = 0; i < this.meshes.length; i++)
        {
            const useMat = gltf.shaders[this.meshes[i].material];

            if (!ignoreMat && useMat) cgl.pushShader(gltf.shaders[this.meshes[i].material]);
            // console.log(gltf.shaders[this.meshes[i].material],this.meshes[i].material)
            if (skinRenderer)skinRenderer.renderStart(cgl, _time);

            this.meshes[i].render(cgl, ignoreMat, skinRenderer, _time);
            if (skinRenderer)skinRenderer.renderFinish(cgl);
            if (!ignoreMat && useMat) cgl.popShader();
        }
    }
};
const gltfNode = class
{
    constructor(node, gltf)
    {
        this.isChild = node.isChild || false;
        this.name = node.name;
        if (node.hasOwnProperty("camera")) this.camera = node.camera;
        this.hidden = false;
        this.mat = mat4.create();
        this._animMat = mat4.create();
        this._tempMat = mat4.create();
        this._tempQuat = quat.create();
        this._tempRotmat = mat4.create();
        this.mesh = null;
        this.children = [];
        this._node = node;
        this._gltf = gltf;
        this.absMat = mat4.create();
        this.addTranslate = null;
        this._tempAnimScale = null;
        this.addMulMat = null;
        this.updateMatrix();
        this._animActions = {};
        this.skinRenderer = null;
        this.copies = [];
    }

    get skin()
    {
        if (this._node.hasOwnProperty("skin")) return this._node.skin;
        else return -1;
    }

    copy()
    {
        this.isCopy = true;
        const n = new gltfNode(this._node, this._gltf);
        n.copyOf = this;

        n._animActions = this._animActions;
        n.children = this.children;
        n.skinRenderer = new GltfSkin(n);

        this.updateMatrix();
        return n;
    }

    hasSkin()
    {
        if (this._node.hasOwnProperty("skin")) return this._gltf.json.skins[this._node.skin].name || "unknown";
        return false;
    }

    initSkin()
    {
        if (this.skin > -1)
        {
            this.skinRenderer = new GltfSkin(this);
        }
    }

    updateMatrix()
    {
        mat4.identity(this.mat);
        if (this._node.translation) mat4.translate(this.mat, this.mat, this._node.translation);

        if (this._node.rotation)
        {
            const rotmat = mat4.create();
            this._rot = this._node.rotation;

            mat4.fromQuat(rotmat, this._node.rotation);
            mat4.mul(this.mat, this.mat, rotmat);
        }

        if (this._node.scale)
        {
            this._scale = this._node.scale;
            mat4.scale(this.mat, this.mat, this._scale);
        }

        if (this._node.hasOwnProperty("mesh"))
        {
            this.mesh = this._gltf.meshes[this._node.mesh];
            if (this.isCopy)
            {
                console.log(this.mesh);
            }
        }

        if (this._node.children)
        {
            for (let i = 0; i < this._node.children.length; i++)
            {
                this._gltf.json.nodes[i].isChild = true;
                if (this._gltf.nodes[this._node.children[i]]) this._gltf.nodes[this._node.children[i]].isChild = true;
                this.children.push(this._node.children[i]);
            }
        }
    }

    unHide()
    {
        this.hidden = false;
        for (let i = 0; i < this.children.length; i++)
            if (this.children[i].unHide) this.children[i].unHide();
    }

    calcBounds(gltf, mat, bounds)
    {
        const localMat = mat4.create();

        if (mat) mat4.copy(localMat, mat);
        if (this.mat) mat4.mul(localMat, localMat, this.mat);

        if (this.mesh)
        {
            const bb = this.mesh.bounds.copy();
            bb.mulMat4(localMat);
            bounds.apply(bb);

            if (bounds.changed)
            {
                boundingPoints.push(
                    bb._min[0] || 0, bb._min[1] || 0, bb._min[2] || 0,
                    bb._max[0] || 0, bb._max[1] || 0, bb._max[2] || 0);
            }
        }

        for (let i = 0; i < this.children.length; i++)
        {
            if (gltf.nodes[this.children[i]] && gltf.nodes[this.children[i]].calcBounds)
            {
                const b = gltf.nodes[this.children[i]].calcBounds(gltf, localMat, bounds);

                bounds.apply(b);
            }
        }

        if (bounds.changed) return bounds;
        else return null;
    }

    setAnimAction(name)
    {
        // console.log("setAnimAction:", name);
        if (!name) return;

        this._currentAnimaction = name;

        if (name && !this._animActions[name])
        {
            // console.log("no action found:", name,this._animActions);
            return null;
        }

        // else console.log("YES action found:", name);
        // console.log(this._animActions);

        for (let path in this._animActions[name])
        {
            if (path == "translation") this._animTrans = this._animActions[name][path];
            else if (path == "rotation") this._animRot = this._animActions[name][path];
            else if (path == "scale") this._animScale = this._animActions[name][path];
            else console.warn("unknown anim path", path, this._animActions[name][path]);
        }
    }

    setAnim(path, name, anims)
    {
        if (!path || !name || !anims) return;

        // console.log("setanim", this._node.name, path, name, anims);

        this._animActions[name] = this._animActions[name] || {};

        // console.log(this._animActions);
        // debugger;

        // for (let i = 0; i < this.copies.length; i++) this.copies[i]._animActions = this._animActions;

        if (this._animActions[name][path]) op.warn("animation action path already exists", name, path, this._animActions[name][path]);

        this._animActions[name][path] = anims;

        if (path == "translation") this._animTrans = anims;
        else if (path == "rotation") this._animRot = anims;
        else if (path == "scale") this._animScale = anims;
        else console.warn("unknown anim path", path, anims);
    }

    modelMatLocal()
    {
        return this._animMat || this.mat;
    }

    modelMatAbs()
    {
        return this.absMat;
    }

    transform(cgl, _time)
    {
        if (!_time && _time != 0)_time = time;

        this._lastTimeTrans = _time;

        // console.log(this._rot)

        gltfTransforms++;

        if (!this._animTrans && !this._animRot && !this._animScale)
        {
            mat4.mul(cgl.mMatrix, cgl.mMatrix, this.mat);
            this._animMat = null;
        }
        else
        {
            this._animMat = this._animMat || mat4.create();
            mat4.identity(this._animMat);

            const playAnims = true;

            if (playAnims && this._animTrans)
            {
                mat4.translate(this._animMat, this._animMat, [
                    this._animTrans[0].getValue(_time),
                    this._animTrans[1].getValue(_time),
                    this._animTrans[2].getValue(_time)]);
            }
            else
            if (this._node.translation) mat4.translate(this._animMat, this._animMat, this._node.translation);

            if (playAnims && this._animRot)
            {
                if (this._animRot[0].defaultEasing == CABLES.EASING_LINEAR) CABLES.TL.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);
                else if (this._animRot[0].defaultEasing == CABLES.EASING_ABSOLUTE)
                {
                    this._tempQuat[0] = this._animRot[0].getValue(_time);
                    this._tempQuat[1] = this._animRot[1].getValue(_time);
                    this._tempQuat[2] = this._animRot[2].getValue(_time);
                    this._tempQuat[3] = this._animRot[3].getValue(_time);
                }
                else if (this._animRot[0].defaultEasing == CABLES.EASING_CUBICSPLINE)
                {
                    CABLES.TL.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);
                }

                mat4.fromQuat(this._tempMat, this._tempQuat);
                mat4.mul(this._animMat, this._animMat, this._tempMat);
            }
            else if (this._rot)
            {
                mat4.fromQuat(this._tempRotmat, this._rot);
                mat4.mul(this._animMat, this._animMat, this._tempRotmat);
            }

            if (playAnims && this._animScale)
            {
                if (!this._tempAnimScale) this._tempAnimScale = [1, 1, 1];
                this._tempAnimScale[0] = this._animScale[0].getValue(_time);
                this._tempAnimScale[1] = this._animScale[1].getValue(_time);
                this._tempAnimScale[2] = this._animScale[2].getValue(_time);
                mat4.scale(this._animMat, this._animMat, this._tempAnimScale);
            }
            else if (this._scale) mat4.scale(this._animMat, this._animMat, this._scale);

            mat4.mul(cgl.mMatrix, cgl.mMatrix, this._animMat);
        }

        if (this.addTranslate) mat4.translate(cgl.mMatrix, cgl.mMatrix, this.addTranslate);

        if (this.addMulMat) mat4.mul(cgl.mMatrix, cgl.mMatrix, this.addMulMat);

        mat4.copy(this.absMat, cgl.mMatrix);
    }

    render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time)
    {
        if (!dontTransform) cgl.pushModelMatrix();

        if (_time === undefined) _time = gltf.time;

        if (!dontTransform || this.skinRenderer) this.transform(cgl, _time);

        if (this.hidden && !drawHidden)
        {
        }
        else
        {
            if (this.skinRenderer)
            {
                this.skinRenderer.time = _time;
                if (!dontDrawMesh)
                    this.mesh.render(cgl, ignoreMaterial, this.skinRenderer, _time);
            }
            else
            {
                if (this.mesh && !dontDrawMesh)
                    this.mesh.render(cgl, ignoreMaterial, null, _time);
            }
        }

        if (!ignoreChilds && !this.hidden)
            for (let i = 0; i < this.children.length; i++)
                if (gltf.nodes[this.children[i]])
                    gltf.nodes[this.children[i]].render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time);

        if (!dontTransform)cgl.popModelMatrix();
    }
};
let tab = null;

function closeTab()
{
    if (tab)gui.mainTabs.closeTab(tab.id);
    tab = null;
}

function formatVec(arr)
{
    const nums = [];
    for (let i = 0; i < arr.length; i++)
    {
        nums.push(Math.round(arr[i] * 1000) / 1000);
    }

    return nums.join(",");
}

function printNode(html, node, level)
{
    if (!gltf) return;

    html += "<tr class=\"row\">";

    let ident = "";
    let identSpace = "";

    for (let i = 1; i < level; i++)
    {
        identSpace += "&nbsp;&nbsp;&nbsp;";
        let identClass = "identBg";
        if (i == 1)identClass = "identBgLevel0";
        ident += "<td class=\"ident " + identClass + "\" ><div style=\"\"></div></td>";
    }
    let id = CABLES.uuid();
    html += ident;
    html += "<td colspan=\"" + (21 - level) + "\">";
    // html+='<div style="display:inline-block;border:0px solid red;height:10px;width:'+level*10+'px"></div>';

    if (node.mesh && node.mesh.meshes.length)html += "<span class=\"icon icon-cube\"></span>&nbsp;";
    else html += "<span class=\"icon icon-box-select\"></span> &nbsp;";

    html += node.name + "</td><td></td>";

    if (node.mesh)
    {
        html += "<td>";
        for (let i = 0; i < node.mesh.meshes.length; i++)
        {
            if (i > 0)html += ", ";
            html += node.mesh.meshes[i].name;
        }

        html += "</td>";

        html += "<td>";
        html += node.hasSkin() || "-";
        html += "</td>";

        html += "<td>";
        let countMats = 0;
        for (let i = 0; i < node.mesh.meshes.length; i++)
        {
            if (countMats > 0)html += ", ";
            if (gltf.json.materials && node.mesh.meshes[i].hasOwnProperty("material"))
            {
                if (gltf.json.materials[node.mesh.meshes[i].material])
                {
                    html += gltf.json.materials[node.mesh.meshes[i].material].name;
                    countMats++;
                }
            }
        }
        if (countMats == 0)html += "none";
        html += "</td>";
    }
    else
    {
        html += "<td>-</td><td>-</td><td>-</td>";
    }

    html += "<td>";

    if (node._node.translation || node._node.rotation || node._node.scale)
    {
        let info = "";

        if (node._node.translation)info += "Translate: `" + formatVec(node._node.translation) + "` || ";
        if (node._node.rotation)info += "Rotation: `" + formatVec(node._node.rotation) + "` || ";
        if (node._node.scale)info += "Scale: `" + formatVec(node._node.scale) + "` || ";

        html += "<span class=\"icon icon-gizmo info\" data-info=\"" + info + "\"></span> &nbsp;";
    }

    if (node._animRot || node._animScale || node._animTrans)
    {
        let info = "Animated: ";
        if (node._animRot) info += "Rot ";
        if (node._animScale) info += "Scale ";
        if (node._animTrans) info += "Trans ";

        html += "<span class=\"icon icon-clock info\" data-info=\"" + info + "\"></span>&nbsp;";
    }

    if (!node._node.translation && !node._node.rotation && !node._node.scale && !node._animRot && !node._animScale && !node._animTrans) html += "-";

    html += "</td>";

    html += "<td>";
    let hideclass = "";
    if (node.hidden)hideclass = "node-hidden";

    // html+='';
    html += "<a onclick=\"gui.corePatch().getOpById('" + op.id + "').exposeNode('" + node.name + "','transform')\" class=\"treebutton\">Transform</a>";
    html += " <a onclick=\"gui.corePatch().getOpById('" + op.id + "').exposeNode('" + node.name + "','hierarchy')\" class=\"treebutton\">Hierarchy</a>";
    html += " <a onclick=\"gui.corePatch().getOpById('" + op.id + "').exposeNode('" + node.name + "')\" class=\"treebutton\">Node</a>";

    if (node.hasSkin())
        html += " <a onclick=\"gui.corePatch().getOpById('" + op.id + "').exposeNode('" + node.name + "',false,{skin:true});\" class=\"treebutton\">Skin</a>";

    html += "</td><td>";
    html += "&nbsp;<span class=\"icon iconhover icon-eye " + hideclass + "\" onclick=\"gui.corePatch().getOpById('" + op.id + "').toggleNodeVisibility('" + node.name + "');this.classList.toggle('node-hidden');\"></span>";
    html += "</td>";

    html += "</tr>";

    if (node.children)
    {
        for (let i = 0; i < node.children.length; i++)
            html = printNode(html, gltf.nodes[node.children[i]], level + 1);
    }

    return html;
}

function printMaterial(mat, idx)
{
    let html = "<tr>";
    html += " <td>" + idx + "</td>";
    html += " <td>" + mat.name + "</td>";
    // html+=' <td><a onclick="" class="treebutton">Assign</a><td>';

    html += " <td>";

    const info = JSON.stringify(mat, null, 4).replaceAll("\"", "").replaceAll("\n", "<br/>");

    html += "<span class=\"icon icon-info\" onclick=\"new CABLES.UI.ModalDialog({ 'html': '<pre>" + info + "</pre>', 'title': '" + mat.name + "' });\"></span>&nbsp;";

    if (mat.pbrMetallicRoughness && mat.pbrMetallicRoughness.baseColorFactor)
    {
        let rgb = "";
        rgb += "" + Math.round(mat.pbrMetallicRoughness.baseColorFactor[0] * 255);
        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[1] * 255);
        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[2] * 255);

        html += "<div style=\"width:15px;height:15px;background-color:rgb(" + rgb + ");display:inline-block\">&nbsp;</a>";
    }
    html += " <td style=\"\">" + (gltf.shaders[idx] ? "-" : "<a onclick=\"gui.corePatch().getOpById('" + op.id + "').assignMaterial('" + mat.name + "')\" class=\"treebutton\">Assign</a>") + "<td>";
    html += "<td>";

    html += "</tr>";
    return html;
}

function printInfo()
{
    if (!gltf) return;

    const startTime = performance.now();
    const sizes = {};
    let html = "<div style=\"overflow:scroll;width:100%;height:100%\">";

    html += "generator:" + gltf.json.asset.generator;

    let numNodes = 0;
    if (gltf.json.nodes)numNodes = gltf.json.nodes.length;
    html += "<div id=\"groupNodes\">Nodes (" + numNodes + ")</div>";

    html += "<table id=\"sectionNodes\" class=\"table treetable\">";

    html += "<tr>";
    html += " <th colspan=\"21\">Name</th>";
    html += " <th>Mesh</th>";
    html += " <th>Skin</th>";
    html += " <th>Material</th>";
    html += " <th>Transform</th>";
    html += " <th>Expose</th>";
    html += " <th></th>";
    html += "</tr>";

    for (let i = 0; i < gltf.nodes.length; i++)
    {
        if (!gltf.nodes[i].isChild)
            html = printNode(html, gltf.nodes[i], 1);
    }
    html += "</table>";

    // / //////////////////

    let numMaterials = 0;
    if (gltf.json.materials)numMaterials = gltf.json.materials.length;
    html += "<div id=\"groupMaterials\">Materials (" + numMaterials + ")</div>";

    if (!gltf.json.materials || gltf.json.materials.length == 0)
    {
    }
    else
    {
        html += "<table id=\"materialtable\"  class=\"table treetable\">";
        html += "<tr>";
        html += " <th>Index</th>";
        html += " <th>Name</th>";
        html += " <th>Color</th>";
        html += " <th>Function</th>";
        html += " <th></th>";
        html += "</tr>";
        for (let i = 0; i < gltf.json.materials.length; i++)
        {
            html += printMaterial(gltf.json.materials[i], i);
        }
        html += "</table>";
    }

    // / ///////////////////////

    html += "<div id=\"groupMeshes\">Meshes (" + gltf.json.meshes.length + ")</div>";

    html += "<table id=\"meshestable\"  class=\"table treetable\">";
    html += "<tr>";
    html += " <th>Name</th>";
    html += " <th>Node</th>";
    html += " <th>Material</th>";
    html += " <th>Vertices</th>";
    html += " <th>Attributes</th>";
    html += "</tr>";

    let sizeBufferViews = [];
    sizes.meshes = 0;

    for (let i = 0; i < gltf.json.meshes.length; i++)
    {
        html += "<tr>";
        html += "<td>" + gltf.json.meshes[i].name + "</td>";

        html += "<td>";
        let count = 0;
        let nodename = "";
        for (var j = 0; j < gltf.json.nodes.length; j++)
        {
            if (gltf.json.nodes[j].mesh == i)
            {
                count++;
                if (count == 1)
                {
                    nodename = gltf.json.nodes[j].name;
                }
            }
        }
        if (count > 1) html += (count) + " nodes (" + nodename + " ...)";
        else html += nodename;
        html += "</td>";

        // -------

        html += "<td>";
        for (var j = 0; j < gltf.json.meshes[i].primitives.length; j++)
        {
            if (gltf.json.meshes[i].primitives[j].hasOwnProperty("material"))
            {
                if (gltf.json.materials[gltf.json.meshes[i]])
                {
                    html += gltf.json.materials[gltf.json.meshes[i].primitives[j].material].name + " ";
                }
            }
            else html += "None";
        }
        html += "</td>";

        html += "<td>";
        let numVerts = 0;
        for (var j = 0; j < gltf.json.meshes[i].primitives.length; j++)
        {
            if (gltf.json.meshes[i].primitives[j].attributes.POSITION != undefined)
            {
                let v = parseInt(gltf.json.accessors[gltf.json.meshes[i].primitives[j].attributes.POSITION].count);
                numVerts += v;
                html += "" + v + "<br/>";
            }
            else html += "-<br/>";
        }

        if (gltf.json.meshes[i].primitives.length > 0)
            html += "=" + numVerts;
        html += "</td>";

        html += "<td style=\"vertical-align:top;\">";
        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)
        {
            html += Object.keys(gltf.json.meshes[i].primitives[j].attributes);
            html += " <a onclick=\"gui.corePatch().getOpById('" + op.id + "').exposeGeom('" + gltf.json.meshes[i].name + "'," + j + ")\" class=\"treebutton\">Geometry</a>";
            html += "<br/>";
        }
        html += "</td>";
        html += "</tr>";

        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)
        {
            const accessor = gltf.json.accessors[gltf.json.meshes[i].primitives[j].indices];
            if (accessor)
            {
                let bufView = accessor.bufferView;

                if (sizeBufferViews.indexOf(bufView) == -1)
                {
                    sizeBufferViews.push(bufView);
                    if (gltf.json.bufferViews[bufView])sizes.meshes += gltf.json.bufferViews[bufView].byteLength;
                }
            }

            for (let k in gltf.json.meshes[i].primitives[j].attributes)
            {
                const attr = gltf.json.meshes[i].primitives[j].attributes[k];
                const bufView2 = gltf.json.accessors[attr].bufferView;

                if (sizeBufferViews.indexOf(bufView2) == -1)
                {
                    sizeBufferViews.push(bufView2);
                    if (gltf.json.bufferViews[bufView2])sizes.meshes += gltf.json.bufferViews[bufView2].byteLength;
                }
            }
        }
    }
    html += "</table>";

    // / //////////////////////////////////

    let numAnims = 0;
    if (gltf.json.animations)numAnims = gltf.json.animations.length;
    html += "<div id=\"groupAnims\">Animations (" + numAnims + ")</div>";

    if (gltf.json.animations)
    {
        html += "<table id=\"sectionAnim\" class=\"table treetable\">";
        html += "<tr>";
        html += "  <th>Name</th>";
        html += "  <th>Target node</th>";
        html += "  <th>Path</th>";
        html += "  <th>Interpolation</th>";
        html += "  <th>Keys</th>";
        html += "</tr>";

        sizes.animations = 0;

        for (let i = 0; i < gltf.json.animations.length; i++)
        {
            for (let j = 0; j < gltf.json.animations[i].samplers.length; j++)
            {
                let bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].input].bufferView;
                if (sizeBufferViews.indexOf(bufView) == -1)
                {
                    sizeBufferViews.push(bufView);
                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;
                }

                bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].output].bufferView;
                if (sizeBufferViews.indexOf(bufView) == -1)
                {
                    sizeBufferViews.push(bufView);
                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;
                }
            }

            for (let j = 0; j < gltf.json.animations[i].channels.length; j++)
            {
                html += "<tr>";
                html += "  <td> Anim " + i + ": " + gltf.json.animations[i].name + "</td>";

                html += "  <td>" + gltf.nodes[gltf.json.animations[i].channels[j].target.node].name + "</td>";
                html += "  <td>";
                html += gltf.json.animations[i].channels[j].target.path + " ";
                html += "  </td>";

                const smplidx = gltf.json.animations[i].channels[j].sampler;
                const smplr = gltf.json.animations[i].samplers[smplidx];

                html += "  <td>" + smplr.interpolation + "</td>";

                html += "  <td>" + gltf.json.accessors[smplr.output].count;

                html += "&nbsp;&nbsp;<a onclick=\"gui.corePatch().getOpById('" + op.id + "').showAnim('" + i + "','" + j + "')\" class=\"icon icon-search\"></a>";

                html += "</td>";

                html += "</tr>";
            }
        }
        html += "</table>";
    }
    else
    {

    }

    // / ///////////////////

    let numImages = 0;
    if (gltf.json.images)numImages = gltf.json.images.length;
    html += "<div id=\"groupImages\">Images (" + numImages + ")</div>";

    if (gltf.json.images)
    {
        html += "<table id=\"sectionImages\" class=\"table treetable\">";

        html += "<tr>";
        html += "  <th>name</th>";
        html += "  <th>type</th>";
        html += "  <th>func</th>";

        html += "</tr>";

        sizes.images = 0;

        for (let i = 0; i < gltf.json.images.length; i++)
        {
            if (gltf.json.images[i].bufferView)
                sizes.images += gltf.json.bufferViews[gltf.json.images[i].bufferView].byteLength;

            html += "<tr>";
            html += "<td>" + gltf.json.images[i].name + "</td>";
            html += "<td>" + gltf.json.images[i].mimeType + "</td>";
            html += "<td>";

            let name = gltf.json.images[i].name;
            if (name === undefined)name = gltf.json.images[i].bufferView;

            html += "<a onclick=\"gui.corePatch().getOpById('" + op.id + "').exposeTexture('" + name + "')\" class=\"treebutton\">Expose</a>";
            html += "</td>";

            html += "<tr>";
        }
        html += "</table>";
    }

    // / ///////////////////////

    let numCameras = 0;
    if (gltf.json.cameras)numCameras = gltf.json.cameras.length;
    html += "<div id=\"groupCameras\">Cameras (" + numCameras + ")</div>";

    if (gltf.json.cameras)
    {
        html += "<table id=\"sectionCameras\" class=\"table treetable\">";

        html += "<tr>";
        html += "  <th>name</th>";
        html += "  <th>type</th>";
        html += "  <th>info</th>";
        html += "</tr>";

        for (let i = 0; i < gltf.json.cameras.length; i++)
        {
            html += "<tr>";
            html += "<td>" + gltf.json.cameras[i].name + "</td>";
            html += "<td>" + gltf.json.cameras[i].type + "</td>";
            html += "<td>";

            if (gltf.json.cameras[i].perspective)
            {
                html += "yfov: " + Math.round(gltf.json.cameras[i].perspective.yfov * 100) / 100;
                html += ", ";
                html += "zfar: " + Math.round(gltf.json.cameras[i].perspective.zfar * 100) / 100;
                html += ", ";
                html += "znear: " + Math.round(gltf.json.cameras[i].perspective.znear * 100) / 100;
            }
            html += "</td>";

            html += "<tr>";
        }
        html += "</table>";
    }

    // / ////////////////////////////////////

    let numSkins = 0;
    if (gltf.json.skins)numSkins = gltf.json.skins.length;
    html += "<div id=\"groupSkins\">Skins (" + numSkins + ")</div>";

    if (gltf.json.skins)
    {
        // html += "<h3>Skins (" + gltf.json.skins.length + ")</h3>";
        html += "<table id=\"sectionSkins\" class=\"table treetable\">";

        html += "<tr>";
        html += "  <th>name</th>";
        html += "  <th></th>";
        html += "  <th>total joints</th>";
        html += "</tr>";

        for (let i = 0; i < gltf.json.skins.length; i++)
        {
            html += "<tr>";
            html += "<td>" + gltf.json.skins[i].name + "</td>";
            html += "<td>" + "</td>";
            html += "<td>" + gltf.json.skins[i].joints.length + "</td>";
            html += "<td>";
            html += "</td>";
            html += "<tr>";
        }
        html += "</table>";
    }

    // / //////////////////////////

    let sizeBin = 0;
    if (gltf.json.buffers)
        sizeBin = gltf.json.buffers[0].byteLength;

    html += "<div id=\"groupBinary\">File Size Allocation (" + Math.round(sizeBin / 1024) + "k )</div>";

    html += "<table id=\"sectionBinary\" class=\"table treetable\">";
    html += "<tr>";
    html += "  <th>name</th>";
    html += "  <th>size</th>";
    html += "  <th>%</th>";
    html += "</tr>";
    let sizeUnknown = sizeBin;
    for (let i in sizes)
    {
        // html+=i+':'+Math.round(sizes[i]/1024);
        html += "<tr>";
        html += "<td>" + i + "</td>";
        html += "<td>" + readableSize(sizes[i]) + " </td>";
        html += "<td>" + Math.round(sizes[i] / sizeBin * 100) + "% </td>";
        html += "<tr>";
        sizeUnknown -= sizes[i];
    }

    if (sizeUnknown != 0)
    {
        html += "<tr>";
        html += "<td>unknown</td>";
        html += "<td>" + readableSize(sizeUnknown) + " </td>";
        html += "<td>" + Math.round(sizeUnknown / sizeBin * 100) + "% </td>";
        html += "<tr>";
    }

    html += "</table>";
    html += "</div>";

    tab = new CABLES.UI.Tab("GLTF", { "icon": "cube", "infotext": "tab_gltf", "padding": true, "singleton": true });
    gui.mainTabs.addTab(tab, true);

    tab.addEventListener("onClose", closeTab);
    tab.html(html);

    CABLES.UI.Collapsable.setup(ele.byId("groupNodes"), ele.byId("sectionNodes"), false);
    CABLES.UI.Collapsable.setup(ele.byId("groupMaterials"), ele.byId("materialtable"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupAnims"), ele.byId("sectionAnim"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupMeshes"), ele.byId("meshestable"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupCameras"), ele.byId("sectionCameras"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupImages"), ele.byId("sectionImages"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupSkins"), ele.byId("sectionSkins"), true);
    CABLES.UI.Collapsable.setup(ele.byId("groupBinary"), ele.byId("sectionBinary"), true);

    gui.maintabPanel.show(true);
}

function readableSize(n)
{
    if (n > 1024) return Math.round(n / 1024) + " kb";
    if (n > 1024 * 500) return Math.round(n / 1024) + " mb";
    else return n + " bytes";
}
const GltfSkin = class
{
    constructor(node)
    {
        this._mod = null;
        this._node = node;
        this._lastTime = 0;
        this._matArr = [];
        this._m = mat4.create();
        this._invBindMatrix = mat4.create();
        this.identity = true;
    }

    renderFinish(cgl)
    {
        cgl.popModelMatrix();
        this._mod.unbind();
    }

    renderStart(cgl, time)
    {
        if (!this._mod)
        {
            this._mod = new CGL.ShaderModifier(cgl, op.name + this._node.name);

            this._mod.addModule({
                "priority": -2,
                "name": "MODULE_VERTEX_POSITION",
                "srcHeadVert": attachments.skin_head_vert || "",
                "srcBodyVert": attachments.skin_vert || ""
            });

            this._mod.addUniformVert("m4[]", "MOD_boneMats", []);// bohnenmatze
            const tr = vec3.create();
        }

        const skinIdx = this._node.skin;
        const arrLength = gltf.json.skins[skinIdx].joints.length * 16;

        // if (this._lastTime != time || !time)
        {
            // this._lastTime=inTime.get();
            if (this._matArr.length != arrLength) this._matArr.length = arrLength;

            for (let i = 0; i < gltf.json.skins[skinIdx].joints.length; i++)
            {
                const i16 = i * 16;
                const jointIdx = gltf.json.skins[skinIdx].joints[i];
                const nodeJoint = gltf.nodes[jointIdx];

                for (let j = 0; j < 16; j++)
                    this._invBindMatrix[j] = gltf.accBuffers[gltf.json.skins[skinIdx].inverseBindMatrices][i16 + j];

                mat4.mul(this._m, nodeJoint.modelMatAbs(), this._invBindMatrix);

                for (let j = 0; j < this._m.length; j++) this._matArr[i16 + j] = this._m[j];
            }

            this._mod.setUniformValue("MOD_boneMats", this._matArr);
            this._lastTime = time;
        }

        this._mod.define("SKIN_NUM_BONES", gltf.json.skins[skinIdx].joints.length);
        this._mod.bind();

        // draw mesh...
        cgl.pushModelMatrix();
        if (this.identity)mat4.identity(cgl.mMatrix);
    }
};
// https://raw.githubusercontent.com/KhronosGroup/glTF/master/specification/2.0/figures/gltfOverview-2.0.0b.png

const
    inExec = op.inTrigger("Render"),
    dataPort = op.inString("data"),
    inFile = op.inUrl("glb File", [".glb"]),
    inRender = op.inBool("Draw", true),
    inCamera = op.inDropDown("Camera", ["None"], "None"),
    inAnimation = op.inString("Animation", ""),
    inShow = op.inTriggerButton("Show Structure"),
    inCenter = op.inSwitch("Center", ["None", "XYZ", "XZ"], "XYZ"),
    inRescale = op.inBool("Rescale", true),
    inRescaleSize = op.inFloat("Rescale Size", 2.5),

    inTime = op.inFloat("Time"),
    inTimeLine = op.inBool("Sync to timeline", false),
    inLoop = op.inBool("Loop", true),

    inNormFormat = op.inSwitch("Normals Format", ["XYZ", "X-ZY"], "XYZ"),
    inVertFormat = op.inSwitch("Vertices Format", ["XYZ", "XZ-Y"], "XYZ"),
    inCalcNormals = op.inBool("Calc Normals", false),

    inMaterials = op.inObject("Materials"),
    inHideNodes = op.inArray("Hide Nodes"),
    inUseMatProps = op.inBool("Use Material Properties", false),
    inActive = op.inBool("Active", true),

    nextBefore = op.outTrigger("Render Before"),
    next = op.outTrigger("Next"),
    outGenerator = op.outString("Generator"),
    outVersion = op.outNumber("GLTF Version"),
    outExtensions = op.outArray("GLTF Extensions Used"),
    outAnimLength = op.outNumber("Anim Length", 0),
    outAnimTime = op.outNumber("Anim Time", 0),
    outJson = op.outObject("Json"),
    outAnims = op.outArray("Anims"),
    outPoints = op.outArray("BoundingPoints"),
    outBounds = op.outObject("Bounds"),
    outAnimFinished = op.outTrigger("Finished"),
    outLoading = op.outBool("Loading");

op.setPortGroup("Timing", [inTime, inTimeLine, inLoop]);

const le = true; // little endian
const cgl = op.patch.cgl;
inFile.onChange =
    inVertFormat.onChange =
    inCalcNormals.onChange =
    inNormFormat.onChange = reloadSoon;

let gltfTransforms = 0;
let finishedLoading = false;
let cam = null;
let boundingPoints = [];
let gltf = null;
let maxTime = 0;
let time = 0;
let needsMatUpdate = true;
let timedLoader = null;
let loadingId = null;
let data = null;
const scale = vec3.create();
let lastTime = 0;
let doCenter = false;

const boundsCenter = vec3.create();

inShow.onTriggered = printInfo;
dataPort.setUiAttribs({ "hideParam": true, "hidePort": true });
dataPort.onChange = loadData;
inHideNodes.onChange = hideNodesFromData;
inAnimation.onChange = updateAnimation;

op.setPortGroup("Transform", [inRescale, inRescaleSize, inCenter]);

inCenter.onChange = updateCenter;

function updateCamera()
{
    const arr = ["None"];
    if (gltf)
    {
        for (let i = 0; i < gltf.nodes.length; i++)
        {
            if (gltf.nodes[i].camera >= 0)
            {
                arr.push(gltf.nodes[i].name);
            }
        }
    }
    inCamera.uiAttribs.values = arr;
}

function updateCenter()
{
    doCenter = inCenter.get() != "None";

    if (gltf && gltf.bounds)
    {
        boundsCenter.set(gltf.bounds.center);
        boundsCenter[0] = -boundsCenter[0];
        boundsCenter[1] = -boundsCenter[1];
        boundsCenter[2] = -boundsCenter[2];
        if (inCenter.get() == "XZ") boundsCenter[1] = -gltf.bounds.minY;
    }
}

inRescale.onChange = function ()
{
    inRescaleSize.setUiAttribs({ "greyout": !inRescale.get() });
};

inMaterials.onChange = function ()
{
    needsMatUpdate = true;
};

op.onDelete = function ()
{
    closeTab();
};

inTimeLine.onChange = function ()
{
    inTime.setUiAttribs({ "greyout": inTimeLine.get() });
};

inCamera.onChange = setCam;

function setCam()
{
    cam = null;
    if (!gltf) return;

    for (let i = 0; i < gltf.nodes.length; i++)
    {
        if (gltf.nodes[i].name == inCamera.get())cam = new gltfCamera(gltf, gltf.nodes[i]);
    }
}

inExec.onTriggered = function ()
{
    if (!finishedLoading) return;
    if (!inActive.get()) return;

    gltfTransforms = 0;
    if (inTimeLine.get()) time = op.patch.timer.getTime();
    else time = Math.max(0, inTime.get());

    if (inLoop.get())
    {
        time %= maxTime;
        if (time < lastTime)outAnimFinished.trigger();
    }
    else
    {
        if (maxTime > 0 && time >= maxTime)outAnimFinished.trigger();
    }
    lastTime = time;

    cgl.pushModelMatrix();

    outAnimTime.set(time || 0);

    if (finishedLoading && gltf && gltf.bounds)
    {
        if (inRescale.get())
        {
            let sc = inRescaleSize.get() / gltf.bounds.maxAxis;
            gltf.scale = sc;
            vec3.set(scale, sc, sc, sc);
            mat4.scale(cgl.mMatrix, cgl.mMatrix, scale);
        }
        if (doCenter)
        {
            mat4.translate(cgl.mMatrix, cgl.mMatrix, boundsCenter);
        }
    }

    let oldScene = cgl.frameStore.currentScene || null;
    cgl.frameStore.currentScene = gltf;

    nextBefore.trigger();

    if (finishedLoading)
    {
        if (needsMatUpdate) updateMaterials();

        if (cam) cam.start(time);

        if (gltf)
        {
            gltf.time = time;

            {
                if (gltf.bounds && cgl.shouldDrawHelpers(op))
                {
                    if (CABLES.UI.renderHelper)cgl.pushShader(CABLES.GL_MARKER.getDefaultShader(cgl));
                    else cgl.pushShader(CABLES.GL_MARKER.getSelectedShader(cgl));
                    gltf.bounds.render(cgl);
                    cgl.popShader();
                }

                // if (!gltf.renderMMatrix)gltf.renderMMatrix = mat4.create();
                // cgl.pushModelMatrix();
                // mat4.copy(gltf.renderMMatrix, cgl.mMatrix);
                // mat4.identity(cgl.mMatrix);

                if (inRender.get())
                {
                    for (let i = 0; i < gltf.nodes.length; i++)
                        if (!gltf.nodes[i].isChild)
                            gltf.nodes[i].render(cgl);
                }
                else
                {
                    for (let i = 0; i < gltf.nodes.length; i++)
                        if (!gltf.nodes[i].isChild)
                            gltf.nodes[i].render(cgl, false, true);
                    // render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time)
                }

                // cgl.popModelMatrix();
            }
        }
    }

    next.trigger();
    cgl.frameStore.currentScene = oldScene;

    cgl.popModelMatrix();

    if (cam)cam.end();
};

function finishLoading()
{
    if (!gltf)
    {
        op.setUiError("nogltf", "gltf not found");
        return;
    }
    op.setUiError("nogltf", null);
    if (gltf.loadingMeshes > 0)
    {
        // op.log("waiting for async meshes...");
        setTimeout(finishLoading, 100);
        return;
    }

    gltf.timing.push("finishLoading()", Math.round((performance.now() - gltf.startTime)));

    needsMatUpdate = true;
    // op.refreshParams();
    outAnimLength.set(maxTime);

    gltf.bounds = new CABLES.CG.BoundingBox();
    // gltf.bounds.applyPos(0, 0, 0);

    if (!gltf)op.setUiError("urlerror", "could not load gltf:<br/>\"" + inFile.get() + "\"", 2);
    else op.setUiError("urlerror", null);

    gltf.timing.push("start calc bounds", Math.round((performance.now() - gltf.startTime)));

    for (let i = 0; i < gltf.nodes.length; i++)
    {
        const node = gltf.nodes[i];
        node.updateMatrix();
        if (!node.isChild) node.calcBounds(gltf, null, gltf.bounds);
    }

    if (gltf.bounds)outBounds.set(gltf.bounds);

    gltf.timing.push("calced bounds", Math.round((performance.now() - gltf.startTime)));

    hideNodesFromData();

    gltf.timing.push("hideNodesFromData", Math.round((performance.now() - gltf.startTime)));

    if (tab)printInfo();

    gltf.timing.push("printinfo", Math.round((performance.now() - gltf.startTime)));

    updateCamera();
    setCam();
    outPoints.set(boundingPoints);

    if (gltf)
    {
        if (inFile.get() && !inFile.get().startsWith("data:"))
        {
            op.setUiAttrib({ "extendTitle": CABLES.basename(inFile.get()) });
        }

        gltf.loaded = Date.now();
        // if (gltf.bounds)outBounds.set(gltf.bounds);
    }

    if (gltf)
    {
        for (let i = 0; i < gltf.nodes.length; i++)
        {
            if (!gltf.nodes[i].isChild)
            {
                gltf.nodes[i].render(cgl, false, true, true, false, true, 0);
            }
        }

        for (let i = 0; i < gltf.nodes.length; i++)
        {
            const node = gltf.nodes[i];
            node.children = uniqueArray(node.children); // stupid fix why are there too many children ?!
        }
    }

    updateCenter();
    updateAnimation();

    outLoading.set(false);

    cgl.patch.loading.finished(loadingId);
    loadingId = null;

    // if (gltf.chunks.length > 1) gltf.chunks[1] = null;
    // if (gltf.chunks.length > 2) gltf.chunks[2] = null;

    op.setUiAttrib({ "accBuffersDelete": CABLES.basename(inFile.get()) });

    if (gltf.accBuffersDelete)
    {
        for (let i = 0; i < gltf.accBuffersDelete.length; i++)
        {
            gltf.accBuffers[gltf.accBuffersDelete[i]] = null;
        }
    }

    finishedLoading = true;
}

function loadBin(addCacheBuster)
{
    if (!inActive.get()) return;

    if (!loadingId)loadingId = cgl.patch.loading.start("gltfScene", inFile.get());

    let fileToLoad = inFile.get();
    let url = op.patch.getFilePath(String(inFile.get()));
    if (inFile.get() && !inFile.get().startsWith("data:"))
    {
        if (addCacheBuster === true)url += "?rnd=" + CABLES.generateUUID();
    }
    finishedLoading = false;
    outLoading.set(true);
    fetch(url)
        .then((res) => { return res.arrayBuffer(); })
        .then((arrayBuffer) =>
        {
            if (inFile.get() != fileToLoad)
            {
                cgl.patch.loading.finished(loadingId);
                loadingId = null;
                return;
            }

            boundingPoints = [];

            maxTime = 0;
            gltf = parseGltf(arrayBuffer);

            finishLoading();
        });
    closeTab();

    const oReq = new XMLHttpRequest();
    oReq.open("GET", url, true);
    oReq.responseType = "arraybuffer";

    cgl.patch.loading.addAssetLoadingTask(() =>
    {

    });
}

// op.onFileChanged = function (fn)
// {
//     gltf.accBuffersDelete[i];
//     if (fn && fn.length > 3 && inFile.get() && inFile.get().indexOf(fn) > -1) reloadSoon(true);
// };

op.onFileChanged = function (fn)
{
    if (inFile.get() && inFile.get().indexOf(fn) > -1)
    {
        reloadSoon(true);
    }
};

inActive.onChange = () =>
{
    if (inActive.get()) reloadSoon();

    if (!inActive.get())
    {
        gltf = null;
    }
};

function reloadSoon(nocache)
{
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function () { loadBin(nocache); }, 30);
}

function updateMaterials()
{
    if (!gltf) return;

    gltf.shaders = {};

    if (inMaterials.links.length == 1 && inMaterials.get())
    {
        // just accept a associative object with shader in it
        const op = inMaterials.links[0].portOut.parent;

        const portShader = op.getPort("Shader");
        const portName = op.getPort("Material Name");

        if (!portShader && !portName)
        {
            const inMats = inMaterials.get();
            for (let matname in inMats)
            {
                if (inMats[matname] && gltf.json.materials)
                    for (let i = 0; i < gltf.json.materials.length; i++)
                    {
                        if (gltf.json.materials[i].name == matname)
                        {
                            if (gltf.shaders[i])
                            {
                                op.warn("double material assignment:", name);
                            }
                            gltf.shaders[i] = inMats[matname];
                        }
                    }
            }
        }
    }

    if (inMaterials.get())
    {
        for (let j = 0; j < inMaterials.links.length; j++)
        {
            const op = inMaterials.links[j].portOut.parent;
            const portShader = op.getPort("Shader");
            const portName = op.getPort("Material Name");

            if (portShader && portName && portShader.get())
            {
                const name = portName.get();
                if (gltf.json.materials)
                    for (let i = 0; i < gltf.json.materials.length; i++)
                        if (gltf.json.materials[i].name == name)
                        {
                            if (gltf.shaders[i])
                            {
                                op.warn("double material assignment:", name);
                            }
                            gltf.shaders[i] = portShader.get();
                        }
            }
        }
    }
    needsMatUpdate = false;
    if (tab)printInfo();
}

function hideNodesFromArray()
{
    const hideArr = inHideNodes.get();

    if (!gltf || !data || !data.hiddenNodes) return;
    if (!hideArr)
    {
        return;
    }

    for (let i = 0; i < hideArr.length; i++)
    {
        const n = gltf.getNode(hideArr[i]);
        if (n)n.hidden = true;
    }
}

function hideNodesFromData()
{
    if (!data)loadData();
    if (!gltf) return;

    gltf.unHideAll();

    if (data && data.hiddenNodes)
    {
        for (const i in data.hiddenNodes)
        {
            const n = gltf.getNode(i);
            if (n) n.hidden = true;
            else op.verbose("node to be hidden not found", i, n);
        }
    }
    hideNodesFromArray();
}

function loadData()
{
    data = dataPort.get();

    if (!data || data === "")data = {};
    else data = JSON.parse(data);

    if (gltf)hideNodesFromData();

    return data;
}

function saveData()
{
    dataPort.set(JSON.stringify(data));
}

function updateAnimation()
{
    if (gltf && gltf.nodes)
    {
        for (let i = 0; i < gltf.nodes.length; i++)
        {
            gltf.nodes[i].setAnimAction(inAnimation.get());
        }
    }
}

function findParents(nodes, childNodeIndex)
{
    for (let i = 0; i < gltf.nodes.length; i++)
    {
        if (gltf.nodes[i].children.indexOf(childNodeIndex) >= 0)
        {
            nodes.push(gltf.nodes[i]);
            if (gltf.nodes[i].isChild) findParents(nodes, i);
        }
    }
}

op.exposeTexture = function (name)
{
    const newop = gui.corePatch().addOp("Ops.Gl.GLTF.GltfTexture");
    newop.getPort("Name").set(name);
    setNewOpPosition(newop, 1);
    op.patch.link(op, next.name, newop, "Render");
    gui.patchView.centerSelectOp(newop.id, true);
    gui.patchView.testCollision(newop);
};

op.exposeGeom = function (name, idx)
{
    const newop = gui.corePatch().addOp("Ops.Gl.GLTF.GltfGeometry");
    newop.getPort("Name").set(name);
    newop.getPort("Submesh").set(idx);
    setNewOpPosition(newop, 1);
    op.patch.link(op, next.name, newop, "Update");
    gui.patchView.centerSelectOp(newop.id, true);
    gui.patchView.testCollision(newop);
};

function setNewOpPosition(newOp, num)
{
    num = num || 1;

    newOp.setUiAttrib({ "translate": { "x": op.uiAttribs.translate.x, "y": op.uiAttribs.translate.y + num * CABLES.GLUI.glUiConfig.newOpDistanceY } });
}

op.exposeNode = function (name, type, options)
{
    let tree = type == "hierarchy";
    if (tree)
    {
        let ops = [];

        for (let i = 0; i < gltf.nodes.length; i++)
        {
            if (gltf.nodes[i].name == name)
            {
                let arrHierarchy = [];
                const node = gltf.nodes[i];
                findParents(arrHierarchy, i);

                arrHierarchy = arrHierarchy.reverse();
                arrHierarchy.push(node, node);

                let prevPort = next.name;
                let prevOp = op;
                for (let j = 0; j < arrHierarchy.length; j++)
                {
                    const newop = gui.corePatch().addOp("Ops.Gl.GLTF.GltfNode_v2");
                    newop.getPort("Node Name").set(arrHierarchy[j].name);
                    op.patch.link(prevOp, prevPort, newop, "Render");
                    setNewOpPosition(newop, j);

                    if (j == arrHierarchy.length - 1)
                    {
                        newop.getPort("Transformation").set(false);
                    }
                    else
                    {
                        newop.getPort("Draw Mesh").set(false);
                        newop.getPort("Draw Childs").set(false);
                    }

                    prevPort = "Next";
                    prevOp = newop;
                    ops.push(newop);
                    gui.patchView.testCollision(newop);
                }
            }
        }

        for (let i = 0; i < ops.length; i++)
        {
            ops[i].selectChilds();
        }
    }
    else
    {
        let newopname = "Ops.Gl.GLTF.GltfNode_v2";
        if (options && options.skin)newopname = "Ops.Gl.GLTF.GltfSkin";
        if (type == "transform")newopname = "Ops.Gl.GLTF.GltfNodeTransform_v2";

        gui.serverOps.loadOpLibs(newopname, () =>
        {
            let newop = gui.corePatch().addOp(newopname);

            newop.getPort("Node Name").set(name);
            setNewOpPosition(newop);
            op.patch.link(op, next.name, newop, "Render");
            gui.patchView.centerSelectOp(newop.id, true);
            gui.patchView.testCollision(newop);
        });
    }
    gui.closeModal();
};

op.assignMaterial = function (name)
{
    const newop = gui.corePatch().addOp("Ops.Gl.GLTF.GltfSetMaterial");
    newop.getPort("Material Name").set(name);
    op.patch.link(op, inMaterials.name, newop, "Material");
    gui.patchView.centerSelectOp(newop.id, true);
    setNewOpPosition(newop);
    gui.patchView.testCollision(newop);

    gui.closeModal();
};

op.toggleNodeVisibility = function (name)
{
    const n = gltf.getNode(name);
    n.hidden = !n.hidden;
    data.hiddenNodes = data.hiddenNodes || {};

    if (n)
        if (n.hidden)data.hiddenNodes[name] = true;
        else delete data.hiddenNodes[name];

    saveData();
};

op.showAnim = function (anim, channel)
{
    const an = gltf.json.animations[anim];
    const chan = gltf.json.animations[anim].channels[channel];

    const node = gltf.nodes[chan.target.node];
    const sampler = an.samplers[chan.sampler];

    const acc = gltf.json.accessors[sampler.input];
    const bufferIn = gltf.accBuffers[sampler.input];

    const accOut = gltf.json.accessors[sampler.output];
    const bufferOut = gltf.accBuffers[sampler.output];
};

function uniqueArray(arr)
{
    const u = {}, a = [];
    for (let i = 0, l = arr.length; i < l; ++i)
    {
        if (!u.hasOwnProperty(arr[i]))
        {
            a.push(arr[i]);
            u[arr[i]] = 1;
        }
    }
    return a;
}


};

Ops.Gl.GLTF.GltfScene_v3.prototype = new CABLES.Op();
CABLES.OPS["a9c59d94-8aea-4c20-ab5d-63ce46ecfa16"]={f:Ops.Gl.GLTF.GltfScene_v3,objName:"Ops.Gl.GLTF.GltfScene_v3"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfSetMaterial
// 
// **************************************************************

Ops.Gl.GLTF.GltfSetMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inShader = op.inObject("Shader", null, "shader"),
    inName = op.inString("Material Name", "none"),
    outMat = op.outObject("Material");

inName.onChange =
inShader.onChange = function ()
{
    op.setTitle("Material " + inName.get());
    outMat.set(null);
    outMat.set(inShader.get());
};


};

Ops.Gl.GLTF.GltfSetMaterial.prototype = new CABLES.Op();
CABLES.OPS["baf968ea-e4df-4fca-9cda-e6ddd38a4200"]={f:Ops.Gl.GLTF.GltfSetMaterial,objName:"Ops.Gl.GLTF.GltfSetMaterial"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfSkin
// 
// **************************************************************

Ops.Gl.GLTF.GltfSkin = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"joints_vert":"\n\n\n\n\n    // if(attrJoints.x!=-1.0)\n    {\n        int index=int(attrJoints.x);\n        vec4 newPos = (MOD_boneMats[index] * pos) * attrWeights.x;\n        vec3 newNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.x).xyz);\n\n        // if(attrJoints.y!=-1.0)\n        {\n            index=int(attrJoints.y);\n            newPos += (MOD_boneMats[index] * pos) * attrWeights.y;\n            newNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.y).xyz)+newNorm;\n        }\n\n        // if(attrJoints.z!=-1.0)\n        {\n            index=int(attrJoints.z);\n            newPos += (MOD_boneMats[index] * pos) * attrWeights.z;\n            newNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.z).xyz)+newNorm;\n        }\n\n        // if(attrJoints.w!=-1.0)\n        {\n            index=int(attrJoints.w);\n            newPos += (MOD_boneMats[index] * pos) * attrWeights.w ;\n            newNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.w).xyz)+newNorm;\n        }\n\n        pos=newPos;\n        norm=normalize(newNorm.xyz);\n    }\n\n\n\n// mat4 skinMatrix =\n//     attrWeights.x * MOD_boneMats[int(attrJoints.x)] +\n//     attrWeights.y * MOD_boneMats[int(attrJoints.y)] +\n//     attrWeights.z * MOD_boneMats[int(attrJoints.z)] +\n//     attrWeights.w * MOD_boneMats[int(attrJoints.w)];\n\n// mMatrix*=skinMatrix;\n\n\n\n\n\n\n\n\n\n","joints_head_vert":"IN vec4 attrWeights;\nIN vec4 attrJoints;\n\n\nUNI mat4 MOD_boneMats[SKIN_NUM_BONES];",};
const
    exec = op.inTrigger("Render"),
    inNodeName = op.inString("Node Name", "default"),
    inSceneTime = op.inBool("Scene Time", true),
    inTime = op.inFloat("Time", 0),
    inBlendAnims = op.inArray("Blend Anims"),
    outFound = op.outBool("Found Node"),
    outFoundSkin = op.outBool("Found Skin"),
    next = op.outTrigger("Next");

exec.onTriggered = update;
const cgl = op.patch.cgl;
const mod = new CGL.ShaderModifier(cgl, op.name);
let arr = [];
let node = null;
const tr = vec3.create();

inSceneTime.onChange = updateTimeInputs;

updateTimeInputs();

function updateTimeInputs()
{
    inTime.setUiAttribs({ "greyout": inSceneTime.get() });
}

inNodeName.onChange = () =>
{
    op.setUiAttrib({ "extendTitle": inNodeName.get() });
    node = null;
    update();
};

function update()
{
    if (!cgl.frameStore || !cgl.frameStore.currentScene) return;

    const gltf = cgl.frameStore.currentScene;
    const name = inNodeName.get();

    for (let i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
    {
        if (cgl.frameStore.currentScene.nodes[i].name == name)
        {
            node = cgl.frameStore.currentScene.nodes[i];
            outFound.set(true);
        }
    }

    if (!node)
    {
        outFound.set(false);
        return;
    }
    outFoundSkin.set(node.skin > -1);

    if (node.skin == -1)
    {
        return;
    }

    if (!gltf.json.skins)
    {
        op.warn.log("no skins found...");
        return;
    }

    let time = gltf.time;
    if (!inSceneTime.get())
    {
        time = inTime.get();
    }

    if (!inSceneTime.get())
        for (let i = 0; i < gltf.nodes.length; i++)
            if (!gltf.nodes[i].isChild)
                gltf.nodes[i].render(cgl, false, true, true, false, false, time);

    transformBlend(node, cgl, time);

    node.render(cgl, true, false, true, false, true, time);

    next.trigger();
}

function transformBlend(node, cgl, time)
{
    // let hasTrans = node._anims.trans.length > 0;
    // let hasRot = node._anims.rot.length > 0;
    // hasRot = false;
    // let hasScale = node._anims.scale.length > 0;
    // hasScale = false;

    const animnames = Object.keys(cgl.frameStore.currentScene.uniqueAnimNames);

    const weights = inBlendAnims.get();

    // if ((!hasTrans && !hasRot && !hasScale) || _w === 0)
    // {
    //     mat4.mul(cgl.mMatrix, cgl.mMatrix, node.mat);
    //     node._animMat = null;
    // }
    // else
    {
        // node._animActions[n][path]
        // animnames

        node._animMat = node._animMat || mat4.create();
        mat4.identity(node._animMat);

        const playAnims = true;

        if (playAnims)
        {
            let _x = 0, _y = 0, _z = 0, _w = 0;

            for (let i = 0; i < animnames.length; i++)
            {
                const animName = animnames[i];
                if (!node._animActions[animName] || !node._animActions[animName].translation) continue;

                let _time = time;// times[animnames[i]];
                // let _anim = node._anims.trans[i];

                let _anim = node._animActions[animName].translation;
                let weight = weights[i];

                if (_anim)
                {
                    _x += _anim[0].getValue(_time) * weight + (_anim[0].getValue(0) * (1 - weight));
                    _y += _anim[1].getValue(_time) * weight + (_anim[1].getValue(0) * (1 - weight));
                    _z += _anim[2].getValue(_time) * weight + (_anim[2].getValue(0) * (1 - weight));
                    _w += 1;
                }
            }

            if (_w > 0)
            {
                _x /= _w;
                _y /= _w;
                _z /= _w;

                mat4.translate(node._animMat, node._animMat, [_x, _y, _z]);
            }
        }
        else
        if (node._node.translation) mat4.translate(node._animMat, node._animMat, node._node.translation);

        if (playAnims)
        {
            node._tempQuats = node._tempQuats || [];

            for (let i = 0; i < animnames.length; i++)
            {
                const animName = animnames[i];
                if (!node._animActions[animName] || !node._animActions[animName].translation) continue;

                let _time = time;// times[animnames[i]];

                let _tempQuat2 = node._tempQuats[i] || quat.create();

                // let shouldAnim = node._anims.rot[i] && node._anims.trans[i];
                // let _anim = node._anims.rot[i];
                let _anim = node._animActions[animName].rotation;
                let weight = weights[i];

                if (_anim)
                {
                    CABLES.TL.Anim.slerpQuaternion(_time, _tempQuat2, _anim[0], _anim[1], _anim[2], _anim[3]);
                }
                node._tempQuats[i] = (_tempQuat2);
            }

            let _finalQuat = node._tempQuat;

            for (let i = 0; i < node._tempQuats.length; i++)
            {
                // if (weights[i] === 0) continue;
                quat.slerp(_finalQuat, _finalQuat, node._tempQuats[i], node._anims.trans[i] ? weights[i] : 0);
            }

            mat4.fromQuat(node._tempMat, _finalQuat);
            mat4.mul(node._animMat, node._animMat, node._tempMat);

            node._tempQuat = _finalQuat;
        }
        else if (node._rot)
        {
            mat4.fromQuat(node._tempRotmat, node._rot);
            mat4.mul(node._animMat, node._animMat, node._tempRotmat);
        }

        if (playAnims)
        {
            let _x = 0, _y = 0, _z = 0, _w = 0;

            for (let i = 0; i < animnames.length; i++)
            {
                const animName = animnames[i];
                if (!node._animActions[animName] || !node._animActions[animName].translation) continue;

                let _time = time;// times[animnames[i]];

                // let _anim = node._anims.scale[i];
                let _anim = node._animActions[animName].scaling;
                let weight = weights[i];

                if (_anim)
                {
                    _x += _anim[0].getValue(_time) * weight;
                    _y += _anim[1].getValue(_time) * weight;
                    _z += _anim[2].getValue(_time) * weight;
                    _w += weight;
                }
            }

            if (_w > 0)
            {
                _x /= _w;
                _y /= _w;
                _z /= _w;

                mat4.scale(node._animMat, node._animMat, [_x, _y, _z]);
            }
        }
        else if (node._scale) mat4.scale(node._animMat, node._animMat, node._scale);

        mat4.mul(cgl.mMatrix, cgl.mMatrix, node._animMat);
    }

    if (node.addTranslate)mat4.translate(cgl.mMatrix, cgl.mMatrix, node.addTranslate);

    if (node.addMulMat) mat4.mul(cgl.mMatrix, cgl.mMatrix, node.addMulMat);

    mat4.copy(node.absMat, cgl.mMatrix);
}


};

Ops.Gl.GLTF.GltfSkin.prototype = new CABLES.Op();
CABLES.OPS["0ce62e9b-d990-4ae2-b40f-a036a021aa9c"]={f:Ops.Gl.GLTF.GltfSkin,objName:"Ops.Gl.GLTF.GltfSkin"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfTexture
// 
// **************************************************************

Ops.Gl.GLTF.GltfTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Render"),
    imgName = op.inString("Name", ""),
    tfilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"], "mipmap"),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"),
    aniso = op.inSwitch("Anisotropic", [0, 1, 2, 4, 8, 16], 0),
    flip = op.inValueBool("Flip", false),
    unpackAlpha = op.inValueBool("Pre Multiplied Alpha", false),
    outTex = op.outTexture("Texture"),
    width = op.outNumber("Width"),
    height = op.outNumber("Height"),
    type = op.outString("Type"),
    outFound = op.outBool("Found");

const cgl = op.patch.cgl;
let tex = null;
let cgl_filter = 0;
let cgl_wrap = 0;
let cgl_aniso = 0;

aniso.onChange = tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;
imgName.onChange = flip.onChange = unpackAlpha.onChange = function () { reloadSoon(); };

function reloadSoon()
{
    tex = null;
}

inExec.onTriggered = function ()
{
    if (tex) return;

    if (!cgl.frameStore.currentScene || !cgl.frameStore.currentScene.json) return;

    if (cgl.frameStore.currentScene.chunks.length < 2)
    {
        return;
    }

    if (!cgl.frameStore.currentScene.json.images) return;

    let img = null;

    for (let i = 0; i < cgl.frameStore.currentScene.json.images.length; i++)
    {
        if (cgl.frameStore.currentScene.json.images[i].name == imgName.get() || cgl.frameStore.currentScene.json.images[i].bufferView == parseFloat(imgName.get()))
        {
            img = cgl.frameStore.currentScene.json.images[i];
        }
    }
    if (!img)
    {
        tex = CGL.Texture.getEmptyTexture(cgl);
        outFound.set(false);
        outTex.set(tex);
        width.set(tex.width);
        height.set(tex.height);
        return;
    }

    const buffView = cgl.frameStore.currentScene.json.bufferViews[img.bufferView];
    let dv = cgl.frameStore.currentScene.chunks[1].dataView;

    if (!buffView) return;
    const data = new Uint8Array(buffView.byteLength);

    for (let i = 0; i < buffView.byteLength; i++)
        data[i] = dv.getUint8(buffView.byteOffset + i);

    const blob = new Blob([data.buffer], { "type": img.mimeType });
    const sourceURI = URL.createObjectURL(blob);

    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;
    else if (tfilter.get() == "Anisotropic") cgl_filter = CGL.Texture.FILTER_ANISOTROPIC;

    cgl_aniso = parseFloat(aniso.get());

    tex = CGL.Texture.load(cgl, sourceURI,
        function (err)
        {
            if (err)
            {
                outFound.set(false);
            }

            outTex.set(tex);

            width.set(tex.width);
            height.set(tex.height);
            type.set(img.mimeType);
            outTex.set(null);
            outTex.set(tex);
            outFound.set(true);
        }, {
            "anisotropic": cgl_aniso,
            "wrap": cgl_wrap,
            "flip": flip.get(),
            "unpackAlpha": unpackAlpha.get(),
            "filter": cgl_filter
        });

    outTex.set(null);
    outTex.set(tex);
};

function onFilterChange()
{
    reloadSoon();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reloadSoon();
}


};

Ops.Gl.GLTF.GltfTexture.prototype = new CABLES.Op();
CABLES.OPS["6479a948-7a48-42a3-b40a-794f4364715f"]={f:Ops.Gl.GLTF.GltfTexture,objName:"Ops.Gl.GLTF.GltfTexture"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfTransformNode
// 
// **************************************************************

Ops.Gl.GLTF.GltfTransformNode = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Render"),
    inNodeName = op.inString("Node Name"),
    inPosX = op.inFloat("Translate X", 0),
    inPosY = op.inFloat("Translate Y", 0),
    inPosZ = op.inFloat("Translate Z", 0),
    inRotX = op.inFloat("Rotation X", 0),
    inRotY = op.inFloat("Rotation Y", 0),
    inRotZ = op.inFloat("Rotation Z", 0),
    next = op.outTrigger("Next"),
    outFound = op.outBool("Found");

const cgl = op.patch.cgl;

let q = quat.create();
let mat = mat4.create();
let qmat = mat4.create();

let node = null;
let currentSceneLoaded = null;

inNodeName.onChange = function ()
{
    node = null;
    outFound.set(false);
    op.setUiAttrib({ "extendTitle": inNodeName.get() });
};

op.onDelete = function ()
{
    // todo restore orig values!
};

inExec.onTriggered = function ()
{
    if (!cgl.frameStore.currentScene) return;
    if (currentSceneLoaded != cgl.frameStore.currentScene.loaded) node = null;

    if (!node)
    {
        const name = inNodeName.get();

        if (!cgl.frameStore || !cgl.frameStore.currentScene || !cgl.frameStore.currentScene.nodes) return;

        currentSceneLoaded = cgl.frameStore.currentScene.loaded;

        for (let i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
        {
            if (cgl.frameStore.currentScene.nodes[i].name == name)
            {
                node = cgl.frameStore.currentScene.nodes[i];
                outFound.set(true);
            }
        }
    }

    if (node)
    {
        mat4.identity(mat);
        mat4.translate(mat, mat, [inPosX.get(), inPosY.get(), inPosZ.get()]);

        mat4.rotateX(mat, mat, inRotX.get());
        mat4.rotateY(mat, mat, inRotY.get());
        mat4.rotateZ(mat, mat, inRotZ.get());

        node.addMulMat = mat;
    }

    next.trigger();
};


};

Ops.Gl.GLTF.GltfTransformNode.prototype = new CABLES.Op();
CABLES.OPS["bccdb19d-6786-4656-90d7-e798346ea644"]={f:Ops.Gl.GLTF.GltfTransformNode,objName:"Ops.Gl.GLTF.GltfTransformNode"};




// **************************************************************
// 
// Ops.Gl.GLTF.GltfVertexAnim
// 
// **************************************************************

Ops.Gl.GLTF.GltfVertexAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Render"),
    inNodeName = op.inString("Node Name", "default"),
    inSceneTime = op.inBool("Scene Time", true),
    inTime = op.inFloat("Time", 0),
    outFound = op.outBoolNum("Found Node"),
    next = op.outTrigger("Next");

exec.onTriggered = render;
const cgl = op.patch.cgl;
let node = null;
let needsUpdate = true;
let origGMesh = null;
let mesh = null;
let geom = null;
let morphGeom = null;
let origGeom = null;

inSceneTime.onChange = updateTimeInputs;
updateTimeInputs();

let lastMorph1 = -1;
let lastMorph2 = -1;
let lastFract = -1;

inNodeName.onChange = () =>
{
    op.setUiAttrib({ "extendTitle": inNodeName.get() });
    node = null;
    needsUpdate = true;
    lastMorph1 = -1;
    lastMorph2 = -1;
    lastFract = -1;
};

function updateTimeInputs()
{
    inTime.setUiAttribs({ "greyout": inSceneTime.get() });
}

function morph(finalGeom, mt, mt2, fract)
{
    if (mt && mt.vertices && mt2)
    {
        if (finalGeom.vertexNormals.length != mt.vertexNormals.length)
            finalGeom.vertexNormals = new Float32Array(mt.vertexNormals.length);

        for (let i = 0; i < finalGeom.vertices.length; i++)
        {
            finalGeom.vertices[i] =
                    origGeom.vertices[i] +
                    (1.0 - fract) * mt.vertices[i] +
                    fract * mt2.vertices[i];

            finalGeom.vertexNormals[i] =
                    (1.0 - fract) * mt.vertexNormals[i] +
                    fract * mt2.vertexNormals[i];
        }
    }
}


function update()
{
    if (!cgl.frameStore.currentScene) return;

    needsUpdate = false;
    mesh = null;

    const gltf = cgl.frameStore.currentScene;
    const name = inNodeName.get();
    for (let i = 0; i < cgl.frameStore.currentScene.nodes.length; i++)
    {
        op.log(cgl.frameStore.currentScene.nodes[i].name);
        if (cgl.frameStore.currentScene.nodes[i].name == name)
        {
            node = cgl.frameStore.currentScene.nodes[i];
            outFound.set(true);
            op.log(node);

            if (node.mesh && node.mesh.meshes)
            {
                // mesh=node.mesh.meshes[0].copy();
                origGMesh = node.mesh.meshes[0];
                origGeom = node.mesh.meshes[0].geom;
                geom = node.mesh.meshes[0].geom.copy();
                morphGeom = geom.copy();
                mesh = new CGL.Mesh(cgl, geom);
                // mesh.setGeom();
            }
            else op.warn("[gltfvertexanim] node found but no meshes");

            op.log("orig mesh", node.mesh.meshes[0]);
            op.log("mesh", mesh);
        }
    }

    if (!node)
    {
        outFound.set(false);
    }
}

function render()
{
    if (!cgl.frameStore.currentScene) return;

    if (needsUpdate) update();

    if (!geom) return;
    if (!mesh) return;

    let time = cgl.frameStore.currentScene.time;
    if (!inSceneTime.get())time = inTime.get();

    if (time >= geom.morphTargets.length - 1) time = geom.morphTargets.length - 1;

    let morph1 = Math.floor(time);
    let morph2 = Math.floor(time + 1);
    const fract = time % 1;

    if (lastMorph1 != morph1 || lastMorph2 != morph2 || fract != lastFract)
    {
        const mt = geom.morphTargets[morph1];
        const mt2 = geom.morphTargets[morph2];

        morph(morphGeom, mt, mt2, fract);

        mesh.updateNormals(morphGeom);
        mesh.updateVertices(morphGeom);

        lastMorph1 = morph1;
        lastMorph2 = morph2;
        lastFract = fract;
    }

    mesh.render(cgl.getShader());

    next.trigger();
}


};

Ops.Gl.GLTF.GltfVertexAnim.prototype = new CABLES.Op();
CABLES.OPS["e64b035c-133e-43b0-9ff8-fcd03ee5f26e"]={f:Ops.Gl.GLTF.GltfVertexAnim,objName:"Ops.Gl.GLTF.GltfVertexAnim"};




// **************************************************************
// 
// Ops.Gl.Geometry.AlignGeometry
// 
// **************************************************************

Ops.Gl.Geometry.AlignGeometry = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    geometry = op.inObject("Geometry"),
    x = op.inValueSelect("X", ["Ignore", "Center", "Max", "Min"], "Ignore"),
    y = op.inValueSelect("Y", ["Ignore", "Center", "Max", "Min"], "Ignore"),
    z = op.inValueSelect("Z", ["Ignore", "Center", "Max", "Min"], "Ignore"),
    outGeom = op.outObject("Result");

x.onChange = y.onChange = z.onChange = geometry.onChange = update;

const
    axis = [0, 0, 0],
    ALIGN_NONE = 0,
    ALIGN_CENTER = 1,
    ALIGN_MAX = 2,
    ALIGN_MIN = 3;

let oldGeom = null,
    geom = null;

function getAxisId(port)
{
    if (port.get() == "Ignore") return ALIGN_NONE;
    if (port.get() == "Center") return ALIGN_CENTER;
    if (port.get() == "Max") return ALIGN_MAX;
    if (port.get() == "Min") return ALIGN_MIN;
}

function update()
{
    if (oldGeom != geometry.get())
    {
        geom = null;
        oldGeom = geometry.get();
    }

    if (!oldGeom)
    {
        outGeom.set(null);
        return;
    }

    axis[0] = getAxisId(x);
    axis[1] = getAxisId(y);
    axis[2] = getAxisId(z);

    const bounds = oldGeom.getBounds();
    if (!geom) geom = oldGeom.copy();

    for (let axi = 0; axi < 3; axi++)
    {
        let min = 0, max = 0;
        if (axi === 0)
        {
            min = bounds.minX;
            max = bounds.maxX;
        }
        else if (axi == 1)
        {
            min = bounds.minY;
            max = bounds.maxY;
        }
        else if (axi == 2)
        {
            min = bounds.minZ;
            max = bounds.maxZ;
        }

        if (axis[axi] == ALIGN_NONE)
        {
            for (let i = 0; i < geom.vertices.length; i += 3)
                geom.vertices[i + axi] = oldGeom.vertices[i + axi];
        }
        else if (axis[axi] == ALIGN_CENTER)
        {
            const off = min + (max - min) / 2;
            for (let i = 0; i < geom.vertices.length; i += 3)
                geom.vertices[i + axi] = oldGeom.vertices[i + axi] - off;
        }
        else if (axis[axi] == ALIGN_MAX)
        {
            for (let i = 0; i < geom.vertices.length; i += 3)
                geom.vertices[i + axi] = oldGeom.vertices[i + axi] - max;
        }
        else if (axis[axi] == ALIGN_MIN)
        {
            for (let i = 0; i < geom.vertices.length; i += 3)
                geom.vertices[i + axi] = oldGeom.vertices[i + axi] - min;
        }
    }

    outGeom.set(null);
    outGeom.set(geom);
}


};

Ops.Gl.Geometry.AlignGeometry.prototype = new CABLES.Op();
CABLES.OPS["955c1a40-17ca-4944-8cf6-07e14212be2d"]={f:Ops.Gl.Geometry.AlignGeometry,objName:"Ops.Gl.Geometry.AlignGeometry"};




// **************************************************************
// 
// Ops.Gl.Geometry.BoundingBoxVisible
// 
// **************************************************************

Ops.Gl.Geometry.BoundingBoxVisible = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Exec"),
    inBB = op.inObject("Boundings"),
    inActive = op.inBool("Active", true),
    inDraw = op.inBool("Draw", true),

    inWidth = op.inFloat("Width", 1),
    inHeight = op.inFloat("Height", 1),
    inLength = op.inFloat("Length", 1),

    next = op.outTrigger("Next"),
    result = op.outBool("Visible"),

    cgl = op.patch.cgl,
    trans = vec3.create(),
    m = mat4.create(),
    pos = vec3.create(),
    identVec = vec3.create();

let
    vp = null,
    geom = null,
    bb = null,
    mesh = null;

inBB.onLinkChanged = updateUi;
updateUi();

function isVisible(posi)
{
    // vec3.add(pos,pos,posi);
    vec3.transformMat4(pos, posi, m);

    vec3.transformMat4(trans, pos, cgl.pMatrix);

    const xp = (trans[0] * vp[2] / 2) + vp[2] / 2;
    const yp = (trans[1] * vp[3] / 2) + vp[3] / 2;

    return pos[2] < 0.0 && xp > 0 && xp < vp[2] && yp > 0 && yp < vp[3];
}

function updateUi()
{
    inWidth.setUiAttribs({ "greyout": inBB.isLinked() });
    inHeight.setUiAttribs({ "greyout": inBB.isLinked() });
    inLength.setUiAttribs({ "greyout": inBB.isLinked() });
}

inHeight.onChange =
inLength.onChange =
inWidth.onChange =
inBB.onChange = function ()
{
    mesh = null;
};
buildMesh();

function buildMesh()
{
    if (inBB.isLinked())
    {
        bb = inBB.get();
        if (!bb || !bb._max || !bb._min) return;
    }
    else
    {
        bb = new CABLES.CG.BoundingBox();

        bb.applyPos(inWidth.get() / 2, inHeight.get() / 2, inLength.get() / 2);
        bb.applyPos(-inWidth.get() / 2, -inHeight.get() / 2, -inLength.get() / 2);
    }

    geom = new CGL.Geometry(op.name);
    geom.vertices =
    [
        bb._max[0], bb._max[1], bb._max[2],
        bb._min[0], bb._max[1], bb._max[2],

        bb._min[0], bb._max[1], bb._max[2],
        bb._min[0], bb._min[1], bb._max[2],

        bb._min[0], bb._min[1], bb._max[2],
        bb._max[0], bb._min[1], bb._max[2],

        bb._max[0], bb._min[1], bb._max[2],
        bb._max[0], bb._max[1], bb._max[2],

        //

        bb._max[0], bb._max[1], bb._min[2],
        bb._min[0], bb._max[1], bb._min[2],

        bb._min[0], bb._max[1], bb._min[2],
        bb._min[0], bb._min[1], bb._min[2],

        bb._min[0], bb._min[1], bb._min[2],
        bb._max[0], bb._min[1], bb._min[2],

        bb._max[0], bb._min[1], bb._min[2],
        bb._max[0], bb._max[1], bb._min[2],

        //

        bb._max[0], bb._max[1], bb._min[2],
        bb._max[0], bb._max[1], bb._max[2],

        bb._min[0], bb._max[1], bb._min[2],
        bb._min[0], bb._max[1], bb._max[2],

        bb._max[0], bb._min[1], bb._min[2],
        bb._max[0], bb._min[1], bb._max[2],

        bb._min[0], bb._min[1], bb._min[2],
        bb._min[0], bb._min[1], bb._max[2],

        //

        bb._min[0], bb._min[1], bb._min[2],
        bb._max[0], bb._max[1], bb._max[2],

        bb._max[0], bb._min[1], bb._min[2],
        bb._min[0], bb._max[1], bb._max[2],

    ];

    mesh = new CGL.Mesh(cgl, geom, cgl.gl.LINES);
}

// LINE/LINE
function lineToScreen(posA, posB)
{
    vec3.transformMat4(pos, posA, m);
    vec3.transformMat4(trans, pos, cgl.pMatrix);

    if (pos[2] > 0.0) return false;

    const x1 = (trans[0] * vp[2] / 2) + vp[2] / 2;
    const y1 = (trans[1] * vp[3] / 2) + vp[3] / 2;

    vec3.transformMat4(pos, posB, m);
    vec3.transformMat4(trans, pos, cgl.pMatrix);

    if (pos[2] > 0.0) return false;

    const x2 = (trans[0] * vp[2] / 2) + vp[2] / 2;
    const y2 = (trans[1] * vp[3] / 2) + vp[3] / 2;

    const w = vp[2];
    const h = vp[3];

    return lineline(x1, y1, x2, y2, 0, 0, w, h) ||

        lineline(x1, y1, x2, y2, 0, 0, w, 0) ||
        lineline(x1, y1, x2, y2, 0, h, w, h) ||

        lineline(x1, y1, x2, y2, 0, 0, 0, h) ||
        lineline(x1, y1, x2, y2, w, 0, w, h);
}

function lineline(x1, y1, x2, y2, x3, y3, x4, y4)
{
    // calculate the direction of the lines
    const uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
    const uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

    // if uA and uB are between 0-1, lines are colliding
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1)
    {
        // const intersectionX =d x1 + (uA * (x2 - x1));
        // const intersectionY = y1 + (uA * (y2 - y1));

        return true;
    }
    return false;
}

exec.onTriggered = () =>
{
    if (!inActive.get()) return;

    if (inBB.isLinked())
    {
        bb = inBB.get();
    }

    if (inBB.isLinked() && (!bb || !bb._center || !bb._max))
    {
        result.set(false);
        return;
    }

    if (inDraw.get())
    {
        if (!geom || !mesh) buildMesh();
        if (mesh)mesh.render(cgl.getShader());
    }

    vp = cgl.getViewPort();

    mat4.multiply(m, cgl.vMatrix, cgl.mMatrix);

    if (bb)
    {
        const isVis =

            isVisible(bb._center) ||

            isVisible(bb._max) ||
            isVisible(bb._min) ||

            lineToScreen(bb._max, bb._min) ||

            lineToScreen([bb._max[0], bb._max[1], bb._max[2]], [bb._min[0], bb._max[1], bb._max[2]]) ||
            lineToScreen([bb._min[0], bb._max[1], bb._max[2]], [bb._min[0], bb._min[1], bb._max[2]]) ||
            lineToScreen([bb._min[0], bb._min[1], bb._max[2]], [bb._max[0], bb._min[1], bb._max[2]]) ||
            lineToScreen([bb._max[0], bb._min[1], bb._max[2]], [bb._max[0], bb._max[1], bb._max[2]]) ||

            //

            lineToScreen([bb._max[0], bb._max[1], bb._min[2]], [bb._min[0], bb._max[1], bb._min[2]]) ||
            lineToScreen([bb._min[0], bb._max[1], bb._min[2]], [bb._min[0], bb._min[1], bb._min[2]]) ||
            lineToScreen([bb._min[0], bb._min[1], bb._min[2]], [bb._max[0], bb._min[1], bb._min[2]]) ||
            lineToScreen([bb._max[0], bb._min[1], bb._min[2]], [bb._max[0], bb._max[1], bb._min[2]]) ||

            //

            lineToScreen([bb._max[0], bb._max[1], bb._min[2]], [bb._max[0], bb._max[1], bb._max[2]]) ||
            lineToScreen([bb._min[0], bb._max[1], bb._min[2]], [bb._min[0], bb._max[1], bb._max[2]]) ||
            lineToScreen([bb._max[0], bb._min[1], bb._min[2]], [bb._max[0], bb._min[1], bb._max[2]]) ||
            lineToScreen([bb._min[0], bb._min[1], bb._min[2]], [bb._min[0], bb._min[1], bb._max[2]]);

        result.set(isVis);
    }

    next.trigger();
};


};

Ops.Gl.Geometry.BoundingBoxVisible.prototype = new CABLES.Op();
CABLES.OPS["a4a8d0ca-296e-4bf5-a7be-4585f875bc06"]={f:Ops.Gl.Geometry.BoundingBoxVisible,objName:"Ops.Gl.Geometry.BoundingBoxVisible"};




// **************************************************************
// 
// Ops.Gl.Geometry.DivideGeometry
// 
// **************************************************************

Ops.Gl.Geometry.DivideGeometry = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

let geometry = op.inObject("Geometry");
let outGeom = op.outObject("Result");

geometry.onChange = update;


function update()
{
    outGeom.set(null);
    if (geometry.get())
    {
        let geom = geometry.get();
        let newGeom = new CGL.Geometry(op.name);

        let newVerts = [];
        let newFaces = [];
        let newNormals = [];
        let newTexCoords = [];

        for (let i = 0; i < geom.verticesIndices.length; i += 3)
        {
            newFaces.push(newVerts.length / 3);
            newVerts.push(geom.vertices[geom.verticesIndices[i + 0] * 3 + 0]);
            newVerts.push(geom.vertices[geom.verticesIndices[i + 0] * 3 + 1]);
            newVerts.push(geom.vertices[geom.verticesIndices[i + 0] * 3 + 2]);
            newNormals.push(geom.vertexNormals[geom.verticesIndices[i + 0] * 3 + 0]);
            newNormals.push(geom.vertexNormals[geom.verticesIndices[i + 0] * 3 + 1]);
            newNormals.push(geom.vertexNormals[geom.verticesIndices[i + 0] * 3 + 2]);
            newTexCoords.push(geom.texCoords[geom.verticesIndices[i + 0] * 2 + 0]);
            newTexCoords.push(geom.texCoords[geom.verticesIndices[i + 0] * 2 + 1]);

            newFaces.push(newVerts.length / 3);
            newVerts.push(geom.vertices[geom.verticesIndices[i + 1] * 3 + 0]);
            newVerts.push(geom.vertices[geom.verticesIndices[i + 1] * 3 + 1]);
            newVerts.push(geom.vertices[geom.verticesIndices[i + 1] * 3 + 2]);
            newNormals.push(geom.vertexNormals[geom.verticesIndices[i + 1] * 3 + 0]);
            newNormals.push(geom.vertexNormals[geom.verticesIndices[i + 1] * 3 + 1]);
            newNormals.push(geom.vertexNormals[geom.verticesIndices[i + 1] * 3 + 2]);
            newTexCoords.push(geom.texCoords[geom.verticesIndices[i + 1] * 2 + 0]);
            newTexCoords.push(geom.texCoords[geom.verticesIndices[i + 1] * 2 + 1]);

            newFaces.push(newVerts.length / 3);
            newVerts.push(geom.vertices[geom.verticesIndices[i + 2] * 3 + 0]);
            newVerts.push(geom.vertices[geom.verticesIndices[i + 2] * 3 + 1]);
            newVerts.push(geom.vertices[geom.verticesIndices[i + 2] * 3 + 2]);
            newNormals.push(geom.vertexNormals[geom.verticesIndices[i + 2] * 3 + 0]);
            newNormals.push(geom.vertexNormals[geom.verticesIndices[i + 2] * 3 + 1]);
            newNormals.push(geom.vertexNormals[geom.verticesIndices[i + 2] * 3 + 2]);
            newTexCoords.push(geom.texCoords[geom.verticesIndices[i + 2] * 2 + 0]);
            newTexCoords.push(geom.texCoords[geom.verticesIndices[i + 2] * 2 + 1]);
        }

        newGeom.vertices = newVerts;
        newGeom.vertexNormals = newNormals;
        newGeom.verticesIndices = newFaces;
        newGeom.setTexCoords(newTexCoords);

        outGeom.set(newGeom);
    }
}


};

Ops.Gl.Geometry.DivideGeometry.prototype = new CABLES.Op();
CABLES.OPS["ab0c768e-e684-47ba-b11f-f95d86532df2"]={f:Ops.Gl.Geometry.DivideGeometry,objName:"Ops.Gl.Geometry.DivideGeometry"};




// **************************************************************
// 
// Ops.Gl.Geometry.FlipNormals
// 
// **************************************************************

Ops.Gl.Geometry.FlipNormals = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    geometry = op.inObject("Geometry"),
    outGeom = op.outObject("Result"),
    doFlip = op.inValueBool("Flip", true),
    doNormalize = op.inValueBool("Normalize", true);

doFlip.onChange =
    doNormalize.onChange =
    geometry.onChange = flip;

function flip()
{
    let oldGeom = geometry.get();

    if (!oldGeom)
    {
        outGeom.set(null);
        return;
    }

    let geom = oldGeom.copy();

    if (doFlip.get())
    {
        for (let i = 0; i < geom.vertexNormals.length; i++)
            geom.vertexNormals[i] *= -1;

        if (doNormalize.get())
        {
            let vec = vec3.create();

            for (let i = 0; i < geom.vertexNormals.length; i += 3)
            {
                vec3.set(vec,
                    geom.vertexNormals[i + 0],
                    geom.vertexNormals[i + 1],
                    geom.vertexNormals[i + 2]);
                vec3.normalize(vec, vec);

                geom.vertexNormals[i + 0] = vec[0];
                geom.vertexNormals[i + 1] = vec[1];
                geom.vertexNormals[i + 2] = vec[2];
            }
        }
    }

    outGeom.set(geom);
}


};

Ops.Gl.Geometry.FlipNormals.prototype = new CABLES.Op();
CABLES.OPS["0055f588-dde6-4232-958b-4c19cdc67abd"]={f:Ops.Gl.Geometry.FlipNormals,objName:"Ops.Gl.Geometry.FlipNormals"};




// **************************************************************
// 
// Ops.Gl.Geometry.FreezeMeshes
// 
// **************************************************************

Ops.Gl.Geometry.FreezeMeshes = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inCapture = op.inTriggerButton("Capture"),
    outGeom = op.outObject("Geometry", null, "geometry"),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;
let shouldCapture = false;
let geom = null;

inCapture.onTriggered = () =>
{
    shouldCapture = true;
    if (shouldCapture)
    {
        geom = new CGL.Geometry();

        const old = CGL.Mesh.prototype.render;
        CGL.Mesh.prototype.render = meshCapture;

        next.trigger();

        CGL.Mesh.prototype.render = old;
        shouldCapture = false;

        // geom.unIndex(false, true);

        outGeom.set(null);
        outGeom.set(geom);
    }
};

function meshCapture()
{
    if (!this._geom || !this._geom.copy)
    {
        return;
    }

    const g = this._geom.copy();
    const normalMat = mat4.create();
    mat4.invert(normalMat, cgl.mMatrix);
    mat4.transpose(normalMat, normalMat);

    for (let i = 0; i < g.vertices.length; i += 3)
    {
        const v = [g.vertices[i + 0], g.vertices[i + 1], g.vertices[i + 2]];

        vec3.transformMat4(v, v, cgl.mMatrix);

        g.vertices[i + 0] = v[0];
        g.vertices[i + 1] = v[1];
        g.vertices[i + 2] = v[2];

        // ----------

        const vn = [g.vertexNormals[i + 0], g.vertexNormals[i + 1], g.vertexNormals[i + 2], 1];
        vec4.transformMat4(vn, vn, normalMat);

        g.vertexNormals[i + 0] = vn[0];
        g.vertexNormals[i + 1] = vn[1];
        g.vertexNormals[i + 2] = vn[2];
    }

    // g.unIndex();
    geom.merge(g);
}


};

Ops.Gl.Geometry.FreezeMeshes.prototype = new CABLES.Op();
CABLES.OPS["6bcd033d-3a20-477f-93f1-33d0c701528a"]={f:Ops.Gl.Geometry.FreezeMeshes,objName:"Ops.Gl.Geometry.FreezeMeshes"};




// **************************************************************
// 
// Ops.Gl.Geometry.GeometryBoundingBox
// 
// **************************************************************

Ops.Gl.Geometry.GeometryBoundingBox = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inGeom = op.inObject("Geometry"),
    outBB = op.outObject("Boundings"),
    outMinX = op.outNumber("Min X"),
    outMinY = op.outNumber("Min Y"),
    outMinZ = op.outNumber("Min Z"),
    outMaxX = op.outNumber("Max X"),
    outMaxY = op.outNumber("Max Y"),
    outMaxZ = op.outNumber("Max Z"),
    outPoints = op.outArray("MaxMin Points");

const points = [];

inGeom.onChange = () =>
{
    const bb = new CGL.BoundingBox(inGeom.get());
    outBB.set(bb);

    outMinX.set(bb._min[0]);
    outMinY.set(bb._min[1]);
    outMinZ.set(bb._min[2]);

    outMaxX.set(bb._max[0]);
    outMaxY.set(bb._max[1]);
    outMaxZ.set(bb._max[2]);


    points.length = 0;
    points.push(
        // bb._max[0],bb._max[1],bb._max[2],
        // bb._min[0],bb._min[1],bb._min[2],

        bb._max[0], bb._max[1], bb._max[2],
        bb._max[0], bb._min[1], bb._max[2],
        bb._min[0], bb._min[1], bb._max[2],
        bb._min[0], bb._max[1], bb._max[2],

        bb._max[0], bb._max[1], bb._min[2],
        bb._max[0], bb._min[1], bb._min[2],
        bb._min[0], bb._min[1], bb._min[2],
        bb._min[0], bb._max[1], bb._min[2],

        bb._center[0], bb._center[1], bb._center[2]
    );
    outPoints.set(null);
    outPoints.set(points);
};


};

Ops.Gl.Geometry.GeometryBoundingBox.prototype = new CABLES.Op();
CABLES.OPS["7c13487b-87b2-40c9-b363-c5f699968579"]={f:Ops.Gl.Geometry.GeometryBoundingBox,objName:"Ops.Gl.Geometry.GeometryBoundingBox"};




// **************************************************************
// 
// Ops.Gl.Geometry.GeometryExtrude
// 
// **************************************************************

Ops.Gl.Geometry.GeometryExtrude = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inGeom = op.inObject("Geometry", null, "geometry"),
    inHeight = op.inFloat("Height", 0.5),
    inSmooth = op.inBool("Smooth", true),
    inExtrudeWalls = op.inBool("Walls", true),
    inCapTop = op.inBool("Top", true),
    inCapBottom = op.inBool("Bottom", true),
    outGeom = op.outObject("Result Geometry", null, "geometry");

function isClockwise(verts)
{
    let sum = 0.0;
    for (let i = 0; i < verts.length - 3; i += 3)
    {
        // Vector v1 = verts[i];
        // Vector v2 = verts[(i + 1) % verts.length];
        sum += (verts[i + 3] - verts[i]) * (verts[i + 3 + 1] + verts[i]);
    }
    return sum > 0.0;
}

inSmooth.onChange =
inExtrudeWalls.onChange =
inCapTop.onChange =
inCapBottom.onChange =
inHeight.onChange =
inGeom.onChange = () =>
{
    const geom = inGeom.get();

    if (!geom)
    {
        outGeom.set(null);
        return;
    }

    function edgesUsedMulti(idx1, idx2)
    {
        let count = 0;
        for (let i = 0; i < geom.verticesIndices.length; i += 3)
        {
            if (
                (
                    geom.verticesIndices[i] == idx1 ||
                    geom.verticesIndices[i + 1] == idx1 ||
                    geom.verticesIndices[i + 2] == idx1
                ) &&
                (
                    geom.verticesIndices[i] == idx2 ||
                    geom.verticesIndices[i + 1] == idx2 ||
                    geom.verticesIndices[i + 2] == idx2
                ))
            {
                count++;
                if (count == 2) return true;
            }
        }

        return false;
    }

    let verts = [];
    const indices = [];
    const h = inHeight.get();

    if (inExtrudeWalls.get())
        for (let i = 0; i < geom.verticesIndices.length; i += 3)
        {
            const vert1 = geom.verticesIndices[i];
            const vert2 = geom.verticesIndices[i + 1];
            const vert3 = geom.verticesIndices[i + 2];

            // 1
            if (!edgesUsedMulti(vert1, vert2))
            {
                const a = [];
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2]]);
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2] + h]);
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2]]);

                if (!isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());

                a.length = 0;
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2] + h]);
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2]]);
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2] + h]);

                if (!isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());
            }

            // 2
            if (!edgesUsedMulti(vert3, vert2))
            {
                const a = [];
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2]]);
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2] + h]);
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2]]);

                if (isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());

                a.length = 0;

                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2] + h]);
                a.push([geom.vertices[vert2 * 3 + 0], geom.vertices[vert2 * 3 + 1], geom.vertices[vert2 * 3 + 2]]);
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2] + h]);

                if (isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());
            }
            // 3

            if (!edgesUsedMulti(vert3, vert1))
            {
                const a = [];
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2]]);
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2] + h]);
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2]]);

                if (!isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());

                a.length = 0;

                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2] + h]);
                a.push([geom.vertices[vert1 * 3 + 0], geom.vertices[vert1 * 3 + 1], geom.vertices[vert1 * 3 + 2]]);
                a.push([geom.vertices[vert3 * 3 + 0], geom.vertices[vert3 * 3 + 1], geom.vertices[vert3 * 3 + 2] + h]);

                if (!isClockwise(a)) verts = verts.concat(a);
                else verts = verts.concat(a.reverse());
            }
        }

    const newGeom = CGL.Geometry.buildFromFaces(verts, "extrude", true);

    newGeom.calculateNormals();
    newGeom.calcTangentsBitangents();

    if (inCapBottom.get())
    {
        newGeom.merge(geom);
    }

    if (inCapTop.get())
    {
        const flippedgeo = geom.copy();

        for (let i = 0; i < flippedgeo.vertices.length; i += 3)
            flippedgeo.vertices[i + 2] += h;

        flippedgeo.flipVertDir();
        flippedgeo.flipNormals();
        newGeom.merge(flippedgeo);
    }

    newGeom.flipVertDir();

    if (!inSmooth.get())
    {
        newGeom.unIndex();
        newGeom.calculateNormals({ "forceZUp": true });
        newGeom.flipNormals();
    }

    outGeom.set(null);
    outGeom.set(newGeom);
};


};

Ops.Gl.Geometry.GeometryExtrude.prototype = new CABLES.Op();
CABLES.OPS["64a34a29-000d-4350-875f-5b72b97a314f"]={f:Ops.Gl.Geometry.GeometryExtrude,objName:"Ops.Gl.Geometry.GeometryExtrude"};




// **************************************************************
// 
// Ops.Gl.Geometry.GeometryInfo
// 
// **************************************************************

Ops.Gl.Geometry.GeometryInfo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    geometry = op.inObject("Geometry", null, "geometry"),
    outIndexed = op.outBoolNum("Indexed", false),
    outFaces = op.outNumber("Faces"),
    outIndices = op.outNumber("Indices"),
    outVertices = op.outNumber("Vertices"),
    outNormals = op.outNumber("Normals"),
    outTexCoords = op.outNumber("TexCoords"),
    outTangents = op.outNumber("Tangents"),
    outBiTangents = op.outNumber("BiTangents"),
    outVertexColors = op.outNumber("VertexColors"),
    outAttribs = op.outNumber("Other Attributes");

geometry.onLinkChanged = () =>
{
};

geometry.onChange = function ()
{
    let geom = geometry.get();
    if (geom)
    {
        const info = geom.getInfo();
        outFaces.set(info.numFaces);
        outIndices.set(info.indices || info.indices);
        outVertices.set(info.numVerts);
        outNormals.set(info.numNormals);
        outTexCoords.set(info.numTexCoords);
        outTangents.set(info.numTangents);
        outBiTangents.set(info.numBiTangents);
        outVertexColors.set(info.numVertexColors);
        outAttribs.set(info.numAttribs);
        outIndexed.set(info.isIndexed);
    }
    else
    {
        outIndexed.set(null);
        outFaces.set(null);
        outVertices.set(null);
        outNormals.set(null);
        outTexCoords.set(null);
        outTangents.set(null);
        outBiTangents.set(null);
        outVertexColors.set(null);
        outAttribs.set(null);
    }
};


};

Ops.Gl.Geometry.GeometryInfo.prototype = new CABLES.Op();
CABLES.OPS["a9208e84-e957-43ac-9a79-9c719eff95eb"]={f:Ops.Gl.Geometry.GeometryInfo,objName:"Ops.Gl.Geometry.GeometryInfo"};




// **************************************************************
// 
// Ops.Gl.Geometry.GeometryMerge
// 
// **************************************************************

Ops.Gl.Geometry.GeometryMerge = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inGeom = op.inObject("Geometry"),
    inGeom2 = op.inObject("Geometry 2"),
    inMerge = op.inTriggerButton("Merge"),
    inReset = op.inTriggerButton("Reset"),
    outGeom = op.outObject("Geometry Result");

const geom = new CGL.Geometry(op.name);

outGeom.set(geom);

inReset.onTriggered = function ()
{
    geom.clear();
    outGeom.set(null);
    outGeom.set(geom);
};

inMerge.onTriggered = function ()
{
    if (inGeom.get() || inGeom2.get())
    {
        if (inGeom.get())geom.merge(inGeom.get());
        if (inGeom2.get())geom.merge(inGeom2.get());
        outGeom.set(null);
        outGeom.set(geom);
    }
};


};

Ops.Gl.Geometry.GeometryMerge.prototype = new CABLES.Op();
CABLES.OPS["f915eaab-92df-495e-84ed-500ec301b6f7"]={f:Ops.Gl.Geometry.GeometryMerge,objName:"Ops.Gl.Geometry.GeometryMerge"};




// **************************************************************
// 
// Ops.Gl.Geometry.GeometryMergeSimple
// 
// **************************************************************

Ops.Gl.Geometry.GeometryMergeSimple = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inGeom = op.inObject("Geometry"),
    inGeom2 = op.inObject("Geometry 2"),
    outGeom = op.outObject("Geometry Result");

let geom = new CGL.Geometry(op.name);
outGeom.set(geom);

inGeom.onChange =
inGeom2.onChange =
function ()
{
    if (inGeom.get() || inGeom2.get())
    {
        geom = new CGL.Geometry(op.name);
        if (inGeom.get())
        {
            geom = inGeom.get().copy();
        }
        if (inGeom2.get())geom.merge(inGeom2.get());
        outGeom.set(null);
        outGeom.set(geom);
    }
};


};

Ops.Gl.Geometry.GeometryMergeSimple.prototype = new CABLES.Op();
CABLES.OPS["e9a6c398-b6f2-4c53-a7ea-47aa835c6938"]={f:Ops.Gl.Geometry.GeometryMergeSimple,objName:"Ops.Gl.Geometry.GeometryMergeSimple"};




// **************************************************************
// 
// Ops.Gl.Geometry.GeometryPoints
// 
// **************************************************************

Ops.Gl.Geometry.GeometryPoints = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    geometry = op.inObject("Geometry"),
    outFaces = op.outArray("Faces", 3),
    outVertices = op.outArray("Vertices", 3),
    outNormals = op.outArray("Normals", 3),
    outTextcoords = op.outArray("TexCoords", 2),
    outVertexColors = op.outArray("Vertex Colors", 4),
    outTangents = op.outArray("Tangents", 3),
    outBiTangents = op.outArray("BiTangents", 3);

geometry.onChange = function ()
{
    let geom = geometry.get();
    if (!geom) return;

    // convert float32array to array
    let verts = Array.prototype.slice.call(geom.vertices);

    outVertices.set(verts);
    outFaces.set(geom.verticesIndices);
    outTextcoords.set(geom.texCoords);
    outNormals.set(geom.vertexNormals);
    outTangents.set(geom.tangents);
    outBiTangents.set(geom.biTangents);
    outVertexColors.set(geom.vertexColors);
};


};

Ops.Gl.Geometry.GeometryPoints.prototype = new CABLES.Op();
CABLES.OPS["b215118b-de1f-4be9-8890-d07a2ecff010"]={f:Ops.Gl.Geometry.GeometryPoints,objName:"Ops.Gl.Geometry.GeometryPoints"};




// **************************************************************
// 
// Ops.Gl.Geometry.GeometryToObj
// 
// **************************************************************

Ops.Gl.Geometry.GeometryToObj = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inGeo = op.inObject("Geometry", null, "geometry"),
    outStr = op.outString("Obj");

function decimal(n)
{
    return Math.round(n * 10000000) / 10000000;
}

inGeo.onChange = () =>
{
    const geom = inGeo.get();

    if (!geom)
    {
        outStr.set(null);
        return;
    }

    let str = "# made with cables.gl".endl().endl();

    str += "# " + JSON.stringify(geom.getInfo());
    str += "".endl();
    str += "".endl();

    // vertices
    for (let i = 0; i < geom.vertices.length; i += 3)
    {
        str += "v " + decimal(geom.vertices[i + 0]) + " " + decimal(geom.vertices[i + 1]) + " " + decimal(geom.vertices[i + 2]) + "".endl();
    }

    str += "".endl();

    // normals
    for (let i = 0; i < geom.vertexNormals.length; i += 3)
    {
        str += "vn " + decimal(geom.vertexNormals[i + 0]) + " " + decimal(geom.vertexNormals[i + 1]) + " " + decimal(geom.vertexNormals[i + 2]) + "".endl();
    }

    str += "".endl();

    // texcoords
    for (let i = 0; i < geom.texCoords.length; i += 2)
    {
        str += "vt " + decimal(geom.texCoords[i + 0]) + " " + decimal(geom.texCoords[i + 1]) + " 0".endl();
    }

    str += "".endl();

    // faces
    if (geom.verticesIndices.length)
    {
        for (let i = 0; i < geom.verticesIndices.length; i += 3)
        {
            str += "f ";
            for (let j = 0; j < 3; j++)
            {
                str += (geom.verticesIndices[i + j] + 1) + "/" + (geom.verticesIndices[i + j] + 1) + "/" + (geom.verticesIndices[i + j] + 1) + " ";
            }
            str += "".endl();
        }
    }
    else
    {
        for (let i = 0; i < geom.vertices.length / 3 - 1; i += 3)
        {
            str += "f " + i + " " + (i + 1) + " " + (i + 2) + " ".endl();
        }
    }

    // str += "".endl();

    outStr.set(str);
};


};

Ops.Gl.Geometry.GeometryToObj.prototype = new CABLES.Op();
CABLES.OPS["3890b676-9ba6-42c1-9a57-659b74958e20"]={f:Ops.Gl.Geometry.GeometryToObj,objName:"Ops.Gl.Geometry.GeometryToObj"};




// **************************************************************
// 
// Ops.Gl.Geometry.GeometryUnIndex
// 
// **************************************************************

Ops.Gl.Geometry.GeometryUnIndex = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    geometry = op.inObject("Geometry"),
    result = op.outObject("Result");

geometry.onChange = function ()
{
    let geom = geometry.get();

    if (geom)
    {
        if (!geom.isIndexed())
        {
            result.set(geom);
            return;
        }

        const newGeom = geom.copy();
        newGeom.unIndex(false, true);
        result.set(newGeom);
    }
    else result.set(null);
};


};

Ops.Gl.Geometry.GeometryUnIndex.prototype = new CABLES.Op();
CABLES.OPS["b0b2430c-5206-4d1f-a0a6-bc5d79a29027"]={f:Ops.Gl.Geometry.GeometryUnIndex,objName:"Ops.Gl.Geometry.GeometryUnIndex"};




// **************************************************************
// 
// Ops.Gl.Geometry.ReverseVertices
// 
// **************************************************************

Ops.Gl.Geometry.ReverseVertices = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    geometry = op.inObject("Geometry"),
    outGeom = op.outObject("Result"),
    doFlip = op.inValueBool("Flip", true);

doFlip.onChange =
    geometry.onChange = flip;

function flip()
{
    let oldGeom = geometry.get();

    if (!oldGeom)
    {
        outGeom.set(null);
        return;
    }

    let geom = oldGeom.copy();

    if(doFlip.get())geom.flipVertDir();

    outGeom.set(null);
    outGeom.set(geom);
}


};

Ops.Gl.Geometry.ReverseVertices.prototype = new CABLES.Op();
CABLES.OPS["548079e7-616d-4f7a-98a0-509c9c7bc36d"]={f:Ops.Gl.Geometry.ReverseVertices,objName:"Ops.Gl.Geometry.ReverseVertices"};




// **************************************************************
// 
// Ops.Gl.Geometry.ScaleGeometry
// 
// **************************************************************

Ops.Gl.Geometry.ScaleGeometry = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let geometry = op.inObject("Geometry");
let scale = op.inValue("Scale", 1);
let outGeom = op.outObject("Result");

scale.onChange = geometry.onChange = update;

function update()
{
    let oldGeom = geometry.get();

    if (oldGeom)
    {
        let geom = oldGeom.copy();
        let rotVec = vec3.create();
        let emptyVec = vec3.create();
        let transVec = vec3.create();
        let centerVec = vec3.create();
        let s = scale.get();

        for (let i = 0; i < geom.vertices.length; i += 3)
        {
            geom.vertices[i + 0] *= s;
            geom.vertices[i + 1] *= s;
            geom.vertices[i + 2] *= s;
        }

        outGeom.set(geom);
    }
    else outGeom.set(null);
}


};

Ops.Gl.Geometry.ScaleGeometry.prototype = new CABLES.Op();
CABLES.OPS["7730e67b-5916-4481-bcd1-54fa6e3a1d02"]={f:Ops.Gl.Geometry.ScaleGeometry,objName:"Ops.Gl.Geometry.ScaleGeometry"};




// **************************************************************
// 
// Ops.Gl.Geometry.SortGeometryAxis
// 
// **************************************************************

Ops.Gl.Geometry.SortGeometryAxis = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    SORT_RANDOM = "Random",
    SORT_X = "X Axis",
    SORT_Y = "Y Axis",
    SORT_Z = "Z Axis",
    SORT_NONE = "None",

    geometry = op.inObject("Geometry"),
    sorting = op.inValueSelect("Sort", [SORT_RANDOM, SORT_X, SORT_Y, SORT_Z, SORT_NONE], SORT_X),
    reverse = op.inValueBool("Reverse", false),
    outGeom = op.outObject("Result");

reverse.onChange =
    geometry.onChange =
    sorting.onChange = update;

function update()
{
    if (geometry.get())
    {
        const geom = geometry.get();
        let faces = [];
        faces.length = geom.verticesIndices.length / 3;

        for (let i = 0; i < geom.verticesIndices.length; i += 3)
        {
            const face = [0, 0, 0];
            face[0] = geom.verticesIndices[i + 0];
            face[1] = geom.verticesIndices[i + 1];
            face[2] = geom.verticesIndices[i + 2];
            faces[i / 3] = face;
        }

        if (sorting.get() == SORT_RANDOM)
        {
            faces = CABLES.shuffleArray(faces);
        }
        else
        if (sorting.get() == SORT_Y)
        {
            faces.sort(function (a, b)
            {
                let avgA = 0;
                avgA += geom.vertices[a[0] * 3 + 1];
                avgA += geom.vertices[a[1] * 3 + 1];
                avgA += geom.vertices[a[2] * 3 + 1];
                avgA /= 3;

                let avgB = 0;
                avgB += geom.vertices[b[0] * 3 + 1];
                avgB += geom.vertices[b[1] * 3 + 1];
                avgB += geom.vertices[b[2] * 3 + 1];
                avgB /= 3;

                return avgA - avgB;
            });
        }
        else
        if (sorting.get() == SORT_X)
        {
            faces.sort(function (a, b)
            {
                let avgA = 0;
                avgA += geom.vertices[a[0] * 3 + 0];
                avgA += geom.vertices[a[1] * 3 + 0];
                avgA += geom.vertices[a[2] * 3 + 0];
                avgA /= 3;

                let avgB = 0;
                avgB += geom.vertices[b[0] * 3 + 0];
                avgB += geom.vertices[b[1] * 3 + 0];
                avgB += geom.vertices[b[2] * 3 + 0];
                avgB /= 3;

                return avgA - avgB;
            });
        }
        else
        if (sorting.get() == SORT_Z)
        {
            faces.sort(function (a, b)
            {
                let avgA = 0;
                avgA += geom.vertices[a[0] * 3 + 2];
                avgA += geom.vertices[a[1] * 3 + 2];
                avgA += geom.vertices[a[2] * 3 + 2];
                avgA /= 3;

                let avgB = 0;
                avgB += geom.vertices[b[0] * 3 + 2];
                avgB += geom.vertices[b[1] * 3 + 2];
                avgB += geom.vertices[b[2] * 3 + 2];
                avgB /= 3;

                return avgA - avgB;
            });
        }
        else
        {
            if (sorting.get() != SORT_NONE) op.error("No sorting found", sorting.get());
        }

        const newGeom = new CGL.Geometry(op.name);
        const newVerts = [];
        const newFaces = [];
        const newNormals = [];
        const newTexCoords = [];
        const newTangents = [];
        const newBiTangents = [];

        if (reverse.get())
        {
            faces = faces.reverse();
        }

        faces = [].concat.apply([], faces);

        for (let i = 0; i < faces.length; i += 3)
        {
            newFaces.push(
                newVerts.length / 3);
            newVerts.push(
                geom.vertices[faces[i + 0] * 3 + 0],
                geom.vertices[faces[i + 0] * 3 + 1],
                geom.vertices[faces[i + 0] * 3 + 2]);
            newNormals.push(
                geom.vertexNormals[faces[i + 0] * 3 + 0],
                geom.vertexNormals[faces[i + 0] * 3 + 1],
                geom.vertexNormals[faces[i + 0] * 3 + 2]);
            newTexCoords.push(
                geom.texCoords[faces[i + 0] * 2 + 0],
                geom.texCoords[faces[i + 0] * 2 + 1]);

            if (geom.tangents)
                newTangents.push(
                    geom.tangents[faces[i + 0] * 3 + 0],
                    geom.tangents[faces[i + 0] * 3 + 1],
                    geom.tangents[faces[i + 0] * 3 + 2]);
            if (geom.biTangents)
                newBiTangents.push(
                    geom.biTangents[faces[i + 0] * 3 + 0],
                    geom.biTangents[faces[i + 0] * 3 + 1],
                    geom.biTangents[faces[i + 0] * 3 + 2]);

            newFaces.push(
                newVerts.length / 3);
            newVerts.push(
                geom.vertices[faces[i + 1] * 3 + 0],
                geom.vertices[faces[i + 1] * 3 + 1],
                geom.vertices[faces[i + 1] * 3 + 2]);
            newNormals.push(
                geom.vertexNormals[faces[i + 1] * 3 + 0],
                geom.vertexNormals[faces[i + 1] * 3 + 1],
                geom.vertexNormals[faces[i + 1] * 3 + 2]);
            newTexCoords.push(
                geom.texCoords[faces[i + 1] * 2 + 0],
                geom.texCoords[faces[i + 1] * 2 + 1]);
            if (geom.tangents)
                newTangents.push(
                    geom.tangents[faces[i + 1] * 3 + 0],
                    geom.tangents[faces[i + 1] * 3 + 1],
                    geom.tangents[faces[i + 1] * 3 + 2]);
            if (geom.biTangents)
                newBiTangents.push(
                    geom.biTangents[faces[i + 1] * 3 + 0],
                    geom.biTangents[faces[i + 1] * 3 + 1],
                    geom.biTangents[faces[i + 1] * 3 + 2]);

            newFaces.push(
                newVerts.length / 3);
            newVerts.push(
                geom.vertices[faces[i + 2] * 3 + 0],
                geom.vertices[faces[i + 2] * 3 + 1],
                geom.vertices[faces[i + 2] * 3 + 2]);
            newNormals.push(
                geom.vertexNormals[faces[i + 2] * 3 + 0],
                geom.vertexNormals[faces[i + 2] * 3 + 1],
                geom.vertexNormals[faces[i + 2] * 3 + 2]);
            newTexCoords.push(
                geom.texCoords[faces[i + 2] * 2 + 0],
                geom.texCoords[faces[i + 2] * 2 + 1]);
            if (geom.tangents)
                newTangents.push(
                    geom.tangents[faces[i + 2] * 3 + 0],
                    geom.tangents[faces[i + 2] * 3 + 1],
                    geom.tangents[faces[i + 2] * 3 + 2]);
            if (geom.biTangents)
                newBiTangents.push(
                    geom.biTangents[faces[i + 2] * 3 + 0],
                    geom.biTangents[faces[i + 2] * 3 + 1],
                    geom.biTangents[faces[i + 2] * 3 + 2]);
        }

        newGeom.vertices = newVerts;
        newGeom.vertexNormals = newNormals;
        newGeom.verticesIndices = newFaces;
        newGeom.texCoords = newTexCoords;
        newGeom.tangents = newTangents;
        newGeom.biTangents = newBiTangents;

        outGeom.set(null);
        outGeom.set(newGeom);
    }
}


};

Ops.Gl.Geometry.SortGeometryAxis.prototype = new CABLES.Op();
CABLES.OPS["8b0a635c-83f0-4d95-9b9c-1b5ca55c6724"]={f:Ops.Gl.Geometry.SortGeometryAxis,objName:"Ops.Gl.Geometry.SortGeometryAxis"};




// **************************************************************
// 
// Ops.Gl.Geometry.SvgPathToGeometry_v2
// 
// **************************************************************

Ops.Gl.Geometry.SvgPathToGeometry_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("SVG Path"),
    inStepSize = op.inFloat("Bezier Stepsize", 3),
    inRescale = op.inFloat("Rescale", 1),
    outGeom = op.outObject("Geometry", null, "geometry");

inStepSize.onChange =
inRescale.onChange =
inStr.onChange = () =>
{
    let str = inStr.get();

    if (!str || str.length < 2)
    {
        outGeom.set(null);
        return;
    }

    str = str.replace(/([A-Z,a-z])/g, " $1 ");

    const cmds = fromPathToArray(str);

    // create a list of closed contours
    const polys = [];
    cmds.forEach(({ type, x, y, x1, y1, x2, y2 }) =>
    {
        switch (type)
        {
        case "M":
            polys.push(new Polygon());
            polys[polys.length - 1].moveTo({ x, y });
            break;
        case "L":
            polys[polys.length - 1].moveTo({ x, y });
            break;
        case "C":
            polys[polys.length - 1].cubicTo({ x, y }, { "x": x1, "y": y1 }, { "x": x2, "y": y2 });
            break;
        case "Q":
            polys[polys.length - 1].conicTo({ x, y }, { "x": x1, "y": y1 });
            break;
        case "Z":
            polys[polys.length - 1].close();
            break;
        }
    });

    // sort contours by descending area
    polys.sort((a, b) => { return Math.abs(b.area) - Math.abs(a.area); });
    // classify contours to find holes and their 'parents'
    const root = [];
    for (let i = 0; i < polys.length; ++i)
    {
        let parent = null;
        for (let j = i - 1; j >= 0; --j)
        {
            // a contour is a hole if it is inside its parent and has different winding
            if (polys[j].inside(polys[i].points[0]) && polys[i].area * polys[j].area < 0)
            {
                parent = polys[j];
                break;
            }
        }
        if (parent)
        {
            parent.children.push(polys[i]);
        }
        else
        {
            root.push(polys[i]);
        }
    }

    const totalPoints = polys.reduce((sum, p) => { return sum + p.points.length; }, 0);
    const vertexData = new Float32Array(totalPoints * 2);
    let vertexCount = 0;
    const indices = [];

    function process(poly)
    {
        // construct input for earcut
        const coords = [];
        const holes = [];

        poly.points.forEach(({ x, y }) => { return coords.push(x, y); });

        poly.children.forEach((child) =>
        {
            // children's children are new, separate shapes
            child.children.forEach(process);

            holes.push(coords.length / 2);
            child.points.forEach(({ x, y }) => { return coords.push(x, y); });
        });

        // add vertex data
        vertexData.set(coords, vertexCount * 2);
        // add index data
        earcut(coords, holes).forEach((i) => { return indices.push(i + vertexCount); });
        vertexCount += coords.length / 2;
    }

    root.forEach(process);

    const finalVertexData = new Float32Array(totalPoints * 3);

    let max = -99999;

    for (let i = 0; i < finalVertexData.length / 3; i++)
    {
        finalVertexData[i * 3 + 0] = vertexData[i * 2 + 0];
        finalVertexData[i * 3 + 1] = vertexData[i * 2 + 1] * -1;
        max = Math.max(finalVertexData[i * 3 + 1], max);

        finalVertexData[i * 3 + 2] = 0;
    }

    let resc = inRescale.get();

    let geom = new CGL.Geometry("circle");
    geom.setVertices(finalVertexData);
    geom.verticesIndices = indices;

    if (resc != 0)
    {
        const bounds = geom.getBounds();
        for (let i = 0; i < finalVertexData.length / 3; i++)
        {
            finalVertexData[i * 3 + 0] = (finalVertexData[i * 3 + 0] / (bounds.size[0] / 2)) * resc;
            finalVertexData[i * 3 + 1] = (finalVertexData[i * 3 + 1] / (bounds.size[0] / 2)) * resc;
        }
        geom.setVertices(finalVertexData);
    }

    geom.mapTexCoords2d();
    geom.flipVertDir();
    geom.calculateNormals();
    geom.calcTangentsBitangents();

    outGeom.set(geom);
};

const PATH_COMMANDS = {
    "M": ["x", "y"],
    "m": ["dx", "dy"],
    "H": ["x"],
    "h": ["dx"],
    "V": ["y"],
    "v": ["dy"],
    "L": ["x", "y"],
    "l": ["dx", "dy"],
    "Z": [],
    "C": ["x1", "y1", "x2", "y2", "x", "y"],
    "c": ["dx1", "dy1", "dx2", "dy2", "dx", "dy"],
    "S": ["x2", "y2", "x", "y"],
    "s": ["dx2", "dy2", "dx", "dy"],
    "Q": ["x1", "y1", "x", "y"],
    "q": ["dx1", "dy1", "dx", "dy"],
    "T": ["x", "y"],
    "t": ["dx", "dy"],
    "A": ["rx", "ry", "rotation", "large-arc", "sweep", "x", "y"],
    "a": ["rx", "ry", "rotation", "large-arc", "sweep", "dx", "dy"]
};

function fromPathToArray(path)
{
    const items = path.replace(/[\n\r]/g, "")
        .replace(/-/g, " -")
        .replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ")
        .trim()
        .split(/\s*,|\s+/);

    const segments = [];
    let currentCommand = "";
    let currentElement = {};
    while (items.length > 0)
    {
        let it = items.shift();
        if (PATH_COMMANDS.hasOwnProperty(it))
        {
            currentCommand = it;
        }
        else
        {
            items.unshift(it);
        }

        currentElement = { "type": currentCommand };
        PATH_COMMANDS[currentCommand].forEach((prop) =>
        {
            it = items.shift(); // TODO sanity check
            currentElement[prop] = parseFloat(it);
        });
        if (currentCommand === "M")
        {
            currentCommand = "L";
        }
        else if (currentCommand === "m")
        {
            currentCommand = "l";
        }
        segments.push(currentElement);
    }
    return segments;
}

// https://stackoverflow.com/questions/50554803/triangulate-path-data-from-opentype-js-using-earcut

const MAX_BEZIER_STEPS = 15;
// this is for inside checks - doesn't have to be particularly
// small because glyphs have finite resolution
const EPSILON = 1e-6;

class Polygon
{
    constructor()
    {
        this.points = [];
        this.children = [];
        this.area = 0.0;

        this.BEZIER_STEP_SIZE = inStepSize.get();
    }

    moveTo(p)
    {
        this.points.push(p);
    }

    lineTo(p)
    {
        this.points.push(p);
    }

    close()
    {
        let cur = this.points[this.points.length - 1];
        this.points.forEach((next) =>
        {
            this.area += 0.5 * cross(cur, next);
            cur = next;
        });
    }

    conicTo(p, p1)
    {
        const p0 = this.points[this.points.length - 1];
        const dist = distance(p0, p1) + distance(p1, p);
        const steps = Math.max(2, Math.min(MAX_BEZIER_STEPS, dist / this.BEZIER_STEP_SIZE));
        for (let i = 1; i <= steps; ++i)
        {
            const t = i / steps;
            this.points.push(lerp(lerp(p0, p1, t), lerp(p1, p, t), t));
        }
    }

    cubicTo(p, p1, p2)
    {
        const p0 = this.points[this.points.length - 1];
        const dist = distance(p0, p1) + distance(p1, p2) + distance(p2, p);
        const steps = Math.max(2, Math.min(MAX_BEZIER_STEPS, dist / this.BEZIER_STEP_SIZE));
        for (let i = 1; i <= steps; ++i)
        {
            const t = i / steps;
            const a = lerp(lerp(p0, p1, t), lerp(p1, p2, t), t);
            const b = lerp(lerp(p1, p2, t), lerp(p2, p, t), t);
            this.points.push(lerp(a, b, t));
        }
    }

    inside(p)
    {
        let count = 0, cur = this.points[this.points.length - 1];
        this.points.forEach((next) =>
        {
            const p0 = (cur.y < next.y ? cur : next);
            const p1 = (cur.y < next.y ? next : cur);
            if (p0.y < p.y + EPSILON && p1.y > p.y + EPSILON)
            {
                if ((p1.x - p0.x) * (p.y - p0.y) > (p.x - p0.x) * (p1.y - p0.y))
                {
                    count += 1;
                }
            }
            cur = next;
        });
        return (count % 2) !== 0;
    }
}

function distance(p1, p2)
{
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}

function lerp(p1, p2, t)
{
    return { "x": (1 - t) * p1.x + t * p2.x, "y": (1 - t) * p1.y + t * p2.y };
}

function cross(p1, p2)
{
    return p1.x * p2.y - p1.y * p2.x;
}


};

Ops.Gl.Geometry.SvgPathToGeometry_v2.prototype = new CABLES.Op();
CABLES.OPS["4267b3e7-1285-4a3e-acc8-ea92a72a6bc0"]={f:Ops.Gl.Geometry.SvgPathToGeometry_v2,objName:"Ops.Gl.Geometry.SvgPathToGeometry_v2"};




// **************************************************************
// 
// Ops.Gl.Geometry.TransformGeometry
// 
// **************************************************************

Ops.Gl.Geometry.TransformGeometry = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    geometry = op.inObject("Geometry"),
    transX = op.inValue("Translate X"),
    transY = op.inValue("Translate Y"),
    transZ = op.inValue("Translate Z"),
    scaleX = op.inValueSlider("Scale X", 1),
    scaleY = op.inValueSlider("Scale Y", 1),
    scaleZ = op.inValueSlider("Scale Z", 1),
    rotX = op.inValue("Rotation X"),
    rotY = op.inValue("Rotation Y"),
    rotZ = op.inValue("Rotation Z"),
    outGeom = op.outObject("Result", null, "geometry");

transX.onChange =
    transY.onChange =
    transZ.onChange =
    scaleX.onChange =
    scaleY.onChange =
    scaleZ.onChange =
    rotX.onChange =
    rotY.onChange =
    rotZ.onChange =
    geometry.onChange = update;

const rotVec = vec3.create();
const emptyVec = vec3.create();
const transVec = vec3.create();
const centerVec = vec3.create();

function update()
{
    const oldGeom = geometry.get();
    const i = 0;

    if (oldGeom)
    {
        const geom = oldGeom.copy();

        for (let i = 0; i < geom.vertices.length; i += 3)
        {
            geom.vertices[i + 0] *= scaleX.get();
            geom.vertices[i + 1] *= scaleY.get();
            geom.vertices[i + 2] *= scaleZ.get();

            geom.vertices[i + 0] += transX.get();
            geom.vertices[i + 1] += transY.get();
            geom.vertices[i + 2] += transZ.get();
        }

        for (let i = 0; i < geom.vertices.length; i += 3)
        {
            vec3.set(rotVec,
                geom.vertices[i + 0],
                geom.vertices[i + 1],
                geom.vertices[i + 2]);

            vec3.rotateX(rotVec, rotVec, transVec, rotX.get() * CGL.DEG2RAD);
            vec3.rotateY(rotVec, rotVec, transVec, rotY.get() * CGL.DEG2RAD);
            vec3.rotateZ(rotVec, rotVec, transVec, rotZ.get() * CGL.DEG2RAD);

            geom.vertices[i + 0] = rotVec[0];
            geom.vertices[i + 1] = rotVec[1];
            geom.vertices[i + 2] = rotVec[2];
        }

        outGeom.set(null);
        outGeom.set(geom);
    }
    else
    {
        outGeom.set(null);
    }
}


};

Ops.Gl.Geometry.TransformGeometry.prototype = new CABLES.Op();
CABLES.OPS["9678fee2-5436-499c-b94d-2603cdbeb380"]={f:Ops.Gl.Geometry.TransformGeometry,objName:"Ops.Gl.Geometry.TransformGeometry"};




// **************************************************************
// 
// Ops.Gl.GlInfo
// 
// **************************************************************

Ops.Gl.GlInfo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const gl = op.patch.cgl.gl;

let mxsmpl = 0;
if (gl.MAX_SAMPLES !== undefined)mxsmpl = gl.getParameter(gl.MAX_SAMPLES);

const
    outGlVersion = op.outNumber("WebGl Version", gl.getParameter(gl.VERSION)),
    outGlslVersion = op.outNumber("GLSL Version", gl.getParameter(gl.SHADING_LANGUAGE_VERSION)),
    outFragUnis = op.outNumber("Max Frag uniforms", gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)),
    outVertUnis = op.outNumber("Max Vert uniforms", gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)),
    outTexSize = op.outNumber("Max Texture Size", gl.getParameter(gl.MAX_TEXTURE_SIZE)),
    outTexUnits = op.outNumber("Max Texture Units", gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)),
    outVarVec = op.outNumber("Max Varying Vectors", gl.getParameter(gl.MAX_VARYING_VECTORS)),
    outMSAA = op.outNumber("Max MSAA Samples", mxsmpl),
    outExts = op.outArray("Extensions", gl.getSupportedExtensions()),
    outVendor = op.outString("Vendor"),
    outRenderer = op.outString("Renderer"),
    debugInfo = gl.getExtension("WEBGL_debug_renderer_info");

if (debugInfo)
{
    outVendor.set(gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL));
    outRenderer.set(gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL));
}


};

Ops.Gl.GlInfo.prototype = new CABLES.Op();
CABLES.OPS["2a90bd0e-e743-475e-8e19-00793950b531"]={f:Ops.Gl.GlInfo,objName:"Ops.Gl.GlInfo"};




// **************************************************************
// 
// Ops.Gl.GlPrimitive
// 
// **************************************************************

Ops.Gl.GlPrimitive = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Execute"),
    next = op.outTrigger("Next"),

    prim = op.inValueSelect("Primitive", ["LINES", "LINE_STRIP", "LINE_LOOP", "POINTS", "TRIANGLES", "TRIANGLE_FAN", "TRIANGLE_STRIP"], "LINES");
const cgl = op.patch.cgl;

let glPrim = cgl.gl.LINES;

prim.onChange = function ()
{
    if (prim.get() == "LINES")glPrim = cgl.gl.LINES;
    if (prim.get() == "LINE_STRIP")glPrim = cgl.gl.LINE_STRIP;
    if (prim.get() == "LINE_LOOP")glPrim = cgl.gl.LINE_LOOP;
    if (prim.get() == "POINTS")glPrim = cgl.gl.POINTS;
    if (prim.get() == "TRIANGLES")glPrim = cgl.gl.TRIANGLES;
    if (prim.get() == "TRIANGLE_FAN")glPrim = cgl.gl.TRIANGLE_FAN;
    if (prim.get() == "TRIANGLE_STRIP")glPrim = cgl.gl.TRIANGLE_STRIP;
};

exec.onTriggered = function ()
{
    let shader = cgl.getShader();
    if (!shader) return;
    let oldPrim = shader.glPrimitive;
    shader.glPrimitive = glPrim;

    next.trigger();

    shader.glPrimitive = oldPrim;
};


};

Ops.Gl.GlPrimitive.prototype = new CABLES.Op();
CABLES.OPS["ef0bae7e-32c9-4815-9ac3-9439fc1194ee"]={f:Ops.Gl.GlPrimitive,objName:"Ops.Gl.GlPrimitive"};




// **************************************************************
// 
// Ops.Gl.GradientTexture
// 
// **************************************************************

Ops.Gl.GradientTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inGrad = op.inGradient("Gradient"),
    inDir = op.inValueSelect("Direction", ["X", "Y", "Radial"], "X"),
    inSmoothstep = op.inValueBool("Smoothstep", false),
    inStep = op.inBool("Step", false),
    inFlip = op.inBool("Flip", false),
    inSRGB = op.inBool("sRGB", false),
    inOklab = op.inBool("Oklab", false),
    inSize = op.inValueInt("Size", 256),
    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    twrap = op.inValueSelect("wrap", ["clamp to edge", "repeat", "mirrored repeat"], "clamp to edge"),
    inGradArray = op.inArray("Gradient Array"),
    inRandom = op.inTriggerButton("Randomize Colors"),
    outTex = op.outTexture("Texture"),
    outColors = op.outArray("Colors", null, 3),
    outColorPos = op.outArray("Colors Pos", null, 1);

const cgl = op.patch.cgl;

twrap.onChange =
    tfilter.onChange =
    inStep.onChange =
    inFlip.onChange =
    inSRGB.onChange =
    inOklab.onChange =
    inSize.onChange = inGrad.onChange = inSmoothstep.onChange = inDir.onChange = inGradArray.onChange = update;

inGrad.set("{\"keys\" : [{\"pos\":0,\"r\":0,\"g\":0,\"b\":0},{\"pos\":0.25,\"r\":0,\"g\":0,\"b\":0},{\"pos\":0.75,\"r\":1,\"g\":1,\"b\":1},{\"pos\":1,\"r\":1,\"g\":1,\"b\":1}]}");

op.onLoaded = update;

inRandom.onTriggered = () =>
{
    const keys = parseKeys();
    if (keys)
    {
        keys.forEach((key) =>
        {
            key.r = Math.random();
            key.g = Math.random();
            key.b = Math.random();
        });
        const newKeys = JSON.stringify({ "keys": keys });
        inGrad.set(newKeys);
    }
};

function rgbToOklab(r, g, b)
{
    let l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
    let m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
    let s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;
    l = Math.cbrt(l); m = Math.cbrt(m); s = Math.cbrt(s);
    return [
        l * +0.2104542553 + m * +0.7936177850 + s * -0.0040720468,
        l * +1.9779984951 + m * -2.4285922050 + s * +0.4505937099,
        l * +0.0259040371 + m * +0.7827717662 + s * -0.8086757660
    ];
}

function clamp(value, min, max)
{
    return Math.max(Math.min(value, max), min);
}

function oklabToRGB(L, a, b)
{
    let l = L + a * +0.3963377774 + b * +0.2158037573;
    let m = L + a * -0.1055613458 + b * -0.0638541728;
    let s = L + a * -0.0894841775 + b * -1.2914855480;
    l **= 3; m **= 3; s **= 3;
    let r = l * +4.0767416621 + m * -3.3077115913 + s * +0.2309699292;
    let g = l * -1.2684380046 + m * +2.6097574011 + s * -0.3413193965;
    var b = l * -0.0041960863 + m * -0.7034186147 + s * +1.7076147010;
    r = clamp(r, 0, 1); g = clamp(g, 0, 1); b = clamp(b, 0, 1);
    return [r, g, b];
}

function lin2srgb(r, g, b)
{
    r /= 255;

    const thr = 0.0031308;

    let c_loR = 12.92 * r;

    let c_hiR = 1.055 * Math.pow(r, 0.41666) - 0.055;
    return ((r < thr) ? c_loR : c_hiR) * 255;
}

function update()
{
    const keys = parseKeys();
    if (keys) updateGradient(keys);
}

function parseKeys()
{
    let keys = null;
    op.setUiError("nodata", null);
    op.setUiError("parse", null);

    if (Array.isArray(inGradArray.get()))
    {
        keys = inGradArray.get();
    }
    else
    {
        let grad = null;
        if (!inGrad.get() || inGrad.get() === "")
        {
            op.setUiError("nodata", "gradient no data");
            return null;
        }

        try
        {
            grad = JSON.parse(inGrad.get());
        }
        catch (e)
        {
            op.setUiError("parse", "could not parse gradient data");
        }

        if (!grad || !grad.keys)
        {
            op.setUiError("nodata", "gradient no data");
            return null;
        }
        keys = grad.keys;
    }
    return keys;
}

function updateGradient(keys)
{
    let width = Math.round(inSize.get());
    if (width < 4) width = 4;

    let selectedWrap = 0;
    let selectedFilter = 0;
    if (twrap.get() == "repeat") selectedWrap = CGL.Texture.WRAP_REPEAT;
    else if (twrap.get() == "mirrored repeat") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (twrap.get() == "clamp to edge") selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    if (tfilter.get() == "nearest") selectedFilter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") selectedFilter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") selectedFilter = CGL.Texture.FILTER_MIPMAP;

    const tex = new CGL.Texture(cgl);

    if (inDir.get() == "X" || inDir.get() == "Y")
    {
        const pixels = new Uint8Array(width * 4);

        for (let i = 0; i < keys.length - 1; i++)
        {
            const keyA = keys[i];
            const keyB = keys[i + 1];

            for (let x = keyA.pos * width; x < keyB.pos * width; x++)
            {
                let p = CABLES.map(x, keyA.pos * width, keyB.pos * width, 0, 1);
                if (inStep.get())p = Math.round(p);
                if (inSmoothstep.get()) p = CABLES.smoothStep(p);
                x = Math.round(x);

                let xx = x;
                if (inFlip.get())xx = width - x - 1;

                if (inOklab.get())
                {
                    const klabA = rgbToOklab(keyA.r, keyA.g, keyA.b);
                    const labA_r = klabA[0];
                    const labA_g = klabA[1];
                    const labA_b = klabA[2];

                    const klabB = rgbToOklab(keyB.r, keyB.g, keyB.b);
                    const labB_r = klabB[0];
                    const labB_g = klabB[1];
                    const labB_b = klabB[2];

                    const l = ((p * labB_r + (1.0 - p) * labA_r));
                    const a = ((p * labB_g + (1.0 - p) * labA_g));
                    const b = ((p * labB_b + (1.0 - p) * labA_b));

                    const pixCol = oklabToRGB(l, a, b);
                    pixels[xx * 4 + 0] = Math.round(pixCol[0] * 255);
                    pixels[xx * 4 + 1] = Math.round(pixCol[1] * 255);
                    pixels[xx * 4 + 2] = Math.round(pixCol[2] * 255);
                }
                else
                {
                    pixels[xx * 4 + 0] = Math.round((p * keyB.r + (1.0 - p) * keyA.r) * 255);
                    pixels[xx * 4 + 1] = Math.round((p * keyB.g + (1.0 - p) * keyA.g) * 255);
                    pixels[xx * 4 + 2] = Math.round((p * keyB.b + (1.0 - p) * keyA.b) * 255);
                }

                if (typeof keyA.a !== "undefined" && typeof keyB.a !== "undefined")
                {
                    const alpha = Math.round((p * keyB.a + (1.0 - p) * keyA.a) * 255);
                    pixels[xx * 4 + 3] = alpha;
                }
                else
                {
                    pixels[xx * 4 + 3] = Math.round(255);
                }
            }
        }

        if (inSRGB.get())
            for (let i = 0; i < pixels.length; i += 4)
            {
                pixels[i + 0] = lin2srgb(pixels[i + 0]);
                pixels[i + 1] = lin2srgb(pixels[i + 1]);
                pixels[i + 2] = lin2srgb(pixels[i + 2]);
            }

        if (inDir.get() == "X") tex.initFromData(pixels, width, 1, selectedFilter, selectedWrap);
        if (inDir.get() == "Y") tex.initFromData(pixels, 1, width, selectedFilter, selectedWrap);
    }

    if (inDir.get() == "Radial")
    {
        const pixels = new Uint8Array(width * width * 4);

        const animR = new CABLES.Anim();
        const animG = new CABLES.Anim();
        const animB = new CABLES.Anim();

        for (let i = 0; i < keys.length - 1; i++)
        {
            animR.setValue(keys[i].pos, keys[i].r);
            animG.setValue(keys[i].pos, keys[i].g);
            animB.setValue(keys[i].pos, keys[i].b);
        }

        for (let x = 0; x < width; x++)
        {
            for (let y = 0; y < width; y++)
            {
                const dx = x - (width - 1) / 2;
                const dy = y - (width - 1) / 2;
                let pos = Math.sqrt(dx * dx + dy * dy) / (width) * 2;

                if (inSmoothstep.get()) pos = CABLES.smoothStep(pos);

                pixels[(x * 4) + (y * 4 * width) + 0] = animR.getValue(pos) * 255;
                pixels[(x * 4) + (y * 4 * width) + 1] = animG.getValue(pos) * 255;
                pixels[(x * 4) + (y * 4 * width) + 2] = animB.getValue(pos) * 255;
                pixels[(x * 4) + (y * 4 * width) + 3] = Math.round(255);
            }
        }

        if (inSRGB.get())
            for (let i = 0; i < pixels.length; i += 4)
            {
                pixels[i + 0] = lin2srgb(pixels[i + 0]);
                pixels[i + 1] = lin2srgb(pixels[i + 1]);
                pixels[i + 2] = lin2srgb(pixels[i + 2]);
            }

        tex.initFromData(pixels, width, width, selectedFilter, selectedWrap);
    }

    const colorArr = [];
    for (let i = 0; i < keys.length - 1; i++)
    {
        colorArr.push(keys[i].r, keys[i].g, keys[i].b);
    }

    const colorPosArr = [];
    for (let i = 0; i < keys.length - 1; i++)
    {
        colorPosArr.push(keys[i].pos);
    }

    outColors.set(colorArr);
    outColorPos.set(colorPosArr);

    outTex.set(null);
    outTex.set(tex);
}


};

Ops.Gl.GradientTexture.prototype = new CABLES.Op();
CABLES.OPS["01380a50-2dbb-4465-ae80-86349b0b717a"]={f:Ops.Gl.GradientTexture,objName:"Ops.Gl.GradientTexture"};




// **************************************************************
// 
// Ops.Gl.GridTransform
// 
// **************************************************************

Ops.Gl.GridTransform = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    numX = op.inValueInt("Num X", 5),
    numY = op.inValueInt("Num Y", 5),
    spaceX = op.inValue("Space X", 1),
    spaceY = op.inValue("Space Y", 1),
    next = op.outTrigger("Next"),
    outIndex = op.outNumber("Index"),
    outX = op.outNumber("x index"),
    outY = op.outNumber("y index");

let matOrig = mat4.create();
let vec = vec3.create();

let cgl = op.patch.cgl;

render.onTriggered = function ()
{
    cgl.pushModelMatrix();

    mat4.copy(matOrig, cgl.modelMatrix());

    let mx = spaceX.get();
    let my = spaceY.get();

    let maxX = Math.floor(numX.get());
    let maxY = Math.floor(numY.get());

    let alX = ((maxX - 1) * mx) / 2;
    let alY = ((maxY - 1) * my) / 2;

    let i = 0;
    for (let y = 0; y < maxY; y++)
    {
        outY.set(y);

        for (let x = 0; x < maxX; x++)
        {
            vec3.set(vec,
                x * mx - alX,
                y * my - alY,
                0);
            outX.set(x);
            mat4.translate(cgl.mMatrix, matOrig, vec);
            outIndex.set(i);
            i++;
            next.trigger();
        }
    }

    cgl.popModelMatrix();
};


};

Ops.Gl.GridTransform.prototype = new CABLES.Op();
CABLES.OPS["242e9cfa-3f83-4ff7-b9e8-1c136938a270"]={f:Ops.Gl.GridTransform,objName:"Ops.Gl.GridTransform"};




// **************************************************************
// 
// Ops.Gl.Identity
// 
// **************************************************************

Ops.Gl.Identity = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe=op.inTrigger("exe");
const trigger=op.outTrigger('trigger');
const cgl=op.patch.cgl;

exe.onTriggered=function()
{
    cgl.pushModelMatrix();

    mat4.identity(cgl.mMatrix);
    trigger.trigger();

    cgl.popModelMatrix();
};

};

Ops.Gl.Identity.prototype = new CABLES.Op();
CABLES.OPS["59a5a21f-4498-4960-8527-86f75ab5ec11"]={f:Ops.Gl.Identity,objName:"Ops.Gl.Identity"};




// **************************************************************
// 
// Ops.Gl.IdentityViewMatrix
// 
// **************************************************************

Ops.Gl.IdentityViewMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe=op.inTrigger("exe");
const trigger=op.outTrigger('trigger');
const cgl=op.patch.cgl;

exe.onTriggered=function()
{
    cgl.pushViewMatrix();
    mat4.identity(cgl.vMatrix);
    trigger.trigger();
    cgl.popViewMatrix();
};

};

Ops.Gl.IdentityViewMatrix.prototype = new CABLES.Op();
CABLES.OPS["265c70e7-4d20-4ce0-9aa4-2c12ed867e8f"]={f:Ops.Gl.IdentityViewMatrix,objName:"Ops.Gl.IdentityViewMatrix"};




// **************************************************************
// 
// Ops.Gl.ImageSequenceAnim_v2
// 
// **************************************************************

Ops.Gl.ImageSequenceAnim_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTime = op.inValue("Time"),
    inType = op.inSwitch("Unit", ["Seconds", "Frames"], "Seconds"),
    fps = op.inValueFloat("FPS", 10),
    numX = op.inValueFloat("Num X", 4),
    numY = op.inValueFloat("Num Y", 4),
    maxFrames = op.inInt("Max Frames", 0),

    texRepeatX = op.outNumber("Repeat X"),
    texRepeatY = op.outNumber("Repeat Y"),
    texU = op.outNumber("Offset X"),
    texV = op.outNumber("Offset Y"),

    outFrame = op.outNumber("Frame"),
    outProgress = op.outNumber("Progress");

numX.onChange = numY.onChange = setRepeat;

texU.set(0);
texV.set(0);

const posX = 0;
const posY = 0;
const lastSwitch = 0;
const frame = 0;
setRepeat();

function setRepeat()
{
    texRepeatY.set(1 / numY.get());
    texRepeatX.set(1 / numX.get());
    update();
}

inTime.onChange = update;

function update()
{
    let frame = Math.ceil(Math.abs(inTime.get()) * (fps.get()));
    if (inType.get() == "Frames") frame = inTime.get();
    let numFrames = numX.get() * numY.get();
    if (maxFrames.get() !== 0) numFrames = maxFrames.get();

    frame %= numFrames;

    const row = Math.floor(frame / (numX.get()));
    const col = frame - (row * (numX.get()));

    outFrame.set(frame);
    outProgress.set((frame) / (numFrames - 1));

    texU.set(texRepeatX.get() * col);
    texV.set(texRepeatY.get() * row);
}


};

Ops.Gl.ImageSequenceAnim_v2.prototype = new CABLES.Op();
CABLES.OPS["282203ae-8e8c-4ff7-a0a6-f0cb0ec1ca25"]={f:Ops.Gl.ImageSequenceAnim_v2,objName:"Ops.Gl.ImageSequenceAnim_v2"};




// **************************************************************
// 
// Ops.Gl.InteractiveRectangle_v2
// 
// **************************************************************

Ops.Gl.InteractiveRectangle_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Trigger in"),
    trigger = op.outTrigger("Trigger out"),
    width = op.inValue("Width", 1),
    height = op.inValue("Height", 1),
    inId = op.inString("ID"),
    classPort = op.inString("Class"),
    pivotX = op.inValueSelect("Pivot x", ["center", "left", "right"]),
    pivotY = op.inValueSelect("Pivot y", ["center", "top", "bottom"]),
    axis = op.inValueSelect("Axis", ["xy", "xz"]),
    isInteractive = op.inValueBool("Is Interactive", true),
    renderRect = op.inValueBool("Render Rectangle", true),
    divVisible = op.inValueBool("Show Boundings", true),
    cursorPort = op.inValueSelect("Cursor", ["auto", "crosshair", "pointer", "Hand", "move", "n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize", "text", "wait", "help", "none"], "pointer"),
    active = op.inValueBool("Render", true);

const geomOut = op.outObject("geometry");
geomOut.ignoreValueSerialize = true;

const
    mouseOver = op.outBoolNum("Pointer Hover", false),
    mouseDown = op.outBoolNum("Pointer Down", false),
    outX = op.outNumber("Pointer X"),
    outY = op.outNumber("Pointer Y"),
    outTop = op.outNumber("Top"),
    outLeft = op.outNumber("Left"),
    outRight = op.outNumber("Right"),
    outBottom = op.outNumber("Bottom"),
    mouseClick = op.outTrigger("Left Click");

const elementPort = op.outObject("Dom Element");

active.setUiAttribs({ "title": "Active" });

const cgl = op.patch.cgl;
axis.set("xy");
pivotX.set("center");
pivotY.set("center");

const geom = new CGL.Geometry(op.name);
let mesh = null;
let div = null;
const m = mat4.create();
const trans = mat4.create();
const pos = vec3.create();
const divAlign = vec3.create();
const divAlignSize = vec3.create();

axis.onChange = rebuild;
pivotX.onChange = rebuild;
pivotY.onChange = rebuild;
width.onChange = rebuild;
height.onChange = rebuild;
cursorPort.onChange = updateCursor;
rebuild();

const modelMatrix = mat4.create();
const identViewMatrix = mat4.create();
const zeroVec3 = vec3.create();

render.onTriggered = function ()
{
    if (!div)
    {
        setUpDiv();
        addListeners();
        updateDivVisibility();
        updateIsInteractive();
    }
    updateDivSize();

    if (active.get() && renderRect.get() && mesh) mesh.render(cgl.getShader());

    trigger.trigger();
};

function rebuild()
{
    let w = width.get();
    let h = height.get();
    let x = 0;
    let y = 0;

    if (typeof w == "string")w = parseFloat(w);
    if (typeof h == "string")h = parseFloat(h);

    if (pivotX.get() == "center")
    {
        x = 0;
        divAlign[0] = -w / 2;
    }
    if (pivotX.get() == "right")
    {
        x = -w / 2;
    }
    if (pivotX.get() == "left")
    {
        x = w / 2;
    }

    if (pivotY.get() == "center")
    {
        y = 0;
        divAlign[1] = -h / 2;
    }
    if (pivotY.get() == "top") y = -h / 2;
    if (pivotY.get() == "bottom") y = +h / 2;

    const verts = [];
    const tc = [];
    const norms = [];
    const indices = [];

    const numRows = 1;
    const numColumns = 1;

    const stepColumn = w / numColumns;
    const stepRow = h / numRows;

    let c, r;

    for (r = 0; r <= numRows; r++)
    {
        for (c = 0; c <= numColumns; c++)
        {
            verts.push(c * stepColumn - width.get() / 2 + x);
            if (axis.get() == "xz") verts.push(0.0);
            verts.push(r * stepRow - height.get() / 2 + y);
            if (axis.get() == "xy") verts.push(0.0);

            tc.push(c / numColumns);
            tc.push(1.0 - r / numRows);

            if (axis.get() == "xz")
            {
                norms.push(0);
                norms.push(1);
                norms.push(0);
            }

            if (axis.get() == "xy")
            {
                norms.push(0);
                norms.push(0);
                norms.push(-1);
            }
        }
    }

    for (c = 0; c < numColumns; c++)
    {
        for (r = 0; r < numRows; r++)
        {
            const ind = c + (numColumns + 1) * r;
            const v1 = ind;
            const v2 = ind + 1;
            const v3 = ind + numColumns + 1;
            const v4 = ind + 1 + numColumns + 1;

            indices.push(v1);
            indices.push(v3);
            indices.push(v2);

            indices.push(v2);
            indices.push(v3);
            indices.push(v4);
        }
    }

    geom.clear();
    geom.vertices = verts;
    geom.texCoords = tc;
    geom.verticesIndices = indices;
    geom.vertexNormals = norms;

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);

    geomOut.set(null);
    geomOut.set(geom);
}

let divX = 0;
let divY = 0;
let divWidth = 0;
let divHeight = 0;

const mMatrix = mat4.create();
divVisible.onChange = updateDivVisibility;
inId.onChange = updateId;
classPort.onChange = updateClassNames;

function updateDivVisibility()
{
    if (div)
    {
        if (divVisible.get()) div.style.border = "1px solid red";
        else div.style.border = "none";
    }
}

function updateCursor()
{
    if (div)
    {
        div.style.cursor = cursorPort.get();
    }
}

function updateId()
{
    if (div)
    {
        div.setAttribute("id", inId.get());
    }
}

function updateDivSize()
{
    // var vp=cgl.getViewPort();

    mat4.multiply(mMatrix, cgl.vMatrix, cgl.mMatrix);
    vec3.transformMat4(pos, divAlign, mMatrix);
    vec3.transformMat4(trans, pos, cgl.pMatrix);

    const x1 = (trans[0] * cgl.canvasWidth / 2) + cgl.canvasWidth / 2;
    const y1 = (trans[1] * cgl.canvasHeight / 2) + cgl.canvasHeight / 2;

    divAlignSize[0] = divAlign[0] + width.get();
    divAlignSize[1] = divAlign[1];

    vec3.transformMat4(pos, divAlignSize, mMatrix);
    vec3.transformMat4(trans, pos, cgl.pMatrix);

    const x2 = ((trans[0] * cgl.canvasWidth / 2) + cgl.canvasWidth / 2);
    const y2 = ((trans[1] * cgl.canvasHeight / 2) + cgl.canvasHeight / 2);

    divAlignSize[0] = divAlign[0];
    divAlignSize[1] = divAlign[1] + height.get();

    vec3.transformMat4(pos, divAlignSize, mMatrix);
    vec3.transformMat4(trans, pos, cgl.pMatrix);

    const x3 = ((trans[0] * cgl.canvasWidth / 2) + cgl.canvasWidth / 2);
    const y3 = ((trans[1] * cgl.canvasHeight / 2) + cgl.canvasHeight / 2);

    divAlignSize[0] = divAlign[0] + width.get();
    divAlignSize[1] = divAlign[1] + height.get();

    vec3.transformMat4(pos, divAlignSize, mMatrix);
    vec3.transformMat4(trans, pos, cgl.pMatrix);

    const x4 = ((trans[0] * cgl.canvasWidth / 2) + cgl.canvasWidth / 2);
    const y4 = ((trans[1] * cgl.canvasHeight / 2) + cgl.canvasHeight / 2);

    divX = Math.min(x1, x2, x3, x4);
    divY = Math.min(cgl.canvasHeight - y1, cgl.canvasHeight - y2, cgl.canvasHeight - y3, cgl.canvasHeight - y4);

    const xb = Math.max(x1, x2, x3, x4);
    const yb = Math.max(cgl.canvasHeight - y1, cgl.canvasHeight - y2, cgl.canvasHeight - y3, cgl.canvasHeight - y4);

    outTop.set(divY);
    outLeft.set(divX);
    outRight.set(xb);
    outBottom.set(yb);

    divWidth = Math.abs(xb - divX);
    divHeight = Math.abs(yb - divY);

    divX /= op.patch.cgl.pixelDensity;
    divY /= op.patch.cgl.pixelDensity;
    divWidth /= op.patch.cgl.pixelDensity;
    divHeight /= op.patch.cgl.pixelDensity;

    // div.style.left=divX+'px';
    // div.style.top=divY+'px';
    // div.style.width=divWidth+'px';
    // div.style.height=divHeight+'px';

    const divXpx = divX + "px";
    const divYpx = divY + "px";
    const divWidthPx = divWidth + "px";
    const divHeightPx = divHeight + "px";
    if (divXpx != div.style.left) div.style.left = divXpx;
    if (divYpx != div.style.top) div.style.top = divYpx;
    if (div.style.width != divWidthPx) div.style.width = divWidthPx;
    if (div.style.height != divHeightPx) div.style.height = divHeightPx;
}

function updateClassNames()
{
    if (div)
    {
        div.className = classPort.get();
    }
}

op.onDelete = function ()
{
    if (div)div.remove();
};

function setUpDiv()
{
    if (!div)
    {
        div = document.createElement("div");
        div.dataset.op = op.id;
        div.oncontextmenu = function (e)
        {
            e.preventDefault();
        };

        div.style.padding = "0px";
        div.style.position = "absolute";
        div.style["box-sizing"] = "border-box";
        div.style.border = "1px solid red";
        // div.style['border-left']="1px solid blue";
        // div.style['border-top']="1px solid green";
        div.style["z-index"] = "500";

        div.style["-webkit-user-select"] = "none";
        div.style["user-select"] = "none";
        div.style["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)";
        div.style["-webkit-touch-callout"] = "none";

        const canvas = op.patch.cgl.canvas.parentElement;
        canvas.appendChild(div);
        updateCursor();
        updateIsInteractive();
        updateId();
        updateClassNames();
    }
    updateDivSize();
    elementPort.set(div);
}

let listenerElement = null;

function onMouseMove(e)
{
    const offsetX = -width.get() / 2;
    const offsetY = -height.get() / 2;

    outX.set(Math.max(0.0, Math.min(1.0, e.offsetX / divWidth)));
    outY.set(Math.max(0.0, Math.min(1.0, 1.0 - e.offsetY / divHeight)));
}

function onMouseLeave(e)
{
    mouseDown.set(false);
    mouseOver.set(false);
}

function onMouseEnter(e)
{
    mouseOver.set(true);
}

function onMouseDown(e)
{
    mouseDown.set(true);
}

function onMouseUp(e)
{
    mouseDown.set(false);
}

function onmouseclick(e)
{
    mouseClick.trigger();
}

function onTouchMove(e)
{
    const targetEle = document.elementFromPoint(e.targetTouches[0].pageX, e.targetTouches[0].pageY);

    if (targetEle == div)
    {
        mouseOver.set(true);
        if (e.touches && e.touches.length > 0)
        {
            const rect = div.getBoundingClientRect(); // e.target
            const x = e.targetTouches[0].pageX - rect.left;
            const y = e.targetTouches[0].pageY - rect.top;

            const touch = e.touches[0];

            outX.set(Math.max(0.0, Math.min(1.0, x / divWidth)));
            outY.set(Math.max(0.0, Math.min(1.0, 1.0 - y / divHeight)));

            onMouseMove(touch);
        }
    }
    else
    {
        mouseOver.set(false);
    }
}

active.onChange = updateActiveRender;
function updateActiveRender()
{
    if (active.get())
    {
        addListeners();
        if (div) div.style.display = "block";
    }
    else
    {
        removeListeners();
        if (div) div.style.display = "none";
    }
}

isInteractive.onChange = updateIsInteractive;
function updateIsInteractive()
{
    if (isInteractive.get())
    {
        addListeners();
        if (div)div.style["pointer-events"] = "initial";
    }
    else
    {
        removeListeners();
        mouseDown.set(false);
        mouseOver.set(false);
        if (div)div.style["pointer-events"] = "none";
    }
}

function removeListeners()
{
    if (listenerElement)
    {
        document.removeEventListener("touchmove", onTouchMove);
        listenerElement.removeEventListener("touchend", onMouseUp);
        listenerElement.removeEventListener("touchstart", onMouseDown);

        listenerElement.removeEventListener("click", onmouseclick);
        listenerElement.removeEventListener("mousemove", onMouseMove);
        listenerElement.removeEventListener("mouseleave", onMouseLeave);
        listenerElement.removeEventListener("mousedown", onMouseDown);
        listenerElement.removeEventListener("mouseup", onMouseUp);
        listenerElement.removeEventListener("mouseenter", onMouseEnter);
        // listenerElement.removeEventListener('contextmenu', onClickRight);
        listenerElement = null;
    }
}

function addListeners()
{
    if (listenerElement)removeListeners();

    listenerElement = div;

    if (listenerElement)
    {
        document.addEventListener("touchmove", onTouchMove);
        listenerElement.addEventListener("touchend", onMouseUp);
        listenerElement.addEventListener("touchstart", onMouseDown);

        listenerElement.addEventListener("click", onmouseclick);
        listenerElement.addEventListener("mousemove", onMouseMove);
        listenerElement.addEventListener("mouseleave", onMouseLeave);
        listenerElement.addEventListener("mousedown", onMouseDown);
        listenerElement.addEventListener("mouseup", onMouseUp);
        listenerElement.addEventListener("mouseenter", onMouseEnter);
        // listenerElement.addEventListener('contextmenu', onClickRight);
    }
}


};

Ops.Gl.InteractiveRectangle_v2.prototype = new CABLES.Op();
CABLES.OPS["334728ca-60a2-4a42-a059-d9b5f3fe4d32"]={f:Ops.Gl.InteractiveRectangle_v2,objName:"Ops.Gl.InteractiveRectangle_v2"};




// **************************************************************
// 
// Ops.Gl.LayerSequence
// 
// **************************************************************

Ops.Gl.LayerSequence = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    cleanup = op.inTriggerButton("Clean up connections");

const
    cgl = op.patch.cgl,
    triggers = [],
    num = 16;

let updateTimeout = null;

exe.onTriggered = triggerAll;
cleanup.onTriggered = clean;
cleanup.setUiAttribs({ "hidePort": true });
cleanup.setUiAttribs({ "hideParam": true });

for (let i = 0; i < num; i++)
{
    const p = op.outTrigger("trigger " + i);
    triggers.push(p);
    p.onLinkChanged = updateButton;
}

function updateButton()
{
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() =>
    {
        let show = false;
        for (let i = 0; i < triggers.length; i++)
            if (triggers[i].links.length > 1) show = true;

        cleanup.setUiAttribs({ "hideParam": !show });

        if (op.isCurrentUiOp()) op.refreshParams();
    }, 60);
}

function triggerAll()
{
    for (let i = 0; i < triggers.length; i++)
    {
        if (triggers[i].isLinked())
        {
            cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

            triggers[i].trigger();
        }
    }
}

function clean()
{
    let count = 0;
    for (let i = 0; i < triggers.length; i++)
    {
        let removeLinks = [];

        if (triggers[i].links.length > 1)
            for (let j = 1; j < triggers[i].links.length; j++)
            {
                while (triggers[count].links.length > 0) count++;

                removeLinks.push(triggers[i].links[j]);
                const otherPort = triggers[i].links[j].getOtherPort(triggers[i]);
                op.patch.link(op, "trigger " + count, otherPort.parent, otherPort.name);
                count++;
            }

        for (let j = 0; j < removeLinks.length; j++) removeLinks[j].remove();
    }
    updateButton();
}


};

Ops.Gl.LayerSequence.prototype = new CABLES.Op();
CABLES.OPS["09c33c7e-e282-468d-93e1-b8a7a0a4c4d2"]={f:Ops.Gl.LayerSequence,objName:"Ops.Gl.LayerSequence"};




// **************************************************************
// 
// Ops.Gl.LetterBox
// 
// **************************************************************

Ops.Gl.LetterBox = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");

const outWidth = op.outNumber("Width");
const outHeight = op.outNumber("Height");

let ratio = op.inValueSelect("ratio", [1, 1.25, 1.3333333333, 1.777777777778, 1.88, 2.33333333333333, 2.4151, 3, 4]);

ratio.set(1.777777777778);

const cgl = op.patch.cgl;

let blackBars = op.inValueBool("black bars");
blackBars.set(true);

let x = 0, y = 0, w = 1000, h = 1000;

function resize()
{
    let _w = cgl.canvasHeight * ratio.get();
    let _h = cgl.canvasHeight;
    let _x = 0;
    let _y = 0;
    if (_w > cgl.canvasWidth)
    {
        _w = cgl.canvasWidth;
        _h = cgl.canvasWidth / ratio.get();
    }

    if (_w < cgl.canvasWidth) _x = (cgl.canvasWidth - _w) / 2;
    if (_h < cgl.canvasHeight) _y = (cgl.canvasHeight - _h) / 2;

    _w = Math.ceil(_w);
    _h = Math.ceil(_h);
    _x = Math.ceil(_x);
    _y = Math.ceil(_y);

    if (_w != w || _h != h || _x != x || _y != y)
    {
        w = _w;
        h = _h;
        x = _x;
        y = _y;

        cgl.setViewPort(x, y, w, h);

        for (let i = 0; i < op.patch.ops.length; i++)
            if (op.patch.ops[i].onResize)op.patch.ops[i].onResize();
    }

    outWidth.set(w);
    outHeight.set(h);
}

op.onDelete = function ()
{
    // cgl.gl.disable(cgl.gl.SCISSOR_TEST);
    cgl.resetViewPort();
};

render.onTriggered = function ()
{
    if (blackBars.get())
    {
        cgl.gl.clearColor(0, 0, 0, 1);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
    }

    resize();

    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w + 0.5);
    h = Math.round(h + 0.5);

    cgl.gl.scissor(x, y, w, h);
    cgl.setViewPort(x, y, w, h);

    mat4.perspective(cgl.pMatrix, 45, ratio.get(), 0.1, 1100.0);

    trigger.trigger();
};


};

Ops.Gl.LetterBox.prototype = new CABLES.Op();
CABLES.OPS["6a62d24e-d0a6-4110-a042-15e3cda59db4"]={f:Ops.Gl.LetterBox,objName:"Ops.Gl.LetterBox"};




// **************************************************************
// 
// Ops.Gl.LineFont_v2
// 
// **************************************************************

Ops.Gl.LineFont_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    string = op.inString("Text", "cables"),
    letterSpacing = op.inValue("Letter Spacing", 1),
    align = op.inSwitch("align", ["left", "center", "right"], "left"),
    inDraw = op.inBool("Render", true),
    outArr = op.outArray("Lines", null, 3);

let lineArray = [];
let stringWidth = 0;
const meshes = [];
const vec = vec3.create();
const cgl = op.patch.cgl;
const characters =
    [
        {
            // a
            "l": [
                [182.667, 349.057, 164.167, 349.057],
                [160.333, 360.557, 171.333, 326.89, 175.333, 326.89, 186, 360.557],
            ]
        },
        {
            // b
            "l":
            [
                [174.333, 343.057, 160.255, 343.057],
                [160.333, 326.89, 175.5, 326.89, 178.333, 330.724, 178.333, 340.724, 174.333, 343.057, 180.5, 346.807, 180.5, 357.474, 176, 360.557, 160.167, 360.557, 160.333, 326.89]
            ]
        },
        {
            // c
            "l":
            [
                [180.583, 331.307, 175.917, 326.807, 166, 326.807, 160.083, 332.557, 160.083, 354.557, 165.833, 360.474, 175.917, 360.474, 180.5, 355.807],
            ]
        },
        {
            // d
            "l":
            [
                [160.083, 327.057, 160.083, 360.557, 175.417, 360.557, 180.708, 355.265, 180.708, 332.974, 175.104, 327.057, 160.083, 327.057],
            ]
        },
        {
            // e
            "l":
            [
                [175.167, 343.932, 160.436, 343.932],
                [177.917, 326.807, 164.5, 326.807, 160.436, 330.872, 160.436, 356.845, 164.014, 360.422, 177.917, 360.422]
            ]
        },
        {
            // f
            "l":
            [
                [176.792, 326.932, 164.125, 326.932, 160.167, 330.891, 160.167, 360.683],
                [173.458, 345.599, 160.167, 345.599],
            ]
        },
        {
            // g
            "l":
            [
                [180.455, 332.395, 175.391, 328.33, 166.194, 328.33, 160.167, 334.357, 160.167, 355.933, 165.792, 360.557, 176.038, 360.557, 181.62, 354.976, 181.62, 344.811, 173.122, 344.811],
            ]
        },
        {
            // h
            "l":
            [
                [160.167, 326.89, 160.167, 360.557],
                [160.5, 343.723, 182.333, 343.723],
                [182.333, 326.89, 182.333, 360.974]
            ]
        },
        {
            // i
            "l":
            [
                [160.167, 326.807, 160.167, 360.641]
            ]
        },
        {
            // j
            "l":
            [
                [159.833, 326.89, 166.833, 326.89, 166.833, 362.057, 163.962, 364.928, 159.833, 364.928],
            ]
        },
        {
            // k
            "l":
            [
                [160.167, 326.807, 160.167, 360.974],
                [178.917, 326.807, 160.167, 348.474],
                [164.905, 342.998, 180.333, 360.64]
            ]
        },
        {
            // l
            "l":
            [
                [160.167, 326.974, 160.167, 360.558, 176.083, 360.558],
            ]
        },
        {
            "l":
            [
                [160.167, 360.557, 160.247, 326.89, 164.997, 326.89, 175.5, 360.557, 178, 360.557, 188.58, 326.89, 193.33, 326.89, 193.25, 360.557],
            ]
        },
        {
            // n
            "l":
            [
                [160.167, 360.599, 160.167, 326.933, 164.629, 326.933, 178.333, 360.599, 182.083, 360.599, 182.083, 326.933],
            ]
        },
        {
            "l":
            [
                [160.283, 332.448, 165.764, 326.967, 178.405, 326.967, 183.668, 332.23, 183.668, 354.365, 177.434, 360.599, 166.367, 360.599, 160.167, 354.399, 160.283, 332.448],
            ]
        },

        {
            // p
            "l":
            [
                [160.167, 360.432, 160.167, 327.015, 175.955, 327.015, 179.667, 330.728, 179.667, 341.015, 175.602, 345.08, 160.167, 345.08],
            ]
        },

        {
            // q
            "l":
            [
                [184.504, 361.693, 180.517, 357.706],
                [160.283, 332.413, 165.764, 326.932, 178.405, 326.932, 183.668, 332.195, 183.668, 354.33, 177.434, 360.564, 166.367, 360.564, 160.167, 354.364, 160.283, 332.413],
            ]
        },
        {
            // r
            "l":
            [
                [179.667, 360.307, 173.5, 344.955],
                [160.167, 360.307, 160.167, 326.89, 175.955, 326.89, 179.667, 330.603, 179.667, 340.89, 175.602, 344.955, 160.167, 344.955],
            ]
        },
        {
            // s
            "l":
            [
                [179.979, 326.87, 165.895, 326.87, 160.167, 332.598, 160.167, 338.307, 179.292, 349.057, 179.292, 355.223, 173.917, 360.598, 160.167, 360.598],
            ]
        },
        {
            // t
            "l":
            [
                [170.417, 326.89, 170.417, 360.974],
                [180.5, 326.89, 160.167, 326.89]
            ]
        },
        {
            // u
            "l":
            [
                [160.167, 327.14, 160.167, 356.845, 164.108, 360.786, 178.125, 360.786, 182.012, 356.899, 181.958, 327.14],
            ]
        },
        {
            // v
            "l":
            [
                [160.167, 326.901, 170.167, 360.797, 174.417, 360.797, 184.667, 326.734],
            ]
        },
        {
            // w
            "l":
            [
                [203.5, 326.89, 195.208, 360.557, 191.458, 360.557, 184, 326.89, 179.758, 326.89, 172.208, 360.557, 168.458, 360.557, 160.167, 326.89],
            ]
        },
        {
            // x
            "l":
            [
                [181.333, 360.64, 159.667, 326.807],
                [159.667, 360.557, 181.75, 326.807]
            ]
        },
        {
            // y
            "l":
            [
                [160.167, 326.891, 168.508, 347.224, 173.992, 347.224, 182.917, 326.891],
                [171.333, 347.224, 171.333, 360.641]
            ]
        },
        {
            // z
            "l":
            [
                [161.167, 326.807, 180.5, 326.807, 180.5, 332.473, 161.167, 355.223, 161.167, 360.557, 180.5, 360.557],
            ]
        },

        {
            // 0
            "l":
            [
                [167.591, 326.89, 173.076, 326.89, 180.5, 334.315, 180.5, 353.132, 173.076, 360.557, 167.591, 360.557, 160.167, 353.132, 160.167, 334.315, 167.591, 326.89],
            ]
        },
        {
            // 1
            "l":
            [
                [160.167, 334.315, 167.549, 326.932, 170.333, 326.89, 170.417, 360.557],
            ]
        },
        {
            // 2
            "l":
            [
                [164.066, 330.415, 167.591, 326.89, 180.5, 326.89, 180.5, 330.603, 160.167, 351.224, 160.167, 360.557, 180.5, 360.599],
            ]
        },
        {
            // 3
            "l":
            [
                [169.583, 342.932, 180.5, 342.932],
                [163.129, 331.353, 167.591, 326.89, 180.5, 326.89, 180.5, 360.557, 167.591, 360.557, 162.837, 355.803],
            ]
        },
        {
            // 4
            "l":
            [
                [178.076, 326.89, 178.076, 360.599],
                [160.167, 326.89, 160.167, 338.474, 165.104, 343.412, 178.5, 343.412],
            ]
        },
        {
            // 5
            "l":
            [
                [180.5, 326.89, 160.098, 326.958, 160.167, 342.932, 180.5, 342.932, 180.5, 353.132, 173.076, 360.557, 160.167, 360.557],
            ]
        },
        {
            // 6
            "l":
            [
                [173.076, 326.89, 167.591, 326.89, 160.167, 333.89, 160.167, 353.132, 167.591, 360.557, 173.417, 360.557, 180.671, 353.303, 180.671, 342.932, 160.167, 342.932],
            ]
        },
        {
            // 7
            "l":
            [
                [163.591, 326.89, 180.5, 326.89, 170.417, 360.557],
            ]
        },
        {
            // 8
            "l":
            [
                [180.5, 334.315, 173.076, 326.89, 167.591, 326.89, 160.167, 334.315, 180.5, 353.132, 173.076, 360.557, 167.591, 360.557, 160.167, 353.132, 180.5, 334.315],
            ]
        },
        {
            // 9
            "l":
            [
                [167.591, 360.557, 173.076, 360.557, 180.5, 353.132, 180.5, 334.315, 173.076, 326.89, 167.591, 326.89, 160.167, 334.315, 160.167, 342.932, 180.5, 342.932]
            ]
        },

        {
            // &
            "l":
            [
                [182.496, 351.137, 173.076, 360.557, 167.591, 360.557, 160.167, 353.132, 160.167, 348.087, 173.922, 339.533, 172.229, 326.89, 165.167, 326.89, 165.052, 339.515, 184.292, 359.432],
            ]
        },
        {
            // '
            "l":
            [
        		[160.167, 326.932, 160.167, 333.557],
        		[162.879, 326.932, 162.879, 333.557]

            ]
        },
        {
            // ;
            "l":
            [
        		[160.167, 342.932, 160.167, 346.224],
        		[160.167, 354.224, 160.167, 360.557]
            ]
        },
        {
            // :
            "l":
            [
        		[160.167, 342.932, 160.167, 346.224],
        		[160.167, 354.224, 160.167, 357.974]
            ]
        },
        {
            // _
            "l":
            [
        		[160.167, 360.557, 170.417, 360.557]
            ]
        },
        {
            // +
            "l":
            [
        		[160.167, 342.932, 170, 342.932],
                [164.833, 347.849, 164.833, 338.015]
            ]
        },
        {
            // -
            "l":
            [
        		[160.167, 342.932, 170, 342.932],
            ]
        },
        {
            // /
            "l":
            [
        		[180.5, 326.89, 160.167, 360.557],
            ]
        },
        {
            // .
            "l":
            [
        		[160.167, 360.599, 163.417, 360.599],
            ]
        },
        {
            // ,
            "l":
            [
        		[165.163, 360.557, 160.167, 365.553],
            ]
        },
        {
            // )
            "l":
            [
        		[160.167, 360.557, 167.591, 353.132, 167.591, 334.315, 160.167, 326.89],
            ]
        },
        {
            // (
            "l":
            [
        		[167.591, 326.89, 160.167, 334.315, 160.167, 353.132, 167.591, 360.557],
            ]
        },
        {
            // ?
            "l":
            [
        		[170.333, 363.481, 170.333, 368.966],
        		[160.167, 334.315, 167.591, 326.89, 173.076, 326.89, 180.5, 334.315, 180.5, 342.932, 170.333, 353.132, 170.333, 360.557]
            ]
        },
        {
            // !
            "l":
            [
                [160.167, 353.557, 160.167, 326.89],
                [160.167, 357.64, 160.167, 360.557]
            ]
        },

    ];

function translateX(w)
{
    transX += w;

    vec3.set(vec, w, 0, 0);
    mat4.translate(cgl.mMatrix, cgl.mMatrix, vec);
}

let alignMode = 0;
align.onChange = function ()
{
    if (align.get() == "left")alignMode = 0;
    if (align.get() == "center")alignMode = 1;
    if (align.get() == "right")alignMode = 2;
};

let oldPrim = 0;
let shader = null;

let transX = 0;

function renderChar(charIndex, simulate)
{
    shader = cgl.getShader();
    if (!shader) return;
    oldPrim = shader.glPrimitive;

    shader.glPrimitive = cgl.gl.LINE_STRIP;

    if (charIndex >= characters.length)charIndex = 0;

    if (!simulate)
    {
        for (let m = 0; m < characters[charIndex].linesArr.length; m += 3)
        {
            lineArray.push(
                characters[charIndex].linesArr[m + 0] + transX,
                characters[charIndex].linesArr[m + 1],
                characters[charIndex].linesArr[m + 2]
            );

            // characters[charIndex].m[m].render(op.patch.cgl.getShader());
        }

        for (let m = 0; m < characters[charIndex].m.length; m++)
        {
            if (inDraw.get())
                characters[charIndex].m[m].render(op.patch.cgl.getShader());
        }
        translateX(characters[charIndex].w * letterSpacing.get());
    }
    else
    {
        stringWidth += characters[charIndex].w * letterSpacing.get();
    }
    shader.glPrimitive = oldPrim;
}

render.onTriggered = function ()
{
    stringWidth = 0;
    if (!string.get()) return;
    let spaceWidth = 0.15;
    vec3.set(vec, 0.3, 0, 0);
    cgl.pushModelMatrix();

    let startCharacters = 97;
    let startNumbers = 48;

    let str = string.get() + "";

    // cgl.gl.lineWidth(lineWidth.get());

    for (let sim = 0; sim < 2; sim++)
    {
        transX = 0;
        lineArray.length = 0;
        let simulate = sim === 0;

        if (!simulate)
        {
            if (alignMode == 1) translateX(-stringWidth / 2 + 0.04 * letterSpacing.get());
            if (alignMode == 2) translateX(-stringWidth + 0.08 * letterSpacing.get());
        }

        for (let i = 0; i < str.length; i++)
        {
            let w = 0;
            let charIndex = str.toLowerCase().charCodeAt(i);

            if (charIndex == 38) renderChar(36, simulate); // &
            else if (charIndex == 39) renderChar(37, simulate); // '
            else if (charIndex == 34) renderChar(37, simulate); // '
            else if (charIndex == 59) renderChar(38, simulate); // ;
            else if (charIndex == 58) renderChar(39, simulate); // :
            else if (charIndex == 95) renderChar(40, simulate); // _
            else if (charIndex == 43) renderChar(41, simulate); // +
            else if (charIndex == 45) renderChar(42, simulate); // -
            else if (charIndex == 47) renderChar(43, simulate); // /
            else if (charIndex == 46) renderChar(44, simulate); // .
            else if (charIndex == 44) renderChar(45, simulate); // ,
            else if (charIndex == 41) renderChar(46, simulate); // )
            else if (charIndex == 40) renderChar(47, simulate); // ()
            else if (charIndex == 63) renderChar(48, simulate); // ?
            else if (charIndex == 33) renderChar(49, simulate); // !
            else
            if (charIndex >= startNumbers && charIndex <= startNumbers + 10)
            {
                renderChar(charIndex - startNumbers + 26, simulate);
            }
            else
            if (charIndex >= startCharacters && charIndex - startCharacters < characters.length)
            {
                renderChar(charIndex - startCharacters, simulate);
            }
            else
            if (charIndex == 32)
            {
                if (simulate)stringWidth += spaceWidth;
                else translateX(spaceWidth);
            }
            else
            {
                renderChar(48, simulate);
            }
        }
    }

    outArr.set(null);
    outArr.set(lineArray);

    cgl.popModelMatrix();
};

function avg(which)
{
    let avgX = 0, avgY = 0;
    let count = 0;
    for (let l = 0; l < characters[which].l.length; l++)
    {
        for (let j = 0; j < characters[which].l[l].length; j += 2)
        {
            avgX += characters[which].l[l][j];
            avgY += characters[which].l[l][j + 1];
            count++;
        }
    }
    avgX /= count;
    avgY /= count;
    return [avgX, avgY];
}

function min(which)
{
    let min = 9999999;

    for (let l = 0; l < characters[which].l.length; l++)
    {
        for (let j = 0; j < characters[which].l[l].length; j += 2)
        {
            min = Math.min(min, characters[which].l[l][j]);
        }
    }
    return min;
}

function width(which)
{
    let min = 9999999;
    let max = -9999999;

    for (let l = 0; l < characters[which].l.length; l++)
    {
        for (let j = 0; j < characters[which].l[l].length; j += 2)
        {
            min = Math.min(min, characters[which].l[l][j]);
            max = Math.max(max, characters[which].l[l][j]);
        }
    }
    return ((max - min));
}

meshes.length = 0;

let avgXY = [];
let avg1 = avg(0);
let avg2 = avg(1);

avgXY = [(avg1[0] + avg2[0]) / 2, (avg1[1] + avg2[1]) / 2];

for (let i = 0; i < characters.length; i++)
{
    characters[i].w = width(i) * (0.002);
    characters[i].m = [];
    let lines = [];

    for (let l = 0; l < characters[i].l.length; l++)
    {
        let count = 0;
        let indices = [];
        let vertices = [];

        for (let j = 0; j < characters[i].l[l].length - 2; j += 2)
        {
            lines.push(
                (characters[i].l[l][j] - min(i)) * 0.005,
                (characters[i].l[l][j + 1] - avgXY[1]) * -0.005,
                0);

            lines.push(
                (characters[i].l[l][j + 2] - min(i)) * 0.005,
                (characters[i].l[l][j + 3] - avgXY[1]) * -0.005,
                0);
        }

        for (let j = 0; j < characters[i].l[l].length; j += 2)
        {
            vertices.push((characters[i].l[l][j] - min(i)) * 0.005);
            vertices.push((characters[i].l[l][j + 1] - avgXY[1]) * -0.005);
            vertices.push(0);

            indices.push(count);
            count++;
        }

        characters[i].linesArr = lines;
        let geom = new CGL.Geometry(op.name);
        geom.vertices = vertices;
        geom.verticesIndices = indices;
        let mesh = new CGL.Mesh(op.patch.cgl, geom);
        characters[i].m.push(mesh);
    }

    outArr.set([]);

    characters[i].w += 0.1;
}


};

Ops.Gl.LineFont_v2.prototype = new CABLES.Op();
CABLES.OPS["a3615010-05af-45bc-bf98-6972c2de21bc"]={f:Ops.Gl.LineFont_v2,objName:"Ops.Gl.LineFont_v2"};




// **************************************************************
// 
// Ops.Gl.MainLoop
// 
// **************************************************************

Ops.Gl.MainLoop = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    fpsLimit = op.inValue("FPS Limit", 0),
    trigger = op.outTrigger("trigger"),
    width = op.outNumber("width"),
    height = op.outNumber("height"),
    reduceFocusFPS = op.inValueBool("Reduce FPS not focussed", true),
    reduceLoadingFPS = op.inValueBool("Reduce FPS loading"),
    clear = op.inValueBool("Clear", true),
    clearAlpha = op.inValueBool("ClearAlpha", true),
    fullscreen = op.inValueBool("Fullscreen Button", false),
    active = op.inValueBool("Active", true),
    hdpi = op.inValueBool("Hires Displays", false),
    inUnit = op.inSwitch("Pixel Unit", ["Display", "CSS"], "Display");

op.onAnimFrame = render;
hdpi.onChange = function ()
{
    if (hdpi.get()) op.patch.cgl.pixelDensity = window.devicePixelRatio;
    else op.patch.cgl.pixelDensity = 1;

    op.patch.cgl.updateSize();
    if (CABLES.UI) gui.setLayout();

    // inUnit.setUiAttribs({ "greyout": !hdpi.get() });

    // if (!hdpi.get())inUnit.set("CSS");
    // else inUnit.set("Display");
};

active.onChange = function ()
{
    op.patch.removeOnAnimFrame(op);

    if (active.get())
    {
        op.setUiAttrib({ "extendTitle": "" });
        op.onAnimFrame = render;
        op.patch.addOnAnimFrame(op);
        op.log("adding again!");
    }
    else
    {
        op.setUiAttrib({ "extendTitle": "Inactive" });
    }
};

const cgl = op.patch.cgl;
let rframes = 0;
let rframeStart = 0;

if (!op.patch.cgl) op.uiAttr({ "error": "No webgl cgl context" });

const identTranslate = vec3.create();
vec3.set(identTranslate, 0, 0, 0);
const identTranslateView = vec3.create();
vec3.set(identTranslateView, 0, 0, -2);

fullscreen.onChange = updateFullscreenButton;
setTimeout(updateFullscreenButton, 100);
let fsElement = null;

let winhasFocus = true;
let winVisible = true;

window.addEventListener("blur", () => { winhasFocus = false; });
window.addEventListener("focus", () => { winhasFocus = true; });
document.addEventListener("visibilitychange", () => { winVisible = !document.hidden; });
testMultiMainloop();

inUnit.onChange = () =>
{
    width.set(0);
    height.set(0);
};

function getFpsLimit()
{
    if (reduceLoadingFPS.get() && op.patch.loading.getProgress() < 1.0) return 5;

    if (reduceFocusFPS.get())
    {
        if (!winVisible) return 10;
        if (!winhasFocus) return 30;
    }

    return fpsLimit.get();
}

function updateFullscreenButton()
{
    function onMouseEnter()
    {
        if (fsElement)fsElement.style.display = "block";
    }

    function onMouseLeave()
    {
        if (fsElement)fsElement.style.display = "none";
    }

    op.patch.cgl.canvas.addEventListener("mouseleave", onMouseLeave);
    op.patch.cgl.canvas.addEventListener("mouseenter", onMouseEnter);

    if (fullscreen.get())
    {
        if (!fsElement)
        {
            fsElement = document.createElement("div");

            const container = op.patch.cgl.canvas.parentElement;
            if (container)container.appendChild(fsElement);

            fsElement.addEventListener("mouseenter", onMouseEnter);
            fsElement.addEventListener("click", function (e)
            {
                if (CABLES.UI && !e.shiftKey) gui.cycleFullscreen();
                else cgl.fullScreen();
            });
        }

        fsElement.style.padding = "10px";
        fsElement.style.position = "absolute";
        fsElement.style.right = "5px";
        fsElement.style.top = "5px";
        fsElement.style.width = "20px";
        fsElement.style.height = "20px";
        fsElement.style.cursor = "pointer";
        fsElement.style["border-radius"] = "40px";
        fsElement.style.background = "#444";
        fsElement.style["z-index"] = "9999";
        fsElement.style.display = "none";
        fsElement.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 490 490\" style=\"width:20px;height:20px;\" xml:space=\"preserve\" width=\"512px\" height=\"512px\"><g><path d=\"M173.792,301.792L21.333,454.251v-80.917c0-5.891-4.776-10.667-10.667-10.667C4.776,362.667,0,367.442,0,373.333V480     c0,5.891,4.776,10.667,10.667,10.667h106.667c5.891,0,10.667-4.776,10.667-10.667s-4.776-10.667-10.667-10.667H36.416     l152.459-152.459c4.093-4.237,3.975-10.99-0.262-15.083C184.479,297.799,177.926,297.799,173.792,301.792z\" fill=\"#FFFFFF\"/><path d=\"M480,0H373.333c-5.891,0-10.667,4.776-10.667,10.667c0,5.891,4.776,10.667,10.667,10.667h80.917L301.792,173.792     c-4.237,4.093-4.354,10.845-0.262,15.083c4.093,4.237,10.845,4.354,15.083,0.262c0.089-0.086,0.176-0.173,0.262-0.262     L469.333,36.416v80.917c0,5.891,4.776,10.667,10.667,10.667s10.667-4.776,10.667-10.667V10.667C490.667,4.776,485.891,0,480,0z\" fill=\"#FFFFFF\"/><path d=\"M36.416,21.333h80.917c5.891,0,10.667-4.776,10.667-10.667C128,4.776,123.224,0,117.333,0H10.667     C4.776,0,0,4.776,0,10.667v106.667C0,123.224,4.776,128,10.667,128c5.891,0,10.667-4.776,10.667-10.667V36.416l152.459,152.459     c4.237,4.093,10.99,3.975,15.083-0.262c3.992-4.134,3.992-10.687,0-14.82L36.416,21.333z\" fill=\"#FFFFFF\"/><path d=\"M480,362.667c-5.891,0-10.667,4.776-10.667,10.667v80.917L316.875,301.792c-4.237-4.093-10.99-3.976-15.083,0.261     c-3.993,4.134-3.993,10.688,0,14.821l152.459,152.459h-80.917c-5.891,0-10.667,4.776-10.667,10.667s4.776,10.667,10.667,10.667     H480c5.891,0,10.667-4.776,10.667-10.667V373.333C490.667,367.442,485.891,362.667,480,362.667z\" fill=\"#FFFFFF\"/></g></svg>";
    }
    else
    {
        if (fsElement)
        {
            fsElement.style.display = "none";
            fsElement.remove();
            fsElement = null;
        }
    }
}

op.onDelete = function ()
{
    cgl.gl.clearColor(0, 0, 0, 0);
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
};

function render(time)
{
    if (!active.get()) return;
    if (cgl.aborted || cgl.canvas.clientWidth === 0 || cgl.canvas.clientHeight === 0) return;

    op.patch.cg = cgl;

    const startTime = performance.now();

    op.patch.config.fpsLimit = getFpsLimit();

    if (cgl.canvasWidth == -1)
    {
        cgl.setCanvas(op.patch.config.glCanvasId);
        return;
    }

    if (cgl.canvasWidth != width.get() || cgl.canvasHeight != height.get())
    {
        let div = 1;
        if (inUnit.get() == "CSS")div = op.patch.cgl.pixelDensity;

        width.set(cgl.canvasWidth / div);
        height.set(cgl.canvasHeight / div);
    }

    if (CABLES.now() - rframeStart > 1000)
    {
        CGL.fpsReport = CGL.fpsReport || [];
        if (op.patch.loading.getProgress() >= 1.0 && rframeStart !== 0)CGL.fpsReport.push(rframes);
        rframes = 0;
        rframeStart = CABLES.now();
    }
    CGL.MESH.lastShader = null;
    CGL.MESH.lastMesh = null;

    cgl.renderStart(cgl, identTranslate, identTranslateView);

    if (clear.get())
    {
        cgl.gl.clearColor(0, 0, 0, 1);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
    }

    trigger.trigger();

    if (CGL.MESH.lastMesh)CGL.MESH.lastMesh.unBind();

    if (CGL.Texture.previewTexture)
    {
        if (!CGL.Texture.texturePreviewer) CGL.Texture.texturePreviewer = new CGL.Texture.texturePreview(cgl);
        CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture);
    }
    cgl.renderEnd(cgl);

    op.patch.cg = null;

    if (clearAlpha.get())
    {
        cgl.gl.clearColor(1, 1, 1, 1);
        cgl.gl.colorMask(false, false, false, true);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
        cgl.gl.colorMask(true, true, true, true);
    }

    if (!cgl.frameStore.phong)cgl.frameStore.phong = {};
    rframes++;

    op.patch.cgl.profileData.profileMainloopMs = performance.now() - startTime;
}

function testMultiMainloop()
{
    setTimeout(
        () =>
        {
            if (op.patch.getOpsByObjName(op.name).length > 1)
            {
                op.setUiError("multimainloop", "there should only be one mainloop op!");
                op.patch.addEventListener("onOpDelete", testMultiMainloop);
            }
            else op.setUiError("multimainloop", null, 1);
        }, 500);
}


};

Ops.Gl.MainLoop.prototype = new CABLES.Op();
CABLES.OPS["b0472a1d-db16-4ba6-8787-f300fbdc77bb"]={f:Ops.Gl.MainLoop,objName:"Ops.Gl.MainLoop"};




// **************************************************************
// 
// Ops.Gl.Matrix.AnimMatrix
// 
// **************************************************************

Ops.Gl.Matrix.AnimMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrigger = op.inTrigger("Update"),
    inMat = op.inArray("Next Matrix"),
    // inStart=op.inTriggerButton("Start Anim"),
    inDur = op.inFloat("Duration", 1),
    next = op.outTrigger("Next"),
    outArr = op.outArray("Matrix");

let lastTime = 0;
let startTime = 0;
let firsttime = true;
let cycle = 1;

const anim = new CABLES.Anim();
anim.createPort(op, "easing", init);
anim.loop = false;

let lastMat = null;

inDur.onChange = inMat.onChange = init;

const a = vec3.create();
const b = vec3.create();

let arr1, arr2;
let result = mat4.create();

inTrigger.onTriggered = () =>
{
    let t = CABLES.now() / 1000;

    const perc = anim.getValue(t);

    if (arr1 && arr2) ipMat(perc);
};

function matEquals(a, b)
{
    return (
        a[0] == b[0] &&
        a[1] == b[1] &&
        a[2] == b[2] &&
        a[3] == b[3] &&
        a[4] == b[4] &&
        a[5] == b[5] &&
        a[6] == b[6] &&
        a[7] == b[7] &&
        a[8] == b[8] &&
        a[9] == b[9] &&
        a[10] == b[10] &&
        a[11] == b[11] &&
        a[12] == b[12] &&
        a[13] == b[13] &&
        a[14] == b[14] &&
        a[15] == b[15]);
}

function init()
{
    if (!inMat.get()) return;
    if (inMat.get() == lastMat)
    {
        // mat4.copy(result,inMat.get());
        return;
    }

    if (lastMat)
        if (inMat.get() == lastMat && matEquals(inMat.get(), lastMat))
        {
            return;
        }

    lastMat = inMat.get();
    startTime = performance.now();
    anim.clear(CABLES.now() / 1000.0);

    anim.setValue(CABLES.now() / 1000.0, cycle);

    if (cycle == 1) cycle = 0;
    else cycle = 1;

    if (cycle == 0)
    {
        arr1 = inMat.get();
        arr2 = mat4.create();
        mat4.copy(arr2, result);
    }
    else
    {
        arr1 = mat4.create();
        arr2 = inMat.get();
        mat4.copy(arr1, result);
    }

    anim.setValue(inDur.get() + CABLES.now() / 1000.0, cycle, () =>
    {
        // result=outArr.get();
    });

    firsttime = false;
}

function ip(val1, val2, perc)
{
    return ((val2 - val1) * perc + val1);
}

function ipMat(perc)
{
    if (!arr1 || !arr2 || arr1.length != arr2.length)
    {
        outArr.set(null);
        op.logError("arrays wrong", arr1.length, arr2.length);
    }
    else
    {
        getYPR(a, arr1);
        getYPR(b, arr2);

        mat4.identity(result);
        result[12] = ip(arr1[12], arr2[12], perc);
        result[13] = ip(arr1[13], arr2[13], perc);
        result[14] = ip(arr1[14], arr2[14], perc);

        vec3.lerp(a, a, b, perc);

        mat4.rotateZ(result, result, a[2]);
        mat4.rotateY(result, result, a[1]);
        mat4.rotateX(result, result, a[0]);

        outArr.set(null);
        outArr.set(result);
    }
    next.trigger();
}

// 0  1  2  3
// 4  5  6  7
// 8  9  10 11
// 12 13 14 15

function getYPR(v, m)
{
    const r1 = Math.atan2(m[6], m[10]);
    const c2 = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
    const r2 = Math.atan2(-m[2], c2);
    const s1 = Math.sin(r1);
    const c1 = Math.cos(r1);
    const r3 = Math.atan2(s1 * m[8] - c1 * m[4], c1 * m[5] - s1 * m[9]);

    v[0] = r1;
    v[1] = r2;
    v[2] = r3;
    return v;
}


};

Ops.Gl.Matrix.AnimMatrix.prototype = new CABLES.Op();
CABLES.OPS["7800dde0-0ce4-4acd-9605-d412931bb90e"]={f:Ops.Gl.Matrix.AnimMatrix,objName:"Ops.Gl.Matrix.AnimMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.ArrayPathFollow
// 
// **************************************************************

Ops.Gl.Matrix.ArrayPathFollow = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("exe");
const arrayIn = op.inArray("array");
const time = op.inValueFloat("time");

const duration = op.inValueFloat("duration");
duration.set(0.1);

const offset = op.inValueFloat("offset");
offset.set(0.0);

const lookAhead = op.inValueFloat("look ahead");
lookAhead.set(3.0);

const trigger = op.outTrigger("trigger");
const triggerLookat = op.outTrigger("transform lookat");
const idx = op.addOutPort(new CABLES.Port(op, "index"));

const vec = vec3.create();
const vecn = vec3.create();
const cgl = op.patch.cgl;

const startTime = CABLES.now();

let animX = new CABLES.Anim();
let animY = new CABLES.Anim();
let animZ = new CABLES.Anim();

let animQX = new CABLES.Anim();
let animQY = new CABLES.Anim();
let animQZ = new CABLES.Anim();
let animQW = new CABLES.Anim();

let animLength = 0;
let timeStep = 0.1;
function setup()
{
    animX = new CABLES.Anim();
    animY = new CABLES.Anim();
    animZ = new CABLES.Anim();

    animQX = new CABLES.Anim();
    animQY = new CABLES.Anim();
    animQZ = new CABLES.Anim();
    animQW = new CABLES.Anim();

    let i = 0;
    const arr = arrayIn.get();
    if (!arr) return;
    timeStep = parseFloat(duration.get());

    for (i = 0; i < arr.length; i += 3)
    {
        animX.setValue(i / 3 * timeStep, arr[i + 0]);
        animY.setValue(i / 3 * timeStep, arr[i + 1]);
        animZ.setValue(i / 3 * timeStep, arr[i + 2]);
        animLength = i / 3 * timeStep;
    }

    for (i = 0; i < arr.length / 3; i++)
    {
        const t = i * timeStep;
        const nt = (i * timeStep + timeStep) % animLength;

        vec3.set(vec,
            animX.getValue(t),
            animY.getValue(t),
            animZ.getValue(t)
        );
        vec3.set(vecn,
            animX.getValue(nt),
            animY.getValue(nt),
            animZ.getValue(nt)
        );

        vec3.set(vec, vecn[0] - vec[0], vecn[1] - vec[1], vecn[2] - vec[2]);
        vec3.normalize(vec, vec);
        vec3.set(vecn, 0, 0, 1);

        quat.rotationTo(q, vecn, vec);

        animQX.setValue(i * timeStep, q[0]);
        animQY.setValue(i * timeStep, q[1]);
        animQZ.setValue(i * timeStep, q[2]);
        animQW.setValue(i * timeStep, q[3]);
    }
}

arrayIn.onChange = duration.onChange = setup;

let q = quat.create();
const qMat = mat4.create();

function render()
{
    if (!arrayIn.get()) return;

    const t = (time.get() + parseFloat(offset.get())) % animLength;
    const nt = (time.get() + timeStep * lookAhead.get() + parseFloat(offset.get())) % animLength;

    vec3.set(vec,
        animX.getValue(t),
        animY.getValue(t),
        animZ.getValue(t)
    );

    idx.set(nt);

    if (triggerLookat.isLinked())
    {
        vec3.set(vecn,
            animX.getValue(nt),
            animY.getValue(nt),
            animZ.getValue(nt)
        );

        cgl.pushModelMatrix();
        mat4.translate(cgl.mMatrix, cgl.mMatrix, vecn);
        triggerLookat.trigger();
        cgl.popModelMatrix();
    }

    cgl.pushModelMatrix();
    mat4.translate(cgl.mMatrix, cgl.mMatrix, vec);

    CABLES.TL.Anim.slerpQuaternion(t, q, animQX, animQY, animQZ, animQW);
    mat4.fromQuat(qMat, q);
    mat4.multiply(cgl.mMatrix, cgl.mMatrix, qMat);

    trigger.trigger();
    cgl.popModelMatrix();
}

exe.onTriggered = render;


};

Ops.Gl.Matrix.ArrayPathFollow.prototype = new CABLES.Op();
CABLES.OPS["395bff14-d092-4e7e-a723-b6a69564add2"]={f:Ops.Gl.Matrix.ArrayPathFollow,objName:"Ops.Gl.Matrix.ArrayPathFollow"};




// **************************************************************
// 
// Ops.Gl.Matrix.ArrayPathFollowParticles_v2
// 
// **************************************************************

Ops.Gl.Matrix.ArrayPathFollowParticles_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"pathfollow_vert":"\nfloat off=MOD_offset;\n\n#ifdef RANDOMSPEED\n    off*=MOD_rand(pos.xy);\n#endif\n\nfloat fr=fract(abs(mod(off+rndOffset,float(PATHFOLLOW_POINTS))));\nint index=int(abs(mod(off+rndOffset,max(0.0,float(PATHFOLLOW_POINTS)))));\nint index2=int(abs(mod(off+1.0+rndOffset,max(0.0,float(PATHFOLLOW_POINTS)))));\n\nif(index2!=0)\n{\n    pos.xyz = mix( MOD_pathPoints[index] ,MOD_pathPoints[index2] ,fr);\n\n    #ifdef CHECK_DISTANCE\n        if( distance(MOD_pathPoints[index] ,MOD_pathPoints[index2]) > MOD_maxDistance ) pos.xyz=vec3(9999999.0,9999999.0,9999999.0);\n    #endif\n}\nelse\n{\n    pos.xyz=MOD_pathPoints[0];\n}\n\npos.xyz+=rndPos;","pathfollow_head_vert":"UNI vec3 MOD_pathPoints[PATHFOLLOW_POINTS];\n\nIN vec3 rndPos;\nIN float rndOffset;\n\n\nfloat MOD_rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n",};
const
    exec = op.inTrigger("Exec"),
    inPoints = op.inArray("Points"),
    inParticles = op.inValue("Num Particles", 500),
    inLength = op.inValue("Length", 20),
    inSpread = op.inValue("Spread", 0.2),
    inOffset = op.inValue("Offset"),
    inMaxDistance = op.inValue("Max Distance", 0),
    inRandomSpeed = op.inValueBool("RandomSpeed"),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;
let shaderModule = null;
let shader = null;
let mesh = null;
let needsRebuild = true;
let geom = null;
let updateUniformPoints = false;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.objName,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.pathfollow_head_vert,
    "srcBodyVert": attachments.pathfollow_vert
});

mod.addUniform("f", "MOD_maxDistance", inMaxDistance);
mod.addUniform("f", "MOD_offset", inOffset);
mod.addUniform("3f[]", "MOD_pathPoints", inPoints);

inParticles.onChange =
    inLength.onChange =
    inSpread.onChange = resetLater;

inMaxDistance.onChange = updateDefines;

function resetLater()
{
    needsRebuild = true;
}

function getRandomVec(size)
{
    return [
        (Math.random() - 0.5) * 2 * size,
        (Math.random() - 0.5) * 2 * size,
        (Math.random() - 0.5) * 2 * size
    ];
}

function rebuild()
{
    op.log("rebuild");

    mesh = null;
    needsRebuild = false;
    let i = 0;
    let verts = null;
    const num = Math.abs(Math.floor(inParticles.get()) * 3);
    if (!verts || verts.length != num) verts = new Float32Array(num);

    for (i = 0; i < verts.length; i += 3)
    {
        verts[i + 0] = (Math.random() - 0.5);
        verts[i + 1] = (Math.random() - 0.5);
        verts[i + 2] = (Math.random() - 0.5);
    }

    if (!geom)geom = new CGL.Geometry(op.name);
    geom.setPointVertices(verts);

    if (!mesh)
    {
        mesh = new CGL.Mesh(cgl, geom, cgl.gl.POINTS);

        mesh.addVertexNumbers = true;
        mesh._verticesNumbers = null;

        op.log("NEW MESH");
    }
    else
    {
        mesh.unBind();
    }
    mesh.setGeom(geom);

    const rndArray = new Float32Array(num);

    let spread = inSpread.get();
    if (spread < 0)spread = 0;

    for (i = 0; i < num / 3; i++)
    {
        let v = getRandomVec(spread);
        while (vec3.len(v) > spread / 2) v = getRandomVec(spread);

        rndArray[i * 3 + 0] = v[0];
        rndArray[i * 3 + 1] = v[1];
        rndArray[i * 3 + 2] = v[2];
    }
    rndArray[i] = (Math.random() - 0.5) * spread;

    mesh.setAttribute("rndPos", rndArray, 3);

    // offset random

    var rndOffset = new Float32Array(num / 3);
    for (i = 0; i < num / 3; i++)
        rndOffset[i] = (Math.random()) * inLength.get();

    mesh.setAttribute("rndOffset", rndOffset, 1);

    // speed random

    var rndOffset = new Float32Array(num / 3);
    for (i = 0; i < num / 3; i++)
        rndOffset[i] = (Math.random()) * inLength.get();

    mesh.setAttribute("rndOffset", rndOffset, 1);
    updateDefines();
}

mod.define("PATHFOLLOW_POINTS", 1);

function updateDefines()
{
    mod.toggleDefine("CHECK_DISTANCE", inMaxDistance.get() != 0);
    mod.toggleDefine("RANDOMSPEED", inRandomSpeed);
}

exec.onTriggered = function ()
{
    if (op.patch.isEditorMode())
    {
        if (cgl.getShader().glPrimitive != cgl.gl.POINTS) op.setUiError("nopointmat", "Using a Material not made for point rendering. Try to use PointMaterial.");
        else op.setUiError("nopointmat", null);
    }

    if (!inPoints.get() || inPoints.get().length === 0) return;
    if (needsRebuild)rebuild();

    mod.bind();

    if (inPoints.get())
        mod.define("PATHFOLLOW_POINTS", Math.floor(inPoints.get().length / 3));
    else mod.define("PATHFOLLOW_POINTS", 0);

    if (mesh) mesh.render(cgl.getShader());

    next.trigger();
    mod.unbind();
};


};

Ops.Gl.Matrix.ArrayPathFollowParticles_v2.prototype = new CABLES.Op();
CABLES.OPS["12a48cb2-a528-4498-8cda-18535af08f4a"]={f:Ops.Gl.Matrix.ArrayPathFollowParticles_v2,objName:"Ops.Gl.Matrix.ArrayPathFollowParticles_v2"};




// **************************************************************
// 
// Ops.Gl.Matrix.ArrayTranslate
// 
// **************************************************************

Ops.Gl.Matrix.ArrayTranslate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    arrayIn = op.inArray("array"),
    trigger = op.outTrigger("trigger"),
    idx = op.addOutPort(new CABLES.Port(op, "index"));

const cgl = op.patch.cgl;
let vec = vec3.create();
exe.onTriggered = render;

function render()
{
    if (!arrayIn.get()) return;
    let arr = arrayIn.get();

    for (let i = 0; i < arr.length; i += 3)
    {
        vec3.set(vec, arr[i], arr[i + 1], arr[i + 2]);
        cgl.pushModelMatrix();
        mat4.translate(cgl.mMatrix, cgl.mMatrix, vec);
        trigger.trigger();
        cgl.popModelMatrix();
    }
}


};

Ops.Gl.Matrix.ArrayTranslate.prototype = new CABLES.Op();
CABLES.OPS["1371bc89-b4ac-4032-86e1-70ff2506665b"]={f:Ops.Gl.Matrix.ArrayTranslate,objName:"Ops.Gl.Matrix.ArrayTranslate"};




// **************************************************************
// 
// Ops.Gl.Matrix.Billboard
// 
// **************************************************************

Ops.Gl.Matrix.Billboard = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exec = op.inTrigger("Exec");
const next = op.outTrigger("Next");

const cgl = op.patch.cgl;

let mm = mat4.create();
let mv = mat4.create();
let m = mat4.create();
let mempty = mat4.create();

exec.onTriggered = function ()
{
    mat4.invert(mm, cgl.mMatrix);
    mat4.invert(mv, cgl.vMatrix);

    mat4.mul(mm, mm, mv);

    mm[12] = 0;
    mm[13] = 0;
    mm[14] = 0;

    cgl.pushModelMatrix();
    cgl.pushViewMatrix();
    mat4.mul(cgl.mMatrix, cgl.mMatrix, mm);
    next.trigger();
    cgl.popViewMatrix();
    cgl.popModelMatrix();
};


};

Ops.Gl.Matrix.Billboard.prototype = new CABLES.Op();
CABLES.OPS["d41e676e-d8a7-4a1e-8abf-f1bddfc982d5"]={f:Ops.Gl.Matrix.Billboard,objName:"Ops.Gl.Matrix.Billboard"};




// **************************************************************
// 
// Ops.Gl.Matrix.Camera
// 
// **************************************************************

Ops.Gl.Matrix.Camera = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");

/* Inputs */
// projection | prespective & ortogonal
const projectionMode = op.inValueSelect("projection mode", ["prespective", "ortogonal"], "prespective");
const zNear = op.inValue("frustum near", 0.01);
const zFar = op.inValue("frustum far", 5000.0);

const fov = op.inValue("fov", 45);
const autoAspect = op.inValueBool("Auto Aspect Ratio", true);
const aspect = op.inValue("Aspect Ratio", 1);

// look at camera
const eyeX = op.inValue("eye X", 0);
const eyeY = op.inValue("eye Y", 0);
const eyeZ = op.inValue("eye Z", 5);

const centerX = op.inValue("center X", 0);
const centerY = op.inValue("center Y", 0);
const centerZ = op.inValue("center Z", 0);

// camera transform and movements
const posX = op.inValue("truck", 0);
const posY = op.inValue("boom", 0);
const posZ = op.inValue("dolly", 0);

const rotX = op.inValue("tilt", 0);
const rotY = op.inValue("pan", 0);
const rotZ = op.inValue("roll", 0);

/* Outputs */
const outAsp = op.outNumber("Aspect");
const outArr = op.outArray("Look At Array");

/* logic */
const cgl = op.patch.cgl;

let asp = 0;

const vUp = vec3.create();
const vEye = vec3.create();
const vCenter = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

const arr = [];

// Transform and move
const vPos = vec3.create();
const transMatrixMove = mat4.create();
mat4.identity(transMatrixMove);

let updateCameraMovementMatrix = true;

render.onTriggered = function ()
{
    if (cgl.frameStore.shadowPass) return trigger.trigger();

    // Aspect ration
    if (!autoAspect.get()) asp = aspect.get();
    else asp = cgl.getViewPort()[2] / cgl.getViewPort()[3];
    outAsp.set(asp);

    // translation (truck, boom, dolly)
    cgl.pushViewMatrix();

    if (updateCameraMovementMatrix)
    {
        mat4.identity(transMatrixMove);

        vec3.set(vPos, posX.get(), posY.get(), posZ.get());
        if (posX.get() !== 0.0 || posY.get() !== 0.0 || posZ.get() !== 0.0)
            mat4.translate(transMatrixMove, transMatrixMove, vPos);

        if (rotX.get() !== 0)
            mat4.rotateX(transMatrixMove, transMatrixMove, rotX.get() * CGL.DEG2RAD);
        if (rotY.get() !== 0)
            mat4.rotateY(transMatrixMove, transMatrixMove, rotY.get() * CGL.DEG2RAD);
        if (rotZ.get() !== 0)
            mat4.rotateZ(transMatrixMove, transMatrixMove, rotZ.get() * CGL.DEG2RAD);

        updateCameraMovementMatrix = false;
    }

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrixMove);

    // projection (prespective / ortogonal)
    cgl.pushPMatrix();

    // look at
    cgl.pushViewMatrix();

    if (projectionMode.get() == "prespective")
    {
        mat4.perspective(
            cgl.pMatrix,
            fov.get() * 0.0174533,
            asp,
            zNear.get(),
            zFar.get()
        );
    }
    else if (projectionMode.get() == "ortogonal")
    {
        mat4.ortho(
            cgl.pMatrix,
            -1 * (fov.get() / 14),
            1 * (fov.get() / 14),
            -1 * (fov.get() / 14) / asp,
            1 * (fov.get() / 14) / asp,
            zNear.get(),
            zFar.get()
        );
    }

    arr[0] = eyeX.get();
    arr[1] = eyeY.get();
    arr[2] = eyeZ.get();

    arr[3] = centerX.get();
    arr[4] = centerY.get();
    arr[5] = centerZ.get();

    arr[6] = 0;
    arr[7] = 1;
    arr[8] = 0;

    outArr.set(null);
    outArr.set(arr);

    vec3.set(vUp, 0, 1, 0);
    vec3.set(vEye, eyeX.get(), eyeY.get(), eyeZ.get());
    vec3.set(vCenter, centerX.get(), centerY.get(), centerZ.get());

    mat4.lookAt(transMatrix, vEye, vCenter, vUp);

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrix);

    trigger.trigger();

    cgl.popViewMatrix();
    cgl.popPMatrix();

    cgl.popViewMatrix();

    // GUI for dolly, boom and truck
    if (op.isCurrentUiOp())
        gui.setTransformGizmo({
            "posX": posX,
            "posY": posY,
            "posZ": posZ
        });
};

const updateUI = function ()
{
    if (!autoAspect.get())
    {
        aspect.setUiAttribs({ "greyout": false });
    }
    else
    {
        aspect.setUiAttribs({ "greyout": true });
    }
};

const cameraMovementChanged = function ()
{
    updateCameraMovementMatrix = true;
};

// listeners
posX.onChange = cameraMovementChanged;
posY.onChange = cameraMovementChanged;
posZ.onChange = cameraMovementChanged;

rotX.onChange = cameraMovementChanged;
rotY.onChange = cameraMovementChanged;
rotZ.onChange = cameraMovementChanged;

autoAspect.onChange = updateUI;
updateUI();


};

Ops.Gl.Matrix.Camera.prototype = new CABLES.Op();
CABLES.OPS["b24dbfdc-485c-49d2-92a1-7258efd9239a"]={f:Ops.Gl.Matrix.Camera,objName:"Ops.Gl.Matrix.Camera"};




// **************************************************************
// 
// Ops.Gl.Matrix.CameraInfo
// 
// **************************************************************

Ops.Gl.Matrix.CameraInfo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    cameraType = op.inSwitch("Camera Type", ["Perspective", "Orthographic"], "Perspective"),
    trigger = op.outTrigger("trigger"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z"),
    outRightX = op.outNumber("Right X"),
    outRightY = op.outNumber("Right Y"),
    outRightZ = op.outNumber("Right Z"),
    outUpX = op.outNumber("Up X"),
    outUpY = op.outNumber("Up Y"),
    outUpZ = op.outNumber("Up Z"),
    outForwardX = op.outNumber("Forward X"),
    outForwardY = op.outNumber("Forward Y"),
    outForwardZ = op.outNumber("Forward Z"),
    outNear = op.outNumber("Near Frustum"),
    outFar = op.outNumber("Far Frustum"),
    outTop = op.outNumber("Bottom Frustum"),
    outBottom = op.outNumber("Top Frustum"),
    outLeft = op.outNumber("Left Frustum"),
    outRight = op.outNumber("Right Frustum"),
    outFov = op.outNumber("FOV"),
    outAspect = op.outNumber("Aspect Ratio");
const
    cgl = op.patch.cgl,
    pos = vec3.create(),
    identVec = vec3.create(),
    iViewMatrix = mat4.create();
render.onTriggered = update;

function update()
{
    mat4.invert(iViewMatrix, cgl.vMatrix);

    outRightX.set(iViewMatrix[0]);
    outRightY.set(iViewMatrix[1]);
    outRightZ.set(iViewMatrix[2]);

    outUpX.set(iViewMatrix[4]);
    outUpY.set(iViewMatrix[5]);
    outUpZ.set(iViewMatrix[6]);

    outForwardX.set(iViewMatrix[8]);
    outForwardY.set(iViewMatrix[9]);
    outForwardZ.set(iViewMatrix[10]);

    outX.set(iViewMatrix[12]);
    outY.set(iViewMatrix[13]);
    outZ.set(iViewMatrix[14]);

    // https://stackoverflow.com/questions/10830293/decompose-projection-matrix44-to-left-right-bottom-top-near-and-far-boundary/10836497#10836497
    const m11 = cgl.pMatrix[4 * 0 + 0];
    const m13 = cgl.pMatrix[4 * 2 + 0];
    const m14 = cgl.pMatrix[4 * 3 + 0];
    const m22 = cgl.pMatrix[4 * 1 + 1];
    const m23 = cgl.pMatrix[4 * 2 + 1];
    const m24 = cgl.pMatrix[4 * 3 + 1];
    const m33 = cgl.pMatrix[4 * 2 + 2];
    const m34 = cgl.pMatrix[4 * 3 + 2];

    // https://stackoverflow.com/questions/46182845/field-of-view-aspect-ratio-view-matrix-from-projection-matrix-hmd-ost-calib
    const FOV = 2 * Math.atan(1 / m22) * 180 / Math.PI;
    const aspectRatio = m22 / m11;

    outFov.set(FOV);
    outAspect.set(aspectRatio);
    if (cameraType.get() === "Perspective")
    {
        const near = m34 / (m33 - 1);
        const far = m34 / (m33 + 1);
        const top = near * (m23 + 1) / m22;
        const bottom = near * (m23 - 1) / m22;
        const left = near * (m13 - 1) / m11;
        const right = near * (m13 + 1) / m11;

        outNear.set(near);
        outFar.set(far);
        outTop.set(top);
        outBottom.set(bottom);
        outLeft.set(left);
        outRight.set(right);
    }
    else if (cameraType.get() === "Orthographic")
    {
        const near = (1 + m34) / m33;
        const far = -(1 - m34) / m33;
        const bottom = near * (m23 - 1) / m22;
        const top = near * (m23 + 1) / m22;
        const left = near * (m13 - 1) / m11;
        const right = near * (m13 + 1) / m11;

        outNear.set(near);
        outFar.set(far);
        outTop.set(top);
        outBottom.set(bottom);
        outLeft.set(left);
        outRight.set(right);
    }

    trigger.trigger();
}


};

Ops.Gl.Matrix.CameraInfo.prototype = new CABLES.Op();
CABLES.OPS["92a0c536-f2bf-4972-9f02-a9accf26c1df"]={f:Ops.Gl.Matrix.CameraInfo,objName:"Ops.Gl.Matrix.CameraInfo"};




// **************************************************************
// 
// Ops.Gl.Matrix.CameraPosition
// 
// **************************************************************

Ops.Gl.Matrix.CameraPosition = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z");

const
    cgl = op.patch.cgl,
    pos = vec3.create(),
    identVec = vec3.create(),
    iViewMatrix = mat4.create();

render.onTriggered = update;

function update()
{
    mat4.invert(iViewMatrix, cgl.vMatrix);
    vec3.transformMat4(pos, identVec, iViewMatrix);

    outX.set(pos[0]);
    outY.set(pos[1]);
    outZ.set(pos[2]);

    trigger.trigger();
}


};

Ops.Gl.Matrix.CameraPosition.prototype = new CABLES.Op();
CABLES.OPS["eff9a971-d9dd-4999-94b1-9a5cbba13581"]={f:Ops.Gl.Matrix.CameraPosition,objName:"Ops.Gl.Matrix.CameraPosition"};




// **************************************************************
// 
// Ops.Gl.Matrix.Coordinates
// 
// **************************************************************

Ops.Gl.Matrix.Coordinates = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z"),
    pos = vec3.create(),
    empty = vec3.create();

render.onTriggered = function ()
{
    const cg = op.patch.cg;

    vec3.transformMat4(pos, empty, cg.mMatrix);

    outX.set(pos[0]);
    outY.set(pos[1]);
    outZ.set(pos[2]);

    trigger.trigger();
};


};

Ops.Gl.Matrix.Coordinates.prototype = new CABLES.Op();
CABLES.OPS["390d0214-92a9-48e9-85b4-f3092ee9e043"]={f:Ops.Gl.Matrix.Coordinates,objName:"Ops.Gl.Matrix.Coordinates"};




// **************************************************************
// 
// Ops.Gl.Matrix.DeviceOrientationCamera
// 
// **************************************************************

Ops.Gl.Matrix.DeviceOrientationCamera = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    next = op.outTrigger("Next"),
    winOrient = op.outNumber("Window Orientation"),
    cgl = op.patch.cgl,
    vCenter = vec3.create(),
    transMatrix = mat4.create(),
    displayOrientQuat = quat.create(),
    displayOrientMatrix = mat4.create();

window.addEventListener("deviceorientation", onOrientationChange, true);
let tempQuat = quat.create();
mat4.identity(transMatrix);

const viewDirQuat = quat.create();

render.onTriggered = function ()
{
    // check for new permission request on IOS or android
    if (DeviceMotionEvent && DeviceMotionEvent.requestPermission)
    {
        DeviceOrientationEvent.requestPermission()
            .then((response) =>
            {
                if (response == "granted")
                {
                    window.addEventListener("deviceorientation", onOrientationChange, true);
                }
            })
            .catch(op.error);
    }
    else
    {
        window.addEventListener("deviceorientation", onOrientationChange, true);
    }

    if (window.orientation === undefined)
    {
        next.trigger();
        return;
    }

    cgl.pushViewMatrix();

    tempQuat = quat.clone(viewDirQuat);
    quat.invert(tempQuat, tempQuat);

    if (window.orientation == 90 || window.orientation == -90)
    {
        quat.setAxisAngle(displayOrientQuat, [0, 0, 1], window.orientation * CGL.DEG2RAD);
        quat.multiply(tempQuat, displayOrientQuat, tempQuat);
    }

    mat4.fromQuat(transMatrix, tempQuat);
    // added rotateX by 90 as orientation was incorrect
    mat4.rotateX(transMatrix, transMatrix, 90.0 * CGL.DEG2RAD);
    mat4.rotateY(transMatrix, transMatrix, 90.0 * CGL.DEG2RAD);
    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrix);

    // mat4.translate(cgl.vMatrix,cgl.vMatrix,[1,0,0]);//original code

    next.trigger();
    cgl.popViewMatrix();
};

// frp, http://asterixcreative.com/blog/mobile-gyroscope-with-javascript-and-quaternions-programming-tutorial-part-1/
function quatFromEuler(quat, alpha, beta, gamma)
{
    const x = CGL.DEG2RAD * beta;
    const y = CGL.DEG2RAD * gamma;
    const z = CGL.DEG2RAD * alpha;

    const cX = Math.cos(x / 2);
    const cY = Math.cos(y / 2);
    const cZ = Math.cos(z / 2);
    const sX = Math.sin(x / 2);
    const sY = Math.sin(y / 2);
    const sZ = Math.sin(z / 2);

    quat[0] = sX * cY * cZ - cX * sY * sZ;
    quat[1] = cX * sY * cZ + sX * cY * sZ;
    quat[2] = cX * cY * sZ + sX * sY * cZ;
    quat[3] = cX * cY * cZ - sX * sY * sZ;

    return quat;
}

function onOrientationChange(event)
{
    const alpha = (event.alpha || 0);
    const beta = (event.beta || 0);
    const gamma = (event.gamma || 0);

    winOrient.set(window.orientation || 0);
    quatFromEuler(viewDirQuat, alpha, beta, gamma);
}


};

Ops.Gl.Matrix.DeviceOrientationCamera.prototype = new CABLES.Op();
CABLES.OPS["c213a5b4-6a47-425a-9457-ae0b14c88e9a"]={f:Ops.Gl.Matrix.DeviceOrientationCamera,objName:"Ops.Gl.Matrix.DeviceOrientationCamera"};




// **************************************************************
// 
// Ops.Gl.Matrix.GetMatrixScaling
// 
// **************************************************************

Ops.Gl.Matrix.GetMatrixScaling = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    inArr = op.inArray("Matrix"),
    trigger = op.outTrigger("trigger"),
    outX = op.outNumber("Scaling");

const cgl = op.patch.cgl;
const pos = vec3.create();
const identVec = vec3.create();
const iViewMatrix = mat4.create();

function getScaling(mat)
{
    let m31 = mat[8];
    let m32 = mat[9];
    let m33 = mat[10];

    return Math.hypot(m31, m32, m33);
}

render.onTriggered = function ()
{
    if (!inArr.get()) return;

    outX.set(getScaling(cgl.mMatrix));

    trigger.trigger();
};


};

Ops.Gl.Matrix.GetMatrixScaling.prototype = new CABLES.Op();
CABLES.OPS["3bcc8ae2-0837-4560-90dc-ae7836ee9db0"]={f:Ops.Gl.Matrix.GetMatrixScaling,objName:"Ops.Gl.Matrix.GetMatrixScaling"};




// **************************************************************
// 
// Ops.Gl.Matrix.GetModelMatrix
// 
// **************************************************************

Ops.Gl.Matrix.GetModelMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    matrix = op.outArray("matrix");

const m = mat4.create();

render.onTriggered = function ()
{
    mat4.copy(m, op.patch.cg.mMatrix);
    matrix.set(null);
    matrix.set(m);
    trigger.trigger();
};

matrix.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);


};

Ops.Gl.Matrix.GetModelMatrix.prototype = new CABLES.Op();
CABLES.OPS["2d96f0a3-979a-4dc3-8c49-848f08efe0e0"]={f:Ops.Gl.Matrix.GetModelMatrix,objName:"Ops.Gl.Matrix.GetModelMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.GetProjectonMatrix
// 
// **************************************************************

Ops.Gl.Matrix.GetProjectonMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    cgl = op.patch.cgl,
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    matrix = op.outArray("matrix", null, 16);

let m = mat4.create();
mat4.identity(m);
matrix.set(m);

render.onTriggered = function ()
{
    mat4.copy(m, cgl.pMatrix);
    matrix.set(null);
    matrix.set(m);
    trigger.trigger();
};


};

Ops.Gl.Matrix.GetProjectonMatrix.prototype = new CABLES.Op();
CABLES.OPS["3f048006-89e9-4e3f-a7d3-42aaa77ed630"]={f:Ops.Gl.Matrix.GetProjectonMatrix,objName:"Ops.Gl.Matrix.GetProjectonMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.GetViewMatrix
// 
// **************************************************************

Ops.Gl.Matrix.GetViewMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let render = op.inTrigger("render");
let trigger = op.outTrigger("trigger");
let matrix = op.addOutPort(new CABLES.Port(op, "matrix", CABLES.OP_PORT_TYPE_ARRAY));

let m = mat4.create();

render.onTriggered = function ()
{
    mat4.copy(m, op.patch.cg.vMatrix);
    matrix.set(null);
    matrix.set(m);
    trigger.trigger();
};

matrix.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);


};

Ops.Gl.Matrix.GetViewMatrix.prototype = new CABLES.Op();
CABLES.OPS["a58406ae-79b5-4dab-99fa-0a66c2325aab"]={f:Ops.Gl.Matrix.GetViewMatrix,objName:"Ops.Gl.Matrix.GetViewMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.InterpolateMatrix
// 
// **************************************************************

Ops.Gl.Matrix.InterpolateMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("Exe");
const inArr1 = op.inArray("Array 1");
const inArr2 = op.inArray("Array 2");
const inPerc = op.inValueSlider("perc");
const next = op.outTrigger("Next");
const outArr = op.outArray("Result");

const result = mat4.create();

function ip(val1, val2, perc)
{
    return ((val2 - val1) * perc + val1);
}

const a = vec3.create();
const b = vec3.create();

exe.onTriggered = function ()
{
    const arr1 = inArr1.get();
    const arr2 = inArr2.get();

    if (!arr1 || !arr2 || arr1.length != arr2.length)
    {
        outArr.set(null);
        op.logError("arrays wrong");
    }
    else
    {
        getYPR(a, arr1);
        getYPR(b, arr2);

        const perc = inPerc.get();

        mat4.identity(result);
        result[12] = ip(arr1[12], arr2[12], perc);
        result[13] = ip(arr1[13], arr2[13], perc);
        result[14] = ip(arr1[14], arr2[14], perc);

        vec3.lerp(a, a, b, perc);

        mat4.rotateZ(result, result, a[2]);
        mat4.rotateY(result, result, a[1]);
        mat4.rotateX(result, result, a[0]);

        outArr.set(null);
        outArr.set(result);
    }
    next.trigger();
};

// 0  1  2  3
// 4  5  6  7
// 8  9  10 11
// 12 13 14 15

function getYPR(v, m)
{
    const r1 = Math.atan2(m[6], m[10]);
    const c2 = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
    const r2 = Math.atan2(-m[2], c2);
    const s1 = Math.sin(r1);
    const c1 = Math.cos(r1);
    const r3 = Math.atan2(s1 * m[8] - c1 * m[4], c1 * m[5] - s1 * m[9]);

    v[0] = r1;
    v[1] = r2;
    v[2] = r3;
    return v;
}


};

Ops.Gl.Matrix.InterpolateMatrix.prototype = new CABLES.Op();
CABLES.OPS["84e1908b-fc17-47db-9ba1-bc38d7809076"]={f:Ops.Gl.Matrix.InterpolateMatrix,objName:"Ops.Gl.Matrix.InterpolateMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.InvertMatrix
// 
// **************************************************************

Ops.Gl.Matrix.InvertMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inMat = op.inArray("Matrix"),
    outMat = op.outArray("Result");

const m = mat4.create();

inMat.onChange = () =>
{
    if (!inMat.get()) return;
    mat4.invert(m, inMat.get());
    outMat.set(null);
    outMat.set(m);
};


};

Ops.Gl.Matrix.InvertMatrix.prototype = new CABLES.Op();
CABLES.OPS["2ebd0d87-f67a-4101-bdf0-283c610b095a"]={f:Ops.Gl.Matrix.InvertMatrix,objName:"Ops.Gl.Matrix.InvertMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.LookatCamera
// 
// **************************************************************

Ops.Gl.Matrix.LookatCamera = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");

const eyeX = op.inValueFloat("eyeX");
const eyeY = op.inValueFloat("eyeY");
const eyeZ = op.inValueFloat("eyeZ");

const centerX = op.inValueFloat("centerX");
const centerY = op.inValueFloat("centerY");
const centerZ = op.inValueFloat("centerZ");

const vecUpX = op.inValueFloat("upX");
const vecUpY = op.inValueFloat("upY");
const vecUpZ = op.inValueFloat("upZ");

const outArr = op.outArray("Array");

centerX.set(0);
centerY.set(0);
centerZ.set(0);

eyeX.set(5);
eyeY.set(5);
eyeZ.set(5);

vecUpX.set(0);
vecUpY.set(1);
vecUpZ.set(0);

const cgl = op.patch.cgl;
const vUp = vec3.create();
const vEye = vec3.create();
const vCenter = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

const arr = [];


render.onTriggered = function ()
{
    if (cgl.frameStore.shadowPass) return trigger.trigger();


    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": eyeX,
                "posY": eyeY,
                "posZ": eyeZ
            });


    cgl.pushViewMatrix();

    arr[0] = eyeX.get();
    arr[1] = eyeY.get();
    arr[2] = eyeZ.get();

    arr[3] = centerX.get();
    arr[4] = centerY.get();
    arr[5] = centerZ.get();

    arr[6] = vecUpX.get();
    arr[7] = vecUpY.get();
    arr[8] = vecUpZ.get();
    outArr.set(null);
    outArr.set(arr);

    vec3.set(vUp, vecUpX.get(), vecUpY.get(), vecUpZ.get());
    vec3.set(vEye, eyeX.get(), eyeY.get(), eyeZ.get());
    vec3.set(vCenter, centerX.get(), centerY.get(), centerZ.get());

    mat4.lookAt(transMatrix, vEye, vCenter, vUp);

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrix);

    trigger.trigger();
    cgl.popViewMatrix();
};


};

Ops.Gl.Matrix.LookatCamera.prototype = new CABLES.Op();
CABLES.OPS["e0f1bad6-7dfb-4665-b458-ca50a1bfe7fa"]={f:Ops.Gl.Matrix.LookatCamera,objName:"Ops.Gl.Matrix.LookatCamera"};




// **************************************************************
// 
// Ops.Gl.Matrix.MatrixTranslation
// 
// **************************************************************

Ops.Gl.Matrix.MatrixTranslation = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    inArr = op.inArray("Matrix"),
    trigger = op.outTrigger("trigger"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z");

const cgl = op.patch.cgl;
const pos = vec3.create();
const identVec = vec3.create();
const iViewMatrix = mat4.create();

render.onTriggered = function ()
{
    if (!inArr.get()) return;

    mat4.invert(iViewMatrix, inArr.get());
    vec3.transformMat4(pos, identVec, iViewMatrix);

    outX.set(pos[0]);
    outY.set(pos[1]);
    outZ.set(pos[2]);

    trigger.trigger();
};


};

Ops.Gl.Matrix.MatrixTranslation.prototype = new CABLES.Op();
CABLES.OPS["d5ba91a4-d419-4805-b37f-595c261615b3"]={f:Ops.Gl.Matrix.MatrixTranslation,objName:"Ops.Gl.Matrix.MatrixTranslation"};




// **************************************************************
// 
// Ops.Gl.Matrix.MulViewMatrix
// 
// **************************************************************

Ops.Gl.Matrix.MulViewMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    matrix = op.inArray("matrix"),
    inIdentity = op.inValueBool("Identity", false),
    trigger = op.outTrigger("trigger");

const m = mat4.create();
const cgl = this.patch.cgl;

matrix.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

render.onTriggered = function ()
{
    cgl.pushViewMatrix();

    if (matrix.get())
    {
        if (inIdentity.get()) mat4.identity(cgl.vMatrix);

        mat4.multiply(cgl.vMatrix, cgl.vMatrix, matrix.get());
    }

    trigger.trigger();
    cgl.popViewMatrix();
};


};

Ops.Gl.Matrix.MulViewMatrix.prototype = new CABLES.Op();
CABLES.OPS["c2833486-717e-4f3c-9dd8-c62cc92ea46e"]={f:Ops.Gl.Matrix.MulViewMatrix,objName:"Ops.Gl.Matrix.MulViewMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.MultiplyModelMatrix
// 
// **************************************************************

Ops.Gl.Matrix.MultiplyModelMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let cgl = op.patch.cgl;
let render = op.inTrigger("render");
let inIdentity = op.inValueBool("Identity", false);
let next = op.outTrigger("trigger");

let m = mat4.create();
let matrix = op.inArray("matrix");

render.onTriggered = function ()
{
    cgl.pushModelMatrix();

    if (inIdentity.get()) mat4.identity(cgl.mMatrix);

    const m = matrix.get();

    if (m) mat4.multiply(cgl.mMatrix, cgl.mMatrix, m);

    next.trigger();
    cgl.popModelMatrix();
};

matrix.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);


};

Ops.Gl.Matrix.MultiplyModelMatrix.prototype = new CABLES.Op();
CABLES.OPS["ec2784ab-9174-4052-894b-744a18e0d348"]={f:Ops.Gl.Matrix.MultiplyModelMatrix,objName:"Ops.Gl.Matrix.MultiplyModelMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.OrbitControls
// 
// **************************************************************

Ops.Gl.Matrix.OrbitControls = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    minDist = op.inValueFloat("min distance"),
    maxDist = op.inValueFloat("max distance"),

    minRotY = op.inValue("min rot y", 0),
    maxRotY = op.inValue("max rot y", 0),

    initialRadius = op.inValue("initial radius", 0),
    initialAxis = op.inValueSlider("initial axis y"),
    initialX = op.inValueSlider("initial axis x"),

    mul = op.inValueFloat("mul"),
    smoothness = op.inValueSlider("Smoothness", 1.0),
    speedX = op.inValue("Speed X", 1),
    speedY = op.inValue("Speed Y", 1),

    active = op.inValueBool("Active", true),

    allowPanning = op.inValueBool("Allow Panning", true),
    allowZooming = op.inValueBool("Allow Zooming", true),
    allowRotation = op.inValueBool("Allow Rotation", true),
    restricted = op.inValueBool("restricted", true),

    trigger = op.outTrigger("trigger"),
    outRadius = op.outNumber("radius"),
    outXDeg = op.outNumber("Rot X"),
    outYDeg = op.outNumber("Rot Y"),

    inReset = op.inTriggerButton("Reset");

op.setPortGroup("Initial Values", [initialAxis, initialX, initialRadius]);
op.setPortGroup("Interaction", [mul, smoothness, speedX, speedY]);
op.setPortGroup("Boundaries", [minRotY, maxRotY, minDist, maxDist]);

mul.set(1);
minDist.set(0.05);
maxDist.set(99999);

inReset.onTriggered = reset;

let eye = vec3.create();
const vUp = vec3.create();
const vCenter = vec3.create();
const viewMatrix = mat4.create();
const tempViewMatrix = mat4.create();
const vOffset = vec3.create();
const finalEyeAbs = vec3.create();

initialAxis.set(0.5);

let mouseDown = false;
let radius = 5;
outRadius.set(radius);

let lastMouseX = 0, lastMouseY = 0;
let percX = 0, percY = 0;

vec3.set(vCenter, 0, 0, 0);
vec3.set(vUp, 0, 1, 0);

const tempEye = vec3.create();
const finalEye = vec3.create();
const tempCenter = vec3.create();
const finalCenter = vec3.create();

let px = 0;
let py = 0;

let divisor = 1;
let element = null;
updateSmoothness();

op.onDelete = unbind;

const halfCircle = Math.PI;
const fullCircle = Math.PI * 2;

function reset()
{
    let off = 0;

    if (px % fullCircle < -halfCircle)
    {
        off = -fullCircle;
        px %= -fullCircle;
    }
    else
    if (px % fullCircle > halfCircle)
    {
        off = fullCircle;
        px %= fullCircle;
    }
    else px %= fullCircle;

    py %= (Math.PI);

    vec3.set(vOffset, 0, 0, 0);
    vec3.set(vCenter, 0, 0, 0);
    vec3.set(vUp, 0, 1, 0);

    percX = (initialX.get() * Math.PI * 2 + off);
    percY = (initialAxis.get() - 0.5);

    radius = initialRadius.get();
    eye = circlePos(percY);
}

function updateSmoothness()
{
    divisor = smoothness.get() * 10 + 1.0;
}

smoothness.onChange = updateSmoothness;

let initializing = true;

function ip(val, goal)
{
    if (initializing) return goal;
    return val + (goal - val) / divisor;
}

let lastPy = 0;
const lastPx = 0;

render.onTriggered = function ()
{
    const cgl = op.patch.cg;

    if (!element)
    {
        setElement(cgl.canvas);
        bind();
    }

    cgl.pushViewMatrix();

    px = ip(px, percX);
    py = ip(py, percY);

    let degY = (py + 0.5) * 180;

    if (minRotY.get() !== 0 && degY < minRotY.get())
    {
        degY = minRotY.get();
        py = lastPy;
    }
    else if (maxRotY.get() !== 0 && degY > maxRotY.get())
    {
        degY = maxRotY.get();
        py = lastPy;
    }
    else
    {
        lastPy = py;
    }

    const degX = (px) * CGL.RAD2DEG;

    outYDeg.set(degY);
    outXDeg.set(degX);

    circlePosi(eye, py);

    vec3.add(tempEye, eye, vOffset);
    vec3.add(tempCenter, vCenter, vOffset);

    finalEye[0] = ip(finalEye[0], tempEye[0]);
    finalEye[1] = ip(finalEye[1], tempEye[1]);
    finalEye[2] = ip(finalEye[2], tempEye[2]);

    finalCenter[0] = ip(finalCenter[0], tempCenter[0]);
    finalCenter[1] = ip(finalCenter[1], tempCenter[1]);
    finalCenter[2] = ip(finalCenter[2], tempCenter[2]);

    const empty = vec3.create();

    mat4.lookAt(viewMatrix, finalEye, finalCenter, vUp);
    mat4.rotate(viewMatrix, viewMatrix, px, vUp);

    // finaly multiply current scene viewmatrix
    mat4.multiply(cgl.vMatrix, cgl.vMatrix, viewMatrix);

    trigger.trigger();
    cgl.popViewMatrix();
    initializing = false;
};

function circlePosi(vec, perc)
{
    const mmul = mul.get();
    if (radius < minDist.get() * mmul) radius = minDist.get() * mmul;
    if (radius > maxDist.get() * mmul) radius = maxDist.get() * mmul;

    outRadius.set(radius * mmul);

    let i = 0, degInRad = 0;

    degInRad = 360 * perc / 2 * CGL.DEG2RAD;
    vec3.set(vec,
        Math.cos(degInRad) * radius * mmul,
        Math.sin(degInRad) * radius * mmul,
        0);
    return vec;
}

function circlePos(perc)
{
    const mmul = mul.get();
    if (radius < minDist.get() * mmul)radius = minDist.get() * mmul;
    if (radius > maxDist.get() * mmul)radius = maxDist.get() * mmul;

    outRadius.set(radius * mmul);

    let i = 0, degInRad = 0;
    const vec = vec3.create();
    degInRad = 360 * perc / 2 * CGL.DEG2RAD;
    vec3.set(vec,
        Math.cos(degInRad) * radius * mmul,
        Math.sin(degInRad) * radius * mmul,
        0);
    return vec;
}

function onmousemove(event)
{
    if (!mouseDown) return;

    const x = event.clientX;
    const y = event.clientY;

    let movementX = (x - lastMouseX);
    let movementY = (y - lastMouseY);

    movementX *= speedX.get();
    movementY *= speedY.get();

    if (event.buttons == 2 && allowPanning.get())
    {
        vOffset[2] += movementX * 0.01 * mul.get();
        vOffset[1] += movementY * 0.01 * mul.get();
    }
    else
    if (event.buttons == 4 && allowZooming.get())
    {
        radius += movementY * 0.05;
        eye = circlePos(percY);
    }
    else
    {
        if (allowRotation.get())
        {
            percX += movementX * 0.003;
            percY += movementY * 0.002;

            if (restricted.get())
            {
                if (percY > 0.5)percY = 0.5;
                if (percY < -0.5)percY = -0.5;
            }
        }
    }

    lastMouseX = x;
    lastMouseY = y;
}

function onMouseDown(event)
{
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
    mouseDown = true;

    try { element.setPointerCapture(event.pointerId); }
    catch (e) {}
}

function onMouseUp(e)
{
    mouseDown = false;
    // cgl.canvas.style.cursor='url(/ui/img/rotate.png),pointer';

    try { element.releasePointerCapture(e.pointerId); }
    catch (e) {}
}

function lockChange()
{
    const el = op.patch.cg.canvas;

    if (document.pointerLockElement === el || document.mozPointerLockElement === el || document.webkitPointerLockElement === el)
    {
        document.addEventListener("mousemove", onmousemove, false);
    }
}

function onMouseEnter(e)
{
    // cgl.canvas.style.cursor='url(/ui/img/rotate.png),pointer';
}

initialRadius.onChange = function ()
{
    radius = initialRadius.get();
    reset();
};

initialX.onChange = function ()
{
    px = percX = (initialX.get() * Math.PI * 2);
};

initialAxis.onChange = function ()
{
    py = percY = (initialAxis.get() - 0.5);
    eye = circlePos(percY);
};

const onMouseWheel = function (event)
{
    if (allowZooming.get())
    {
        const delta = CGL.getWheelSpeed(event) * 0.06;
        radius += (parseFloat(delta)) * 1.2;

        eye = circlePos(percY);
    }
};

const ontouchstart = function (event)
{
    if (event.touches && event.touches.length > 0) onMouseDown(event.touches[0]);
};

const ontouchend = function (event)
{
    onMouseUp();
};

const ontouchmove = function (event)
{
    if (event.touches && event.touches.length > 0) onmousemove(event.touches[0]);
};

active.onChange = function ()
{
    if (active.get())bind();
    else unbind();
};

function setElement(ele)
{
    unbind();
    element = ele;
    bind();
}

function bind()
{
    if (!element) return;

    element.addEventListener("pointermove", onmousemove);
    element.addEventListener("pointerdown", onMouseDown);
    element.addEventListener("pointerup", onMouseUp);
    element.addEventListener("pointerleave", onMouseUp);
    element.addEventListener("pointerenter", onMouseEnter);
    element.addEventListener("contextmenu", function (e) { e.preventDefault(); });
    element.addEventListener("wheel", onMouseWheel, { "passive": true });
}

function unbind()
{
    if (!element) return;

    element.removeEventListener("pointermove", onmousemove);
    element.removeEventListener("pointerdown", onMouseDown);
    element.removeEventListener("pointerup", onMouseUp);
    element.removeEventListener("pointerleave", onMouseUp);
    element.removeEventListener("pointerenter", onMouseUp);
    element.removeEventListener("wheel", onMouseWheel);
}

eye = circlePos(0);

initialX.set(0.25);
initialRadius.set(0.05);


};

Ops.Gl.Matrix.OrbitControls.prototype = new CABLES.Op();
CABLES.OPS["eaf4f7ce-08a3-4d1b-b9f4-ebc0b7b1cde1"]={f:Ops.Gl.Matrix.OrbitControls,objName:"Ops.Gl.Matrix.OrbitControls"};




// **************************************************************
// 
// Ops.Gl.Matrix.Quaternion
// 
// **************************************************************

Ops.Gl.Matrix.Quaternion = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    x = op.inValueFloat("x"),
    y = op.inValueFloat("y"),
    z = op.inValueFloat("z"),
    w = op.inValueFloat("w");

let q = quat.create();
let qMat = mat4.create();
let cgl = op.patch.cgl;
render.onTriggered = function ()
{
    if (x.isAnimated())
    {
        let time = op.patch.timer.getTime();
        CABLES.TL.Anim.slerpQuaternion(time, q, x.anim, y.anim, z.anim, w.anim);
    }
    else
    {
        quat.set(q, x.get(), y.get(), z.get(), w.get());
    }
    cgl.pushModelMatrix();

    mat4.fromQuat(qMat, q);
    mat4.multiply(cgl.mMatrix, cgl.mMatrix, qMat);

    trigger.trigger();
    cgl.popModelMatrix();
};


};

Ops.Gl.Matrix.Quaternion.prototype = new CABLES.Op();
CABLES.OPS["e256892f-7f68-4113-9eb8-cd981026ea8b"]={f:Ops.Gl.Matrix.Quaternion,objName:"Ops.Gl.Matrix.Quaternion"};




// **************************************************************
// 
// Ops.Gl.Matrix.QuaternionCamera
// 
// **************************************************************

Ops.Gl.Matrix.QuaternionCamera = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),

    eyeX = op.inValueFloat("eyeX", 5),
    eyeY = op.inValueFloat("eyeY", 5),
    eyeZ = op.inValueFloat("eyeZ", 5),

    quatX = op.inValueFloat("quatX", 0),
    quatY = op.inValueFloat("quatY", 0),
    quatZ = op.inValueFloat("quatZ", 0),
    quatW = op.inValueFloat("quatW", 0),

    vecUpX = op.inValueFloat("upX", 0),
    vecUpY = op.inValueFloat("upY", 1),
    vecUpZ = op.inValueFloat("upZ", 0);

const cgl = op.patch.cgl;
const vUp = vec3.create();
const vEye = vec3.create();
const vCenter = vec3.create();
const vQuat = quat.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);


// arr[i*3+0]=n._animTrans[0].getValue(t);

// arrRot[i*4+3]=n._animRot[3].getValue(t);


const arr = [];

render.onTriggered = function ()
{
    if (cgl.frameStore.shadowPass) return trigger.trigger();

    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": eyeX,
                "posY": eyeY,
                "posZ": eyeZ
            });

    cgl.pushViewMatrix();

    quat.set(vQuat, quatX.get(), quatY.get(), quatZ.get(), quatW.get());

    vec3.set(vUp, vecUpX.get(), vecUpY.get(), vecUpZ.get());
    vec3.set(vEye, eyeX.get(), eyeY.get(), eyeZ.get());

    vec3.set(vCenter, 0, -1, 0);
    vec3.transformQuat(vCenter, vCenter, vQuat);
    vec3.normalize(vCenter, vCenter);
    vec3.add(vCenter, vCenter, vEye);

    mat4.lookAt(transMatrix, vEye, vCenter, vUp);

    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrix);

    trigger.trigger();
    cgl.popViewMatrix();
};


};

Ops.Gl.Matrix.QuaternionCamera.prototype = new CABLES.Op();
CABLES.OPS["7141c048-615e-47b5-9d8b-d0ceaad9bd79"]={f:Ops.Gl.Matrix.QuaternionCamera,objName:"Ops.Gl.Matrix.QuaternionCamera"};




// **************************************************************
// 
// Ops.Gl.Matrix.RandomGridPlacement
// 
// **************************************************************

Ops.Gl.Matrix.RandomGridPlacement = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Exe"),
    maxDepth = op.inValue("max Depth", 4),
    deeper = op.inValueSlider("Possibility"),
    seed = op.inValue("Seed", 1),
    inScale = op.inValueSlider("Scale", 1),
    width = op.inValue("Width", 4),
    height = op.inValue("Height", 3),
    next = op.outTrigger("Next"),
    outIndex = op.outNumber("Index"),
    outDepth = op.outNumber("depth");

const cgl = op.patch.cgl;
let globalScale = 1;
let vPos = vec3.create();
let vScale = vec3.create();
let hhalf = 0;
let whalf = 0;
let index = 0;

function drawSquare(x, y, depth, scale)
{
    let godeeper = Math.seededRandom() > deeper.get() * 0.9;

    if (depth > maxDepth.get())godeeper = false;

    if (godeeper)
    {
        depth++;
        let st = 1 / (depth * depth);

        for (let _x = 0; _x < 2; _x++)
        {
            for (let _y = 0; _y < 2; _y++)
            {
                let xx = _x * scale / 2;
                let yy = _y * scale / 2;

                drawSquare(
                    x + xx - scale / 4,
                    y + yy - scale / 4,
                    depth,
                    scale / 2 * globalScale);
            }
        }
    }
    else
    {
        cgl.pushModelMatrix();
        vec3.set(vScale, scale, scale, scale);
        vec3.set(vPos, x - whalf + 0.5, y - hhalf + 0.5, 0);
        index++;
        outIndex.set(index);
        outDepth.set(depth);

        mat4.translate(cgl.mMatrix, cgl.mMatrix, vPos);
        mat4.scale(cgl.mMatrix, cgl.mMatrix, vScale);
        next.trigger();

        cgl.popModelMatrix();
    }
}

exe.onTriggered = function ()
{
    index = 0;
    Math.randomSeed = seed.get();

    whalf = width.get() / 2;
    hhalf = height.get() / 2;

    globalScale = inScale.get();

    for (let x = 0; x < width.get(); x++)
    {
        for (let y = 0; y < height.get(); y++)
        {
            drawSquare(x, y, 0, globalScale);
            let sc = 1;
        }
    }
};


};

Ops.Gl.Matrix.RandomGridPlacement.prototype = new CABLES.Op();
CABLES.OPS["3353effa-851f-4c0f-bace-ba5e2e82ae49"]={f:Ops.Gl.Matrix.RandomGridPlacement,objName:"Ops.Gl.Matrix.RandomGridPlacement"};




// **************************************************************
// 
// Ops.Gl.Matrix.RandomGridPlacementArrays
// 
// **************************************************************

Ops.Gl.Matrix.RandomGridPlacementArrays = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Exe"),
    maxDepth = op.inValue("max Depth", 4),
    deeper = op.inValueSlider("Possibility", 0.5),
    seed = op.inValue("Seed", 1),
    inScale = op.inValueSlider("Scale", 1),
    width = op.inValue("Width", 4),
    height = op.inValue("Height", 3),
    outPosArr = op.outArray("Positions"),
    outScaleArr = op.outArray("Scalings"),
    outArrayLength = op.outNumber("Array Length"),
    outArrayPoints = op.outNumber("Total Points");

const cgl = op.patch.cgl;
let needsChange = true;
let globalScale = 1;
let vPos = vec3.create();
let vScale = vec3.create();
let hhalf = 0;
let whalf = 0;
let index = 0;
let arrPos = [];
let arrScale = [];

let count = 0;

maxDepth.onChange =
    deeper.onChange =
    seed.onChange =
    inScale.onChange =
    width.onChange =
    height.onChange =
    function ()
    {
        needsChange = true;
    };

function drawSquare(x, y, depth, scale)
{
    let godeeper = Math.seededRandom() > deeper.get() * 0.9;

    if (depth > maxDepth.get())godeeper = false;

    if (godeeper)
    {
        depth++;
        let st = 1 / (depth * depth);

        for (let _x = 0; _x < 2; _x++)
        {
            for (let _y = 0; _y < 2; _y++)
            {
                let xx = _x * scale / 2;
                let yy = _y * scale / 2;

                drawSquare(
                    x + xx - scale / 4,
                    y + yy - scale / 4,
                    depth,
                    scale / 2 * globalScale);
            }
        }
    }
    else
    {
        vec3.set(vScale, scale, scale, scale);
        vec3.set(vPos, x - whalf + 0.5, y - hhalf + 0.5, 0);
        index++;

        arrPos[count * 3 + 0] = vPos[0];
        arrPos[count * 3 + 1] = vPos[1];
        arrPos[count * 3 + 2] = vPos[2];

        arrScale[count * 3 + 0] = vScale[0];
        arrScale[count * 3 + 1] = vScale[1];
        arrScale[count * 3 + 2] = vScale[2];

        count++;
    }
}

exe.onTriggered = function ()
{
    if (!needsChange) return;

    needsChange = false;
    index = 0;
    Math.randomSeed = seed.get();

    whalf = width.get() / 2;
    hhalf = height.get() / 2;

    globalScale = inScale.get();

    arrPos.length = 0;
    arrScale.length = 0;
    count = 0;

    for (let x = 0; x < width.get(); x++)
    {
        for (let y = 0; y < height.get(); y++)
        {
            drawSquare(x, y, 0, globalScale);
            let sc = 1;
        }
    }

    outArrayLength.set(arrPos.length);
    outArrayPoints.set(arrPos.length / 3);

    outPosArr.set(null);
    outPosArr.set(arrPos);
    outScaleArr.set(null);
    outScaleArr.set(arrScale);
};


};

Ops.Gl.Matrix.RandomGridPlacementArrays.prototype = new CABLES.Op();
CABLES.OPS["81f910ec-a11c-4bee-bd63-8ae036632d7d"]={f:Ops.Gl.Matrix.RandomGridPlacementArrays,objName:"Ops.Gl.Matrix.RandomGridPlacementArrays"};




// **************************************************************
// 
// Ops.Gl.Matrix.Scale
// 
// **************************************************************

Ops.Gl.Matrix.Scale = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    scale = op.inValueFloat("scale", 1.0),
    trigger = op.outTrigger("trigger");

const vScale = vec3.create();

scale.onChange = scaleChanged;
scaleChanged();

render.onTriggered = function ()
{
    const cgl = op.patch.cg;
    cgl.pushModelMatrix();
    mat4.scale(cgl.mMatrix, cgl.mMatrix, vScale);
    trigger.trigger();
    cgl.popModelMatrix();
};

function scaleChanged()
{
    const s = scale.get();
    vec3.set(vScale, s, s, s);
}


};

Ops.Gl.Matrix.Scale.prototype = new CABLES.Op();
CABLES.OPS["50e7f565-0cdb-47ca-912b-87c04e2f00e3"]={f:Ops.Gl.Matrix.Scale,objName:"Ops.Gl.Matrix.Scale"};




// **************************************************************
// 
// Ops.Gl.Matrix.ScaleXYZ
// 
// **************************************************************

Ops.Gl.Matrix.ScaleXYZ = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    scaleX = op.inValueFloat("x", 1),
    scaleY = op.inValueFloat("y", 1),
    scaleZ = op.inValueFloat("z", 1),
    trigger = op.outTrigger("trigger");

const vScale = vec3.create();

let hasChanged = true;

scaleX.onChange = scaleY.onChange = scaleZ.onChange = scaleChanged;

scaleChanged();

render.onTriggered = execrender;

function execrender()
{
    const cgl = op.patch.cg || op.patch.cgl;

    if (hasChanged)
    {
        vec3.set(vScale, scaleX.get(), scaleY.get(), scaleZ.get());
        hasChanged = false;
    }

    cgl.pushModelMatrix();
    mat4.scale(cgl.mMatrix, cgl.mMatrix, vScale);
    trigger.trigger();
    cgl.popModelMatrix();
}

function scaleChanged()
{
    hasChanged = true;
}


};

Ops.Gl.Matrix.ScaleXYZ.prototype = new CABLES.Op();
CABLES.OPS["9ba52457-5f0d-4b20-a97c-4ec4856b8e29"]={f:Ops.Gl.Matrix.ScaleXYZ,objName:"Ops.Gl.Matrix.ScaleXYZ"};




// **************************************************************
// 
// Ops.Gl.Matrix.ScaleXYZViewMatrix
// 
// **************************************************************

Ops.Gl.Matrix.ScaleXYZViewMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    scaleX = op.inValueFloat("x", 1),
    scaleY = op.inValueFloat("y", 1),
    scaleZ = op.inValueFloat("z", 1),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
let vScale = vec3.create();
let transMatrix = mat4.create();
mat4.identity(transMatrix);

scaleX.onChange = scaleY.onChange = scaleZ.onChange = scaleChanged;
scaleChanged();

render.onTriggered = exec;

function exec()
{
    cgl.pushViewMatrix();
    mat4.multiply(cgl.vMatrix, cgl.vMatrix, transMatrix);
    trigger.trigger();
    cgl.popViewMatrix();
}

function scaleChanged()
{
    vec3.set(vScale, scaleX.get(), scaleY.get(), scaleZ.get());
    mat4.identity(transMatrix);
    mat4.scale(transMatrix, transMatrix, vScale);
}


};

Ops.Gl.Matrix.ScaleXYZViewMatrix.prototype = new CABLES.Op();
CABLES.OPS["8b1fa9c9-0c4d-41b6-9c4f-8f4b633a9d7f"]={f:Ops.Gl.Matrix.ScaleXYZViewMatrix,objName:"Ops.Gl.Matrix.ScaleXYZViewMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.ScreenCoordinates
// 
// **************************************************************

Ops.Gl.Matrix.ScreenCoordinates = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Execute"),
    inUnit = op.inSwitch("Pixel Unit", ["Display", "CSS"], "Display"),
    trigger = op.outTrigger("Trigger"),
    x = op.outNumber("X"),
    y = op.outNumber("Y"),
    visi = op.outNumber("Visible");

const cgl = op.patch.cgl;
const trans = vec3.create();
const m = mat4.create();
const pos = vec3.create();
const identVec = vec3.create();

let div = Math.randomSeed = 1;
inUnit.onChange = () =>
{
    if (inUnit.get() == "CSS")div = cgl.pixelDensity;
    else div = 1;
};

exec.onTriggered = function ()
{
    mat4.multiply(m, cgl.vMatrix, cgl.mMatrix);
    vec3.transformMat4(pos, identVec, m);

    vec3.transformMat4(trans, pos, cgl.pMatrix);

    const vp = cgl.getViewPort();
    const xp = (trans[0] * vp[2] / 2) + vp[2] / 2;
    const yp = (trans[1] * vp[3] / 2) + vp[3] / 2;

    visi.set(pos[2] < 0.0 && xp > 0 && xp < vp[2] && yp > 0 && yp < vp[3]);

    x.set(xp / div);
    y.set(yp / div);

    trigger.trigger();
};


};

Ops.Gl.Matrix.ScreenCoordinates.prototype = new CABLES.Op();
CABLES.OPS["75cadc63-62bb-4ddd-b519-aa99568a1e6b"]={f:Ops.Gl.Matrix.ScreenCoordinates,objName:"Ops.Gl.Matrix.ScreenCoordinates"};




// **************************************************************
// 
// Ops.Gl.Matrix.ScreenPosTo3d_v3
// 
// **************************************************************

Ops.Gl.Matrix.ScreenPosTo3d_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Exec"),
    inX = op.inValue("X"),
    inY = op.inValue("Y"),
    inputType = op.inSwitch("Input Type", ["Pixel", "-1 to 1"], "Pixel"),
    outTrigger = op.outTrigger("Trigger out"),
    outX = op.outNumber("Result X"),
    outY = op.outNumber("Result Y");

const mat = mat4.create();
const cgl = op.patch.cgl;

exec.onTriggered = calc;

let inp = 0;
inputType.onChange = () =>
{
    if (inputType.get() == "Pixel")inp = 0;
    else if (inputType.get() == "-1 to 1")inp = 1;
};

function calc()
{
    let x = 0;
    let y = 0;

    let aspect = cgl.canvas.clientWidth / cgl.canvas.clientHeight;

    if (inp === 0) // pixel
    {
        x = 2.0 * inX.get() / cgl.canvas.clientWidth - 1;
        y = -2.0 * inY.get() / cgl.canvas.clientHeight + 1;
    }
    else if (inp === 1) // -1 to 1
    {
        x = inX.get();
        y = inY.get();
    }

    let point3d = vec3.fromValues(x, y, 0);

    mat4.mul(mat, cgl.pMatrix, cgl.vMatrix);

    mat4.invert(mat, mat);

    vec3.transformMat4(point3d, point3d, mat);

    outX.set(point3d[0] * 10);
    outY.set(point3d[1] * 10);
    outTrigger.trigger();
}


};

Ops.Gl.Matrix.ScreenPosTo3d_v3.prototype = new CABLES.Op();
CABLES.OPS["48d72532-afa6-40c9-a895-00a43635a94b"]={f:Ops.Gl.Matrix.ScreenPosTo3d_v3,objName:"Ops.Gl.Matrix.ScreenPosTo3d_v3"};




// **************************************************************
// 
// Ops.Gl.Matrix.SetProjectionMatrix
// 
// **************************************************************

Ops.Gl.Matrix.SetProjectionMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inExe=op.inTrigger("exe");
const inMatrix=op.inArray('Matrix');
const next=op.outTrigger("next");
const cgl=op.patch.cgl;

inExe.onTriggered=function()
{
    if(inMatrix.get())
    {
        cgl.pushPMatrix();

        mat4.copy(cgl.pMatrix,inMatrix.get() );

        next.trigger();
        cgl.popPMatrix();

    }

};

};

Ops.Gl.Matrix.SetProjectionMatrix.prototype = new CABLES.Op();
CABLES.OPS["2c614eb3-ab11-4793-a085-3ef8f517e30b"]={f:Ops.Gl.Matrix.SetProjectionMatrix,objName:"Ops.Gl.Matrix.SetProjectionMatrix"};




// **************************************************************
// 
// Ops.Gl.Matrix.Shear
// 
// **************************************************************

Ops.Gl.Matrix.Shear = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render=op.inTrigger('render'),
    shearX=op.inValueFloat("shearX",0.5),
    shearY=op.inValueFloat("shearY"),
    trigger=op.outTrigger('trigger');

const cgl=op.patch.cgl;
const shearMatrix = mat4.create();

shearY.onChange=shearX.onChange=update;

function update()
{
    mat4.identity(shearMatrix);
    shearMatrix[1]=Math.tan(shearX.get());
    shearMatrix[4]=Math.tan(shearY.get());
}

render.onTriggered=function()
{
    cgl.pushModelMatrix();

    mat4.multiply(cgl.mMatrix,cgl.mMatrix,shearMatrix);
    trigger.trigger();

    cgl.popModelMatrix();
};



};

Ops.Gl.Matrix.Shear.prototype = new CABLES.Op();
CABLES.OPS["02d76d99-67f2-4146-b906-8bce2c3ad6bb"]={f:Ops.Gl.Matrix.Shear,objName:"Ops.Gl.Matrix.Shear"};




// **************************************************************
// 
// Ops.Gl.Matrix.Transform
// 
// **************************************************************

Ops.Gl.Matrix.Transform = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    posX = op.inValue("posX", 0),
    posY = op.inValue("posY", 0),
    posZ = op.inValue("posZ", 0),
    scale = op.inValue("scale", 1),
    rotX = op.inValue("rotX", 0),
    rotY = op.inValue("rotY", 0),
    rotZ = op.inValue("rotZ", 0),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Rotation", [rotX, rotY, rotZ]);
op.setPortGroup("Position", [posX, posY, posZ]);
op.setPortGroup("Scale", [scale]);
op.setUiAxisPorts(posX, posY, posZ);

const vPos = vec3.create();
const vScale = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

let
    doScale = false,
    doTranslate = false,
    translationChanged = true,
    scaleChanged = true,
    rotChanged = true;

rotX.onChange = rotY.onChange = rotZ.onChange = setRotChanged;
posX.onChange = posY.onChange = posZ.onChange = setTranslateChanged;
scale.onChange = setScaleChanged;

render.onTriggered = function ()
{
    // if(!CGL.TextureEffect.checkOpNotInTextureEffect(op)) return;

    let updateMatrix = false;
    if (translationChanged)
    {
        updateTranslation();
        updateMatrix = true;
    }
    if (scaleChanged)
    {
        updateScale();
        updateMatrix = true;
    }
    if (rotChanged) updateMatrix = true;

    if (updateMatrix) doUpdateMatrix();

    const cg = op.patch.cgl;
    cg.pushModelMatrix();
    mat4.multiply(cg.mMatrix, cg.mMatrix, transMatrix);

    trigger.trigger();
    cg.popModelMatrix();

    if (CABLES.UI && CABLES.UI.showCanvasTransforms) gui.setTransform(op.id, posX.get(), posY.get(), posZ.get());

    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": posX,
                "posY": posY,
                "posZ": posZ,
            });
};

op.transform3d = function ()
{
    return { "pos": [posX, posY, posZ] };
};

function doUpdateMatrix()
{
    mat4.identity(transMatrix);
    if (doTranslate)mat4.translate(transMatrix, transMatrix, vPos);

    if (rotX.get() !== 0)mat4.rotateX(transMatrix, transMatrix, rotX.get() * CGL.DEG2RAD);
    if (rotY.get() !== 0)mat4.rotateY(transMatrix, transMatrix, rotY.get() * CGL.DEG2RAD);
    if (rotZ.get() !== 0)mat4.rotateZ(transMatrix, transMatrix, rotZ.get() * CGL.DEG2RAD);

    if (doScale)mat4.scale(transMatrix, transMatrix, vScale);
    rotChanged = false;
}

function updateTranslation()
{
    doTranslate = false;
    if (posX.get() !== 0.0 || posY.get() !== 0.0 || posZ.get() !== 0.0) doTranslate = true;
    vec3.set(vPos, posX.get(), posY.get(), posZ.get());
    translationChanged = false;
}

function updateScale()
{
    // doScale=false;
    // if(scale.get()!==0.0)
    doScale = true;
    vec3.set(vScale, scale.get(), scale.get(), scale.get());
    scaleChanged = false;
}

function setTranslateChanged()
{
    translationChanged = true;
}

function setScaleChanged()
{
    scaleChanged = true;
}

function setRotChanged()
{
    rotChanged = true;
}

doUpdateMatrix();


};

Ops.Gl.Matrix.Transform.prototype = new CABLES.Op();
CABLES.OPS["650baeb1-db2d-4781-9af6-ab4e9d4277be"]={f:Ops.Gl.Matrix.Transform,objName:"Ops.Gl.Matrix.Transform"};




// **************************************************************
// 
// Ops.Gl.Matrix.TransformMul
// 
// **************************************************************

Ops.Gl.Matrix.TransformMul = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render=op.inTrigger("render");
const mul=op.inValueFloat("mul");
const trigger=op.outTrigger("trigger");

const cgl=op.patch.cgl;

render.onTriggered=function()
{
    var pos=[0,0,0];
    vec3.transformMat4(pos, [0,0,0], cgl.mMatrix);

    cgl.pushModelMatrix();
    vec3.mul(pos,pos,[mul.get(),mul.get(),mul.get()] );

    mat4.translate(cgl.mMatrix,cgl.mMatrix, pos );
    trigger.trigger();

    cgl.popModelMatrix();
};

};

Ops.Gl.Matrix.TransformMul.prototype = new CABLES.Op();
CABLES.OPS["2a83f565-7c5c-4cce-862f-d38481eb3726"]={f:Ops.Gl.Matrix.TransformMul,objName:"Ops.Gl.Matrix.TransformMul"};




// **************************************************************
// 
// Ops.Gl.Matrix.TransformView
// 
// **************************************************************

Ops.Gl.Matrix.TransformView = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    posX = op.inValueFloat("posX"),
    posY = op.inValueFloat("posY"),
    posZ = op.inValueFloat("posZ"),
    scale = op.inValueFloat("scale"),
    rotX = op.inValueFloat("rotX"),
    rotY = op.inValueFloat("rotY"),
    rotZ = op.inValueFloat("rotZ"),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Position", [posX, posY, posZ]);
op.setPortGroup("Scale", [scale]);
op.setPortGroup("Rotation", [rotX, rotZ, rotY]);

const vPos = vec3.create();
const vScale = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

let doScale = false;
let doTranslate = false;

let translationChanged = true;
let didScaleChanged = true;
let didRotChanged = true;

render.onTriggered = function ()
{
    const cg = op.patch.cg;

    let updateMatrix = false;
    if (translationChanged)
    {
        updateTranslation();
        updateMatrix = true;
    }
    if (didScaleChanged)
    {
        updateScale();
        updateMatrix = true;
    }
    if (didRotChanged)
    {
        updateMatrix = true;
    }
    if (updateMatrix)doUpdateMatrix();

    cg.pushViewMatrix();
    mat4.multiply(cg.vMatrix, cg.vMatrix, transMatrix);

    trigger.trigger();
    cg.popViewMatrix();

    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": posX,
                "posY": posY,
                "posZ": posZ,
            });
};

op.transform3d = function ()
{
    return {
        "pos": [posX, posY, posZ]
    };
};

function doUpdateMatrix()
{
    mat4.identity(transMatrix);
    if (doTranslate)mat4.translate(transMatrix, transMatrix, vPos);

    if (rotX.get() !== 0)mat4.rotateX(transMatrix, transMatrix, rotX.get() * CGL.DEG2RAD);
    if (rotY.get() !== 0)mat4.rotateY(transMatrix, transMatrix, rotY.get() * CGL.DEG2RAD);
    if (rotZ.get() !== 0)mat4.rotateZ(transMatrix, transMatrix, rotZ.get() * CGL.DEG2RAD);

    if (doScale)mat4.scale(transMatrix, transMatrix, vScale);
    rotChanged = false;
}

function updateTranslation()
{
    doTranslate = false;
    if (posX.get() !== 0.0 || posY.get() !== 0.0 || posZ.get() !== 0.0) doTranslate = true;
    vec3.set(vPos, posX.get(), posY.get(), posZ.get());
    translationChanged = false;
}

function updateScale()
{
    doScale = false;
    if (scale.get() !== 0.0)doScale = true;
    vec3.set(vScale, scale.get(), scale.get(), scale.get());
    scaleChanged = false;
}

function translateChanged()
{
    translationChanged = true;
}

function scaleChanged()
{
    didScaleChanged = true;
}

function rotChanged()
{
    didRotChanged = true;
}

rotX.onChange =
rotY.onChange =
rotZ.onChange = rotChanged;

scale.onChange = scaleChanged;

posX.onChange =
posY.onChange =
posZ.onChange = translateChanged;

rotX.set(0.0);
rotY.set(0.0);
rotZ.set(0.0);

scale.set(1.0);

posX.set(0.0);
posY.set(0.0);
posZ.set(0.0);

doUpdateMatrix();


};

Ops.Gl.Matrix.TransformView.prototype = new CABLES.Op();
CABLES.OPS["0b3e04f7-323e-4ac8-8a22-a21e2f36e0e9"]={f:Ops.Gl.Matrix.TransformView,objName:"Ops.Gl.Matrix.TransformView"};




// **************************************************************
// 
// Ops.Gl.Matrix.Translate
// 
// **************************************************************

Ops.Gl.Matrix.Translate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");
const x = op.inValue("x");
const y = op.inValue("y");
const z = op.inValue("z");

let vec = vec3.create();

render.onTriggered = function ()
{
    const cgl = op.patch.cg;

    vec3.set(vec, x.get(), y.get(), z.get());
    cgl.pushModelMatrix();
    mat4.translate(cgl.mMatrix, cgl.mMatrix, vec);
    trigger.trigger();
    cgl.popModelMatrix();
};


};

Ops.Gl.Matrix.Translate.prototype = new CABLES.Op();
CABLES.OPS["1f89ba0e-e7eb-46d7-8c66-7814b7c528b9"]={f:Ops.Gl.Matrix.Translate,objName:"Ops.Gl.Matrix.Translate"};




// **************************************************************
// 
// Ops.Gl.Matrix.TranslateView
// 
// **************************************************************

Ops.Gl.Matrix.TranslateView = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render=op.inTrigger('render'),
    x=op.inValueFloat("x"),
    y=op.inValueFloat("y"),
    z=op.inValueFloat("z"),
    trigger=op.outTrigger('trigger');

const cgl=op.patch.cgl;
const vec=vec3.create();

render.onTriggered=function()
{
    vec3.set(vec, x.get(),y.get(),z.get());
    cgl.pushViewMatrix();
    mat4.translate(cgl.vMatrix,cgl.vMatrix, vec);
    trigger.trigger();
    cgl.popViewMatrix();
};


};

Ops.Gl.Matrix.TranslateView.prototype = new CABLES.Op();
CABLES.OPS["b15472e2-b895-4dde-95c3-239fa5e08afc"]={f:Ops.Gl.Matrix.TranslateView,objName:"Ops.Gl.Matrix.TranslateView"};




// **************************************************************
// 
// Ops.Gl.Matrix.VectorTranslate
// 
// **************************************************************

Ops.Gl.Matrix.VectorTranslate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exec = op.inTrigger("Exec");
const speed = op.inValue("Speed");
const vecX = op.inValue("Vector X");
const vecY = op.inValue("Vector Y");
const vecZ = op.inValue("Vector Z");
const resetVecX = op.inFloat("Reset Position X");
const resetVecY = op.inFloat("Reset Position Y");
const resetVecZ = op.inFloat("Reset Position Z");
const next = op.outTrigger("Next");

const reset = op.inTriggerButton("reset");

const max = op.inValue("max");

const cgl = op.patch.cgl;

const vec = vec3.create();
const pos = vec3.create();
const mat = mat4.create();

let lastTime = 0;
let timeDiff = 0;

reset.onTriggered = function ()
{
    vec3.set(pos,
        (resetVecX.get()),
        (resetVecY.get()),
        (resetVecZ.get())
    );
};

let dir = false;
function changeDir(d)
{
    dir = !dir;

    move();
}

function isOutside()
{
    if (
        pos[0] > max.get() || pos[0] < -max.get()
        || pos[1] > max.get() || pos[1] < -max.get()
        || pos[2] > max.get() || pos[2] < -max.get())
        return true;
    return false;
}

function move()
{
}

exec.onTriggered = function ()
{
    timeDiff = op.patch.freeTimer.get() - lastTime;
    const m = speed.get() * timeDiff * 0.1;

    vec3.set(vec,
        (vecX.get()),
        (vecY.get()),
        (vecZ.get())
    );

    vec3.normalize(vec, vec);

    vec[0] *= m;
    vec[1] *= m;
    vec[2] *= m;

    lastTime = op.patch.freeTimer.get();

    move();

    // if(isOutside())
    // {
    //     op.log("OUTSIDE");
    //     changeDir();
    //     var count=0;
    //     while(isOutside() && count<10)
    //     {
    //         randomize();
    // count++;
    //         move();
    //     }
    // }

    // if(pos[0]>max.get() || pos[0]<-max.get()) changeDir();
    //     else if(pos[1]>max.get() || pos[1]<-max.get()) changeDir();
    //         else if(pos[2]>max.get() || pos[2]<-max.get()) changeDir();

    vec3.add(pos, pos, vec);

    cgl.pushModelMatrix();

    mat4.translate(cgl.mMatrix, cgl.mMatrix, pos);

    next.trigger();

    cgl.popModelMatrix();
};


};

Ops.Gl.Matrix.VectorTranslate.prototype = new CABLES.Op();
CABLES.OPS["ca65a1bc-3efa-4b73-96c4-087003b9470a"]={f:Ops.Gl.Matrix.VectorTranslate,objName:"Ops.Gl.Matrix.VectorTranslate"};




// **************************************************************
// 
// Ops.Gl.Matrix.WASDCamera_v2
// 
// **************************************************************

Ops.Gl.Matrix.WASDCamera_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    enablePointerLock = op.inBool("Enable pointer lock", true),
    trigger = op.outTrigger("trigger"),
    isLocked = op.outBoolNum("isLocked", false),

    moveSpeed = op.inFloat("Speed", 1),
    mouseSpeed = op.inFloat("Mouse Speed", 1),
    fly = op.inValueBool("Allow Flying", true),
    inActive = op.inBool("Active", true),

    inMoveXPos = op.inBool("Move X+"),
    inMoveXNeg = op.inBool("Move X-"),
    inMoveYPos = op.inBool("Move Y+"),
    inMoveYNeg = op.inBool("Move Y-"),

    inReset = op.inTriggerButton("Reset"),

    outPosX = op.outNumber("posX"),
    outPosY = op.outNumber("posY"),
    outPosZ = op.outNumber("posZ"),

    outMouseDown = op.outTrigger("Mouse Left"),
    outMouseDownRight = op.outTrigger("Mouse Right"),

    outDirX = op.outNumber("Dir X"),
    outDirY = op.outNumber("Dir Y"),
    outDirZ = op.outNumber("Dir Z");

const vPos = vec3.create();
let speedx = 0, speedy = 0, speedz = 0;
const movementSpeedFactor = 0.5;

op.setPortGroup("Move", [inMoveYNeg, inMoveYPos, inMoveXNeg, inMoveXPos]);

let mouseNoPL = { "firstMove": true,
    "deltaX": 0,
    "deltaY": 0,
};

const DEG2RAD = 3.14159 / 180.0;

let rotX = 0;
let rotY = 0;

let posX = 0;
let posY = 0;
let posZ = 0;

let pressedW = false;
let pressedA = false;
let pressedS = false;
let pressedD = false;

const cgl = op.patch.cgl;

const viewMatrix = mat4.create();

op.toWorkPortsNeedToBeLinked(render);
let lastMove = 0;

initListener();

enablePointerLock.onChange = initListener;

inReset.onTriggered = () =>
{
    rotX = 0;
    rotY = 0;
    posX = 0;
    posY = 0;
    posZ = 0;
};

inActive.onChange = () =>
{
    document.exitPointerLock();
    removeListener();

    lockChangeCallback();

    if (inActive.get())
    {
        initListener();
    }
};

render.onTriggered = function ()
{
    if (cgl.frameStore.shadowPass) return trigger.trigger();

    calcCameraMovement();
    move();

    if (!fly.get())posY = 0.0;

    if (speedx !== 0.0 || speedy !== 0.0 || speedz !== 0)
    {
        outPosX.set(posX);
        outPosY.set(posY);
        outPosZ.set(posZ);
    }

    cgl.pushViewMatrix();

    vec3.set(vPos, -posX, -posY, -posZ);

    mat4.identity(cgl.vMatrix);

    mat4.rotateX(cgl.vMatrix, cgl.vMatrix, DEG2RAD * rotX);
    mat4.rotateY(cgl.vMatrix, cgl.vMatrix, DEG2RAD * rotY);

    mat4.translate(cgl.vMatrix, cgl.vMatrix, vPos);

    trigger.trigger();
    cgl.popViewMatrix();

    // for dir vec
    mat4.identity(viewMatrix);
    mat4.rotateX(viewMatrix, viewMatrix, DEG2RAD * rotX);
    mat4.rotateY(viewMatrix, viewMatrix, DEG2RAD * rotY);
    mat4.transpose(viewMatrix, viewMatrix);

    const dir = vec4.create();
    vec4.transformMat4(dir, [0, 0, 1, 1], viewMatrix);

    vec4.normalize(dir, dir);
    outDirX.set(-dir[0]);
    outDirY.set(-dir[1]);
    outDirZ.set(-dir[2]);
};

//--------------

function calcCameraMovement()
{
    let camMovementXComponent = 0.0,
        camMovementYComponent = 0.0,
        camMovementZComponent = 0.0,
        pitchFactor = 0,
        yawFactor = 0;

    if (pressedW)
    {
        // Control X-Axis movement
        pitchFactor = Math.cos(DEG2RAD * rotX);

        camMovementXComponent += (movementSpeedFactor * (Math.sin(DEG2RAD * rotY))) * pitchFactor;

        // Control Y-Axis movement
        camMovementYComponent += movementSpeedFactor * (Math.sin(DEG2RAD * rotX)) * -1.0;

        // Control Z-Axis movement
        yawFactor = (Math.cos(DEG2RAD * rotX));
        camMovementZComponent += (movementSpeedFactor * (Math.cos(DEG2RAD * rotY)) * -1.0) * yawFactor;
    }

    if (pressedS)
    {
        // Control X-Axis movement
        pitchFactor = Math.cos(DEG2RAD * rotX);
        camMovementXComponent += (movementSpeedFactor * (Math.sin(DEG2RAD * rotY)) * -1.0) * pitchFactor;

        // Control Y-Axis movement
        camMovementYComponent += movementSpeedFactor * (Math.sin(DEG2RAD * rotX));

        // Control Z-Axis movement
        yawFactor = (Math.cos(DEG2RAD * rotX));
        camMovementZComponent += (movementSpeedFactor * (Math.cos(DEG2RAD * rotY))) * yawFactor;
    }

    let yRotRad = DEG2RAD * rotY;

    if (pressedA)
    {
        // Calculate our Y-Axis rotation in radians once here because we use it twice

        camMovementXComponent += -movementSpeedFactor * (Math.cos(yRotRad));
        camMovementZComponent += -movementSpeedFactor * (Math.sin(yRotRad));
    }

    if (pressedD)
    {
        // Calculate our Y-Axis rotation in radians once here because we use it twice

        camMovementXComponent += movementSpeedFactor * (Math.cos(yRotRad));
        camMovementZComponent += movementSpeedFactor * (Math.sin(yRotRad));
    }

    const mulSpeed = 0.016;

    speedx = camMovementXComponent * mulSpeed;
    speedy = camMovementYComponent * mulSpeed;
    speedz = camMovementZComponent * mulSpeed;

    if (speedx > movementSpeedFactor) speedx = movementSpeedFactor;
    if (speedx < -movementSpeedFactor) speedx = -movementSpeedFactor;

    if (speedy > movementSpeedFactor) speedy = movementSpeedFactor;
    if (speedy < -movementSpeedFactor) speedy = -movementSpeedFactor;

    if (speedz > movementSpeedFactor) speedz = movementSpeedFactor;
    if (speedz < -movementSpeedFactor) speedz = -movementSpeedFactor;
}

function moveCallback(e)
{
    const mouseSensitivity = 0.1;
    rotX += e.movementY * mouseSensitivity * mouseSpeed.get();
    rotY += e.movementX * mouseSensitivity * mouseSpeed.get();

    if (rotX < -90.0) rotX = -90.0;
    if (rotX > 90.0) rotX = 90.0;
    if (rotY < -180.0) rotY += 360.0;
    if (rotY > 180.0) rotY -= 360.0;
}

const canvas = document.getElementById("glcanvas");

function mouseDown(e)
{
    if (e.which == 3) outMouseDownRight.trigger();
    else outMouseDown.trigger();
}

function lockChangeCallback(e)
{
    if (document.pointerLockElement === canvas ||
            document.mozPointerLockElement === canvas ||
            document.webkitPointerLockElement === canvas)
    {
        document.addEventListener("pointerdown", mouseDown, false);
        document.addEventListener("pointermove", moveCallback, false);
        document.addEventListener("keydown", keyDown, false);
        document.addEventListener("keyup", keyUp, false);
        isLocked.set(true);
    }
    else
    {
        document.removeEventListener("pointerdown", mouseDown, false);
        document.removeEventListener("pointermove", moveCallback, false);
        document.removeEventListener("keydown", keyDown, false);
        document.removeEventListener("keyup", keyUp, false);
        isLocked.set(false);
        pressedW = false;
        pressedA = false;
        pressedS = false;
        pressedD = false;
    }
}

function startPointerLock()
{
    const test = false;
    if (render.isLinked() && enablePointerLock.get())
    {
        document.addEventListener("pointermove", moveCallback, false);
        canvas.requestPointerLock = canvas.requestPointerLock ||
                                    canvas.mozRequestPointerLock ||
                                    canvas.webkitRequestPointerLock;
        canvas.requestPointerLock();
    }
}

function removeListener()
{
    cgl.canvas.removeEventListener("pointermove", moveCallbackNoPL, false);
    cgl.canvas.removeEventListener("pointerup", upCallbackNoPL, false);
    cgl.canvas.removeEventListener("keydown", keyDown, false);
    cgl.canvas.removeEventListener("keyup", keyUp, false);

    document.removeEventListener("pointerlockchange", lockChangeCallback, false);
    document.removeEventListener("mozpointerlockchange", lockChangeCallback, false);
    document.removeEventListener("webkitpointerlockchange", lockChangeCallback, false);
    document.getElementById("glcanvas").removeEventListener("mousedown", startPointerLock);
}

function initListener()
{
    if (enablePointerLock.get())
    {
        document.addEventListener("pointerlockchange", lockChangeCallback, false);
        document.addEventListener("mozpointerlockchange", lockChangeCallback, false);
        document.addEventListener("webkitpointerlockchange", lockChangeCallback, false);
        document.getElementById("glcanvas").addEventListener("mousedown", startPointerLock);

        cgl.canvas.removeEventListener("pointermove", moveCallbackNoPL, false);
        cgl.canvas.removeEventListener("pointerup", upCallbackNoPL, false);
        cgl.canvas.removeEventListener("keydown", keyDown, false);
        cgl.canvas.removeEventListener("keyup", keyUp, false);
    }
    else
    {
        cgl.canvas.addEventListener("pointermove", moveCallbackNoPL, false);
        cgl.canvas.addEventListener("pointerup", upCallbackNoPL, false);
        cgl.canvas.addEventListener("keydown", keyDown, false);
        cgl.canvas.addEventListener("keyup", keyUp, false);
    }
}

function upCallbackNoPL(e)
{
    try { cgl.canvas.releasePointerCapture(e.pointerId); }
    catch (e) {}
    mouseNoPL.firstMove = true;
}

function moveCallbackNoPL(e)
{
    if (e && e.buttons == 1)
    {
        try { cgl.canvas.setPointerCapture(e.pointerId); }
        catch (_e) {}

        if (!mouseNoPL.firstMove)
        {
            // outDragging.set(true);
            const deltaX = (e.clientX - mouseNoPL.lastX) * mouseSpeed.get() * 0.5;
            const deltaY = (e.clientY - mouseNoPL.lastY) * mouseSpeed.get() * 0.5;

            rotX += deltaY;
            rotY += deltaX;
            // outDeltaX.set(deltaX);
            // outDeltaY.set(deltaY);
        }

        mouseNoPL.firstMove = false;

        mouseNoPL.lastX = e.clientX;
        mouseNoPL.lastY = e.clientY;
    }
}

function move()
{
    let timeOffset = window.performance.now() - lastMove;
    timeOffset *= moveSpeed.get();
    posX += speedx * timeOffset;
    posY += speedy * timeOffset;
    posZ += speedz * timeOffset;

    lastMove = window.performance.now();
}

function keyDown(e)
{
    switch (e.which)
    {
    case 87:
        pressedW = true;
        break;
    case 65:
        pressedA = true;
        break;
    case 83:
        pressedS = true;
        break;
    case 68:
        pressedD = true;
        break;

    default:
        break;
    }
}

function keyUp(e)
{
    switch (e.which)
    {
    case 87:
        pressedW = false;
        break;
    case 65:
        pressedA = false;
        break;
    case 83:
        pressedS = false;
        break;
    case 68:
        pressedD = false;
        break;
    }
}

inMoveXPos.onChange = () => { pressedD = inMoveXPos.get(); };
inMoveXNeg.onChange = () => { pressedA = inMoveXNeg.get(); };
inMoveYPos.onChange = () => { pressedW = inMoveYPos.get(); };
inMoveYNeg.onChange = () => { pressedS = inMoveYNeg.get(); };


};

Ops.Gl.Matrix.WASDCamera_v2.prototype = new CABLES.Op();
CABLES.OPS["af6c3fe2-58a9-4f81-be41-4c21aabffde9"]={f:Ops.Gl.Matrix.WASDCamera_v2,objName:"Ops.Gl.Matrix.WASDCamera_v2"};




// **************************************************************
// 
// Ops.Gl.MediaRecorder
// 
// **************************************************************

Ops.Gl.MediaRecorder = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const videoTypes = ["webm", "mp4", "x-matroska"];
const audioTypes = ["webm", "mp3", "x-matroska"];
const videoCodecs = ["vp9", "vp8", "avc1", "av1", "h265", "h264", "mpeg", "mp4a"];
const audioCodecs = ["opus", "pcm", "aac", "mp3", "ogg"];

const supportedVideos = getSupportedMimeTypes("video", videoTypes, videoCodecs, audioCodecs);

function getSupportedMimeTypes(media, types, codecs, codecsB)
{
    const isSupported = MediaRecorder.isTypeSupported;
    const supported = [];

    types.forEach((type) =>
    {
        const mimeType = `${media}/${type}`;
        if (isSupported(mimeType))
            supported.push(mimeType);
    });

    types.forEach((type) =>
    {
        const mimeType = `${media}/${type}`;
        codecs.forEach((codec) =>
        {
            return [`${mimeType}; codecs=${codec}`].forEach((variation) =>
            {
                if (isSupported(variation)) supported.push(variation);

                codecsB.forEach((codecB) =>
                {
                    return [`${mimeType}; codecs=${codec},${codecB}`].forEach((eachVariation) =>
                    {
                        if (isSupported(eachVariation)) supported.push(eachVariation);
                    });
                });
            });
        });
    });
    return supported;
}

// / ////////////////

const
    recordingToggle = op.inBool("Recording", false),

    inFilename = op.inString("Filename", "cables"),
    inCodecs = op.inDropDown("Mimetype", supportedVideos),
    inMbit = op.inFloat("MBit", 5),
    inFPS = op.inFloat("FPS", 30),

    inMedia = op.inSwitch("Media", ["Video", "Audio", "Audio+Video"], "Video"),
    inAudio = op.inObject("Audio In", null, "audioNode"),
    inCanvasId = op.inString("Video Canvas Id", "glcanvas"),

    outState = op.outString("State"),
    outError = op.outString("Error"),
    outCodec = op.outString("Final Mimetype"),
    outCodecs = op.outArray("Valid Mimetypes", supportedVideos);

op.setPortGroup("Inputs", [inMedia, inAudio, inCanvasId]);
op.setPortGroup("Encoding", [inMbit, inCodecs, inFPS]);

const gl = op.patch.cgl.gl;
let fb = null;
const cgl = op.patch.cgl;

let cgl_filter = 0;
let cgl_wrap = 0;
let tex = null;
let timeout = null;
let firstTime = true;
let mediaRecorder;
let recordedBlobs;
let sourceBuffer;

recordingToggle.onChange = toggleRecording;

inFPS.onChange =
    inMbit.onChange =
    inMedia.onChange =
    inAudio.onChange =
    inCanvasId.onChange =
    inCodecs.onChange = setupMediaRecorder;

op.patch.cgl.on("resize", () =>
{
    if (mediaRecorder && mediaRecorder.state === "active")mediaRecorder.stop();
    mediaRecorder = null;
});

setupMediaRecorder();

function handleDataAvailable(event)
{
    if (event.data && event.data.size > 0)
    {
        recordedBlobs.push(event.data);
    }
}

function toggleRecording()
{
    if (recordingToggle.get()) startRecording();
    else stopRecording();
}

function setupMediaRecorder()
{
    outCodec.set("unknown");

    outState.set("");
    outCodec.set("");
    outError.set("");
    op.setUiError("constr", null);
    op.setUiError("audionoaudio", null);
    op.setUiError("nocanvas", null);
    mediaRecorder = null;

    if (inCodecs.get() === "" || inCodecs.get() === 0)
    {
        return;
    }

    let options = { "mimeType": inCodecs.get(), "videoBitsPerSecond": inMbit.get() * 1024 * 1024 };
    recordedBlobs = [];
    try
    {
        const canvas = document.getElementById(inCanvasId.get());
        if (!canvas)
        {
            op.setUiError("nocanvas", "canvas not found ");
            return;
        }
        canvas.getContext("2d");
        const streamVid = canvas.captureStream(inFPS.get());

        let stream = streamVid;
        if (inMedia.get() !== "Video")
        {
            const audioCtx = CABLES.WEBAUDIO.createAudioContext(op);
            const streamAudio = audioCtx.createMediaStreamDestination();

            if (!inAudio.get())
            {
                op.setUiError("audionoaudio", "no audio connected ");
                return;
            }
            inAudio.get().connect(streamAudio);

            if (inMedia.get() === "Audio+Video")stream = new MediaStream([...streamVid.getTracks(), ...streamAudio.stream.getTracks()]);
            else stream = streamAudio;
        }

        mediaRecorder = new MediaRecorder(stream, options);
    }
    catch (err)
    {
        op.error(err);
        op.error("error mr constructor: ", err);
        outError.set(err.message);
        op.setUiError("contr", "MediaRecorder error: " + err.message);
    }
    if (mediaRecorder)
    {
        outState.set(mediaRecorder.state);
        outCodec.set(mediaRecorder.mimeType);
    }
    else
    {
        op.warn("no mediarecorder created...");
    }
}

// The nested try blocks will be simplified when Chrome 47 moves to Stable
function startRecording()
{
    if (!mediaRecorder)setupMediaRecorder();
    if (!mediaRecorder)
    {
        op.setUiError("noobj", "could not create mediarecorder, try setting all parameters");
        return;
    }

    recordedBlobs = [];

    op.setUiError("noobj", null);

    op.verbose("start recording: ", inCodecs.get());

    mediaRecorder.ondataavailable = handleDataAvailable;
    mediaRecorder.start(1000);

    outState.set(mediaRecorder.state);
    op.log("MediaRecorder started", mediaRecorder);
}

function stopRecording()
{
    if (!mediaRecorder)
    {
        // op.warn("cant stop no mediarecorder");
        return;
    }
    op.verbose("mediaRecorder.state", mediaRecorder.state);
    if (mediaRecorder.state === "inactive") return;

    op.verbose("mediaRecorder.videoBitsPerSecond  ", mediaRecorder.videoBitsPerSecond / 1024 / 1024);
    op.verbose("mediaRecorder.mimeType  ", mediaRecorder.mimeType);

    mediaRecorder.onstop = download;

    mediaRecorder.stop();
    outState.set(mediaRecorder.state);

    op.verbose("Recorded Blobs: ", recordedBlobs);
    // download();
}

function download()
{
    if (recordedBlobs.length === 0)
    {
        op.warn("download canceled, no recordedBlobs");
    }

    if (!mediaRecorder) return;

    const blob = new Blob(recordedBlobs, { "type": "application/octet-stream" });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.style.display = "none";
    a.href = url;
    const codec = mediaRecorder.mimeType;
    let ext = "webm";
    if (codec.indexOf("video/x-matroska") >= 0)ext = "mkv";
    if (codec.indexOf("video/mp4") >= 0)ext = "mp4";
    a.download = (inFilename.get() || "cables") + "." + ext;
    document.body.appendChild(a);
    a.click();
    setTimeout(() =>
    {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    }, 100);
}


};

Ops.Gl.MediaRecorder.prototype = new CABLES.Op();
CABLES.OPS["ff12e50f-e2bd-4554-9aec-dab9de4cba8b"]={f:Ops.Gl.MediaRecorder,objName:"Ops.Gl.MediaRecorder"};




// **************************************************************
// 
// Ops.Gl.MeshInstancer_v4
// 
// **************************************************************

Ops.Gl.MeshInstancer_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"instancer_body_frag":"#ifdef COLORIZE_INSTANCES\n    #ifdef BLEND_MODE_MULTIPLY\n        col.rgb *= frag_instColor.rgb;\n        col.a *= frag_instColor.a;\n    #endif\n\n    #ifdef BLEND_MODE_ADD\n        col.rgb += frag_instColor.rgb;\n        col.a += frag_instColor.a;\n    #endif\n\n    #ifdef BLEND_MODE_NONE\n        col.rgb = frag_instColor.rgb;\n        col.a = frag_instColor.a;\n    #endif\n#endif\n","instancer_body_vert":"\n\n#ifdef HAS_TEXCOORDS\ntexCoord=(texCoord*instTexCoords.zw)+instTexCoords.xy;\n#endif\n\nmMatrix*=instMat;\npos.xyz*=MOD_scale;\n\n#ifdef HAS_COLORS\nfrag_instColor=instColor;\n#endif\n#ifndef HAS_COLORS\nfrag_instColor=vec4(1.0);\n#endif\n\n","instancer_head_frag":"IN vec4 frag_instColor;\n","instancer_head_vert":"\nIN vec4 instColor;\nIN mat4 instMat;\nIN vec4 instTexCoords;\nOUT mat4 instModelMat;\nOUT vec4 frag_instColor;\n\n#define INSTANCING\n\n",};
const
    exe = op.inTrigger("exe"),
    geom = op.inObject("geom", null, "geometry"),
    inScale = op.inValue("Scale", 1),
    doLimit = op.inValueBool("Limit Instances", false),
    inLimit = op.inValueInt("Limit", 100),
    inTranslates = op.inArray("positions", 3),
    inScales = op.inArray("Scale Array", 3),
    inRot = op.inArray("Rotations", 3),
    inRotMeth = op.inSwitch("Rotation Type", ["Euler", "Quaternions"], "Euler"),
    inBlendMode = op.inSwitch("Material blend mode", ["Multiply", "Add", "Normal"], "Multiply"),
    inColor = op.inArray("Colors", 4),
    inTexCoords = op.inArray("TexCoords", 4),
    outTrigger = op.outTrigger("Trigger Out"),
    outNum = op.outNumber("Num");

op.setPortGroup("Limit Number of Instances", [inLimit, doLimit]);
op.setPortGroup("Parameters", [inScales, inRot, inTranslates, inRotMeth]);
op.toWorkPortsNeedToBeLinked(geom);
op.toWorkPortsNeedToBeLinked(exe);

geom.ignoreValueSerialize = true;

const cgl = op.patch.cgl;
const m = mat4.create();
let
    matrixArray = new Float32Array(1),
    instColorArray = new Float32Array(1),
    instTexcoordArray = new Float32Array(1),
    mesh = null,
    recalc = true,
    num = 0,
    arrayChangedColor = true,
    arrayChangedTexcoords = true,
    arrayChangedTrans = true;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "name": "MODULE_VERTEX_POSITION",
    "title": op.name,
    "priority": -2,
    "srcHeadVert": attachments.instancer_head_vert,
    "srcBodyVert": attachments.instancer_body_vert
});

mod.addModule({
    "name": "MODULE_COLOR",
    "priority": -2,
    "title": op.name,
    "srcHeadFrag": attachments.instancer_head_frag,
    "srcBodyFrag": attachments.instancer_body_frag,
});

mod.addUniformVert("f", "MOD_scale", inScale);

let needsUpdateDefines = true;
inBlendMode.onChange = () => { needsUpdateDefines = true; };
doLimit.onChange = updateLimit;
exe.onTriggered = doRender;
exe.onLinkChanged = function ()
{
    if (!exe.isLinked()) removeModule();
};

updateLimit();

inRot.onChange =
inScales.onChange =
inTranslates.onChange =
inRotMeth.onChange =
    function ()
    {
        arrayChangedTrans = true;
        recalc = true;
    };

inTexCoords.onChange = function ()
{
    arrayChangedTexcoords = true;
    recalc = true;
    needsUpdateDefines = true;
};

inColor.onChange = function ()
{
    arrayChangedColor = true;
    recalc = true;
    needsUpdateDefines = true;
};

function reset()
{
    arrayChangedColor = true,
    arrayChangedTrans = true;
    recalc = true;
}

function updateDefines()
{
    mod.toggleDefine("COLORIZE_INSTANCES", inColor.get());
    mod.toggleDefine("TEXCOORDS_INSTANCES", inTexCoords.get());
    mod.toggleDefine("BLEND_MODE_MULTIPLY", inBlendMode.get() === "Multiply");
    mod.toggleDefine("BLEND_MODE_ADD", inBlendMode.get() === "Add");
    mod.toggleDefine("BLEND_MODE_NONE", inBlendMode.get() === "Normal");
    needsUpdateDefines = false;
}

geom.onChange = function ()
{
    if (mesh)mesh.dispose();
    if (!geom.get())
    {
        mesh = null;
        return;
    }

    mesh = new CGL.Mesh(cgl, geom.get());
    reset();
};

function removeModule()
{

}

function setupArray()
{
    if (!mesh) return;

    let transforms = inTranslates.get();
    if (!transforms) transforms = [0, 0, 0];

    num = Math.floor(transforms.length / 3);

    if (needsUpdateDefines)updateDefines();

    const colArr = inColor.get();
    const tcArr = inTexCoords.get();
    const scales = inScales.get();
    const useQuats = inRotMeth.get() == "Quaternions";
    const useNormals = inRotMeth.get() == "Normals";

    let stride = 3;
    if (useQuats)stride = 4;
    inRot.setUiAttribs({ "stride": stride });

    if (matrixArray.length != num * 16) matrixArray = new Float32Array(num * 16);
    if (instColorArray.length != num * 4)
    {
        arrayChangedColor = true;
        instColorArray = new Float32Array(num * 4);
    }
    if (instTexcoordArray.length != num * 4)
    {
        arrayChangedTexcoords = true;
        instTexcoordArray = new Float32Array(num * 4);
    }

    const rotArr = inRot.get();

    for (let i = 0; i < num; i++)
    {
        mat4.identity(m);

        mat4.translate(m, m,
            [
                transforms[i * 3],
                transforms[i * 3 + 1],
                transforms[i * 3 + 2]
            ]);

        if (rotArr)
        {
            if (useQuats)
            {
                const mq = mat4.create();
                const q = [rotArr[i * 4 + 0], rotArr[i * 4 + 1], rotArr[i * 4 + 2], rotArr[i * 4 + 3]];
                quat.normalize(q, q);
                mat4.fromQuat(mq, q);
                mat4.mul(m, m, mq);
            }
            if (useNormals)
            {
                // let q = quat.create();
                // if (rotArr[i + 1] > 0.99999)
                // {
                //     q.set(0, 0, 0, 1);
                // }
                // else if (rotArr[i + 1] < -0.99999)
                // {
                //     q.set(1, 0, 0, 0);
                // }
                // else
                // {
                //     let axis = vec3.create();
                //     vec3.set(axis, rotArr[i + 2], 0, -rotArr[i + 0]);
                //     vec3.normalize(axis, axis);
                //     let radians = Math.acos(rotArr[i + 1]);
                //     quat.setAxisAngle(q, axis, radians);
                // }

                // const mq = mat4.create();

                // quat.normalize(q, q);
                // mat4.fromQuat(mq, q);
                // mat4.mul(m, m, mq);
            }
            else
            {
                mat4.rotateX(m, m, rotArr[i * 3 + 0] * CGL.DEG2RAD);
                mat4.rotateY(m, m, rotArr[i * 3 + 1] * CGL.DEG2RAD);
                mat4.rotateZ(m, m, rotArr[i * 3 + 2] * CGL.DEG2RAD);
            }
        }

        if (arrayChangedColor && colArr)
        {
            instColorArray[i * 4 + 0] = colArr[i * 4 + 0];
            instColorArray[i * 4 + 1] = colArr[i * 4 + 1];
            instColorArray[i * 4 + 2] = colArr[i * 4 + 2];
            instColorArray[i * 4 + 3] = colArr[i * 4 + 3];
        }

        if (arrayChangedTexcoords && tcArr)
        {
            instTexcoordArray[i * 4 + 0] = tcArr[i * 4 + 0];
            instTexcoordArray[i * 4 + 1] = tcArr[i * 4 + 1];
            instTexcoordArray[i * 4 + 2] = tcArr[i * 4 + 2];
            instTexcoordArray[i * 4 + 3] = tcArr[i * 4 + 3];
        }

        if (scales && scales.length > i) mat4.scale(m, m, [scales[i * 3], scales[i * 3 + 1], scales[i * 3 + 2]]);
        else mat4.scale(m, m, [1, 1, 1]);

        for (let a = 0; a < 16; a++) matrixArray[i * 16 + a] = m[a];
    }

    mesh.numInstances = num;

    if (arrayChangedTrans) mesh.addAttribute("instMat", matrixArray, 16);
    if (arrayChangedColor) mesh.addAttribute("instColor", instColorArray, 4, { "instanced": true });
    if (arrayChangedTexcoords) mesh.addAttribute("instTexCoords", instTexcoordArray, 4, { "instanced": true });

    mod.toggleDefine("HAS_TEXCOORDS", tcArr);
    mod.toggleDefine("HAS_COLORS", colArr);

    arrayChangedColor = false;
    recalc = false;
}

function updateLimit()
{
    inLimit.setUiAttribs({ "greyout": !doLimit.get() });
}

function doRender()
{
    if (!mesh) return;
    if (recalc) setupArray();

    mod.bind();

    if (doLimit.get()) mesh.numInstances = Math.min(num, inLimit.get());
    else mesh.numInstances = num;

    outNum.set(this.name, mesh.numInstances);

    if (mesh.numInstances > 0) mesh.render(cgl.getShader());

    outTrigger.trigger();

    mod.unbind();
}


};

Ops.Gl.MeshInstancer_v4.prototype = new CABLES.Op();
CABLES.OPS["322d8c8d-851b-481d-9bee-ec1cf7d57a35"]={f:Ops.Gl.MeshInstancer_v4,objName:"Ops.Gl.MeshInstancer_v4"};




// **************************************************************
// 
// Ops.Gl.MeshMorph
// 
// **************************************************************

Ops.Gl.MeshMorph = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    NUMGEOMS = 16,
    render = op.inTrigger("render"),
    inMethod = op.inSwitch("Method", ["Auto Anim", "Interpolate Index", "Interpolate Indices"], "Auto Anim"),
    nextGeom = op.inValueInt("Geometry"),
    duration = op.inValue("Duration", 1.0),
    inIndex = op.inFloat("Index", 0),
    inIndex2 = op.inFloat("Index 2", 0),
    inFade = op.inFloatSlider("Fade", 0),
    finished = op.outBoolNum("Finished"),
    next = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const inGeoms = [];
let mesh = null;
let method_autoAnim = true;
let method_manualFade = false;
let method_interpolate = false;
let method_interpolate2 = false;
let oldGeom = 0;

const anim = new CABLES.Anim();
anim.clear();
const inEase = anim.createPort(op, "Easing", updateGeom);

window.meshsequencecounter = window.meshsequencecounter || 1;
window.meshsequencecounter++;
const prfx = String.fromCharCode(97 + window.meshsequencecounter);

const srcHeadVert = ""
    .endl() + "IN vec3 " + prfx + "attrMorphTargetA;"
    .endl() + "IN vec3 " + prfx + "attrMorphTargetB;"
    .endl();

const srcBodyVert = ""
    .endl() + "  pos = vec4(" + prfx + "attrMorphTargetA * MOD_fade + " + prfx + "attrMorphTargetB * (1.0 - MOD_fade), 1. );"

    .endl();

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addUniform("f", "MOD_fade", 1);
mod.addUniform("f", "MOD_doMorph", 1);
mod.addModule({
    "title": op.objName,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": srcHeadVert,
    "srcBodyVert": srcBodyVert
});

inIndex2.onChange =
    inIndex.onChange =
    nextGeom.onChange = updateGeom;
render.onTriggered = doRender;
inMethod.onChange = updateUi;
updateUi();

for (let i = 0; i < NUMGEOMS; i++)
{
    const inGeom = op.inObject("Geometry " + (i));
    inGeom.onChange = updateMeshes;
    inGeoms.push(inGeom);
}

function updateUi()
{
    method_interpolate = inMethod.get() == "Interpolate Index";
    method_autoAnim = inMethod.get() == "Auto Anim";
    method_interpolate2 = inMethod.get() == "Interpolate Indices";

    duration.setUiAttribs({ "greyout": !method_autoAnim });
    nextGeom.setUiAttribs({ "greyout": !(method_autoAnim || method_manualFade) });
    inIndex.setUiAttribs({ "greyout": !(method_interpolate || method_interpolate2) });
    inIndex2.setUiAttribs({ "greyout": !method_interpolate2 });
    inIndex2.setUiAttribs({ "greyout": !method_interpolate2 });
    inEase.setUiAttribs({ "greyout": !method_autoAnim });

    inFade.setUiAttribs({ "greyout": !(method_manualFade || method_interpolate2) });
}

function checkLength()
{
    op.setUiError("nosamelength", null);
    let oldGeomLength = 0;

    for (let i = 0; i < inGeoms.length; i++)
    {
        const geom = inGeoms[i].get();
        if (geom && geom._vertices)
        {
            if (oldGeomLength != 0 && oldGeomLength != geom._vertices.length) op.setUiError("nosamelength", "Geometries must have the same number of vertices!", 1);
            oldGeomLength = geom._vertices.length;
        }
    }
}

function updateMeshes()
{
    checkLength();
    if (mesh) return;

    for (let i = 0; i < inGeoms.length; i++)
    {
        const geom = inGeoms[i].get();
        if (geom && geom._vertices)
        {
            if (i === 0)
            {
                mesh = new CGL.Mesh(cgl, geom);

                mesh.addAttribute(prfx + "attrMorphTargetA", geom._vertices, 3);
                mesh.addAttribute(prfx + "attrMorphTargetB", geom._vertices, 3);
                updateGeom();
            }
        }
    }
}

function updateGeom()
{
    let geom1;
    let geom2;

    if (method_autoAnim || method_manualFade)
    {
        let getGeom = nextGeom.get();
        if (getGeom < 0) getGeom = 0;
        else if (getGeom >= NUMGEOMS) getGeom = NUMGEOMS;
        let temp = 0;

        if (oldGeom === getGeom) return;

        anim.clear();
        anim.setValue(op.patch.freeTimer.get(), 0);
        anim.setValue(op.patch.freeTimer.get() + duration.get(), 1,
            function ()
            {
                oldGeom = getGeom;
                finished.set(true);
            });
        finished.set(false);

        geom1 = inGeoms[oldGeom].get();
        geom2 = inGeoms[getGeom].get();

        if (method_manualFade)
        {
            if (inFade.get() != 0) geom2 = inGeoms[oldGeom].get();
            if (inFade.get() == 1) geom1 = inGeoms[getGeom].get();

            oldGeom = getGeom;
        }
    }

    if (method_interpolate2)
    {
        const b = Math.max(Math.floor(inIndex.get()), 0);
        const a = Math.min(Math.ceil(inIndex2.get()), NUMGEOMS);

        if (inGeoms[a]) geom1 = inGeoms[a].get();
        else geom1 = null;

        if (inGeoms[b]) geom2 = inGeoms[b].get();
        else geom2 = null;
    }

    if (method_interpolate)
    {
        const a = Math.max(Math.floor(inIndex.get()), 0);
        const b = Math.min(Math.ceil(inIndex.get()), NUMGEOMS);

        if (inGeoms[a]) geom1 = inGeoms[a].get();
        else geom1 = null;

        if (inGeoms[b]) geom2 = inGeoms[b].get();
        else geom2 = null;
    }

    if (mesh && geom1 && geom2 && geom1._vertices && geom2._vertices)
    {
        mesh.updateAttribute(prfx + "attrMorphTargetB", geom1._vertices);
        mesh.updateAttribute(prfx + "attrMorphTargetA", geom2._vertices);
    }
}

function doRender()
{
    if (method_autoAnim) mod.setUniformValue("MOD_fade", anim.getValue(op.patch.freeTimer.get()));
    else if (method_interpolate)
    {
        let f = inIndex.get() % 1;
        mod.setUniformValue("MOD_fade", f);
    }
    else if (method_manualFade) mod.setUniformValue("MOD_fade", inFade.get());
    else if (method_interpolate2) mod.setUniformValue("MOD_fade", inFade.get());

    if (mesh)
    {
        mod.bind();
        mesh.render(cgl.getShader());
        next.trigger();
        mod.unbind();
    }
}


};

Ops.Gl.MeshMorph.prototype = new CABLES.Op();
CABLES.OPS["41bc544e-a0c9-450b-b657-405d80b1298c"]={f:Ops.Gl.MeshMorph,objName:"Ops.Gl.MeshMorph"};




// **************************************************************
// 
// Ops.Gl.Meshes.CablesLogo
// 
// **************************************************************

Ops.Gl.Meshes.CablesLogo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    scale = op.inValue("Scale", 1),
    draw = op.inBool("Draw", true),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("Geometry");

const verts = [14.4166, 163.754, 0, 18.4809, 210.763, 0, 54.9491, 204.346, 0, 42.7849, 158.762, 0, 22.5453, 257.772, 0, 67.1133, 249.93, 0, 109.532, 234.597, 0, 89.7001, 191.777, 0, 69.8685, 148.956, 0, 121.577, 173.384, 0, 94.8187, 134.563, 0, 148.336, 212.204, 0, 185.332, 186.28, 0, 150.011, 149.481, 0, 116.915, 116.086, 0, 174.431, 120.383, 0, 135.438, 94.0268, 0, 213.424, 146.739, 0, 241.515, 107.197, 0, 193.515, 87.7918, 0, 149.882, 69.1061, 0, 205.939, 53.4095, 0, 159.743, 42.0425, 0, 252.134, 64.7765, 0, 259.112, 21.5601, 0, 211.953, 17.6223, 0, 164.793, 13.6845, 0, 211.807, -19.1835, 0, 164.803, -15.1197, 0, 258.81, -23.2474, 0, 251.027, -67.8259, 0, 205.438, -55.6602, 0, 159.849, -43.4946, 0, 192.786, -90.46, 0, 150.007, -70.5651, 0, 235.565, -110.355, 0, 213.005, -149.583, 0, 174.326, -122.559, 0, 135.648, -95.5346, 0, 150.535, -150.933, 0, 117.14, -117.606, 0, 183.929, -184.259, 0, 149.313, -213.406, 0, 122.21, -174.782, 0, 95.1064, -136.159, 0, 90.1486, -193.307, 0, 70.1663, -150.569, 0, 110.131, -236.046, 0, 67.6335, -251.595, 0, 55.3747, -206.031, 0, 43.116, -160.467, 0, 18.9111, -212.474, 0, 14.7512, -165.479, 0, 23.071, -259.469, 0, -22.1816, -259.545, 0, -18.1173, -212.536, 0, -14.0529, -165.527, 0, -54.5854, -206.119, 0, -42.4212, -160.536, 0, -66.7496, -251.703, 0, -108.973, -236.672, 0, -89.239, -193.701, 0, -69.5049, -150.73, 0, -120.824, -175.76, 0, -94.4551, -136.336, 0, -147.193, -215.185, 0, -183.41, -190.469, 0, -148.964, -152.339, 0, -116.552, -117.859, 0, -173.286, -123.476, 0, -135.074, -95.8, 0, -211.498, -151.152, 0, -239.586, -111.835, 0, -192.467, -90.79, 0, -149.518, -70.8793, 0, -205.184, -55.8988, 0, -159.38, -43.8157, 0, -250.988, -67.9818, 0, -258.553, -23.6913, 0, -211.491, -19.5745, 0, -164.429, -15.4577, 0, -211.443, 17.4104, 0, -164.439, 13.3465, 0, -258.446, 21.4742, 0, -250.664, 66.0527, 0, -205.075, 53.8871, 0, -159.486, 41.7214, 0, -192.423, 88.6869, 0, -149.644, 68.7919, 0, -235.201, 108.582, 0, -212.641, 147.81, 0, -173.962, 120.786, 0, -135.284, 93.7614, 0, -150.171, 149.16, 0, -116.777, 115.833, 0, -183.566, 182.486, 0, -148.949, 211.632, 0, -121.846, 173.009, 0, -94.7427, 134.385, 0, -89.7849, 191.534, 0, -69.8026, 148.796, 0, -109.767, 234.272, 0, -67.2698, 249.822, 0, -55.011, 204.258, 0, -42.7523, 158.694, 0, -18.5474, 210.7, 0, -14.3875, 163.705, 0, -22.7074, 257.695, 0, 22.5453, 257.772, 0, 18.4809, 210.763, 0, 14.4166, 163.754, 0, 256.822, 264.163, 0, 296.476, 236.296, 0, 276.952, 212.586, 0, 276.952, 212.586, 0, 240.805, 244.919, 0, 256.822, 264.163, 0, 336.13, 208.429, 0, 313.099, 180.253, 0, 276.952, 212.586, 0, 276.952, 212.586, 0, 296.476, 236.296, 0, 336.13, 208.429, 0, 288.309, 152.686, 0, 255.898, 189.327, 0, 313.099, 180.253, 0, 223.486, 225.968, 0, 240.805, 244.919, 0, 285.635, 306.513, 0, 328.243, 283.496, 0, 313.087, 259.335, 0, 313.087, 259.335, 0, 271.643, 284.706, 0, 285.635, 306.513, 0, 370.852, 260.478, 0, 354.53, 233.964, 0, 313.087, 259.335, 0, 313.087, 259.335, 0, 328.243, 283.496, 0, 370.852, 260.478, 0, 336.13, 208.429, 0, 296.476, 236.296, 0, 354.53, 233.964, 0, 336.13, 208.429, 0, 256.822, 264.163, 0, 271.643, 284.706, 0, 296.476, 236.296, 0, 256.822, 264.163, 0, 311.134, 352.806, 0, 357.268, 338.992, 0, 343.405, 310.57, 0, 343.405, 310.57, 0, 299.162, 329.55, 0, 311.134, 352.806, 0, 403.403, 325.177, 0, 387.649, 291.589, 0, 343.405, 310.57, 0, 343.405, 310.57, 0, 357.268, 338.992, 0, 403.403, 325.177, 0, 370.852, 260.478, 0, 328.243, 283.496, 0, 387.649, 291.589, 0, 370.852, 260.478, 0, 285.635, 306.513, 0, 299.162, 329.55, 0, 328.243, 283.496, 0, 285.635, 306.513, 0, 328.173, 398.813, 0, 377.479, 395.259, 0, 368.527, 367.195, 0, 368.527, 367.195, 0, 320.46, 375.27, 0, 328.173, 398.813, 0, 426.784, 391.705, 0, 416.594, 359.12, 0, 368.527, 367.195, 0, 368.527, 367.195, 0, 377.479, 395.259, 0, 426.784, 391.705, 0, 403.403, 325.177, 0, 357.268, 338.992, 0, 416.594, 359.12, 0, 403.403, 325.177, 0, 311.134, 352.806, 0, 320.46, 375.27, 0, 357.268, 338.992, 0, 311.134, 352.806, 0, 341.169, 453.101, 0, 389.523, 451.215, 0, 384.421, 423.263, 0, 384.421, 423.263, 0, 335.304, 425.309, 0, 341.169, 453.101, 0, 437.877, 449.328, 0, 433.538, 421.218, 0, 384.421, 423.263, 0, 384.421, 423.263, 0, 389.523, 451.215, 0, 437.877, 449.328, 0, 426.784, 391.705, 0, 377.479, 395.259, 0, 433.538, 421.218, 0, 426.784, 391.705, 0, 328.173, 398.813, 0, 335.304, 425.309, 0, 377.479, 395.259, 0, 328.173, 398.813, 0, 347.768, 502.233, 0, 394.824, 501.411, 0, 392.954, 479.119, 0, 392.954, 479.119, 0, 345.086, 480.533, 0, 347.768, 502.233, 0, 441.88, 500.589, 0, 440.822, 477.705, 0, 392.954, 479.119, 0, 392.954, 479.119, 0, 394.824, 501.411, 0, 441.88, 500.589, 0, 437.877, 449.328, 0, 389.523, 451.215, 0, 440.822, 477.705, 0, 437.877, 449.328, 0, 341.169, 453.101, 0, 345.086, 480.533, 0, 389.523, 451.215, 0, 341.169, 453.101, 0, 352.384, 517.252, 0, 394.985, 517.267, 0, 395.241, 512.525, 0, 395.241, 512.525, 0, 349.927, 512.83, 0, 352.384, 517.252, 0, 437.585, 517.282, 0, 440.555, 512.22, 0, 395.241, 512.525, 0, 395.241, 512.525, 0, 394.985, 517.267, 0, 437.585, 517.282, 0, 441.88, 500.589, 0, 394.824, 501.411, 0, 440.555, 512.22, 0, 441.88, 500.589, 0, 347.768, 502.233, 0, 349.927, 512.83, 0, 394.824, 501.411, 0, 347.768, 502.233, 0, 360.098, 522.975, 0, 394.737, 522.834, 0, 394.834, 520.442, 0, 394.834, 520.442, 0, 355.961, 520.425, 0, 360.098, 522.975, 0, 429.375, 522.693, 0, 433.707, 520.459, 0, 394.834, 520.442, 0, 394.834, 520.442, 0, 394.737, 522.834, 0, 429.375, 522.693, 0, 437.585, 517.282, 0, 394.985, 517.267, 0, 433.707, 520.459, 0, 437.585, 517.282, 0, 355.961, 520.425, 0, 394.834, 520.442, 0, 394.985, 517.267, 0, 352.384, 517.252, 0, 185.332, 186.28, 0, 204.761, 206.303, 0, 234.697, 167.64, 0, 213.424, 146.739, 0, 264.633, 128.977, 0, 241.515, 107.197, 0, -255.099, -268.612, 0, -294.753, -240.745, 0, -275.229, -217.035, 0, -275.229, -217.035, 0, -239.082, -249.368, 0, -255.099, -268.612, 0, -334.408, -212.878, 0, -311.376, -184.702, 0, -275.229, -217.035, 0, -275.229, -217.035, 0, -294.753, -240.745, 0, -334.408, -212.878, 0, -286.56, -157.158, 0, -254.149, -193.771, 0, -311.376, -184.702, 0, -221.739, -230.385, 0, -239.082, -249.368, 0, -283.912, -310.962, 0, -326.521, -287.944, 0, -311.364, -263.784, 0, -311.364, -263.784, 0, -269.92, -289.154, 0, -283.912, -310.962, 0, -369.129, -264.927, 0, -352.807, -238.413, 0, -311.364, -263.784, 0, -311.364, -263.784, 0, -326.521, -287.944, 0, -369.129, -264.927, 0, -334.408, -212.878, 0, -294.753, -240.745, 0, -352.807, -238.413, 0, -334.408, -212.878, 0, -255.099, -268.612, 0, -269.92, -289.154, 0, -294.753, -240.745, 0, -255.099, -268.612, 0, -309.411, -357.255, 0, -355.546, -343.44, 0, -341.683, -315.018, 0, -341.683, -315.018, 0, -297.439, -333.999, 0, -309.411, -357.255, 0, -401.681, -329.626, 0, -385.927, -296.038, 0, -341.683, -315.018, 0, -341.683, -315.018, 0, -355.546, -343.44, 0, -401.681, -329.626, 0, -369.129, -264.927, 0, -326.521, -287.944, 0, -385.927, -296.038, 0, -369.129, -264.927, 0, -283.912, -310.962, 0, -297.439, -333.999, 0, -326.521, -287.944, 0, -283.912, -310.962, 0, -326.45, -403.262, 0, -375.756, -399.708, 0, -366.804, -371.644, 0, -366.804, -371.644, 0, -318.737, -379.718, 0, -326.45, -403.262, 0, -425.061, -396.154, 0, -414.871, -363.569, 0, -366.804, -371.644, 0, -366.804, -371.644, 0, -375.756, -399.708, 0, -425.061, -396.154, 0, -401.681, -329.626, 0, -355.546, -343.44, 0, -414.871, -363.569, 0, -401.681, -329.626, 0, -309.411, -357.255, 0, -318.737, -379.718, 0, -355.546, -343.44, 0, -309.411, -357.255, 0, -339.446, -457.55, 0, -387.8, -455.663, 0, -382.698, -427.712, 0, -382.698, -427.712, 0, -333.581, -429.758, 0, -339.446, -457.55, 0, -436.154, -453.776, 0, -431.815, -425.666, 0, -382.698, -427.712, 0, -382.698, -427.712, 0, -387.8, -455.663, 0, -436.154, -453.776, 0, -425.061, -396.154, 0, -375.756, -399.708, 0, -431.815, -425.666, 0, -425.061, -396.154, 0, -326.45, -403.262, 0, -333.581, -429.758, 0, -375.756, -399.708, 0, -326.45, -403.262, 0, -346.045, -506.682, 0, -393.101, -505.86, 0, -391.232, -483.568, 0, -391.232, -483.568, 0, -343.363, -484.982, 0, -346.045, -506.682, 0, -440.157, -505.037, 0, -439.1, -482.153, 0, -391.232, -483.568, 0, -391.232, -483.568, 0, -393.101, -505.86, 0, -440.157, -505.037, 0, -436.154, -453.776, 0, -387.8, -455.663, 0, -439.1, -482.153, 0, -436.154, -453.776, 0, -339.446, -457.55, 0, -343.363, -484.982, 0, -387.8, -455.663, 0, -339.446, -457.55, 0, -350.661, -521.701, 0, -393.262, -521.716, 0, -393.518, -516.974, 0, -393.518, -516.974, 0, -348.204, -517.279, 0, -350.661, -521.701, 0, -435.862, -521.731, 0, -438.832, -516.669, 0, -393.518, -516.974, 0, -393.518, -516.974, 0, -393.262, -521.716, 0, -435.862, -521.731, 0, -440.157, -505.037, 0, -393.101, -505.86, 0, -438.832, -516.669, 0, -440.157, -505.037, 0, -346.045, -506.682, 0, -348.204, -517.279, 0, -393.101, -505.86, 0, -346.045, -506.682, 0, -358.375, -527.424, 0, -393.014, -527.283, 0, -393.111, -524.891, 0, -393.111, -524.891, 0, -354.238, -524.874, 0, -358.375, -527.424, 0, -427.653, -527.142, 0, -431.985, -524.908, 0, -393.111, -524.891, 0, -393.111, -524.891, 0, -393.014, -527.283, 0, -427.653, -527.142, 0, -435.862, -521.731, 0, -393.262, -521.716, 0, -431.985, -524.908, 0, -435.862, -521.731, 0, -354.238, -524.874, 0, -393.111, -524.891, 0, -393.262, -521.716, 0, -350.661, -521.701, 0, -183.41, -190.469, 0, -202.939, -210.621, 0, -232.873, -172.071, 0, -211.498, -151.152, 0, -262.807, -133.52, 0, -239.586, -111.835, 0];
const indices = [0, 1, 2, 2, 3, 0, 2, 1, 4, 4, 5, 2, 6, 7, 2, 2, 5, 6, 8, 3, 2, 2, 7, 8, 6, 11, 9, 9, 7, 6, 8, 7, 9, 9, 10, 8, 12, 13, 9, 9, 11, 12, 14, 10, 9, 9, 13, 14, 12, 17, 15, 15, 13, 12, 14, 13, 15, 15, 16, 14, 18, 19, 15, 15, 17, 18, 20, 16, 15, 15, 19, 20, 18, 23, 21, 21, 19, 18, 20, 19, 21, 21, 22, 20, 24, 25, 21, 21, 23, 24, 26, 22, 21, 21, 25, 26, 24, 29, 27, 27, 25, 24, 26, 25, 27, 27, 28, 26, 30, 31, 27, 27, 29, 30, 32, 28, 27, 27, 31, 32, 30, 35, 33, 33, 31, 30, 32, 31, 33, 33, 34, 32, 36, 37, 33, 33, 35, 36, 38, 34, 33, 33, 37, 38, 36, 41, 39, 39, 37, 36, 38, 37, 39, 39, 40, 38, 42, 43, 39, 39, 41, 42, 44, 40, 39, 39, 43, 44, 42, 47, 45, 45, 43, 42, 44, 43, 45, 45, 46, 44, 48, 49, 45, 45, 47, 48, 50, 46, 45, 45, 49, 50, 48, 53, 51, 51, 49, 48, 50, 49, 51, 51, 52, 50, 54, 55, 51, 51, 53, 54, 56, 52, 51, 51, 55, 56, 54, 59, 57, 57, 55, 54, 56, 55, 57, 57, 58, 56, 60, 61, 57, 57, 59, 60, 62, 58, 57, 57, 61, 62, 60, 65, 63, 63, 61, 60, 62, 61, 63, 63, 64, 62, 66, 67, 63, 63, 65, 66, 68, 64, 63, 63, 67, 68, 66, 71, 69, 69, 67, 66, 68, 67, 69, 69, 70, 68, 72, 73, 69, 69, 71, 72, 74, 70, 69, 69, 73, 74, 72, 77, 75, 75, 73, 72, 74, 73, 75, 75, 76, 74, 78, 79, 75, 75, 77, 78, 80, 76, 75, 75, 79, 80, 78, 83, 81, 81, 79, 78, 80, 79, 81, 81, 82, 80, 84, 85, 81, 81, 83, 84, 86, 82, 81, 81, 85, 86, 84, 89, 87, 87, 85, 84, 86, 85, 87, 87, 88, 86, 90, 91, 87, 87, 89, 90, 92, 88, 87, 87, 91, 92, 90, 95, 93, 93, 91, 90, 92, 91, 93, 93, 94, 92, 96, 97, 93, 93, 95, 96, 98, 94, 93, 93, 97, 98, 96, 101, 99, 99, 97, 96, 98, 97, 99, 99, 100, 98, 102, 103, 99, 99, 101, 102, 104, 100, 99, 99, 103, 104, 102, 107, 105, 105, 103, 102, 104, 103, 105, 105, 106, 104, 108, 109, 105, 105, 107, 108, 110, 106, 105, 105, 109, 110, 111, 112, 113, 123, 124, 113, 113, 125, 123, 126, 127, 113, 113, 124, 126, 123, 272, 270, 270, 124, 123, 126, 124, 270, 270, 269, 126, 268, 269, 270, 270, 271, 268, 273, 271, 270, 270, 272, 273, 114, 115, 116, 117, 118, 119, 120, 121, 122, 128, 129, 130, 130, 142, 143, 131, 132, 133, 140, 141, 131, 134, 135, 136, 136, 146, 147, 137, 138, 139, 144, 145, 137, 148, 149, 150, 150, 162, 163, 151, 152, 153, 160, 161, 151, 154, 155, 156, 156, 166, 167, 157, 158, 159, 164, 165, 157, 168, 169, 170, 170, 182, 183, 171, 172, 173, 180, 181, 171, 174, 175, 176, 176, 186, 187, 177, 178, 179, 184, 185, 177, 188, 189, 190, 190, 202, 203, 191, 192, 193, 200, 201, 191, 194, 195, 196, 196, 206, 207, 197, 198, 199, 204, 205, 197, 208, 209, 210, 210, 222, 223, 211, 212, 213, 220, 221, 211, 214, 215, 216, 216, 226, 227, 217, 218, 219, 224, 225, 217, 228, 229, 230, 228, 264, 250, 230, 242, 243, 248, 249, 250, 250, 262, 263, 231, 232, 233, 240, 241, 231, 234, 235, 236, 236, 246, 247, 237, 238, 239, 244, 245, 237, 251, 252, 253, 260, 261, 251, 254, 255, 256, 257, 258, 259, 265, 266, 267, 274, 275, 276, 286, 287, 276, 276, 288, 286, 289, 290, 276, 276, 287, 289, 286, 435, 433, 433, 287, 286, 289, 287, 433, 433, 432, 289, 431, 432, 433, 433, 434, 431, 436, 434, 433, 433, 435, 436, 277, 278, 279, 280, 281, 282, 283, 284, 285, 291, 292, 293, 293, 305, 306, 294, 295, 296, 303, 304, 294, 297, 298, 299, 299, 309, 310, 300, 301, 302, 307, 308, 300, 311, 312, 313, 313, 325, 326, 314, 315, 316, 323, 324, 314, 317, 318, 319, 319, 329, 330, 320, 321, 322, 327, 328, 320, 331, 332, 333, 333, 345, 346, 334, 335, 336, 343, 344, 334, 337, 338, 339, 339, 349, 350, 340, 341, 342, 347, 348, 340, 351, 352, 353, 353, 365, 366, 354, 355, 356, 363, 364, 354, 357, 358, 359, 359, 369, 370, 360, 361, 362, 367, 368, 360, 371, 372, 373, 373, 385, 386, 374, 375, 376, 383, 384, 374, 377, 378, 379, 379, 389, 390, 380, 381, 382, 387, 388, 380, 391, 392, 393, 391, 427, 413, 393, 405, 406, 411, 412, 413, 413, 425, 426, 394, 395, 396, 403, 404, 394, 397, 398, 399, 399, 409, 410, 400, 401, 402, 407, 408, 400, 414, 415, 416, 423, 424, 414, 417, 418, 419, 420, 421, 422, 428, 429, 430];

let geom = new CGL.Geometry(op.name);
let mesh = null;
scale.onChange = build;
build();

function build()
{
    let sc = scale.get();
    let vertices = verts.slice(0);

    for (let i = 0; i < vertices.length; i++) vertices[i] = vertices[i] / 1000 * sc;

    geom.vertices = vertices;
    geom.mapTexCoords2d();
    geom.verticesIndices = indices;
    geom.tangents = vertices.map(function (v, i) { return i % 3 == 0 ? 1 : 0; });
    geom.biTangents = vertices.map(function (v, i) { return i % 3 == 1 ? 1 : 0; });
    geom.vertexNormals = vertices.map(function (v, i) { return i % 3 == 2 ? 1 : 0; });
    geomOut.set(null);
    geomOut.set(geom);

    if (!mesh)mesh = new CGL.Mesh(op.patch.cgl, geom);
    else mesh.setGeom(geom);
}

render.onTriggered = function ()
{
    if (draw.get())
        mesh.render(op.patch.cgl.getShader());
    trigger.trigger();
};


};

Ops.Gl.Meshes.CablesLogo.prototype = new CABLES.Op();
CABLES.OPS["d53b5d7b-99b5-420e-b5a1-2d7c2c1f1ebb"]={f:Ops.Gl.Meshes.CablesLogo,objName:"Ops.Gl.Meshes.CablesLogo"};




// **************************************************************
// 
// Ops.Gl.Meshes.Circle
// 
// **************************************************************

Ops.Gl.Meshes.Circle = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    radius = op.inValue("radius", 0.5),
    innerRadius = op.inValueSlider("innerRadius", 0),
    segments = op.inValueInt("segments", 40),
    percent = op.inValueSlider("percent", 1),
    steps = op.inValue("steps", 0),
    invertSteps = op.inValueBool("invertSteps", false),
    mapping = op.inSwitch("mapping", ["flat", "round"]),
    drawSpline = op.inValueBool("Spline", false),
    inDraw = op.inValueBool("Draw", true),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("geometry", null, "geometry");

op.setPortGroup("Size", [radius, innerRadius]);
op.setPortGroup("Display", [percent, steps, invertSteps]);

mapping.set("flat");

mapping.onChange =
    segments.onChange =
    radius.onChange =
    innerRadius.onChange =
    percent.onChange =
    steps.onChange =
    invertSteps.onChange =
    drawSpline.onChange = calcLater;

geomOut.ignoreValueSerialize = true;
const cgl = op.patch.cgl;

let geom = new CGL.Geometry("circle");
let mesh = null;
const lastSegs = -1;

let oldPrim = 0;
let shader = null;
let needsCalc = true;

render.onTriggered = renderMesh;

op.preRender = () =>
{
    renderMesh();
};

function renderMesh()
{
    if (!CGL.TextureEffect.checkOpNotInTextureEffect(op)) return;

    if (needsCalc)calc();
    shader = cgl.getShader();
    if (!shader) return;
    oldPrim = shader.glPrimitive;

    if (drawSpline.get()) shader.glPrimitive = cgl.gl.LINE_STRIP;

    if (inDraw.get())mesh.render(shader);
    trigger.trigger();

    shader.glPrimitive = oldPrim;
}

function calc()
{
    const segs = Math.max(3, Math.floor(segments.get()));

    geom.clear();

    const faces = [];
    const texCoords = [];
    const vertexNormals = [];
    const tangents = [];
    const biTangents = [];

    let i = 0, degInRad = 0;
    let oldPosX = 0, oldPosY = 0;
    let oldPosXTexCoord = 0, oldPosYTexCoord = 0;

    let oldPosXIn = 0, oldPosYIn = 0;
    let oldPosXTexCoordIn = 0, oldPosYTexCoordIn = 0;

    let posxTexCoordIn = 0, posyTexCoordIn = 0;
    let posxTexCoord = 0, posyTexCoord = 0;
    let posx = 0, posy = 0;

    const perc = Math.max(0.0, percent.get());
    const verts = [];

    if (drawSpline.get())
    {
        let lastX = 0;
        let lastY = 0;
        const tc = [];
        for (i = 0; i <= segs * perc; i++)
        {
            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            posyTexCoord = 0.5;

            if (i > 0)
            {
                verts.push(lastX);
                verts.push(lastY);
                verts.push(0);
                posxTexCoord = 1.0 - (i - 1) / segs;

                tc.push(posxTexCoord, posyTexCoord);
            }
            verts.push(posx);
            verts.push(posy);
            verts.push(0);

            lastX = posx;
            lastY = posy;
        }
        geom.setPointVertices(verts);
    }
    else
    if (innerRadius.get() <= 0)
    {
        for (i = 0; i <= segs * perc; i++)
        {
            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            if (mapping.get() == "flat")
            {
                posxTexCoord = (Math.cos(degInRad) + 1.0) / 2;
                posyTexCoord = 1.0 - (Math.sin(degInRad) + 1.0) / 2;
                posxTexCoordIn = 0.5;
                posyTexCoordIn = 0.5;
            }
            else if (mapping.get() == "round")
            {
                posxTexCoord = 1.0 - i / segs;
                posyTexCoord = 0;
                posxTexCoordIn = posxTexCoord;
                posyTexCoordIn = 1;
            }

            faces.push(
                [posx, posy, 0],
                [oldPosX, oldPosY, 0],
                [0, 0, 0]
            );

            texCoords.push(posxTexCoord, posyTexCoord, oldPosXTexCoord, oldPosYTexCoord, posxTexCoordIn, posyTexCoordIn);
            vertexNormals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
            tangents.push(1, 0, 0, 1, 0, 0, 1, 0, 0);
            biTangents.push(0, 1, 0, 0, 1, 0, 0, 1, 0);

            oldPosXTexCoord = posxTexCoord;
            oldPosYTexCoord = posyTexCoord;

            oldPosX = posx;
            oldPosY = posy;
        }

        geom = CGL.Geometry.buildFromFaces(faces, "circle");
        geom.vertexNormals = vertexNormals;
        geom.tangents = tangents;
        geom.biTangents = biTangents;
        geom.texCoords = texCoords;
    }
    else
    {
        let count = 0;
        const numSteps = segs * perc;
        const pos = 0;

        for (i = 0; i <= numSteps; i++)
        {
            count++;

            degInRad = (360 / segs) * i * CGL.DEG2RAD;
            posx = Math.cos(degInRad) * radius.get();
            posy = Math.sin(degInRad) * radius.get();

            const posxIn = Math.cos(degInRad) * innerRadius.get() * radius.get();
            const posyIn = Math.sin(degInRad) * innerRadius.get() * radius.get();

            if (mapping.get() == "round")
            {
                posxTexCoord = 1.0 - i / segs;
                posyTexCoord = 0;
                posxTexCoordIn = posxTexCoord;
                posyTexCoordIn = 1;
            }

            if (steps.get() === 0.0 ||
                (count % parseInt(steps.get(), 10) === 0 && !invertSteps.get()) ||
                (count % parseInt(steps.get(), 10) !== 0 && invertSteps.get()))
            {
                faces.push(
                    [posx, posy, 0],
                    [oldPosX, oldPosY, 0],
                    [posxIn, posyIn, 0]
                );

                faces.push(
                    [posxIn, posyIn, 0],
                    [oldPosX, oldPosY, 0],
                    [oldPosXIn, oldPosYIn, 0]
                );

                texCoords.push(
                    posxTexCoord, 0,
                    oldPosXTexCoord, 0,
                    posxTexCoordIn, 1,

                    posxTexCoord, 1,
                    oldPosXTexCoord, 0,
                    oldPosXTexCoordIn, 1);

                vertexNormals.push(
                    0, 0, 1, 0, 0, 1, 0, 0, 1,
                    0, 0, 1, 0, 0, 1, 0, 0, 1
                );
                tangents.push(
                    1, 0, 0, 1, 0, 0, 1, 0, 0,
                    1, 0, 0, 1, 0, 0, 1, 0, 0
                );
                biTangents.push(
                    0, 1, 0, 0, 1, 0, 0, 1, 0,
                    0, 1, 0, 0, 1, 0, 0, 1, 0
                );
            }

            oldPosXTexCoordIn = posxTexCoordIn;
            oldPosYTexCoordIn = posyTexCoordIn;

            oldPosXTexCoord = posxTexCoord;
            oldPosYTexCoord = posyTexCoord;

            oldPosX = posx;
            oldPosY = posy;

            oldPosXIn = posxIn;
            oldPosYIn = posyIn;
        }

        geom = CGL.Geometry.buildFromFaces(faces, "circle");
        geom.vertexNormals = vertexNormals;
        geom.tangents = tangents;
        geom.biTangents = biTangents;

        if (mapping.get() == "flat") geom.mapTexCoords2d();
        else geom.texCoords = texCoords;
    }

    geomOut.set(null);
    geomOut.set(geom);

    if (geom.vertices.length == 0) return;
    if (mesh) mesh.dispose();
    mesh = null;
    mesh = new CGL.Mesh(cgl, geom);
    needsCalc = false;
}

function calcLater()
{
    needsCalc = true;
}

op.onDelete = function ()
{
    if (mesh)mesh.dispose();
};


};

Ops.Gl.Meshes.Circle.prototype = new CABLES.Op();
CABLES.OPS["4db917cc-2cef-43f4-83d5-38c4572fe943"]={f:Ops.Gl.Meshes.Circle,objName:"Ops.Gl.Meshes.Circle"};




// **************************************************************
// 
// Ops.Gl.Meshes.Cone
// 
// **************************************************************

Ops.Gl.Meshes.Cone = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// adapted from the FreeGLUT project
const
    render = op.inTrigger("render"),
    slices = op.inValue("slices", 32),
    stacks = op.inValue("stacks", 5),
    radius = op.inValue("radius", 1),
    height = op.inValue("height", 2),
    active = op.inValueBool("Active", true),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("geometry");

geomOut.ignoreValueSerialize = true;

const cgl = op.patch.cgl;
let mesh = null;
const geom = null;
let i = 0, j = 0, idx = 0, offset = 0;

let needsRebuild = true;

stacks.onChange = slices.onChange = radius.onChange = height.onChange = updateMeshLater;

function updateMeshLater()
{
    needsRebuild = true;
}

render.onTriggered = function ()
{
    if (needsRebuild) updateMesh();
    if (active.get() && mesh)
    {
        mesh.render(cgl.getShader());
    }
    else
    {
        trigger.trigger();
        return;
    }
    // mesh.render(cgl.getShader());
    trigger.trigger();
};

function updateMesh()
{
    let nstacks = Math.round(stacks.get());
    let nslices = Math.round(slices.get());
    if (nstacks < 1)nstacks = 1;
    if (nslices < 3)nslices = 3;
    const r = radius.get();
    generateCone(r, Math.max(0.01, height.get()), nstacks, nslices);
    needsRebuild = false;
}

function circleTable(n, halfCircle)
{
    let i;
    /* Table size, the sign of n flips the circle direction */
    const size = Math.abs(n);

    /* Determine the angle between samples */
    const angle = (halfCircle ? 1 : 2) * Math.PI / n;// ( n === 0 ) ? 1 : n ;

    /* Allocate memory for n samples, plus duplicate of first entry at the end */
    const sint = [];
    const cost = [];

    /* Compute cos and sin around the circle */
    sint[0] = 0.0;
    cost[0] = 1.0;

    for (i = 1; i < size; i++)
    {
        sint[i] = Math.sin(angle * i);
        cost[i] = Math.cos(angle * i);
    }

    if (halfCircle)
    {
        sint[size] = 0.0; /* sin PI */
        cost[size] = -1.0; /* cos PI */
    }
    else
    {
        /* Last sample is duplicate of the first (sin or cos of 2 PI) */
        sint[size] = sint[0];
        cost[size] = cost[0];
    }
    return { "cost": cost, "sint": sint };
}

function generateCone(base, height, stacks, slices)
{
    let r = base;
    let z = 0;
    const geom = new CGL.Geometry(op.name);
    geom.glPrimitive = cgl.gl.TRIANGLE_STRIP;
    geom.tangents = [];
    geom.biTangents = [];

    const table = circleTable(-slices + 1, false);

    const zStep = height / ((stacks > 0) ? stacks : 1);
    const rStep = base / ((stacks > 0) ? stacks : 1);

    /* Scaling factors for vertex normals */
    const cosn = (height / Math.sqrt(height * height + base * base));
    const sinn = (base / Math.sqrt(height * height + base * base));
    const texCoords = [];

    /* bottom */
    geom.vertices[0] = 0;
    geom.vertices[1] = 0;
    geom.vertices[2] = z;
    geom.vertexNormals[0] = 0;
    geom.vertexNormals[1] = 0;
    geom.vertexNormals[2] = -1;
    geom.tangents.push(1, 0, 0);
    geom.biTangents.push(0, 1, 0);

    idx = 3; // index carried over through all for loops - allows mesh buildup
    /* other on bottom (get normals right) */

    for (j = 0; j < slices; j++, idx += 3)
    {
        geom.vertices[idx] = table.cost[j] * r;
        geom.vertices[idx + 1] = table.sint[j] * r;
        geom.vertices[idx + 2] = z;
        geom.vertexNormals[idx] = 0;
        geom.vertexNormals[idx + 1] = 0;
        geom.vertexNormals[idx + 2] = -1;
        geom.tangents[idx] = 1;
        geom.tangents[idx + 1] = 0;
        geom.tangents[idx + 2] = 0;
        geom.biTangents[idx] = 0;
        geom.biTangents[idx + 1] = 1;
        geom.biTangents[idx + 2] = 0;
    }

    /* each stack */
    for (i = 0; i < stacks + 1; i++)
    {
        for (j = 0; j < slices; j++, idx += 3)
        {
            // gets texcoords from textured material
            // xyz converts to xy for uv
            texCoords[idx / 3 * 2] = 1 - j / slices;
            texCoords[idx / 3 * 2 + 1] = 1 - i / stacks;

            geom.vertices[idx] = table.cost[j] * r;
            geom.vertices[idx + 1] = table.sint[j] * r;
            geom.vertices[idx + 2] = z;
            geom.vertexNormals[idx] = table.cost[j] * cosn;
            geom.vertexNormals[idx + 1] = table.sint[j] * cosn;
            geom.vertexNormals[idx + 2] = sinn;
            geom.tangents[idx] = -table.sint[j] * cosn;
            geom.tangents[idx + 1] = table.cost[j] * cosn;
            geom.tangents[idx + 2] = sinn;
            geom.biTangents[idx] = table.sint[j] * cosn * sinn - table.cost[j] * cosn * sinn;
            geom.biTangents[idx + 1] = sinn * (-table.sint[j] * cosn) - sinn * table.cost[j] * cosn;
            geom.biTangents[idx + 2] = table.cost[j] * cosn * table.cost[j] * cosn - (-table.sint[j] * cosn) * table.sint[j] * cosn;
        }

        z += zStep;
        r -= rStep;
    }

    /* top stack - bottom section */
    for (j = 0, idx = 0; j < slices; j++, idx += 2)
    {
        // makes the texture cartopol
        texCoords[0] = (geom.vertices[0] / radius.get()) * 0.5 + 0.5;
        texCoords[1] = 1 - (geom.vertices[1] / radius.get()) * 0.5 + 0.5;

        texCoords[j * 2 + 0] = (geom.vertices[(j) * 3] / radius.get()) * 0.5 + 0.5;
        texCoords[j * 2 + 1] = 1 - (geom.vertices[(j) * 3 + 1] / radius.get()) * 0.5 + 0.5;

        geom.verticesIndices[idx] = 0;
        geom.verticesIndices[idx + 1] = j + 1; /* 0 is top vertex, 1 is first for first stack */
    }

    geom.verticesIndices[idx] = 0; /* repeat first slice's idx for closing off shape */
    geom.verticesIndices[idx + 1] = 1;

    texCoords[0] = (geom.vertices[0] / radius.get()) * 0.5 + 0.5;
    texCoords[1] = 1 - (geom.vertices[1] / radius.get()) * 0.5 + 0.5;

    texCoords[j * 2 + 0] = (geom.vertices[(j) * 3] / radius.get()) * 0.5 + 0.5;
    texCoords[j * 2 + 1] = 1 - (geom.vertices[(j) * 3 + 1] / radius.get()) * 0.5 + 0.5;

    idx += 2;

    /* middle stacks: */
    /* Strip indices are relative to first index belonging to strip, NOT relative to first vertex/normal pair in array */
    for (i = 0; i < stacks; i++, idx += 2)
    {
        offset = 1 + (i + 1) * slices; /* triangle_strip indices start at 1 (0 is top vertex), and we advance one stack down as we go along */
        for (j = 0; j < slices; j++, idx += 2)
        {
            geom.verticesIndices[idx] = offset + j;
            geom.verticesIndices[idx + 1] = offset + j + slices;
        }
        geom.verticesIndices[idx] = offset; /* repeat first slice's idx for closing off shape */
        geom.verticesIndices[idx + 1] = offset + slices;
    }

    geom.setTexCoords(texCoords);

    mesh = new CGL.Mesh(cgl, geom);
    geomOut.set(geom);
}


};

Ops.Gl.Meshes.Cone.prototype = new CABLES.Op();
CABLES.OPS["b67027f5-8f56-4aa0-8bb3-18d42ff15ffe"]={f:Ops.Gl.Meshes.Cone,objName:"Ops.Gl.Meshes.Cone"};




// **************************************************************
// 
// Ops.Gl.Meshes.Corner
// 
// **************************************************************

Ops.Gl.Meshes.Corner = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let render = op.inTrigger("Render");
let width = op.inValueFloat("Width", 1);
let height = op.inValueFloat("Height", 1);
let thickness = op.inValueFloat("Thickness", -0.1);
let dodraw = op.inValueBool("Draw", true);
let pivotX = op.inValueSelect("pivot x", ["center", "left", "right"]);
let pivotY = op.inValueSelect("pivot y", ["center", "top", "bottom"]);

let trigger = op.outTrigger("trigger");
let geomOut = op.outObject("Geometry");

op.setPortGroup("Size", [width, height]);
op.setPortGroup("Align", [pivotX, pivotY]);

let cgl = op.patch.cgl;
let mesh = null;
let geom = new CGL.Geometry(op.name);
geom.tangents = [];
geom.biTangents = [];

pivotX.set("center");
pivotY.set("center");

geomOut.ignoreValueSerialize = true;

width.onChange =
    pivotX.onChange =
    pivotY.onChange =
    height.onChange =
    thickness.onChange = create;

create();

render.onTriggered = function ()
{
    if (dodraw.get()) mesh.render(cgl.getShader());
    trigger.trigger();
};

function create()
{
    let w = width.get();
    let h = height.get();
    let x = -w / 2;
    let y = -h / 2;
    let th = thickness.get();

    let pivot = pivotX.get();
    if (pivot == "right") x = -w;
    else if (pivot == "left") x = 0;

    pivot = pivotY.get();
    if (pivot == "top") y = -w;
    else if (pivot == "bottom") y = 0;

    geom.vertices.length = 0;
    geom.vertices.push(
        x, y, 0,
        x + w, y, 0,
        x + w, y + h, 0,
        x, y + h, 0,
        x - th, y, 0,
        x + w + th, y - th, 0,
        x + w, y + h + th, 0,
        x - th, y + h + th, 0
    );

    if (geom.vertexNormals.length === 0) geom.vertexNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
    if (geom.tangents.length === 0) geom.tangents = [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0];
    if (geom.biTangents.length === 0) geom.biTangents = [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0];

    geom.verticesIndices = [7, 6, 3, 6, 2, 3, 0, 4, 3, 4, 7, 3];

    if (geom.texCoords.length === 0)
    {
        const tc = [];
        for (let i = 0; i < geom.vertices.length; i += 3)
        {
            tc[i / 3 * 2] = geom.vertices[i + 0] / w - 0.5;
            tc[i / 3 * 2 + 1] = geom.vertices[i + 1] / h - 0.5;
        }
        geom.texCoords = tc;
    }

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);

    geomOut.set(null);
    geomOut.set(geom);
}


};

Ops.Gl.Meshes.Corner.prototype = new CABLES.Op();
CABLES.OPS["7624c3bb-d22f-47f3-8581-2ecca73bb12f"]={f:Ops.Gl.Meshes.Corner,objName:"Ops.Gl.Meshes.Corner"};




// **************************************************************
// 
// Ops.Gl.Meshes.Cross
// 
// **************************************************************

Ops.Gl.Meshes.Cross = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    size = op.inValue("Size", 1),
    thick = op.inValue("Thickness", 0.25),
    target = op.inValueBool("Crosshair"),
    active = op.inValueBool("Active", true),

    trigger = op.outTrigger("Next"),
    geomOut = op.outObject("Geometry");

const cgl = op.patch.cgl;
let geom = null;
let mesh = null;

size.onChange =
    thick.onChange =
    target.onChange = buildMeshLater;

render.onTriggered = function ()
{
    if (!mesh)buildMesh();
    if (active.get() && mesh) mesh.render(cgl.getShader());
    trigger.trigger();
};

function buildMesh()
{
    if (!geom)geom = new CGL.Geometry("crossmesh");
    geom.clear();

    let ext = size.get() / 2.0;
    let thi = thick.get();

    if (thi < 0.0)
    {
        thi = 0.0;
    }
    else if (thi > ext)
    {
        thi = ext;
    }

    if (ext < 0.0)
    {
        ext = 0.0;
        thi = 0.0;
    }

    // center verts
    let cx = thi;
    let cy = thi;

    // o is outer verts from center
    let ox = ext;
    let oy = ext;

    geom.vertices = [
        // center piece
        -cx, -cy, 0, // 0
        -cx, cy, 0, // 1
        cx, cy, 0, // 2
        cx, -cy, 0, // 3

        // left piece
        -ox, -cy, 0, // 4
        -ox, cy, 0, // 5
        -cx, cy, 0, // 6
        -cx, -cy, 0, // 7

        // right piece
        cx, -cy, 0, // 8
        cx, cy, 0, // 9
        ox, cy, 0, // 10
        ox, -cy, 0, // 11

        // top piece
        -cx, cy, 0, // 12
        -cx, oy, 0, // 13
        cx, oy, 0, // 14
        cx, cy, 0, // 15

        // bottom piece
        -cx, -oy, 0, // 12
        -cx, -cy, 0, // 13
        cx, -cy, 0, // 14
        cx, -oy, 0 // 15
    ];

    let texCoords = [];
    texCoords.length = (geom.vertices.length / 3.0) * 2.0;

    for (let i = 0; i < geom.vertices.length; i += 3)
    {
        let vx = (geom.vertices[i] / (ox) + 1) / 2;
        let vy = (geom.vertices[i + 1] / (oy) + 1) / 2;
        let index = (i / 3.0) * 2.0;

        texCoords[index] = vx;
        texCoords[index + 1] = vy;
    }

    geom.setTexCoords(texCoords);
    geom.tangents = geom.vertices.map(function (v, i) { return i % 3 == 0 ? 1 : 0; });
    geom.biTangents = geom.vertices.map(function (v, i) { return i % 3 == 1 ? 1 : 0; });
    geom.vertexNormals = geom.vertices.map(function (v, i) { return i % 3 == 2 ? 1 : 0; });

    geom.vertexNormals = [
        // center piece
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,

        // left
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        // right
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        // top
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        // bottom
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0
    ];

    if (target.get() == true)
    {
        // draws a crosshair
        geom.verticesIndices = [
        // left
            4, 5, 6, 4, 6, 7,
            // right
            8, 9, 10, 8, 10, 11,
            // top
            12, 13, 14, 12, 14, 15,
            // bottom
            16, 17, 18, 16, 18, 19
        ];
    }
    else
    {
        // draws a solid cross
        geom.verticesIndices = [
        // center
            0, 1, 2, 0, 2, 3,
            // left
            4, 5, 6, 4, 6, 7,
            // right
            8, 9, 10, 8, 10, 11,
            // top
            12, 13, 14, 12, 14, 15,
            // bottom
            16, 17, 18, 16, 18, 19
        ];
    }

    mesh = new CGL.Mesh(cgl, geom);
    geomOut.set(null);
    geomOut.set(geom);
}

function buildMeshLater()
{
    if (mesh)mesh.dispose();
    mesh = null;
}


};

Ops.Gl.Meshes.Cross.prototype = new CABLES.Op();
CABLES.OPS["eab5773b-dd10-4617-a8a0-e3990b10477a"]={f:Ops.Gl.Meshes.Cross,objName:"Ops.Gl.Meshes.Cross"};




// **************************************************************
// 
// Ops.Gl.Meshes.Cube_v2
// 
// **************************************************************

Ops.Gl.Meshes.Cube_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    active = op.inValueBool("Render Mesh", true),
    width = op.inValue("Width", 1),
    len = op.inValue("Length", 1),
    height = op.inValue("Height", 1),
    center = op.inValueBool("Center", true),
    mapping = op.inSwitch("Mapping", ["Side", "Cube +-"], "Side"),
    mappingBias = op.inValue("Bias", 0),
    inFlipX = op.inValueBool("Flip X", true),
    sideTop = op.inValueBool("Top", true),
    sideBottom = op.inValueBool("Bottom", true),
    sideLeft = op.inValueBool("Left", true),
    sideRight = op.inValueBool("Right", true),
    sideFront = op.inValueBool("Front", true),
    sideBack = op.inValueBool("Back", true),
    trigger = op.outTrigger("Next"),
    geomOut = op.outObject("geometry", null, "geometry");

const cgl = op.patch.cgl;
op.toWorkPortsNeedToBeLinked(render);

op.setPortGroup("Mapping", [mapping, mappingBias, inFlipX]);
op.setPortGroup("Geometry", [width, height, len, center]);
op.setPortGroup("Sides", [sideTop, sideBottom, sideLeft, sideRight, sideFront, sideBack]);

let geom = null,
    mesh = null,
    meshvalid = true,
    needsRebuild = true;

mappingBias.onChange =
    inFlipX.onChange =
    sideTop.onChange =
    sideBottom.onChange =
    sideLeft.onChange =
    sideRight.onChange =
    sideFront.onChange =
    sideBack.onChange =
    mapping.onChange =
    width.onChange =
    height.onChange =
    len.onChange =
    center.onChange = buildMeshLater;

function buildMeshLater()
{
    needsRebuild = true;
}

render.onLinkChanged = function ()
{
    if (!render.isLinked())
    {
        geomOut.set(null);
        return;
    }
    buildMesh();
};

render.onTriggered = function ()
{
    if (needsRebuild)buildMesh();
    if (active.get() && mesh && meshvalid) mesh.render(cgl.getShader());
    trigger.trigger();
};

op.preRender = function ()
{
    buildMesh();
    mesh.render(cgl.getShader());
};

function buildMesh()
{
    if (!geom)geom = new CGL.Geometry("cubemesh");
    geom.clear();

    let x = width.get();
    let nx = -1 * width.get();
    let y = height.get();
    let ny = -1 * height.get();
    let z = len.get();
    let nz = -1 * len.get();

    if (!center.get())
    {
        nx = 0;
        ny = 0;
        nz = 0;
    }
    else
    {
        x *= 0.5;
        nx *= 0.5;
        y *= 0.5;
        ny *= 0.5;
        z *= 0.5;
        nz *= 0.5;
    }

    if (mapping.get() == "Side") sideMappedCube(geom, x, y, z, nx, ny, nz);
    else cubeMappedCube(geom, x, y, z, nx, ny, nz);

    geom.verticesIndices = [];
    if (sideTop.get()) geom.verticesIndices.push(8, 9, 10, 8, 10, 11); // Top face
    if (sideBottom.get()) geom.verticesIndices.push(12, 13, 14, 12, 14, 15); // Bottom face
    if (sideLeft.get()) geom.verticesIndices.push(20, 21, 22, 20, 22, 23); // Left face
    if (sideRight.get()) geom.verticesIndices.push(16, 17, 18, 16, 18, 19); // Right face
    if (sideBack.get()) geom.verticesIndices.push(4, 5, 6, 4, 6, 7); // Back face
    if (sideFront.get()) geom.verticesIndices.push(0, 1, 2, 0, 2, 3); // Front face

    if (geom.verticesIndices.length === 0) meshvalid = false;
    else meshvalid = true;

    if (mesh)mesh.dispose();
    mesh = new CGL.Mesh(cgl, geom);
    geomOut.set(null);
    geomOut.set(geom);

    needsRebuild = false;
}

op.onDelete = function ()
{
    if (mesh)mesh.dispose();
};

function sideMappedCube(geom, x, y, z, nx, ny, nz)
{
    geom.vertices = [
        // Front face
        nx, ny, z,
        x, ny, z,
        x, y, z,
        nx, y, z,
        // Back face
        nx, ny, nz,
        nx, y, nz,
        x, y, nz,
        x, ny, nz,
        // Top face
        nx, y, nz,
        nx, y, z,
        x, y, z,
        x, y, nz,
        // Bottom face
        nx, ny, nz,
        x, ny, nz,
        x, ny, z,
        nx, ny, z,
        // Right face
        x, ny, nz,
        x, y, nz,
        x, y, z,
        x, ny, z,
        // zeft face
        nx, ny, nz,
        nx, ny, z,
        nx, y, z,
        nx, y, nz
    ];

    const bias = mappingBias.get();

    let fone = 1.0;
    let fzero = 0.0;
    if (inFlipX.get())
    {
        fone = 0.0;
        fzero = 1.0;
    }

    geom.setTexCoords([
        // Front face
        fzero + bias, 1 - bias,
        fone - bias, 1 - bias,
        fone - bias, 0 + bias,
        fzero + bias, 0 + bias,
        // Back face
        fone - bias, 1 - bias,
        fone - bias, 0 + bias,
        fzero + bias, 0 + bias,
        fzero + bias, 1 - bias,
        // Top face
        fzero + bias, 0 + bias,
        fzero + bias, 1 - bias,
        fone - bias, 1 - bias,
        fone - bias, 0 + bias,
        // Bottom face
        fone - bias, 0 + bias,
        fzero + bias, 0 + bias,
        fzero + bias, 1 - bias,
        fone - bias, 1 - bias,
        // Right face
        fone - bias, 1 - bias,
        fone - bias, 0 + bias,
        fzero + bias, 0 + bias,
        fzero + bias, 1 - bias,
        // Left face
        fzero + bias, 1 - bias,
        fone - bias, 1 - bias,
        fone - bias, 0 + bias,
        fzero + bias, 0 + bias,
    ]);

    geom.vertexNormals = new Float32Array([
        // Front face
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,

        // Back face
        0.0, 0.0, -1.0,
        0.0, 0.0, -1.0,
        0.0, 0.0, -1.0,
        0.0, 0.0, -1.0,

        // Top face
        0.0, 1.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 1.0, 0.0,

        // Bottom face
        0.0, -1.0, 0.0,
        0.0, -1.0, 0.0,
        0.0, -1.0, 0.0,
        0.0, -1.0, 0.0,

        // Right face
        1.0, 0.0, 0.0,
        1.0, 0.0, 0.0,
        1.0, 0.0, 0.0,
        1.0, 0.0, 0.0,

        // Left face
        -1.0, 0.0, 0.0,
        -1.0, 0.0, 0.0,
        -1.0, 0.0, 0.0,
        -1.0, 0.0, 0.0
    ]);
    geom.tangents = new Float32Array([

        // front face
        -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
        // back face
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
        // top face
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
        // bottom face
        -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
        // right face
        0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
        // left face
        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1
    ]);
    geom.biTangents = new Float32Array([
        // front face
        0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
        // back face
        0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        // top face
        0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
        // bottom face
        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
        // right face
        0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        // left face
        0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0
    ]);
}

function cubeMappedCube(geom, x, y, z, nx, ny, nz)
{
    geom.vertices = [
        // Front face
        nx, ny, z,
        x, ny, z,
        x, y, z,
        nx, y, z,
        // Back face
        nx, ny, nz,
        nx, y, nz,
        x, y, nz,
        x, ny, nz,
        // Top face
        nx, y, nz,
        nx, y, z,
        x, y, z,
        x, y, nz,
        // Bottom face
        nx, ny, nz,
        x, ny, nz,
        x, ny, z,
        nx, ny, z,
        // Right face
        x, ny, nz,
        x, y, nz,
        x, y, z,
        x, ny, z,
        // zeft face
        nx, ny, nz,
        nx, ny, z,
        nx, y, z,
        nx, y, nz
    ];

    const sx = 0.25;
    const sy = 1 / 3;
    const bias = mappingBias.get();

    let flipx = 0.0;
    if (inFlipX.get()) flipx = 1.0;

    const tc = [];
    tc.push(
        // Front face   Z+
        flipx + sx + bias, sy * 2 - bias,
        flipx + sx * 2 - bias, sy * 2 - bias,
        flipx + sx * 2 - bias, sy + bias,
        flipx + sx + bias, sy + bias,
        // Back face Z-
        flipx + sx * 4 - bias, sy * 2 - bias,
        flipx + sx * 4 - bias, sy + bias,
        flipx + sx * 3 + bias, sy + bias,
        flipx + sx * 3 + bias, sy * 2 - bias);

    if (inFlipX.get())
        tc.push(
            // Top face
            sx + bias, 0 - bias,
            sx * 2 - bias, 0 - bias,
            sx * 2 - bias, sy * 1 + bias,
            sx + bias, sy * 1 + bias,
            // Bottom face
            sx + bias, sy * 3 + bias,
            sx + bias, sy * 2 - bias,
            sx * 2 - bias, sy * 2 - bias,
            sx * 2 - bias, sy * 3 + bias
        );

    else
        tc.push(
            // Top face
            sx + bias, 0 + bias,
            sx + bias, sy * 1 - bias,
            sx * 2 - bias, sy * 1 - bias,
            sx * 2 - bias, 0 + bias,
            // Bottom face
            sx + bias, sy * 3 - bias,
            sx * 2 - bias, sy * 3 - bias,
            sx * 2 - bias, sy * 2 + bias,
            sx + bias, sy * 2 + bias);

    tc.push(
        // Right face
        flipx + sx * 3 - bias, 1.0 - sy - bias,
        flipx + sx * 3 - bias, 1.0 - sy * 2 + bias,
        flipx + sx * 2 + bias, 1.0 - sy * 2 + bias,
        flipx + sx * 2 + bias, 1.0 - sy - bias,
        // Left face
        flipx + sx * 0 + bias, 1.0 - sy - bias,
        flipx + sx * 1 - bias, 1.0 - sy - bias,
        flipx + sx * 1 - bias, 1.0 - sy * 2 + bias,
        flipx + sx * 0 + bias, 1.0 - sy * 2 + bias);

    geom.setTexCoords(tc);

    geom.vertexNormals = [
        // Front face
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,

        // Back face
        0.0, 0.0, -1.0,
        0.0, 0.0, -1.0,
        0.0, 0.0, -1.0,
        0.0, 0.0, -1.0,

        // Top face
        0.0, 1.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 1.0, 0.0,

        // Bottom face
        0.0, -1.0, 0.0,
        0.0, -1.0, 0.0,
        0.0, -1.0, 0.0,
        0.0, -1.0, 0.0,

        // Right face
        1.0, 0.0, 0.0,
        1.0, 0.0, 0.0,
        1.0, 0.0, 0.0,
        1.0, 0.0, 0.0,

        // Left face
        -1.0, 0.0, 0.0,
        -1.0, 0.0, 0.0,
        -1.0, 0.0, 0.0,
        -1.0, 0.0, 0.0
    ];
    geom.tangents = new Float32Array([
        // front face
        -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
        // back face
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
        // top face
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
        // bottom face
        -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
        // right face
        0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
        // left face
        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1
    ]);
    geom.biTangents = new Float32Array([
        // front face
        0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
        // back face
        0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        // top face
        0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
        // bottom face
        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
        // right face
        0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        // left face
        0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0
    ]);
}


};

Ops.Gl.Meshes.Cube_v2.prototype = new CABLES.Op();
CABLES.OPS["37b92ba4-cea5-42ae-bf28-a513ca28549c"]={f:Ops.Gl.Meshes.Cube_v2,objName:"Ops.Gl.Meshes.Cube_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.Cylinder_v2
// 
// **************************************************************

Ops.Gl.Meshes.Cylinder_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inRender = op.inTrigger("render"),
    inDraw = op.inValueBool("Draw", true),
    inSegments = op.inValueInt("segments", 40),
    inStacks = op.inValueInt("stacks", 1),
    inLength = op.inValueFloat("length", 1),
    inOuterRadius = op.inValueFloat("outer radius", 0.5),
    inInnerRadius = op.inValueFloat("inner radius", 0),
    inUVMode = op.inValueSelect("UV mode", ["simple", "atlas"], "simple"),
    flipSideMapping = op.inValueBool("Flip Mapping", false),
    inCaps = op.inValueBool("Caps", true),
    inFlat = op.inValueBool("Flat Normals", false),
    outTrigger = op.outTrigger("next"),
    outGeometry = op.outObject("geometry"),
    geom = new CGL.Geometry("cylinder");

const
    TAU = Math.PI * 2,
    cgl = op.patch.cgl;

let needsRebuild = true;
let mesh = null;

inUVMode.setUiAttribs({ "hidePort": true });


op.preRender = buildMesh;

function buildMesh()
{
    const flipTex = flipSideMapping.get();

    const
        segments = Math.max(inSegments.get(), 3) | 0,
        innerRadius = Math.max(inInnerRadius.get(), 0),
        outerRadius = Math.max(inOuterRadius.get(), innerRadius),
        stacks = Math.max(inStacks.get(), inStacks.defaultValue) | 0,
        length = inLength.get(),
        stackLength = length / stacks,
        segmentRadians = TAU / segments,
        uvMode = inUVMode.get();
    let
        positions = [],
        normals = [],
        tangents = [],
        biTangents = [],
        texcoords = [],
        indices = [],
        x, y, z, i, j,
        a, d, o;
    if (uvMode == "atlas") o = 0.5;
    else o = 1;

    // for each stack
    for (
        i = 0, z = -length / 2;
        i <= stacks;
        i++, z += stackLength
    )
    {
        // for each segment
        for (
            j = a = 0;
            j <= segments;
            j++, a += segmentRadians
        )
        {
            positions.push(
                (x = Math.sin(a)) * outerRadius,
                (y = Math.cos(a)) * outerRadius,
                z
            );
            d = Math.sqrt(x * x + y * y);
            x /= d;
            y /= d;
            normals.push(x, y, 0);
            tangents.push(-y, x, 0);
            biTangents.push(0, 0, 1);

            if (flipTex)
                texcoords.push(
                    j / segments,
                    1.0 - ((z / length + 0.5) * o)
                );

            else
                texcoords.push(
                    (z / length + 0.5) * o,
                    j / segments
                );
        }
    }

    // create indices
    for (j = 0; j < stacks; j++)
    {
        for (
            i = 0, d = j * (segments + 1);
            i < segments;
            i++, d++
        )
        {
            a = d + 1;
            indices.push(
                d + (segments + 1), a, d,
                d + (segments + 1), a + (segments + 1), a
            );
        }
    }

    // create inner shell
    if (innerRadius)
    {
        d = positions.length;
        for (i = j = 0; i < d; i += 3, j += 2)
        {
            positions.push(
                (positions[i] / outerRadius) * innerRadius,
                (positions[i + 1] / outerRadius) * innerRadius,
                positions[i + 2]
            );
            normals.push(
                -normals[i],
                -normals[i + 1],
                0
            );
            tangents.push(
                -tangents[i],
                -tangents[i + 1],
                0
            );
            biTangents.push(
                0,
                -biTangents[i + 1],
                -biTangents[i + 2]
            );
            texcoords.push(
                texcoords[j],
                1 - texcoords[j + 1]
            );
        }
        a = d / 3;
        d = indices.length;
        for (i = 0; i < d; i += 6)
        {
            indices.push(
                a + indices[i],
                a + indices[i + 2],
                a + indices[i + 1],
                a + indices[i + 3],
                a + indices[i + 5],
                a + indices[i + 4]
            );
        }

        if (inCaps.get())
        {
            // create caps
            a = positions.length;
            o = a / 2;
            d = segments * 3;

            // cap positions
            Array.prototype.push.apply(positions, positions.slice(0, d));
            Array.prototype.push.apply(positions, positions.slice(o, o + d));
            Array.prototype.push.apply(positions, positions.slice(o - d, o));
            Array.prototype.push.apply(positions, positions.slice(a - d, a));

            // cap normals
            d = segments * 2;
            for (i = 0; i < d; i++) normals.push(0, 0, -1), tangents.push(-1, 0, 0), biTangents.push(0, -1, 0);
            for (i = 0; i < d; i++) normals.push(0, 0, 1), tangents.push(1, 0, 0), biTangents.push(0, 1, 0);

            // cap uvs
            if (uvMode == "atlas")
            {
                d = (innerRadius / outerRadius) * 0.5;
                for (i = o = 0; i < segments; i++, o += segmentRadians)
                    texcoords.push(
                        Math.sin(o) * 0.25 + 0.75,
                        Math.cos(o) * 0.25 + 0.25
                    );
                for (i = o = 0; i < segments; i++, o += segmentRadians)
                    texcoords.push(
                        (Math.sin(o) * d + 0.5) * 0.5 + 0.5,
                        (Math.cos(o) * d + 0.5) * 0.5
                    );
                for (i = o = 0; i < segments; i++, o += segmentRadians)
                    texcoords.push(
                        Math.sin(o) * 0.25 + 0.75,
                        Math.cos(o) * 0.25 + 0.75
                    );
                for (i = o = 0; i < segments; i++, o += segmentRadians)
                    texcoords.push(
                        (Math.sin(o) * d + 0.5) * 0.5 + 0.5,
                        (Math.cos(o) * d + 0.5) * 0.5 + 0.5
                    );
            }
            else
            {
                for (i = 0; i < d; i++) texcoords.push(0, 0);
                for (i = 0; i < d; i++) texcoords.push(1, 1);
            }

            // cap indices
            for (
                i = 0, o = a / 3 + x;
                i < segments - 1;
                i++, o++
            )
            {
                indices.push(
                    o + 1, o + segments, o,
                    o + segments + 1, o + segments, o + 1
                );
            }
            indices.push(
                o + segments, a / 3 + x, a / 3 + segments + x,
                o + segments, o, a / 3 + x
            );
            x += segments * 2;
            for (
                i = 0, o = a / 3 + x;
                i < segments - 1;
                i++, o++
            )
            {
                indices.push(
                    o, o + segments, o + 1,
                    o + 1, o + segments, o + segments + 1
                );
            }
            indices.push(
                a / 3 + segments + x, a / 3 + x, o + segments,
                a / 3 + x, o, o + segments
            );
        }
    }
    else
    {
        a = positions.length;
        d = a / 3;

        positions.push(0, 0, -length / 2);
        Array.prototype.push.apply(positions, positions.slice(0, segments * 3));
        for (i = 0; i <= segments; i++) normals.push(0, 0, -1), tangents.push(-1, 0, 0), biTangents.push(0, -1, 0);

        if (inCaps.get())
        {
            positions.push(0, 0, length / 2);
            Array.prototype.push.apply(positions, positions.slice(a - segments * 3, a));
            for (i = 0; i <= segments; i++) normals.push(0, 0, 1), tangents.push(1, 0, 0), biTangents.push(0, 1, 0);
            if (uvMode == "atlas")
            {
                texcoords.push(0.75, 0.25);
                for (i = a = 0; i < segments; i++, a += segmentRadians)
                    texcoords.push(Math.sin(a) * 0.25 + 0.75, Math.cos(a) * 0.25 + 0.25);
                texcoords.push(0.75, 0.75);
                for (i = a = 0; i < segments; i++, a += segmentRadians)
                    texcoords.push(Math.sin(a) * 0.25 + 0.75, Math.cos(a) * 0.25 + 0.75);
            }
            else
            {
                for (i = 0; i <= segments; i++) texcoords.push(0, 0);
                for (i = 0; i <= segments; i++) texcoords.push(1, 1);
            }
            indices.push(d + 1, d, d + segments);
            for (i = 1; i < segments; i++)
                indices.push(d, d + i, d + i + 1);
            d += segments + 1;
            indices.push(d, d + 1, d + segments);
            for (i = 1; i < segments; i++)
                indices.push(d, d + i + 1, d + i);
            d += segments + 1;
        }
    }

    // set geometry
    geom.clear();
    geom.vertices = positions;
    geom.texCoords = texcoords;
    geom.vertexNormals = normals;
    geom.tangents = tangents;
    geom.biTangents = biTangents;
    geom.verticesIndices = indices;

    if (inFlat.get()) geom.unIndex();

    outGeometry.set(null);
    outGeometry.set(geom);

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);

    needsRebuild = false;
}

// set event handlers
inRender.onTriggered = function ()
{
    if (needsRebuild) buildMesh();
    if (inDraw.get()) mesh.render(cgl.getShader());
    outTrigger.trigger();
};

inSegments.onChange =
inOuterRadius.onChange =
inInnerRadius.onChange =
inCaps.onChange =
inLength.onChange =
flipSideMapping.onChange =
inStacks.onChange =
inFlat.onChange =
inUVMode.onChange = function ()
{
    // only calculate once, even after multiple settings could were changed
    needsRebuild = true;
};

// set lifecycle handlers
op.onDelete = function () { if (mesh)mesh.dispose(); };


};

Ops.Gl.Meshes.Cylinder_v2.prototype = new CABLES.Op();
CABLES.OPS["2899ad67-1e64-4692-af2a-c3b9078f1b5f"]={f:Ops.Gl.Meshes.Cylinder_v2,objName:"Ops.Gl.Meshes.Cylinder_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.FloorGrid
// 
// **************************************************************

Ops.Gl.Meshes.FloorGrid = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"grid_frag":"IN vec4 posColor;\nIN vec3 posFrag;\n\nvoid main()\n{\n    outColor=posColor;\n    outColor.a*=(1.0-(length(posFrag)/30.0));\n}","grid_vert":"IN vec3 vPosition;\nIN vec3 attrVertNormal;\nIN vec2 attrTexCoord;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nOUT vec4 posColor;\nOUT vec3 posFrag;\n\nvoid main()\n{\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mMatrix=modelMatrix;\n\n    mat4 mvMatrix=viewMatrix*mMatrix;\n    posFrag=vPosition;\n    posColor=vec4(0.6,0.6,0.6,0.4);\n\n    if(pos.x==0.0) posColor=vec4(0.3,0.3,1.0,1.0);\n    else if(pos.y==0.0 && pos.z==0.0) posColor=vec4(1.0,0.3,0.3,1.0);\n    else if(mod(pos.z,10.0)==0.0 && mod(pos.x,10.0)==0.0 ) posColor.a=1.0;\n\n    if(pos.y>0.0 && pos.x==0.0) posColor=vec4(0.3,1.0,0.3,1.0);\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
const
    render = op.inTrigger("Render"),
    inActive = op.inBool("Active", true),
    next = op.outTrigger("Next");

const num = 100;

const cgl = op.patch.cgl;
let mesh = null;

const shader = new CGL.Shader(cgl, "gridMaterial");
shader.setSource(attachments.grid_vert, attachments.grid_frag);

function init()
{
    let geomVertical = new CGL.Geometry(op.name);

    const space = 1.0;
    let l = space * num / 2;

    let tc = [];

    for (var i = -num / 2; i < num / 2 + 1; i++)
    {
        geomVertical.vertices.push(-l);
        geomVertical.vertices.push(0);
        geomVertical.vertices.push(i * space);

        geomVertical.vertices.push(l);
        geomVertical.vertices.push(0);
        geomVertical.vertices.push(i * space);

        geomVertical.vertices.push(i * space);
        geomVertical.vertices.push(0);
        geomVertical.vertices.push(-l);

        geomVertical.vertices.push(i * space);
        geomVertical.vertices.push(0);
        geomVertical.vertices.push(l);

        if (i == 0)
        {
            tc.push(0, 1);
            tc.push(0, 1);
            tc.push(0, 0.5);
            tc.push(0, 0.5);
        }
        else
        {
            tc.push(0, 0);
            tc.push(0, 0);
            tc.push(0, 0);
            tc.push(0, 0);
        }
    }

    geomVertical.vertices.push(0);
    geomVertical.vertices.push(0.001);
    geomVertical.vertices.push(0);

    geomVertical.vertices.push(0);
    geomVertical.vertices.push(10);
    geomVertical.vertices.push(0);

    tc.push(0, 0, 0, 0);

    for (var i = 0; i <= 10; i++)
    {
        geomVertical.vertices.push(-0.25);
        geomVertical.vertices.push(i);
        geomVertical.vertices.push(0);

        geomVertical.vertices.push(0.25);
        geomVertical.vertices.push(i);
        geomVertical.vertices.push(0);

        tc.push(0, 0, 0, 0);
    }

    geomVertical.setTexCoords(tc);
    geomVertical.calculateNormals();

    if (!mesh) mesh = new CGL.Mesh(cgl, geomVertical);
    else mesh.setGeom(geomVertical);
}

render.onTriggered = function ()
{
    if (!mesh)init();

    if (cgl.frameStore.shadowPass) return next.trigger();

    cgl.pushShader(shader);
    if (!shader) return;

    let oldPrim = shader.glPrimitive;

    shader.glPrimitive = cgl.gl.LINES;

    if (inActive.get()) mesh.render(shader);
    cgl.popShader();

    shader.glPrimitive = oldPrim;

    next.trigger();
};


};

Ops.Gl.Meshes.FloorGrid.prototype = new CABLES.Op();
CABLES.OPS["645b3877-4fdd-42e5-a369-d9506a65e2f0"]={f:Ops.Gl.Meshes.FloorGrid,objName:"Ops.Gl.Meshes.FloorGrid"};




// **************************************************************
// 
// Ops.Gl.Meshes.FreeFormPlane
// 
// **************************************************************

Ops.Gl.Meshes.FreeFormPlane = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),

    x1 = op.inValue("x 1", -1),
    y1 = op.inValue("y 1", 1),
    z1 = op.inValue("z 1", 0),

    x2 = op.inValue("x 2", 1),
    y2 = op.inValue("y 2", 1),
    z2 = op.inValue("z 2", 0),

    x3 = op.inValue("x 3", -1),
    y3 = op.inValue("y 3", -1),
    z3 = op.inValue("z 3", 0),

    x4 = op.inValue("x 4", 1),
    y4 = op.inValue("y 4", -1),
    z4 = op.inValue("z 4", 0),

    tcx1 = op.inValue("tc x 1", 0),
    tcy1 = op.inValue("tc y 1", 1),

    tcx2 = op.inValue("tc x 2", 1),
    tcy2 = op.inValue("tc y 2", 1),

    tcx3 = op.inValue("tc x 3", 0),
    tcy3 = op.inValue("tc y 3", 0),

    tcx4 = op.inValue("tc x 4", 1),
    tcy4 = op.inValue("tc y 4", 0),
    trigger = op.outTrigger("trigger");

let geom = new CGL.Geometry(op.name);
let mesh = null;
let cgl = op.patch.cgl;

let arrverts = [];
arrverts.length = 12;
let verts = new Float32Array(arrverts);
let indices = [2, 1, 0, 1, 2, 3];
let tc = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]);

let geomOut = op.addOutPort(new CABLES.Port(op, "geometry", CABLES.OP_PORT_TYPE_OBJECT));
geomOut.ignoreValueSerialize = true;

tcx1.onChange =
    tcy1.onChange =
    tcx2.onChange =
    tcy2.onChange =
    tcx3.onChange =
    tcy3.onChange =
    tcx4.onChange =
    tcy4.onChange =
    x1.onChange =
    x2.onChange =
    x3.onChange =
    x4.onChange =
    y1.onChange =
    y2.onChange =
    y3.onChange =
    y4.onChange =
    z1.onChange =
    z2.onChange =
    z3.onChange =
    z4.onChange = rebuild;

rebuild();

render.onTriggered = function ()
{
    mesh.render(cgl.getShader());

    if (op.isCurrentUiOp())
    {
        gui.setTransformGizmo({ "posX": x1, "posY": y1, "posZ": z1 }, 0);
        gui.setTransformGizmo({ "posX": x2, "posY": y2, "posZ": z2 }, 1);
        gui.setTransformGizmo({ "posX": x3, "posY": y3, "posZ": z3 }, 2);
        gui.setTransformGizmo({ "posX": x4, "posY": y4, "posZ": z4 }, 3);
    }

    trigger.trigger();
};

function rebuild()
{
    verts[0] = x1.get();
    verts[1] = y1.get();
    verts[2] = z1.get();

    verts[3] = x2.get();
    verts[4] = y2.get();
    verts[5] = z2.get();

    verts[6] = x3.get();
    verts[7] = y3.get();
    verts[8] = z3.get();

    verts[9] = x4.get();
    verts[10] = y4.get();
    verts[11] = z4.get();

    // var tc=[0,0, 1,0, 0,1,  1,1];

    tc[0] = tcx1.get();
    tc[1] = tcy1.get();

    tc[2] = tcx2.get();
    tc[3] = tcy2.get();

    tc[4] = tcx3.get();
    tc[5] = tcy3.get();

    tc[6] = tcx4.get();
    tc[7] = tcy4.get();

    geom.vertices = verts;
    geom.texCoords = tc;
    geom.verticesIndices = indices;
    geom.calcNormals(true);
    geom.calcTangentsBitangents();

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);

    geomOut.set(null);
    geomOut.set(geom);
}


};

Ops.Gl.Meshes.FreeFormPlane.prototype = new CABLES.Op();
CABLES.OPS["7f03c044-ae95-4273-8d90-0e1c91ecffc7"]={f:Ops.Gl.Meshes.FreeFormPlane,objName:"Ops.Gl.Meshes.FreeFormPlane"};




// **************************************************************
// 
// Ops.Gl.Meshes.FullscreenRectangle
// 
// **************************************************************

Ops.Gl.Meshes.FullscreenRectangle = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"shader_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\n\nvoid main()\n{\n    outColor= texture(tex,texCoord);\n}\n\n","shader_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\n\nOUT vec2 texCoord;\nIN vec2 attrTexCoord;\n\nvoid main()\n{\n   vec4 pos=vec4(vPosition,  1.0);\n\n   texCoord=vec2(attrTexCoord.x,(1.0-attrTexCoord.y));\n\n   gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
const
    render = op.inTrigger("render"),
    inScale = op.inSwitch("Scale", ["Stretch", "Fit"], "Fit"),
    flipY = op.inValueBool("Flip Y"),
    flipX = op.inValueBool("Flip X"),
    inTexture = op.inTexture("Texture"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
let mesh = null;
let geom = new CGL.Geometry("fullscreen rectangle");
let x = 0, y = 0, z = 0, w = 0, h = 0;

flipX.onChange = rebuildFlip;
flipY.onChange = rebuildFlip;
render.onTriggered = doRender;
inTexture.onLinkChanged = updateUi;
op.toWorkPortsNeedToBeLinked(render);

const shader = new CGL.Shader(cgl, "fullscreenrectangle");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);

shader.setSource(attachments.shader_vert, attachments.shader_frag);
shader.fullscreenRectUniform = new CGL.Uniform(shader, "t", "tex", 0);
shader.aspectUni = new CGL.Uniform(shader, "f", "aspectTex", 0);

let useShader = false;
let updateShaderLater = true;
let fitImageAspect = false;
let oldVp = [];

updateUi();

inTexture.onChange = function ()
{
    updateShaderLater = true;
};

function updateUi()
{
    if (!CABLES.UI) return;
    flipY.setUiAttribs({ "greyout": !inTexture.isLinked() });
    flipX.setUiAttribs({ "greyout": !inTexture.isLinked() });
    inScale.setUiAttribs({ "greyout": !inTexture.isLinked() });
}

function updateShader()
{
    let tex = inTexture.get();
    if (tex) useShader = true;
    else useShader = false;
}

op.preRender = function ()
{
    updateShader();
    shader.bind();
    if (mesh)mesh.render(shader);
    doRender();
};

inScale.onChange = () =>
{
    fitImageAspect = inScale.get() == "Fit";
};

function doRender()
{
    if (cgl.getViewPort()[2] != w || cgl.getViewPort()[3] != h || !mesh) rebuild();

    if (updateShaderLater) updateShader();

    cgl.pushPMatrix();
    mat4.identity(cgl.pMatrix);
    mat4.ortho(cgl.pMatrix, 0, w, h, 0, -10.0, 1000);

    cgl.pushModelMatrix();
    mat4.identity(cgl.mMatrix);

    cgl.pushViewMatrix();
    mat4.identity(cgl.vMatrix);

    if (fitImageAspect && inTexture.get())
    {
        const rat = inTexture.get().width / inTexture.get().height;

        let _h = h;
        let _w = h * rat;

        if (_w > w)
        {
            _h = w * 1 / rat;
            _w = w;
        }

        oldVp[0] = cgl.getViewPort()[0];
        oldVp[1] = cgl.getViewPort()[1];
        oldVp[2] = cgl.getViewPort()[2];
        oldVp[3] = cgl.getViewPort()[3];

        cgl.setViewPort((w - _w) / 2, (h - _h) / 2, _w, _h);
        // cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
    }

    if (useShader)
    {
        if (inTexture.get())
            cgl.setTexture(0, inTexture.get().tex);

        mesh.render(shader);
    }
    else
    {
        mesh.render(cgl.getShader());
    }

    cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

    cgl.popPMatrix();
    cgl.popModelMatrix();
    cgl.popViewMatrix();

    if (fitImageAspect && inTexture.get())
        cgl.setViewPort(oldVp[0], oldVp[1], oldVp[2], oldVp[3]);

    trigger.trigger();
}

function rebuildFlip()
{
    mesh = null;
}

function rebuild()
{
    const currentViewPort = cgl.getViewPort();

    if (currentViewPort[2] == w && currentViewPort[3] == h && mesh) return;

    let xx = 0, xy = 0;

    w = currentViewPort[2];
    h = currentViewPort[3];

    geom.vertices = new Float32Array([
        xx + w, xy + h, 0.0,
        xx, xy + h, 0.0,
        xx + w, xy, 0.0,
        xx, xy, 0.0
    ]);

    let tc = null;

    if (flipY.get())
        tc = new Float32Array([
            1.0, 0.0,
            0.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
        ]);
    else
        tc = new Float32Array([
            1.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            0.0, 0.0
        ]);

    if (flipX.get())
    {
        tc[0] = 0.0;
        tc[2] = 1.0;
        tc[4] = 0.0;
        tc[6] = 1.0;
    }

    geom.setTexCoords(tc);

    geom.verticesIndices = new Uint16Array([
        2, 1, 0,
        3, 1, 2
    ]);

    geom.vertexNormals = new Float32Array([
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
    ]);
    geom.tangents = new Float32Array([
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0]);
    geom.biTangents == new Float32Array([
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        0, -1, 0]);

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);
}


};

Ops.Gl.Meshes.FullscreenRectangle.prototype = new CABLES.Op();
CABLES.OPS["255bd15b-cc91-4a12-9b4e-53c710cbb282"]={f:Ops.Gl.Meshes.FullscreenRectangle,objName:"Ops.Gl.Meshes.FullscreenRectangle"};




// **************************************************************
// 
// Ops.Gl.Meshes.GeometryToTexture_v2
// 
// **************************************************************

Ops.Gl.Meshes.GeometryToTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"fragpos_frag":"col=vec4(MOD_pos.xyz,1.0);\n","vertpos_vert":"\n#ifdef MOD_ATTRIB_POS\nMOD_pos=pos.xyz;\n#endif\n#ifdef MOD_ATTRIB_NORMAL\nMOD_pos=norm.xyz;\n#endif\n#ifdef MOD_ATTRIB_TC\nMOD_pos=vec3(attrTexCoord,1.0);\n#endif\n\nfloat tx=mod(attrVertIndex,MOD_texSize)+1.0/MOD_texSize;\nfloat ty=floor(attrVertIndex/MOD_texSize);\n\ngl_PointSize=1.0;\n\npos=vec4(tx,ty+1.0,0.0,1.0);\n",};
const
    exec = op.inTrigger("Render"),
    inGeom = op.inObject("Geometry", null, "geometry"),

    inOrder = op.inDropDown("Order", ["Sequential", "Random", "Vertex X", "Vertex Y", "Vertex Z"], "Sequential"),
    inAttrib = op.inSwitch("Content", ["Vertex Pos", "Normals", "TexCoords"], "Vertex Pos"),

    inSize = op.inSwitch("Size", ["Auto", "Manual"], "Auto"),
    inWidth = op.inValueInt("Tex Width", 256),
    tfilter = op.inValueSelect("filter", ["nearest", "linear"], "nearest"),
    twrap = op.inValueSelect("wrap", ["clamp to edge", "repeat", "mirrored repeat"], "clamp to edge"),

    next = op.outTrigger("Next"),
    outNumVerts = op.outNumber("Total Vertices"),
    outTex = op.outTexture("Texture");

op.setPortGroup("Texture settings", [tfilter, twrap, inWidth, inSize]);

const cgl = op.patch.cgl;
const prevViewPort = [0, 0, 0, 0];
const effect = null;

let autoSize = true;
let needsUpdate = true;
let needsUpdateSize = true;
let shader = null;
let size = 0;
let fb = null;
let needInitFb = true;
let mesh = null;
let vertNums = new Float32Array(1);
let numVerts = 1;

tfilter.onChange =
    twrap.onChange = initFbLater;

inWidth.onChange =
    inSize.onChange = updateSize;

inAttrib.onChange = updateAttrib;

updateUI();

const vertModTitle = "vert_" + op.name;
const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "priority": 200,
    "title": vertModTitle,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": "OUT vec3 MOD_pos;",
    "srcBodyVert": attachments.vertpos_vert
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": "IN vec3 MOD_pos;",
    "srcBodyFrag": attachments.fragpos_frag
});
mod.addUniformVert("f", "MOD_texSize", 0);
updateAttrib();

function shuffleArray(array)
{
    let i = 0;
    let j = 0;
    let temp = null;

    for (i = array.length - 1; i > 0; i -= 1)
    {
        j = Math.floor(Math.seededRandom() * (i + 1));
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

inGeom.onChange = function ()
{
    needsUpdateSize = true;
    needsUpdate = true;
};

function updateAttrib()
{
    mod.toggleDefine("MOD_ATTRIB_POS", inAttrib.get() == "Vertex Pos");
    mod.toggleDefine("MOD_ATTRIB_TC", inAttrib.get() == "TexCoords");
    mod.toggleDefine("MOD_ATTRIB_NORMAL", inAttrib.get() == "Normals");

    needsUpdate = true;
}

inOrder.onChange = () =>
{
    needsUpdate = true;
};

function warning()
{
}

function updateUI()
{
    inWidth.setUiAttribs({ "greyout": inSize.get() == "Auto" });
}

function initFbLater()
{
    needInitFb = true;
    needsUpdate = true;
    warning();
    updateUI();
}

function updateSize()
{
    const oldSize = size;
    size = inWidth.get();

    autoSize = inSize.get() == "Auto";

    const geo = inGeom.get();

    if (autoSize && !geo)
    {
        needsUpdateSize = true;
        size = -1;
        return;
    }
    if (autoSize && geo && geo.vertices)
    {
        size = Math.ceil(Math.sqrt(geo.vertices.length / 3));
    }

    size = Math.ceil(Math.max(1, size));

    updateUI();
    if (oldSize != size) needsUpdate = true;
    needsUpdateSize = false;
    op.log("size", size);
}

function initFb()
{
    if (fb) fb = fb.delete();
    outTex.set(CGL.Texture.getEmptyTexture(cgl));
    if (size < 1) return;

    let filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") filter = CGL.Texture.FILTER_LINEAR;

    let selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    if (twrap.get() == "repeat") selectedWrap = CGL.Texture.WRAP_REPEAT;
    if (twrap.get() == "mirrored repeat") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;

    if (cgl.glVersion >= 2)
    {
        fb = new CGL.Framebuffer2(cgl, size, size,
            {
                "isFloatingPointTexture": true,
                "multisampling": false,
                "wrap": selectedWrap,
                "filter": filter,
                "depth": true,
                "multisamplingSamples": 0,
                "clear": true
            });
    }
    else
    {
        fb = new CGL.Framebuffer(cgl, size, size,
            {
                "isFloatingPointTexture": true,
                "filter": filter,
                "wrap": selectedWrap
            });
    }
    needInitFb = false;
}

exec.onTriggered = function ()
{
    updateSize();

    if (!fb || needInitFb) initFb();
    if (!needsUpdate) return next.trigger();
    if (outTex.get() != CGL.Texture.getEmptyTexture(cgl)) outTex.set(CGL.Texture.getEmptyTexture(cgl));

    const geo = inGeom.get();

    if (!geo || !geo.copy || !geo.vertices) return next.trigger();

    if (size < 1)
    {
        needsUpdate = true;
        return;
    }

    if (fb && fb.getWidth() != size) fb.setSize(size, size);

    const g = geo.copy();

    if (!mesh)mesh = new CGL.Mesh(cgl, new CGL.Geometry("a"), cgl.gl.POINTS);

    g.glPrimitive = cgl.gl.POINTS;
    mesh.setGeom(g);
    numVerts = g.vertices.length / 3;

    if (vertNums.length != numVerts) vertNums = new Float32Array(numVerts);

    for (let i = 0; i < numVerts; i++) vertNums[i] = i;

    if (inOrder.get() == "Random") shuffleArray(vertNums);
    if (inOrder.get() == "Vertex X")
        vertNums.sort(function (a, b) { return g.vertices[a * 3 + 0] - g.vertices[b * 3 + 0]; });
    if (inOrder.get() == "Vertex Y")
        vertNums.sort(function (a, b) { return g.vertices[a * 3 + 1] - g.vertices[b * 3 + 1]; });
    if (inOrder.get() == "Vertex Z")
        vertNums.sort(function (a, b) { return g.vertices[a * 3 + 2] - g.vertices[b * 3 + 2]; });

    mesh._setVertexNumbers(vertNums);

    outNumVerts.set(numVerts);

    render();

    needsUpdate = false;
    next.trigger();
};

function render()
{
    if (!cgl.getShader())
    {
        op.setUiError("not in mainloop", "Needs to be connected to mainloop branch");
        return;
    }
    else op.setUiError("not in mainloop", null);

    const vp = cgl.getViewPort();
    prevViewPort[0] = vp[0];
    prevViewPort[1] = vp[1];
    prevViewPort[2] = vp[2];
    prevViewPort[3] = vp[3];

    fb.renderStart(cgl);

    cgl.pushPMatrix();
    mat4.identity(cgl.pMatrix);

    cgl.pushViewMatrix();
    mat4.identity(cgl.vMatrix);

    cgl.pushModelMatrix();
    mat4.identity(cgl.mMatrix);

    cgl.gl.viewport(0, 0, size, size);

    mat4.ortho(
        cgl.pMatrix,
        0, size,
        0, size,
        -1.00, 100);

    mod.bind();

    mod.setUniformValue("MOD_texSize", size);
    mesh.render(cgl.getShader());

    mod.unbind();

    cgl.popPMatrix();
    cgl.popModelMatrix();
    cgl.popViewMatrix();
    fb.renderEnd(cgl);

    outTex.set(fb.getTextureColor());

    cgl.gl.viewport(prevViewPort[0], prevViewPort[1], prevViewPort[2], prevViewPort[3]);
}


};

Ops.Gl.Meshes.GeometryToTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["d3435879-6b19-460b-911c-87ae5a8d00ad"]={f:Ops.Gl.Meshes.GeometryToTexture_v2,objName:"Ops.Gl.Meshes.GeometryToTexture_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.Grid
// 
// **************************************************************

Ops.Gl.Meshes.Grid = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    inNum = op.inValue("Num", 10),
    inSpacing = op.inValue("Spacing", 1),
    inCenter = op.inBool("Center", true),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;
let mesh = null;

inCenter.onChange =
    inNum.onChange =
    inSpacing.onChange = function ()
    {
        if (mesh)mesh.dispose();
        mesh = null;
    };

function init()
{
    const geomStepsOne = new CGL.Geometry(op.name);
    const geomX = new CGL.Geometry(op.name);

    const space = inSpacing.get();
    const num = Math.floor(inNum.get());
    const l = space * num / 2;

    const tc = [];

    let start = -num / 2;
    let end = num / 2 + 1;

    for (let i = start; i < end; i++)
    {
        geomStepsOne.vertices.push(-l);
        geomStepsOne.vertices.push(i * space);
        geomStepsOne.vertices.push(0);

        geomStepsOne.vertices.push(l);
        geomStepsOne.vertices.push(i * space);
        geomStepsOne.vertices.push(0);

        geomStepsOne.vertices.push(i * space);
        geomStepsOne.vertices.push(-l);
        geomStepsOne.vertices.push(0);

        geomStepsOne.vertices.push(i * space);
        geomStepsOne.vertices.push(l);
        geomStepsOne.vertices.push(0);

        tc.push(0, 0);
        tc.push(0, 0);
        tc.push(0, 0);
        tc.push(0, 0);
    }

    if (!inCenter.get())
    {
        for (let i = 0; i < geomStepsOne.vertices.length; i += 3)
        {
            geomStepsOne.vertices[i + 0] += l;
            geomStepsOne.vertices[i + 1] += l;
        }
    }

    geomStepsOne.setTexCoords(tc);
    geomStepsOne.calculateNormals();

    if (!mesh) mesh = new CGL.Mesh(cgl, geomStepsOne);
    else mesh.setGeom(geomStepsOne);
}

render.onTriggered = function ()
{
    if (!mesh)init();
    let shader = cgl.getShader();
    if (!shader) return;

    let oldPrim = shader.glPrimitive;

    shader.glPrimitive = cgl.gl.LINES;

    mesh.render(shader);

    shader.glPrimitive = oldPrim;

    next.trigger();
};


};

Ops.Gl.Meshes.Grid.prototype = new CABLES.Op();
CABLES.OPS["677a7c03-6885-46b4-8a64-e4ea54ee5d7f"]={f:Ops.Gl.Meshes.Grid,objName:"Ops.Gl.Meshes.Grid"};




// **************************************************************
// 
// Ops.Gl.Meshes.HeightMap
// 
// **************************************************************

Ops.Gl.Meshes.HeightMap = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render = op.inTrigger("render"),
    filename = op.inFile("file"),
    extrude = op.inValueFloat("extrude", 1),
    mWidth = op.inValueFloat("width", 3),
    mHeight = op.inValueFloat("height", 3),
    nRows = op.inValueInt("rows", 20),
    nColumns = op.inValueInt("columns", 20),
    sliceTex = op.inValueBool("texCoords slice"),
    flat = op.inValueBool("flat"),
    trigger = op.outTrigger("trigger");

let outGeom = op.outObject("geometry");
outGeom.ignoreValueSerialize = true;

let geom = new CGL.Geometry(op.name);
let mesh = null;
let cgl = op.patch.cgl;
let image = new Image();

render.onTriggered = function ()
{
    if (mesh) mesh.render(cgl.getShader());
    trigger.trigger();
};

extrude.onChange = mHeight.onChange = mWidth.onChange =
    nRows.onChange = nColumns.onChange = flat.onChange = rebuildGeom;

filename.onChange = reload;

function rebuildGeom()
{
    geom.clear();

    let verts = [];
    let tc = [];
    let indices = [];

    let width = image.width;
    let height = image.height;
    let canvas = document.createElement("canvas");
    let ctx = canvas.getContext("2d");
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(image, 0, 0);

    let meshWidth = mWidth.get();
    let meshHeight = mHeight.get();

    let count = 0;

    let vertStepX = meshWidth / width;
    let vertStepY = meshHeight / height;

    let numRows = parseFloat(nRows.get());
    let numColumns = parseFloat(nColumns.get());
    let rowStepX = width / numColumns;
    let rowStepY = height / numRows;
    let heightMul = extrude.get() * 0.001;

    let stepRow = meshWidth / numRows;
    let stepColumn = meshHeight / numColumns;

    let cycleTex = 0;
    let oldh = 0;

    for (var r = 0; r <= numRows; r++)
    {
        for (var c = 0; c <= numColumns; c++)
        {
            let h = ctx.getImageData(Math.round(c * rowStepX), Math.round(r * rowStepY), 1, 1).data[1] * heightMul;
            // verts.push( c*stepColumn    - meshWidth/2 );
            // verts.push( r*stepRow       - meshHeight/2 );
            verts.push(c * stepColumn);
            verts.push(r * stepRow);
            verts.push(h);

            if (sliceTex.get())
            {
                if (h != oldh)
                {
                    if (c % 2 == 0) tc.push(0.5);
                    else tc.push(1);

                    tc.push(1.0 - r / numRows);
                }
                else
                {
                    tc.push(1);
                    tc.push(0);
                }
                oldh = h;
            }
            else
            {
                tc.push(c / numColumns);
                tc.push(1.0 - r / numRows);
            }
        }
    }

    for (c = 0; c < numColumns; c++)
    {
        for (r = 0; r < numRows; r++)
        {
            let ind = c + (numColumns + 1) * r;
            let v1 = ind;
            let v2 = ind + 1;
            let v3 = ind + numColumns + 1;
            let v4 = ind + 1 + numColumns + 1;

            indices.push(v1);
            indices.push(v2);
            indices.push(v3);

            indices.push(v2);
            indices.push(v3);
            indices.push(v4);
        }
    }

    geom.vertices = verts;
    geom.texCoords = tc;
    geom.verticesIndices = indices;
    if (flat.get())geom.unIndex();
    geom.calculateNormals({ "forceZUp": true });

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    mesh.setGeom(geom);
    outGeom.set(null);
    outGeom.set(geom);
}

function reload()
{
    image.crossOrigin = "";
    let url = op.patch.getFilePath(filename.get());

    let loadingId = op.patch.loading.start("heightmapImage", url);

    image.onabort = image.onerror = function (e)
    {
        op.patch.loading.finished(loadingId);
        op.log("error loading heightmap image...");
    };

    image.onload = function (e)
    {
        rebuildGeom();
        op.patch.loading.finished(loadingId);
    };
    image.src = url;
}


};

Ops.Gl.Meshes.HeightMap.prototype = new CABLES.Op();
CABLES.OPS["81264799-d92b-4b71-a3f1-ad1da8331e62"]={f:Ops.Gl.Meshes.HeightMap,objName:"Ops.Gl.Meshes.HeightMap"};




// **************************************************************
// 
// Ops.Gl.Meshes.Helix
// 
// **************************************************************

Ops.Gl.Meshes.Helix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    draw = op.inValueBool("Draw", true),
    segments = op.inValue("Segments", 40),
    freq = op.inValue("Frequency", 1),
    radius = op.inValue("Radius", 1),
    radiusEnd = op.inValue("Radius End", 1),
    height = op.inValue("Height"),
    next = op.outTrigger("Next"),
    outPoints = op.outArray("Points");

let cgl = op.patch.cgl;
let pos = [];
let needsCalc = true;
let mesh = null;

segments.onChange =
    radius.onChange =
    height.onChange =
    freq.onChange =
    radiusEnd.onChange =
    draw.onChange = calcLater;

render.onTriggered = doRender;

function doRender()
{
    if (needsCalc)calc();

    if (mesh)
    {
        let shader = cgl.getShader();
        if (!shader) return;
        let oldPrim = shader.glPrimitive;
        shader.glPrimitive = cgl.gl.LINE_STRIP;
        mesh.render(shader);
        shader.glPrimitive = oldPrim;
    }

    next.trigger();
}

function calcLater()
{
    needsCalc = true;
}

function calc()
{
    needsCalc = false;
    pos.length = 0;

    let i = 0, degInRad = 0;
    let segs = Math.floor(segments.get());
    if (segs < 1)segs = 1;

    for (i = 0; i < segs; i++)
    {
        let perc = (i / segs);
        let z = perc * height.get();
        let rad = (perc * radiusEnd.get()) + ((1.0 - perc) * radius.get());
        degInRad = (360 / segs) * i * CGL.DEG2RAD;
        pos.push(
            Math.sin(degInRad * freq.get()) * rad,
            Math.cos(degInRad * freq.get()) * rad,
            z);
    }

    if (draw.get())
    {
        let buff = new Float32Array(pos);
        let geom = new CGL.Geometry("helix");
        geom.vertices = buff;

        mesh = new CGL.Mesh(cgl, geom);
    }
    else mesh = null;

    outPoints.set(null);
    outPoints.set(pos);
}


};

Ops.Gl.Meshes.Helix.prototype = new CABLES.Op();
CABLES.OPS["f41fabfc-14c0-4472-a00a-6ab1dcdcc4bc"]={f:Ops.Gl.Meshes.Helix,objName:"Ops.Gl.Meshes.Helix"};




// **************************************************************
// 
// Ops.Gl.Meshes.Icosahedron
// 
// **************************************************************

Ops.Gl.Meshes.Icosahedron = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// from: http://blog.andreaskahler.com/search/label/3D

let render = op.inTrigger("render");
let smooth = op.inValueBool("smooth");
let trigger = op.outTrigger("trigger");
let geomOut = op.outObject("geometry");

geomOut.ignoreValueSerialize = true;

smooth.onChange = generate;

let mesh = null;
let cgl = op.patch.cgl;
smooth.set(false);
generate();

render.onTriggered = function ()
{
    if (mesh) mesh.render(cgl.getShader());
    trigger.trigger();
};

function generate()
{
    let t = Math.sqrt(5.0) / 2;
    let tc = [];
    let verts = [];
    verts.push(-1, t, 0);
    verts.push(1, t, 0);
    verts.push(-1, -t, 0);
    verts.push(1, -t, 0);

    verts.push(0, -1, t);
    verts.push(0, 1, t);
    verts.push(0, -1, -t);
    verts.push(0, 1, -t);

    verts.push(t, 0, -1);
    verts.push(t, 0, 1);
    verts.push(-t, 0, -1);
    verts.push(-t, 0, 1);

    let geom = new CGL.Geometry(op.name);

    geom.vertices = verts;
    geom.verticesIndices = [];

    // 5 faces around point 0
    geom.verticesIndices.push(0, 11, 5);
    geom.verticesIndices.push(0, 5, 1);
    geom.verticesIndices.push(0, 1, 7);
    geom.verticesIndices.push(0, 7, 10);
    geom.verticesIndices.push(0, 10, 11);

    // 5 adjacent faces
    geom.verticesIndices.push(1, 5, 9);
    geom.verticesIndices.push(5, 11, 4);
    geom.verticesIndices.push(11, 10, 2);
    geom.verticesIndices.push(10, 7, 6);
    geom.verticesIndices.push(7, 1, 8);

    // 5 faces around point 3
    geom.verticesIndices.push(3, 9, 4);
    geom.verticesIndices.push(3, 4, 2);
    geom.verticesIndices.push(3, 2, 6);
    geom.verticesIndices.push(3, 6, 8);
    geom.verticesIndices.push(3, 8, 9);

    // 5 adjacent faces
    geom.verticesIndices.push(4, 9, 5);
    geom.verticesIndices.push(2, 4, 11);
    geom.verticesIndices.push(6, 2, 10);
    geom.verticesIndices.push(8, 6, 7);
    geom.verticesIndices.push(9, 8, 1);

    geom.texCoords = tc;

    geom.calcNormals(smooth.get());
    mesh = new CGL.Mesh(cgl, geom);
    geomOut.set(geom);
}


};

Ops.Gl.Meshes.Icosahedron.prototype = new CABLES.Op();
CABLES.OPS["109cead5-8eda-4726-9e3d-b23afe201abd"]={f:Ops.Gl.Meshes.Icosahedron,objName:"Ops.Gl.Meshes.Icosahedron"};




// **************************************************************
// 
// Ops.Gl.Meshes.Line
// 
// **************************************************************

Ops.Gl.Meshes.Line = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    x1 = op.inValue("X 1"),
    y1 = op.inValue("Y 1"),
    z1 = op.inValue("Z 1"),
    x2 = op.inValue("X 2", 1),
    y2 = op.inValue("Y 2", 1),
    z2 = op.inValue("Z 2", 1),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;

const geom = new CGL.Geometry("simplespline");
geom.vertices = [x1.get(), y1.get(), z1.get(), x2.get(), y2.get(), x2.get()];
const mesh = new CGL.Mesh(cgl, geom, cgl.gl.LINES);

let changed = true;

x1.onChange = function () { geom.vertices[0] = x1.get(); changed = true; };
y1.onChange = function () { geom.vertices[1] = y1.get(); changed = true; };
z1.onChange = function () { geom.vertices[2] = z1.get(); changed = true; };

x2.onChange = function () { geom.vertices[3] = x2.get(); changed = true; };
y2.onChange = function () { geom.vertices[4] = y2.get(); changed = true; };
z2.onChange = function () { geom.vertices[5] = z2.get(); changed = true; };

render.onTriggered = function ()
{
    if (changed)
    {
        mesh.updateVertices(geom);
        changed = false;
    }

    let shader = cgl.getShader();
    mesh.render(shader);
    next.trigger();
};


};

Ops.Gl.Meshes.Line.prototype = new CABLES.Op();
CABLES.OPS["c6a0d570-a0ac-4655-b17d-74d0870b0799"]={f:Ops.Gl.Meshes.Line,objName:"Ops.Gl.Meshes.Line"};




// **************************************************************
// 
// Ops.Gl.Meshes.LinesArray
// 
// **************************************************************

Ops.Gl.Meshes.LinesArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    width = op.inValueFloat("width", 10),
    height = op.inValueFloat("height", 1),
    doLog = op.inValueBool("Logarithmic", false),
    pivotX = op.inValueSelect("pivot x", ["center", "left", "right"], "center"),
    pivotY = op.inValueSelect("pivot y", ["center", "top", "bottom"], "center"),
    nColumns = op.inValueInt("num columns", 10),
    nRows = op.inValueInt("num rows", 10),
    axis = op.inValueSelect("axis", ["xy", "xz"], "xy"),
    trigger = op.outTrigger("trigger"),
    outPointArrays = op.outArray("Point Arrays");

const cgl = op.patch.cgl;
let meshes = [];

op.setPortGroup("Size", [width, height]);
op.setPortGroup("Alignment", [pivotX, pivotY]);

axis.onChange =
    pivotX.onChange =
    pivotY.onChange =
    width.onChange =
    height.onChange =
    nRows.onChange =
    nColumns.onChange =
    doLog.onChange = rebuildDelayed;

rebuild();

render.onTriggered = function ()
{
    for (let i = 0; i < meshes.length; i++) meshes[i].render(cgl.getShader());
    trigger.trigger();
};

let delayRebuild = 0;
function rebuildDelayed()
{
    clearTimeout(delayRebuild);
    delayRebuild = setTimeout(rebuild, 60);
}

function rebuild()
{
    let x = 0;
    let y = 0;

    if (pivotX.get() == "center") x = 0;
    if (pivotX.get() == "right") x = -width.get() / 2;
    if (pivotX.get() == "left") x = +width.get() / 2;

    if (pivotY.get() == "center") y = 0;
    if (pivotY.get() == "top") y = -height.get() / 2;
    if (pivotY.get() == "bottom") y = +height.get() / 2;

    let numRows = parseInt(nRows.get(), 10);
    let numColumns = parseInt(nColumns.get(), 10);

    let stepColumn = width.get() / numColumns;
    let stepRow = height.get() / numRows;

    let c, r;
    meshes.length = 0;

    let vx, vy, vz;
    let verts = [];
    let tc = [];
    let indices = [];
    let count = 0;

    function addMesh()
    {
        let geom = new CGL.Geometry(op.name);
        geom.vertices = verts;
        geom.texCoords = tc;
        geom.verticesIndices = indices;

        let mesh = new CGL.Mesh(cgl, geom, cgl.gl.LINES);
        mesh.setGeom(geom);
        meshes.push(mesh);

        verts.length = 0;
        tc.length = 0;
        indices.length = 0;
        count = 0;
        lvx = null;
    }

    let min = Math.log(1 / numRows);
    let max = Math.log(1);
    // op.log(min,max);

    let lines = [];

    for (r = numRows; r >= 0; r--)
    {
        // op.log(r/numRows);
        var lvx = null, lvy = null, lvz = null;
        let ltx = null, lty = null;
        let log = 0;
        let doLoga = doLog.get();

        let linePoints = [];
        lines.push(linePoints);


        for (c = numColumns; c >= 0; c--)
        {
            vx = c * stepColumn - width.get() / 2 + x;
            if (doLoga)
                vy = (Math.log((r / numRows)) / min) * height.get() - height.get() / 2 + y;
            else
                vy = r * stepRow - height.get() / 2 + y;

            let tx = c / numColumns;
            let ty = 1.0 - r / numRows;
            if (doLoga) ty = (Math.log((r / numRows)) / min);

            vz = 0.0;

            if (axis.get() == "xz")
            {
                vz = vy;
                vy = 0.0;
            }
            if (axis.get() == "xy") vz = 0.0;

            if (lvx !== null)
            {
                verts.push(lvx);
                verts.push(lvy);
                verts.push(lvz);

                linePoints.push(lvx, lvy, lvz);

                verts.push(vx);
                verts.push(vy);
                verts.push(vz);

                tc.push(ltx);
                tc.push(lty);

                tc.push(tx);
                tc.push(ty);

                indices.push(count);
                count++;
                indices.push(count);
                count++;
            }

            if (count > 64000)
            {
                addMesh();
            }

            ltx = tx;
            lty = ty;

            lvx = vx;
            lvy = vy;
            lvz = vz;
        }
    }

    outPointArrays.set(lines);

    addMesh();

    // op.log(meshes.length,' meshes');
}


};

Ops.Gl.Meshes.LinesArray.prototype = new CABLES.Op();
CABLES.OPS["a75265c2-957b-4719-9d03-7bbf00ace364"]={f:Ops.Gl.Meshes.LinesArray,objName:"Ops.Gl.Meshes.LinesArray"};




// **************************************************************
// 
// Ops.Gl.Meshes.MeshInstancerFromTexture_v2
// 
// **************************************************************

Ops.Gl.Meshes.MeshInstancerFromTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"instancer_body_frag":"#ifdef USE_TEX_COLOR\n    #ifdef BLEND_MODE_MULTIPLY\n        col.rgb *= frag_instColor.rgb;\n        col.a *= frag_instColor.a;\n    #endif\n\n    #ifdef BLEND_MODE_ADD\n        col.rgb += frag_instColor.rgb;\n        col.a += frag_instColor.a;\n    #endif\n\n    #ifdef BLEND_MODE_NONE\n        col.rgb = frag_instColor.rgb;\n        col.a = frag_instColor.a;\n    #endif\n#endif\n","instancer_body_vert":"float tx=mod(instanceIndex,(MOD_texSizeX))/MOD_texSizeX+(1.0/MOD_texSizeX*0.5);\nfloat ty=float(int((instanceIndex/(MOD_texSizeX))))/MOD_texSizeY+(1.0/MOD_texSizeY*0.5);\n\nvec3 MOD_texPos=texture(MOD_texTrans,vec2(tx,ty)).rgb*MOD_mulRGB;\nmat4 texInstMat;\nvec3 scale=vec3(1.0);\n\n#ifdef USE_TEX_SCALE\n    scale*=texture(MOD_texScale,vec2(tx,ty)).rgb;\n#endif\n\ntexInstMat[0][0]=\ntexInstMat[1][1]=\ntexInstMat[2][2]=\ntexInstMat[3][3]=1.0;\n\n#ifdef USE_TEX_ROT\n    vec3 MOD_texRota=texture(MOD_texRot,vec2(tx,ty)).rgb;\n    texInstMat*=rotationMatrix(vec3(1.0,0.0,0.0),MOD_texRota.r*PI*2.0);\n    texInstMat*=rotationMatrix(vec3(0.0,1.0,0.0),MOD_texRota.g*PI*2.0);\n    texInstMat*=rotationMatrix(vec3(0.0,0.0,1.0),MOD_texRota.b*PI*2.0);\n#endif\n\ntexInstMat[3][0]=MOD_texPos.x;\ntexInstMat[3][1]=MOD_texPos.y;\ntexInstMat[3][2]=MOD_texPos.z;\n\nmat4 scalem;\nscalem[0][0]=MOD_scale*scale.x;\nscalem[1][1]=MOD_scale*scale.y;\nscalem[2][2]=MOD_scale*scale.z;\nscalem[3][3]=1.0;\ntexInstMat*=scalem;\n\nmMatrix*=texInstMat;\n\n#ifdef USE_TEX_COLOR\n\n    vec4 instColor=texture(MOD_texColor,vec2(tx,ty));\n\n    frag_instColor=instColor;\n#endif\n\n#ifdef USE_TEX_TC\n    vec4 instTexCoords=texture(MOD_texCoords,vec2(tx,ty));\n\n    texCoord=(texCoord*instTexCoords.zw)+instTexCoords.xy;\n#endif\n\n\n\n\n","instancer_head_frag":"IN vec4 frag_instColor;\n","instancer_head_vert":"IN mat4 instMat;\nIN vec4 instColor;\nIN float instanceIndex;\nOUT mat4 instModelMat;\nOUT vec4 frag_instColor;\n\n#define INSTANCING\n#define PI 3.14159265358\n\nmat3 ntorot(vec3 r)\n{\n    float cx = cos(radians(r.x));\n    float sx = sin(radians(r.x));\n    float cy = cos(radians(r.y));\n    float sy = sin(radians(r.y));\n    float cz = cos(radians(r.z));\n    float sz = sin(radians(r.z));\n\n    return mat3(cy * cz, \tcx * sz + sx * sy * cz, \tsx * sz - cx * sy * cz,\n    \t\t\t-cy * sz,\tcx * cz - sx * sy * sz,\t\tsx * cz + cx * sy * sz,\n    \t\t\tsy,\t\t\t-sx * cy,\t\t\t\t\tcx * cy);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// vec4 MOD_rot(vec4 pos, vec3 rot, mat4 modelMatrix)\n// {\n//     // pos=pos*rotationX(rot.x)*rotationY(rot.y)*rotationZ(rot.z);\n//     pos.xyz*=ntorot( (rot-0.5) * 3.14*2.0 );\n\n//     return pos;\n// }\n",};
const
    exe = op.inTrigger("exe"),
    geom = op.inObject("Geometry", null, "geometry"),
    inNum = op.inInt("Num Instances", 1000),
    inTex = op.inTexture("Position Texture", null, "texture"),
    inTex2 = op.inTexture("Rotation Texture", null, "texture"),
    inTex3 = op.inTexture("Scale Texture", null, "texture"),
    inTex4 = op.inTexture("Color Texture", null, "texture"),
    inTex5 = op.inTexture("TexCoord Texture", null, "texture"),
    inBlendMode = op.inSwitch("Color Texture Blendmode", ["Multiply", "Add", "Normal"], "Multiply"),
    inScale = op.inValue("Scale", 1),
    inMulR = op.inValue("Multiply Pos X", 1),
    inMulG = op.inValue("Multiply Pos Y", 1),
    inMulB = op.inValue("Multiply Pos Z", 1),
    outTrigger = op.outTrigger("Trigger Out"),
    outNum = op.outNumber("Num");

op.toWorkPortsNeedToBeLinked(geom);
op.toWorkPortsNeedToBeLinked(exe);

geom.ignoreValueSerialize = true;

const cgl = op.patch.cgl;
const m = mat4.create();
let
    // matrixArray = new Float32Array(1),
    // instColorArray = new Float32Array(1),
    mesh = null,
    recalc = true,
    num = 0,
    arrayChangedTrans = true;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "name": "MODULE_VERTEX_POSITION",
    "title": op.name,
    "priority": -2,
    "srcHeadVert": attachments.instancer_head_vert,
    "srcBodyVert": attachments.instancer_body_vert
});

mod.addModule({
    "name": "MODULE_COLOR",
    "priority": -2,
    "title": op.name,
    "srcHeadFrag": attachments.instancer_head_frag,
    "srcBodyFrag": attachments.instancer_body_frag,
});

mod.addUniformVert("f", "MOD_scale", inScale);
mod.addUniformVert("t", "MOD_texTrans");
mod.addUniformVert("t", "MOD_texRot");
mod.addUniformVert("t", "MOD_texScale");
mod.addUniformVert("t", "MOD_texCoords");
mod.addUniformVert("t", "MOD_texColor");
mod.addUniformVert("f", "MOD_texSizeX", 0);
mod.addUniformVert("f", "MOD_texSizeY", 0);
mod.addUniformVert("3f", "MOD_mulRGB", inMulR, inMulG, inMulB);

inBlendMode.onChange =
inTex.onChange =
inTex3.onChange =
inTex4.onChange =
inTex5.onChange =
inTex2.onChange = updateDefines;

// inBlendMode.onChange = updateDefines;
// doLimit.onChange = updateLimit;
exe.onTriggered = doRender;
exe.onLinkChanged = function ()
{
    if (!exe.isLinked()) removeModule();
};

inNum.onChange =
    function ()
    {
        arrayChangedTrans = true;
        recalc = true;
    };

function reset()
{
    arrayChangedTrans = true;
    recalc = true;
}

function updateDefines()
{
    mod.toggleDefine("BLEND_MODE_MULTIPLY", inBlendMode.get() === "Multiply");
    mod.toggleDefine("BLEND_MODE_ADD", inBlendMode.get() === "Add");
    mod.toggleDefine("BLEND_MODE_NONE", inBlendMode.get() === "Normal");

    mod.toggleDefine("USE_TEX_ROT", inTex2.get());
    mod.toggleDefine("USE_TEX_SCALE", inTex3.get());
    mod.toggleDefine("USE_TEX_COLOR", inTex4.get());
    mod.toggleDefine("USE_TEX_TC", inTex5.get());
}

geom.onChange = function ()
{
    if (mesh)mesh.dispose();

    if (!geom.get() || !geom.get().vertices)
    {
        mesh = null;
        return;
    }
    mesh = new CGL.Mesh(cgl, geom.get());
    reset();
};

function removeModule()
{

}

function setupArray()
{
    if (!mesh) return;

    num = Math.max(0, Math.floor(inNum.get()));

    // if (matrixArray.length != num * 16) matrixArray = new Float32Array(num * 16);

    // for (let i = 0; i < num; i++)
    // {
    //     mat4.identity(m);
    //     for (let a = 0; a < 16; a++) matrixArray[i * 16 + a] = m[a];
    // }

    mesh.numInstances = num;
    // mesh.addAttribute("instMat", matrixArray, 16);

    recalc = false;
}

function doRender()
{
    if (!mesh) return;
    if (recalc) setupArray();

    if (!inTex.get()) return;
    if (inTex.get())mod.pushTexture("MOD_texTrans", inTex.get().tex);
    if (inTex2.get())mod.pushTexture("MOD_texRot", inTex2.get().tex);
    if (inTex3.get())mod.pushTexture("MOD_texScale", inTex3.get().tex);
    if (inTex4.get())mod.pushTexture("MOD_texColor", inTex4.get().tex);
    if (inTex5.get())mod.pushTexture("MOD_texCoords", inTex5.get().tex);

    mod.bind();
    mod.setUniformValue("MOD_texSizeX", inTex.get().width);
    mod.setUniformValue("MOD_texSizeY", inTex.get().height);

    // mesh.numInstances = num;

    outNum.set(mesh.numInstances);

    if (mesh.numInstances > 0) mesh.render(cgl.getShader());

    outTrigger.trigger();

    mod.unbind();
}


};

Ops.Gl.Meshes.MeshInstancerFromTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["10771b66-4b63-4f47-b050-3b9c44cb2780"]={f:Ops.Gl.Meshes.MeshInstancerFromTexture_v2,objName:"Ops.Gl.Meshes.MeshInstancerFromTexture_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.ParametricSurface
// 
// **************************************************************

Ops.Gl.Meshes.ParametricSurface = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
/* presets for parametric surface */
const parametricBodies = [
    {
        "title": "Rectangle",
        "xFunction": "u",
        "yFunction": "v",
        "zFunction": "0",
        "uMin": 0,
        "uMax": 2,
        "vMin": 0,
        "vMax": 1,
        "isPiU": false,
        "isPiV": false,
        "uSegments": 24,
        "vSegments": 24,
        "scaleX": 1,
        "scaleY": 1,
        "scaleZ": 1,
        "displaceU": -1,
        "displaceV": -0.5
    },
    {
        "title": "Archimedic Spiral",
        "xFunction": "u*cos(u)",
        "yFunction": "v",
        "zFunction": "u*sin(u)",

        "uMin": 0,
        "uMax": 50,
        "vMin": 0,
        "vMax": 1,
        "isPiU": false,
        "isPiV": false,

        "uSegments": 300,
        "vSegments": 20,

        "scaleX": 0.05,
        "scaleY": 0.05,
        "scaleZ": 0.05,

        "displaceU": 0,
        "displaceV": -3
    },
    {
        "title": "Cylinder",
        "xFunction": "0.5*cos(u)",
        "yFunction": "v",
        "zFunction": "0.5*sin(u)",

        "uMin": -1,
        "uMax": 1,
        "vMin": 0,
        "vMax": 1,
        "isPiU": true,
        "isPiV": false,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 1,
        "scaleY": 1,
        "scaleZ": 1,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Pillow",
        "zFunction": "cos(u)",
        "yFunction": "-1*cos(v)",
        "xFunction": "0.8*sin(u)*sin(v)",

        "uMin": 0,
        "uMax": 1,
        "vMin": -1,
        "vMax": 1,
        "isPiU": true,
        "isPiV": true,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 0.8,
        "scaleY": 0.8,
        "scaleZ": 0.8,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Sine Surface",
        "zFunction": "sin(u)",
        "yFunction": "sin(v)",
        "xFunction": "sin(u+v)",

        "uMin": -1,
        "uMax": 1,
        "vMin": -1,
        "vMax": 1,
        "isPiU": true,
        "isPiV": true,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 0.8,
        "scaleY": 0.8,
        "scaleZ": 0.8,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Steinbach Screw",
        "xFunction": "v*cos(u)",
        "yFunction": "u*sin(v)",
        "zFunction": "u*cos(v)",


        "uMin": -4,
        "uMax": 4,
        "vMin": 0,
        "vMax": 2,
        "isPiU": false,
        "isPiV": true,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 0.18,
        "scaleY": 0.18,
        "scaleZ": 0.18,

        "displaceU": 0,
        "displaceV": 0
    },

    {
        "title": "Moebius Band",
        "xFunction": "cos(v)*(1 + u*cos(v/2))",
        "yFunction": "sin(v)*(1 + u*cos(v/2))",
        "zFunction": "u*sin(v/2)",


        "uMin": -0.3,
        "uMax": 0.3,
        "vMin": 0,
        "vMax": 2,
        "isPiU": false,
        "isPiV": true,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 0.6,
        "scaleY": 0.6,
        "scaleZ": 0.6,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Wavy Sphere",
        "xFunction": "u*cos(cos(u))*cos(v)",
        "yFunction": "u*cos(cos(u))*sin(v)",
        "zFunction": "u*sin(cos(u))",

        "uMin": 0,
        "uMax": 45,
        "vMin": 0,
        "vMax": 2,
        "isPiU": false,
        "isPiV": true,

        "uSegments": 100,
        "vSegments": 100,

        "scaleX": 0.02,
        "scaleY": 0.02,
        "scaleZ": 0.02,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Spring",
        "xFunction": "(2 + 0.5*cos(v))*cos(u)",
        "yFunction": "(2 + 0.5*cos(v))*sin(u)",
        "zFunction": "0.5*(sin(v) + 2*u/PI)",

        "uMin": 0,
        "uMax": 15,
        "vMin": 0,
        "vMax": 2,
        "isPiU": true,
        "isPiV": true,

        "uSegments": 100,
        "vSegments": 100,

        "scaleX": 0.1,
        "scaleY": 0.1,
        "scaleZ": 0.1,

        "displaceU": 0,
        "displaceV": 0
    },

    {
        "title": "Folium",
        "xFunction": "cos(u)*(2*v/PI - tanh(v))",
        "yFunction": "cos(u + 2*PI/3)/cosh(v)",
        "zFunction": "cos(u - 2*PI/3)/cosh(v)",

        "uMin": -1,
        "uMax": 1,
        "vMin": -1,
        "vMax": 1,
        "isPiU": true,
        "isPiV": true,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 1.3,
        "scaleY": 1.3,
        "scaleZ": 1.3,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Hyperbolic Octahedron",
        "xFunction": "pow(cos(u)*cos(v), 3)",
        "yFunction": "pow(sin(u)*cos(v), 3)",
        "zFunction": "pow(sin(v), 3)",

        "uMin": -1 / 2,
        "uMax": 1 / 2,
        "vMin": -1,
        "vMax": 1,
        "isPiU": true,
        "isPiV": true,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 1.3,
        "scaleY": 1.3,
        "scaleZ": 1.3,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Maeder's Owl",
        "xFunction": "v*cos(u)-0.5*v*v*cos(2*u)",
        "yFunction": "-1*v*sin(u) - 0.5*v*v*sin(2*u)",
        "zFunction": "4*exp(1.5*log(v))*cos(3*u/2)/3",

        "uMin": 0,
        "uMax": 4,
        "vMin": 0.001,
        "vMax": 4,
        "isPiU": true,
        "isPiV": false,

        "uSegments": 100,
        "vSegments": 100,

        "scaleX": 0.071,
        "scaleY": 0.071,
        "scaleZ": 0.071,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Tranguloid Trefoil",
        "xFunction": "2*sin(3*u)/(2+cos(v))",
        "yFunction": "2*(sin(u) + 2*sin(2*u))/(2+cos(v+2*PI/3))",
        "zFunction": "(cos(u)-2*cos(2*u))*(2+cos(v+2*PI/3))/4",

        "uMin": -1,
        "uMax": 1,
        "vMin": -1,
        "vMax": 1,
        "isPiU": true,
        "isPiV": true,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 0.3,
        "scaleY": 0.2,
        "scaleZ": 0.3,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Apple",
        "xFunction": "cos(u)*(5 + 4.8 *cos(v)) + pow(v/PI, 20)",
        "yFunction": "-2.3*log(1-v*0.3157) + 6*sin(v) + 2*cos(v) ",
        "zFunction": "sin(u)*(5 + 4.8*cos(v)) + 0.25*cos(5*u)",

        "uMin": -1,
        "uMax": 1,
        "vMin": -1,
        "vMax": 1,
        "isPiU": true,
        "isPiV": true,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 0.06,
        "scaleY": 0.06,
        "scaleZ": 0.06,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Kuen's Surface",
        "xFunction": "(2*(cos(u) + u*sin(u))*sin(v))/(1+u*u*sin(v)*sin(v))",
        "yFunction": "(2*(-u*cos(u) + sin(u))*sin(v))/(1+u*u*sin(v)*sin(v))",
        "zFunction": "log(tan(v/2)) + 2*cos(v)/(1+u*u*sin(v)*sin(v))",

        "uMin": -4.3,
        "uMax": 4.3,
        "vMin": 0.03,
        "vMax": 31.11,
        "isPiU": false,
        "isPiV": false,

        "uSegments": 100,
        "vSegments": 100,

        "scaleX": 0.7,
        "scaleY": 0.7,
        "scaleZ": 0.7,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Henneberg's Surface",
        "xFunction": "2*cos(v)*sinh(u)-0.667*cos(3*v)*sinh(3*u)",
        "yFunction": "2*sin(v)*sinh(u)+0.667*sin(3*v)*sinh(3*u)",
        "zFunction": "2*cos(2*v)*cosh(2*u)",

        "uMin": -1,
        "uMax": 1,
        "vMin": -0.5,
        "vMax": 0.5,
        "isPiU": false,
        "isPiV": true,

        "uSegments": 100,
        "vSegments": 100,

        "scaleX": 0.1,
        "scaleY": 0.1,
        "scaleZ": 0.1,

        "displaceU": 0,
        "displaceV": 0
    },
    {
        /*
a : 1.6
b : 1.6
c	:	1.0
h	:	1.5
k	:	-7.0
w	:	0.075
umin	:	-50.0
umax	:	-1.0
    */
        "title": "Pseudoheliceras subcatenatum",

        "xFunction": "exp(0.075*u)*(1.5 + 1.6 * cos(v))*cos(1.0*u)",
        "yFunction": "-1 * exp(0.075*u)*(1.5 + 1.6 * cos(v))*sin(1.0*u)",
        "zFunction": "exp(0.075*u)*(-7 + 1.6 * sin(v))",

        "uMin": -50,
        "uMax": -1,
        "vMin": 0,
        "vMax": 2,
        "isPiU": false,
        "isPiV": true,

        "uSegments": 50,
        "vSegments": 50,

        "scaleX": 0.3,
        "scaleY": 0.3,
        "scaleZ": 0.3,

        "displaceU": 0,
        "displaceV": 0

    },
    {
        "title": "Little Cycloid",
        "xFunction": "cos(u/2)*cos(u/5)*(10 + cos(v)) + sin(u/5)*sin(v)*cos(v)",
        "yFunction": "sin(u/2)*cos(u/5)*(10 + cos(v)) + sin(u/5)*sin(v)*cos(v)",
        "zFunction": "-sin(u/5)*(10+cos(v))*sin(v)*cos(v)",

        "uMin": 0,
        // 2*b*c
        "uMax": 2 * 5 * 2,
        "vMin": 0,
        "vMax": 4,
        "isPiU": true,
        "isPiV": true,

        "uSegments": 100,
        "vSegments": 100,

        "scaleX": 0.05,
        "scaleY": 0.05,
        "scaleZ": 0.05,

        "displaceU": 0,
        "displaceV": -3
    },
    {
        //  R=50, r=12.5, p=7 und q=3
        "title": "Torus Knot",
        "xFunction": "(50+90*cos(7*u) + 12.5*cos(v)) * cos(8*u)",
        "yFunction": "12.5*sin(v) + 90*sin(7*u)",
        "zFunction": "(50+90*cos(7*u) + 12.5*cos(v)) * sin(8*u)",
        "uMin": 0,
        "uMax": 2,
        "vMin": 0,
        "vMax": 2,
        "isPiU": true,
        "isPiV": true,
        "uSegments": 200,
        "vSegments": 200,
        "scaleX": 0.005,
        "scaleY": 0.005,
        "scaleZ": 0.005,
        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Triaxial Tritorus",
        "yFunction": "sin(u)*(1 + cos(v))",
        "xFunction": "sin(u+2*PI/3)*(1+cos(v+2*PI/3))",
        "zFunction": "sin(u+4*PI/3)*(1+cos(v+4*PI/3))",
        "uMin": -1,
        "uMax": 1,
        "vMin": -1,
        "vMax": 1,
        "isPiU": true,
        "isPiV": true,
        "uSegments": 100,
        "vSegments": 100,
        "scaleX": 0.7,
        "scaleY": 0.7,
        "scaleZ": 0.7,
        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Triaxial Hexatorus",
        "xFunction": "sin(u)/(sqrt(2)+cos(v))",
        "yFunction": "sin(u+2*PI/3)/(sqrt(2)+cos(v+2*PI/3))",
        "zFunction": "cos(u-2*PI/3)/(sqrt(2)+cos(v-2*PI/3))",
        "uMin": 0,
        "uMax": 2,
        "vMin": 0,
        "vMax": 2,
        "isPiU": true,
        "isPiV": true,
        "uSegments": 100,
        "vSegments": 100,
        "scaleX": 0.8,
        "scaleY": 0.8,
        "scaleZ": 0.8,
        "displaceU": 0,
        "displaceV": 0
    },
    {
        "title": "Hyperbolic Helicoid",
        "xFunction": "sinh(v)*cos(4.13*u)/(1+cosh(u)*cosh(v))",
        "yFunction": "sinh(v)*sin(4.13*u)/(1+cosh(u)*cosh(v))",
        "zFunction": "cosh(v)*sinh(u)/(1+cosh(u)*cosh(v))",
        "uMin": -4,
        "uMax": 4,
        "vMin": -4,
        "vMax": 4,
        "isPiU": false,
        "isPiV": false,
        "uSegments": 100,
        "vSegments": 100,
        "scaleX": 1,
        "scaleY": 1,
        "scaleZ": 1,
        "displaceU": 0,
        "displaceV": 0
    },

    {
        "title": "Triple Corkscrew III",
        "xFunction": "u*1.3",
        "yFunction": "0.5*(0.4*(1 - abs(u)) * cos(v) + cos(0.4)*cos(u*PI/2)*cos(u*10*PI))",
        "zFunction": "0.5*(0.4*(1-abs(u))*sin(v) + cos(0.4)*cos(u*PI/2)*sin(u*10*PI))",
        "uMin": -1,
        "uMax": 1,
        "vMin": -1,
        "vMax": 1,
        "isPiU": false,
        "isPiV": true,
        "uSegments": 190,
        "vSegments": 190,
        "scaleX": 1,
        "scaleY": 1,
        "scaleZ": 1,
        "displaceU": 0,
        "displaceV": 0
    },
    {
        // a = 0.4
        // uMin = -13.2
        // uMax = 13.2
        // vMin = -37.4
        // vMax = 37.4


        // r = 1-0.4*0.4
        // w = sqrt(r)
        // d = a( pow(w * cosh(a*u), 2) + pow(a*sin(w*v), 2) )
        // x = -u + (2*r*cosh(a*u)*sinh(a*u)/d)
        // y = 2*w*cosh(a*u)*(-1*(w*cos(v)*cos(w*v)) - (sin(v) * sin(w*v)))/d
        // z = 2*w*cosh(a*u) * (-1* (w*sin(v)*cos(w*v)) + (cos(v)*sin(w*v)))/d
        /*
                w = sqrt(1-0.4*0.4)
                d = 0.4( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) )
                x = -u + (2*(1-0.4*0.4)*cosh(0.4*u)*sinh(0.4*u)/(0.4*( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) )))
                y = 2*(sqrt(1-0.4*0.4))*cosh(0.4*u)*(-1*((sqrt(1-0.4*0.4))*cos(v)*cos((sqrt(1-0.4*0.4))*v)) - (sin(v) * sin((sqrt(1-0.4*0.4))*v)))/(0.4*( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) ))
                z = 2*sqrt(1-0.4*0.4)*cosh(0.4*u) * (-1* (sqrt(1-0.4*0.4)*sin(v)*cos(sqrt(1-0.4*0.4)*v)) + (cos(v)*sin(sqrt(1-0.4*0.4)*v)))/(0.4*( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) ))
                */
        "title": "Breather Surface",
        "xFunction": "-u + (2*(1-0.4*0.4)*cosh(0.4*u)*sinh(0.4*u)/(0.4*( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) )))",
        "yFunction": "2*(sqrt(1-0.4*0.4))*cosh(0.4*u)*(-1*((sqrt(1-0.4*0.4))*cos(v)*cos((sqrt(1-0.4*0.4))*v)) - (sin(v) * sin((sqrt(1-0.4*0.4))*v)))/(0.4*( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) ))",
        "zFunction": "2*sqrt(1-0.4*0.4)*cosh(0.4*u) * (-1* (sqrt(1-0.4*0.4)*sin(v)*cos(sqrt(1-0.4*0.4)*v)) + (cos(v)*sin(sqrt(1-0.4*0.4)*v)))/(0.4*( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) ))",
        "uMin": -13.2,
        "uMax": 13.2,
        "vMin": -37.4,
        "vMax": 37.4,
        "isPiU": false,
        "isPiV": false,
        "uSegments": 190,
        "vSegments": 190,
        "scaleX": 0.2,
        "scaleY": 0.2,
        "scaleZ": 0.2,
        "displaceU": 0,
        "displaceV": 0
    },
    {
        // a = 0.4
        // uMin = -13.2
        // uMax = 13.2
        // vMin = -37.4
        // vMax = 37.4


        // r = 1-0.4*0.4
        // w = sqrt(r)
        // d = a( pow(w * cosh(a*u), 2) + pow(a*sin(w*v), 2) )
        // x = -u + (2*r*cosh(a*u)*sinh(a*u)/d)
        // y = 2*w*cosh(a*u)*(-1*(w*cos(v)*cos(w*v)) - (sin(v) * sin(w*v)))/d
        // z = 2*w*cosh(a*u) * (-1* (w*sin(v)*cos(w*v)) + (cos(v)*sin(w*v)))/d
        /*
                w = sqrt(1-0.4*0.4)
                d = 0.4( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) )
                x = -u + (2*(1-0.4*0.4)*cosh(0.4*u)*sinh(0.4*u)/(0.4*( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) )))
                y = 2*(sqrt(1-0.4*0.4))*cosh(0.4*u)*(-1*((sqrt(1-0.4*0.4))*cos(v)*cos((sqrt(1-0.4*0.4))*v)) - (sin(v) * sin((sqrt(1-0.4*0.4))*v)))/(0.4*( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) ))
                z = 2*sqrt(1-0.4*0.4)*cosh(0.4*u) * (-1* (sqrt(1-0.4*0.4)*sin(v)*cos(sqrt(1-0.4*0.4)*v)) + (cos(v)*sin(sqrt(1-0.4*0.4)*v)))/(0.4*( pow(sqrt(1-0.4*0.4) * cosh(0.4*u), 2) + pow(0.4*sin(sqrt(1-0.4*0.4)*v), 2) ))
                */
        "title": "Breather Surface II",
        "xFunction": "-u + (2*(1-0.6*0.6)*cosh(0.6*u)*sinh(0.6*u)/(0.6*( pow(sqrt(1-0.6*0.6) * cosh(0.6*u), 2) + pow(0.6*sin(sqrt(1-0.6*0.6)*v), 2) )))",
        "yFunction": "2*(sqrt(1-0.6*0.6))*cosh(0.6*u)*(-1*((sqrt(1-0.6*0.6))*cos(v)*cos((sqrt(1-0.6*0.6))*v)) - (sin(v) * sin((sqrt(1-0.6*0.6))*v)))/(0.6*( pow(sqrt(1-0.6*0.6) * cosh(0.6*u), 2) + pow(0.6*sin(sqrt(1-0.6*0.6)*v), 2) ))",
        "zFunction": "2*sqrt(1-0.6*0.6)*cosh(0.6*u) * (-1* (sqrt(1-0.6*0.6)*sin(v)*cos(sqrt(1-0.6*0.6)*v)) + (cos(v)*sin(sqrt(1-0.6*0.6)*v)))/(0.6*( pow(sqrt(1-0.6*0.6) * cosh(0.6*u), 2) + pow(0.6*sin(sqrt(1-0.6*0.6)*v), 2) ))",
        "uMin": -8,
        "uMax": 8,
        "vMin": -15.55,
        "vMax": 15.55,
        "isPiU": false,
        "isPiV": false,
        "uSegments": 190,
        "vSegments": 190,
        "scaleX": 0.2,
        "scaleY": 0.2,
        "scaleZ": 0.2,
        "displaceU": 0,
        "displaceV": 0
    }
];


let shouldRender = true;
let shouldScale = true;

const shapes = op.inDropDown("shapes", parametricBodies.map((bod) => { return bod.title; }));

const render = op.inTrigger("render");
const inSegmentsU = op.inValueInt("u Segments", 48);
const inSegmentsV = op.inValueInt("v Segments", 48);
const multByPiU = op.inValueBool("Multiple of PI - u", false);
const inMinU = op.inValueFloat("uMin", -2);
const inMaxU = op.inValueFloat("uMax", 2);
const inDisplaceU = op.inValueFloat("Displace U", 0);

const multByPiV = op.inValueBool("Multiple of PI - v", false);
const inMinV = op.inValueFloat("vMin", -1);
const inMaxV = op.inValueFloat("vMax", 1);
const inDisplaceV = op.inValueFloat("Displace V", 0);

op.setPortGroup("Segments", [inSegmentsU, inSegmentsV]);
op.setPortGroup("V range", [multByPiV, inMaxV, inMinV, inDisplaceV]);
op.setPortGroup("U range", [multByPiU, inMaxU, inMinU, inDisplaceU]);
const inFunctionX = op.inString("X Function", "u");
const inFunctionY = op.inString("Y Function", "v");

const inFunctionZ = op.inString("Z Function", "0");
const inScaleX = op.inFloatSlider("Scale X", 1);
const inScaleY = op.inFloatSlider("Scale Y", 1);
const inScaleZ = op.inFloatSlider("Scale Z", 1);

op.setPortGroup("XYZ Functions", [inFunctionX, inScaleX, inFunctionY, inScaleY, inFunctionZ, inScaleZ]);
op.setPortGroup("Scaling", [inScaleX, inScaleY, inScaleZ]);
const draw = op.inValueBool("Draw", true);
op.setPortGroup("Draw", [draw]);


const inObj = {
    "xFunction": inFunctionX,
    "yFunction": inFunctionY,
    "zFunction": inFunctionZ,

    "isPiU": multByPiU,
    "uMin": inMinU,
    "uMax": inMaxU,

    "isPiV": multByPiV,
    "vMin": inMinV,
    "vMax": inMaxV,

    "uSegments": inSegmentsU,
    "vSegments": inSegmentsV,

    "scaleX": inScaleX,
    "scaleY": inScaleY,
    "scaleZ": inScaleZ,

    "displaceU": inDisplaceU,
    "displaceV": inDisplaceV
};


const trigger = op.outTrigger("trigger");


const geomOut = op.outObject("geometry");
const outPosition = op.outArray("Position");
const outLength = op.outNumber("Position Amount");
geomOut.ignoreValueSerialize = true;


Object.keys(inObj).forEach((key) =>
{
    inObj[key].set(parametricBodies[0][key]);
});

shapes.set("Rectangle");

shapes.onChange = ({ value }) =>
{
    const [shape] = parametricBodies.filter((s) => { return s.title === value; });
    Object.keys(inObj).forEach((key) =>
    {
        inObj[key].set(shape[key]);
    });

    op.refreshParams();
    create();
};

const cgl = op.patch.cgl;
let mesh = null;
let geom = null;

const create = () =>
{
    if (shouldRender)
    {
        const uSegments = inSegmentsU.get();
        const vSegments = inSegmentsV.get();

        let uMax = inMinU.get() > inMaxU.get() ? inMinU.get() : inMaxU.get();
        let vMax = inMinV.get() > inMaxV.get() ? inMinV.get() : inMaxV.get();
        let uMin = inMaxU.get() < inMinU.get() ? inMaxU.get() : inMinU.get();
        let vMin = inMaxV.get() < inMinV.get() ? inMaxV.get() : inMinV.get();

        uMax = multByPiU.get() ? uMax * Math.PI : uMax;
        vMax = multByPiV.get() ? vMax * Math.PI : vMax;

        uMin = multByPiU.get() ? uMin * Math.PI : uMin;
        vMin = multByPiV.get() ? vMin * Math.PI : vMin;

        const displaceU = inDisplaceU.get();
        const displaceV = inDisplaceV.get();

        const xFunctionString = inFunctionX.get();
        const yFunctionString = inFunctionY.get();
        const zFunctionString = inFunctionZ.get();

        const scaleX = inScaleX.get();
        const scaleY = inScaleY.get();
        const scaleZ = inScaleZ.get();
        let xFunction;
        let yFunction;
        let zFunction;

        const coords = [];
        const texCoords = [];
        const paramVertexIndices = [];
        let normals;
        let tangents;
        let bitangents;

        try
        {
            xFunction = new Function("m", "u", "v", `with(m) { return ${xFunctionString} }`);
            yFunction = new Function("m", "u", "v", `with(m) { return ${yFunctionString} }`);
            zFunction = new Function("m", "u", "v", `with(m) { return ${zFunctionString} }`);

            for (let i = 0; i <= uSegments; i += 1)
            {
                for (let j = 0; j <= vSegments; j += 1)
                {
                    const u_tex = uMin + (i * (uMax - uMin) / uSegments);
                    const v_tex = vMin + (j * (vMax - vMin) / vSegments);

                    const u = displaceU + u_tex;
                    const v = displaceV + v_tex;

                    let x = xFunction(Math, u, v);
                    let y = yFunction(Math, u, v);
                    let z = zFunction(Math, u, v);

                    if (shouldScale)
                    {
                        x *= scaleX;
                        y *= scaleY;
                        z *= scaleZ;
                    }

                    coords.push(x, y, z);


                    texCoords.push(CABLES.map(u_tex, uMin, uMax, 0, 1), CABLES.map(v_tex, vMin, vMax, 1, 0));

                    if (i < uSegments && j < vSegments)
                    {
                        paramVertexIndices.push(i * (vSegments + 1) + j);
                        paramVertexIndices.push((i + 1) * (vSegments + 1) + j);
                        paramVertexIndices.push((i) * (vSegments + 1) + j + 1);

                        paramVertexIndices.push((i + 1) * (vSegments + 1) + j);
                        paramVertexIndices.push((i + 1) * (vSegments + 1) + j + 1);
                        paramVertexIndices.push((i) * (vSegments + 1) + j + 1);
                    }
                }
            }

            tangents = [];
            bitangents = [];
            normals = [];
        }
        catch (e)
        {
            if (e instanceof ReferenceError || e instanceof SyntaxError) { op.logError(e); return; }
            op.log(e);
        }
        geom = new CGL.Geometry("parametric surface");
        geom.clear();
        geom.vertices = coords || [];
        geom.texCoords = texCoords;
        geom.verticesIndices = paramVertexIndices;

        geom.calculateNormals();
        geom.calcTangentsBitangents();

        if (geom.vertices.length == 0) return;

        if (!mesh)
        {
            mesh = new CGL.Mesh(cgl, geom);
        }
        else
        {
            mesh.setGeom(geom);
        }
        geomOut.set(null);
        geomOut.set(geom);
    }
    outPosition.set(null);
    outPosition.set(geom.vertices);
    outLength.set(geom.vertices.length);
    shouldRender = false;
    shouldScale = false;
};

create();

const setRender = () =>
{
    shouldScale = true;
    shouldRender = true;
};
const setScale = () =>
{
    shouldScale = true;
    shouldRender = true;
};

draw.onChange =
 inSegmentsU.onChange =
 inSegmentsV.onChange =
 inMaxU.onChange =
 inMaxV.onChange =
 inMinU.onChange =
 inMinV.onChange =
 inDisplaceV.onChange =
 inDisplaceU.onChange =
 multByPiV.onChange =
 multByPiU.onChange =
 inFunctionX.onChange =
 inFunctionY.onChange =
 inFunctionZ.onChange = setRender;

inScaleX.onChange =
inScaleY.onChange =
inScaleZ.onChange = setScale;

render.onTriggered = function ()
{
    if (shouldRender) create();
    if (draw.get())
    {
        mesh.render(cgl.getShader());
    }
    trigger.trigger();
};


};

Ops.Gl.Meshes.ParametricSurface.prototype = new CABLES.Op();
CABLES.OPS["5d3211a6-801d-4e59-ba6f-546ffe5fd34a"]={f:Ops.Gl.Meshes.ParametricSurface,objName:"Ops.Gl.Meshes.ParametricSurface"};




// **************************************************************
// 
// Ops.Gl.Meshes.PointCloudFromArray
// 
// **************************************************************

Ops.Gl.Meshes.PointCloudFromArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    arr = op.inArray("Array", 3),
    numPoints = op.inValueInt("Num Points"),
    outTrigger = op.outTrigger("Trigger out"),
    outGeom = op.outObject("Geometry"),
    pTexCoordRand = op.inValueBool("Scramble Texcoords", true),
    seed = op.inValue("Seed", 1),
    inCoords = op.inArray("Coordinates", 2),
    vertCols = op.inArray("Vertex Colors", 4);

op.toWorkPortsNeedToBeLinked(arr, exe);
op.setPortGroup("Texture Coordinates", [pTexCoordRand, seed, inCoords]);

const cgl = op.patch.cgl;
const geom = new CGL.Geometry("pointcloudfromarray");
let deactivated = false;
let mesh = null;
let texCoords = [];
let needsRebuild = true;
let showingError = false;

arr.setUiAttribs({ "title": "Positions" });
inCoords.setUiAttribs({ "title": "Texture Coordinates" });

inCoords.onChange =
    pTexCoordRand.onChange = updateTexCoordsPorts;
vertCols.onChange = updateVertCols;
numPoints.onChange = updateNumVerts;
seed.onChange = arr.onChange = vertCols.onLinkChanged = reset;

exe.onTriggered = doRender;

function doRender()
{
    outTrigger.trigger();
    if (CABLES.UI)
    {
        let shader = cgl.getShader();
        if (shader.glPrimitive != cgl.gl.POINTS) op.setUiError("nopointmat", "Using a Material not made for point rendering. Try to use PointMaterial.");
        else op.setUiError("nopointmat", null);
    }

    if (needsRebuild || !mesh) rebuild();
    if (!deactivated && mesh) mesh.render(cgl.getShader());
}

function reset()
{
    deactivated = arr.get() == null;

    if (!deactivated)needsRebuild = true;
    else needsRebuild = false;
}

function updateTexCoordsPorts()
{
    if (inCoords.isLinked())
    {
        seed.setUiAttribs({ "greyout": true });
        pTexCoordRand.setUiAttribs({ "greyout": true });
    }
    else
    {
        pTexCoordRand.setUiAttribs({ "greyout": false });

        if (!pTexCoordRand.get()) seed.setUiAttribs({ "greyout": true });
        else seed.setUiAttribs({ "greyout": false });
    }

    mesh = null;
    needsRebuild = true;
}

function updateVertCols()
{
    if (!vertCols.get()) return;
    if (!geom.vertexColors) reset();

    if (mesh)mesh.setAttribute(CGL.SHADERVAR_VERTEX_COLOR, vertCols.get(), 4);
}

function updateNumVerts()
{
    if (mesh)
    {
        mesh.setNumVertices(Math.min(geom.vertices.length / 3, numPoints.get()));
        if (numPoints.get() == 0)mesh.setNumVertices(geom.vertices.length / 3);
    }
}

function rebuild()
{
    let verts = arr.get();

    if (!verts || verts.length == 0)
    {
        // mesh=null;
        return;
    }

    if (verts.length % 3 !== 0)
    {
        // if (!showingError)
        // {
        op.setUiError("div3", "Array length not multiple of 3");

        // op.uiAttr({ "error": "Array length not divisible by 3!" });
        // showingError = true;
        // }
        return;
    }
    else op.setUiError("div3", null);

    if (geom.vertices.length == verts.length && mesh && !inCoords.isLinked() && !vertCols.isLinked())
    {
        mesh.setAttribute(CGL.SHADERVAR_VERTEX_POSITION, verts, 3);
        geom.vertices = verts;
        needsRebuild = false;

        return;
    }

    geom.clear();
    let num = verts.length / 3;
    num = Math.abs(Math.floor(num));

    if (num == 0) return;

    if (!texCoords || texCoords.length != num * 2) texCoords = new Float32Array(num * 2); // num*2;//=

    let changed = true;
    let rndTc = pTexCoordRand.get();

    if (!inCoords.isLinked())
    {
        Math.randomSeed = seed.get();
        texCoords = []; // needed otherwise its using the reference to input incoords port
        // let genCoords = !inCoords.isLinked();

        for (let i = 0; i < num; i++)
        {
            if (geom.vertices[i * 3] != verts[i * 3] ||
                geom.vertices[i * 3 + 1] != verts[i * 3 + 1] ||
                geom.vertices[i * 3 + 2] != verts[i * 3 + 2])
            {
                // if (genCoords)
                if (rndTc)
                {
                    texCoords[i * 2] = Math.seededRandom();
                    texCoords[i * 2 + 1] = Math.seededRandom();
                }
                else
                {
                    texCoords[i * 2] = i / num;
                    texCoords[i * 2 + 1] = i / num;
                }
            }
        }
    }

    if (vertCols.get())
    {
        if (!showingError && vertCols.get().length != num * 4)
        {
            op.uiAttr({ "error": "Color array does not have the correct length! (should be " + num * 4 + ")" });
            showingError = true;
            mesh = null;
            return;
        }

        geom.vertexColors = vertCols.get();
    }
    else geom.vertexColors = [];

    if (changed)
    {
        if (inCoords.isLinked()) texCoords = inCoords.get();

        geom.setPointVertices(verts);
        geom.setTexCoords(texCoords);
        // geom.verticesIndices = [];

        if (mesh)mesh.dispose();
        mesh = new CGL.Mesh(cgl, geom, cgl.gl.POINTS);

        mesh.addVertexNumbers = true;
        mesh.setGeom(geom);

        outGeom.set(null);
        outGeom.set(geom);
    }

    updateNumVerts();
    needsRebuild = false;
}


};

Ops.Gl.Meshes.PointCloudFromArray.prototype = new CABLES.Op();
CABLES.OPS["0a6d9c6f-6459-45ca-88ad-268a1f7304db"]={f:Ops.Gl.Meshes.PointCloudFromArray,objName:"Ops.Gl.Meshes.PointCloudFromArray"};




// **************************************************************
// 
// Ops.Gl.Meshes.PointCloudFromTexture
// 
// **************************************************************

Ops.Gl.Meshes.PointCloudFromTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"vertposbody_vert":"\n// float tx=mod(attrVertIndex,(MOD_texSize))/(MOD_texSize);\n// float ty=float(int((attrVertIndex/(MOD_texSize))))/(MOD_texSize);\n\nhighp vec4 col=texture(MOD_tex,texCoord);//vec2(tx,ty));\n\n// vec4 col=texture(MOD_tex,texCoord);\n\n#ifdef MOD_HAS_PS_TEX\n    psMul*=texture(MOD_texPointSize,texCoord).r;\n    // psMul*=attrVertIndex/21000.0;\n#endif\n\nvec3 MOD_pos=col.xyz+pos.xyz;\n\n#ifdef MOD_NORMALIZE\n    MOD_pos=(MOD_pos.xyz-0.5)*2.0;\n#endif\n\n#ifdef MOD_AXIS_XYZ\n    pos.xyz=MOD_pos.xyz+pos.xyz;\n#endif\n\n#ifdef MOD_AXIS_XY\n    pos.xy=MOD_pos.xy+pos.xy;\n    pos.z=0.0+pos.z;\n    pos.w=1.0;\n#endif\n\n#ifdef MOD_REMOVEZERO\n    if(MOD_pos.x==0.0 && MOD_pos.y==0.0 && MOD_pos.z==0.0) psMul=0.0;\n#endif\n",};
const
    render = op.inTrigger("render"),
    inNum = op.inInt("Num Points", 0),
    inAxis = op.inSwitch("Axis", ["XYZ", "XY"], "XYZ"),
    inTex = op.inTexture("Texture", null, "texture"),
    inTexPS = op.inTexture("Point Size", null, "texture"),
    inNorm = op.inBool("Normalize", false),
    inRemove0 = op.inBool("Remove Point at 0", false),
    trigger = op.outTrigger("Trigger"),
    outNumPoints = op.outNumber("Total Points", 0);

const cgl = op.patch.cgl;
let mesh = null;
let numVerts = 0;
let currentNum = 0;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "priority": -10,
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": "",
    "srcBodyVert": attachments.vertposbody_vert
});

mod.addUniformVert("t", "MOD_tex");
mod.addUniformVert("t", "MOD_texPointSize");
render.onTriggered = doRender;
updateDefines();

mod.addUniformVert("f", "MOD_texSize", 0);

inNorm.onChange =
    inTexPS.onChange =
    inRemove0.onChange =
    inAxis.onChange = updateDefines;

let needsMeshSetup = true;

inTex.onChange = () => { if (inTex.get() != CGL.Texture.getEmptyTexture(cgl))needsMeshSetup = true; };
inNum.onChange = () => { needsMeshSetup = true; };
updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_REMOVEZERO", inRemove0);
    mod.toggleDefine("MOD_AXIS_XY", inAxis.get() == "XY");
    mod.toggleDefine("MOD_AXIS_XYZ", inAxis.get() == "XYZ");
    mod.toggleDefine("MOD_NORMALIZE", inNorm.get());
    mod.toggleDefine("MOD_HAS_PS_TEX", inTexPS.get());
}

function doRender()
{
    if (inTex.get() == CGL.Texture.getEmptyTexture(cgl))
    {
        trigger.trigger();

        return;
    }

    if (needsMeshSetup)setupMesh();
    if (!inTex.get() || !inTex.get().tex) return;
    mod.bind();
    if (inTex.get())mod.pushTexture("MOD_tex", inTex.get().tex);
    if (inTexPS.get())mod.pushTexture("MOD_texPointSize", inTexPS.get().tex);

    mod.setUniformValue("MOD_texSize", inTex.get().width + 1);

    if (numVerts > 0 && inNum.get() >= 0 && mesh)
    {
        if (inNum.get() > 0)mesh.setNumVertices(Math.min(numVerts, inNum.get()));
        else mesh.setNumVertices(numVerts);

        mesh.render(cgl.getShader());
    }

    trigger.trigger();
    mod.unbind();
}

function setupMesh()
{
    if (!inTex.get())
    {
        outNumPoints.set(0);
        return;
    }
    const num = inTex.get().width * inTex.get().height;
    outNumPoints.set(num);

    if (num == currentNum) return;
    currentNum = num;

    let verts = new Float32Array(num * 3);
    let texCoords = new Float32Array(num * 2);

    let bias = 0.5 * (1.0 / inTex.get().width);

    for (let x = 0; x < inTex.get().width; x++)
        for (let y = 0; y < inTex.get().height; y++)
        {
            texCoords[(x + y * inTex.get().width) * 2] = (x / inTex.get().width) + bias;
            texCoords[(x + y * inTex.get().width) * 2 + 1] = (y / inTex.get().height) + bias;
        }

    const geom = new CGL.Geometry("pointcloudfromTexture");
    geom.setPointVertices(verts);
    geom.setTexCoords(texCoords);
    geom.verticesIndices = [];
    numVerts = verts.length / 3;

    if (mesh)mesh.dispose();

    if (numVerts > 0) mesh = new CGL.Mesh(cgl, geom, cgl.gl.POINTS);

    if (!mesh) return;
    mesh.addVertexNumbers = true;
    mesh.setGeom(geom);
    needsMeshSetup = false;
}


};

Ops.Gl.Meshes.PointCloudFromTexture.prototype = new CABLES.Op();
CABLES.OPS["105d8812-e641-47f2-bbaf-e45d5bc3ea8b"]={f:Ops.Gl.Meshes.PointCloudFromTexture,objName:"Ops.Gl.Meshes.PointCloudFromTexture"};




// **************************************************************
// 
// Ops.Gl.Meshes.Polyhedron_v2
// 
// **************************************************************

Ops.Gl.Meshes.Polyhedron_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const notation = op.inString("Receipt", "djmeD");

const outGeom = op.outObject("Geometry");

let obj = {};

let faces = [];
let vertices = [];
let vertexColors = [];

notation.onChange = buildMesh;
buildMesh();

function getCellVertices(cellArr)
{
    const verts = [];
    for (let i = 0; i < cellArr.length; i++)
    {
        verts.push(obj.positions[cellArr[i]]);
    }
    return verts;
}

function addFace(verts)
{
    const colR = Math.random();
    const colG = Math.random();
    const colB = Math.random();

    if (verts.length == 3)
    {
        for (var i = 0; i < verts.length; i++)
        {
            vertices.push(verts[i][0], verts[i][1], verts[i][2]);

            var index = vertices.length / 3 - 1;
            faces.push(index);
            vertexColors.push(colR, colG, colB, 1);
        }
    }
    else
    if (verts.length == 4)
    {
        for (var i = 0; i < verts.length; i++)
        {
            vertices.push(verts[i][0], verts[i][1], verts[i][2]);
            vertexColors.push(colR, colG, colB, 1);
        }

        var index = vertices.length / 3 - 4;
        faces.push(index);
        faces.push(index + 1);
        faces.push(index + 2);

        faces.push(index + 2);
        faces.push(index + 3);
        faces.push(index + 0);
    }
    else
    {
        let avgX = 0;
        let avgY = 0;
        let avgZ = 0;

        for (var i = 0; i < verts.length; i++)
        {
            avgX += verts[i][0];
            avgY += verts[i][1];
            avgZ += verts[i][2];
        }
        avgX /= verts.length;
        avgY /= verts.length;
        avgZ /= verts.length;

        vertices.push(avgX, avgY, avgZ);
        vertexColors.push(colR, colG, colB, 1);

        var index = vertices.length / 3 - 1;

        for (var i = 0; i < verts.length; i++)
        {
            vertices.push(verts[i][0], verts[i][1], verts[i][2]);
            vertexColors.push(colR, colG, colB, 1);
        }

        const indexEnd = vertices.length / 3 - 1;

        for (var i = index; i < indexEnd; i++)
        {
            faces.push(index);
            faces.push(i);
            faces.push(i + 1);
        }

        faces.push(index);
        faces.push(indexEnd);
        faces.push(index + 1);
    }
}

function buildMesh()
{
    op.setUiError("mesh", null);

    obj = {};

    faces = [];
    vertices = [];
    vertexColors = [];
    const geom = new CGL.Geometry(op.name);

    try
    {
        obj = conwayhart(String(notation.get()));
    }
    catch (ex)
    {
        op.setUiError("mesh", ex);
        op.logError(ex);
        return;
    }

    for (let i = 0; i < obj.cells.length; i++)
    {
        const verts = getCellVertices(obj.cells[i]);
        addFace(verts, geom);
    }

    geom.vertices = vertices;
    geom.verticesIndices = faces;
    geom.vertexColors = vertexColors;
    geom.calculateNormals();
    geom.calcTangentsBitangents();

    outGeom.set(null);
    outGeom.set(geom);
}


};

Ops.Gl.Meshes.Polyhedron_v2.prototype = new CABLES.Op();
CABLES.OPS["203a3bcd-7fff-4791-aab7-378f2b68bf29"]={f:Ops.Gl.Meshes.Polyhedron_v2,objName:"Ops.Gl.Meshes.Polyhedron_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.Pyramid
// 
// **************************************************************

Ops.Gl.Meshes.Pyramid = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let render = op.inTrigger("Render");

let sizeW = op.inValue("Width", 1);
let sizeL = op.inValue("Length", 1);
let sizeH = op.inValue("Height", 2);

let inSmooth = op.inValueBool("Smooth", false);

let inDraw = op.inValueBool("Draw", true);

let trigger = op.outTrigger("trigger");
let geomOut = op.outObject("geometry");

let geom = null;
let cgl = op.patch.cgl;
let mesh = null;

sizeW.onChange = create;
sizeH.onChange = create;
sizeL.onChange = create;
inSmooth.onChange = create;
create();

render.onTriggered = function ()
{
    if (inDraw.get())mesh.render(cgl.getShader());
    trigger.trigger();
};

function create()
{
    if (!geom)geom = new CGL.Geometry(op.name);
    let w = sizeW.get();
    let h = sizeH.get();
    let l = sizeL.get();

    geom.vertices = [
        // -w,-l,0,
        // w,-l,0,
        // w,l,0,
        // -w,l,0,
        // 0,0,h,
        -w, 0, -l,
        w, 0, -l,
        w, 0, l,
        -w, 0, l,
        0, h, 0
    ];

    geom.vertexNormals = [
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0
    ];

    geom.texCoords = [
        0.5, 0.0,
        1.0, 1.0,
        0.0, 1.0,
        0.0, 1.0,
        0.0, 1.0,
    ];

    geom.verticesIndices = [
        0, 1, 2,
        0, 2, 3, // bottom

        4, 1, 0,
        4, 3, 2,
        0, 3, 4,
        4, 2, 1
    ];

    if (!inSmooth.get())geom.unIndex();
    geom.calculateNormals({ "forceZUp": false });

    mesh = new CGL.Mesh(cgl, geom);
    geomOut.set(null);
    geomOut.set(geom);
}


};

Ops.Gl.Meshes.Pyramid.prototype = new CABLES.Op();
CABLES.OPS["22b175c4-591b-47be-9ac7-2eaf5ebaf641"]={f:Ops.Gl.Meshes.Pyramid,objName:"Ops.Gl.Meshes.Pyramid"};




// **************************************************************
// 
// Ops.Gl.Meshes.QuadWarpTexture
// 
// **************************************************************

Ops.Gl.Meshes.QuadWarpTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"shader_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\n\nUNI vec2 a;\nUNI vec2 b;\nUNI vec2 c;\nUNI vec2 d;\n{{MODULES_HEAD}}\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// original function by iq : https://www.shadertoy.com/view/lsBSDm\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n\n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n\n    float w = k1*k1 - 4.0*k0*k2;\n    if( w<0.0 ) return vec2(-1.0);\n    w = sqrt( w );\n\n    // will fail for k0=0, which is only on the ba edge\n    float v = 2.0*k0/(-k1 - w);\n    if( v<0.0 || v>1.0 ) v = 2.0*k0/(-k1 + w);\n\n    float u = (h.x - f.x*v)/(e.x + g.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n    return vec2( u, v );\n}\n\nvoid main()\n{\n    vec2 uv=invBilinear(texCoord,a,b,c,d);\n    vec4 col=texture(tex,1.0-uv);\n    if(uv.x==-1.0 || uv.y==-1.0)discard;\n    {{MODULE_COLOR}}\n    outColor = col;\n}\n","shader_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\n\nOUT vec2 texCoord;\nIN vec2 attrTexCoord;\n\nvoid main()\n{\n   vec4 pos=vec4(vPosition,  1.0);\n\n   texCoord=attrTexCoord;\n\n   gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
const
    render = op.inTrigger("render"),
    x1 = op.inFloat("A X", 0),
    y1 = op.inFloat("A Y", 0),
    x2 = op.inFloat("B X", 1),
    y2 = op.inFloat("B Y", 0),
    x3 = op.inFloat("C X", 1),
    y3 = op.inFloat("C Y", 1),
    x4 = op.inFloat("D X", 0),
    y4 = op.inFloat("D Y", 1),
    flipY = op.inValueBool("Flip Y"),
    flipX = op.inValueBool("Flip X"),
    inTexture = op.inTexture("Texture"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
let mesh = null;
const geom = new CGL.Geometry("fullscreen rectangle");
let x = 0, y = 0, z = 0, w = 0, h = 0;
let updateShaderLater = true;

flipX.onChange = flipY.onChange = rebuildFlip;

const shader = new CGL.Shader(cgl, "fullscreenrectangle");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.shader_vert, attachments.shader_frag);
shader.fullscreenRectUniform = new CGL.Uniform(shader, "t", "tex", 0);
shader.addUniformFrag("2f", "a", x1, y1);
shader.addUniformFrag("2f", "b", x2, y2);
shader.addUniformFrag("2f", "c", x3, y3);
shader.addUniformFrag("2f", "d", x4, y4);

render.onTriggered = doRender;
op.toWorkPortsNeedToBeLinked(render);
op.toWorkPortsNeedToBeLinked(inTexture);

inTexture.onChange = function ()
{
    updateShaderLater = true;
};

function updateShader()
{
    let tex = inTexture.get();
}

op.preRender = function ()
{
    updateShader();
    shader.bind();
    if (mesh)mesh.render(shader);
    doRender();
};

function doRender()
{
    if (cgl.getViewPort()[2] != w || cgl.getViewPort()[3] != h || !mesh) rebuild();

    if (updateShaderLater) updateShader();

    cgl.pushPMatrix();
    mat4.identity(cgl.pMatrix);
    mat4.ortho(cgl.pMatrix, 0, w, h, 0, -10.0, 1000);

    cgl.pushModelMatrix();
    mat4.identity(cgl.mMatrix);

    cgl.pushViewMatrix();
    mat4.identity(cgl.vMatrix);


    if (inTexture.get()) cgl.setTexture(0, inTexture.get().tex);
    else cgl.setTexture(0, CGL.Texture.getTempTexture(cgl).tex);


    cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);
    mesh.render(shader);
    cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

    cgl.popPMatrix();
    cgl.popModelMatrix();
    cgl.popViewMatrix();

    trigger.trigger();
}

function rebuildFlip()
{
    mesh = null;
}

function rebuild()
{
    const currentViewPort = cgl.getViewPort();

    if (currentViewPort[2] == w && currentViewPort[3] == h && mesh) return;

    let xx = 0, xy = 0;

    w = currentViewPort[2];
    h = currentViewPort[3];

    geom.vertices = new Float32Array([
        xx + w, xy + h, 0.0,
        xx, xy + h, 0.0,
        xx + w, xy, 0.0,
        xx, xy, 0.0
    ]);

    let tc = null;

    if (flipY.get())
        tc = new Float32Array([
            1.0, 0.0,
            0.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
        ]);
    else
        tc = new Float32Array([
            1.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            0.0, 0.0
        ]);

    if (flipX.get())
    {
        tc[0] = 0.0;
        tc[2] = 1.0;
        tc[4] = 0.0;
        tc[6] = 1.0;
    }

    geom.setTexCoords(tc);

    geom.verticesIndices = new Uint16Array([
        2, 1, 0,
        3, 1, 2
    ]);

    geom.vertexNormals = new Float32Array([
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
    ]);
    geom.tangents = new Float32Array([
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0]);
    geom.biTangents == new Float32Array([
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        0, -1, 0]);

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);
}


};

Ops.Gl.Meshes.QuadWarpTexture.prototype = new CABLES.Op();
CABLES.OPS["14521baa-af4e-44d5-a92c-3cb54e9aa697"]={f:Ops.Gl.Meshes.QuadWarpTexture,objName:"Ops.Gl.Meshes.QuadWarpTexture"};




// **************************************************************
// 
// Ops.Gl.Meshes.RectangleFrame
// 
// **************************************************************

Ops.Gl.Meshes.RectangleFrame = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    width = op.inValueFloat("Width", 1),
    height = op.inValueFloat("Height", 1),
    thickness = op.inValueFloat("Thickness", -0.1),
    pivotX = op.inSwitch("pivot x", ["center", "left", "right"], "center"),
    pivotY = op.inSwitch("pivot y", ["center", "top", "bottom"], "center"),

    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("Geometry"),

    drawTop = op.inValueBool("Draw Top", true),
    drawBottom = op.inValueBool("Draw Bottom", true),
    drawLeft = op.inValueBool("Draw Left", true),
    drawRight = op.inValueBool("Draw Right", true),
    active = op.inValueBool("Active", true);

op.setPortGroup("Geometry", [width, height, thickness]);
op.setPortGroup("Transform", [pivotX, pivotY]);
op.setPortGroup("Sections", [drawTop, drawBottom, drawLeft, drawRight]);

const cgl = op.patch.cgl;
let mesh = null;
const geom = new CGL.Geometry(op.name);
geom.tangents = [];
geom.biTangents = [];

geomOut.ignoreValueSerialize = true;

width.onChange =
    pivotX.onChange =
    pivotY.onChange =
    height.onChange =
    thickness.onChange =
    drawTop.onChange =
    drawBottom.onChange =
    drawLeft.onChange =
    drawRight.onChange = create;

create();

render.onTriggered = function ()
{
    if (active.get()) mesh.render(cgl.getShader());

    trigger.trigger();
};

function create()
{
    const w = width.get();
    const h = height.get();
    let x = -w / 2;
    let y = -h / 2;
    const th = thickness.get();//* Math.min(height.get(),width.get())*-0.5;

    if (pivotX.get() == "right") x = -w;
    else if (pivotX.get() == "left") x = 0;

    if (pivotY.get() == "top") y = -h;
    else if (pivotY.get() == "bottom") y = 0;

    geom.vertices.length = 0;
    geom.vertices.push(
        x, y, 0,
        x + w, y, 0,
        x + w, y + h, 0,
        x, y + h, 0,
        x - th, y - th, 0,
        x + w + th, y - th, 0,
        x + w + th, y + h + th, 0,
        x - th, y + h + th, 0
    );

    if (geom.vertexNormals.length === 0) geom.vertexNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
    if (geom.tangents.length === 0) geom.tangents = [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0];
    if (geom.biTangents.length === 0) geom.biTangents = [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0];

    if (geom.verticesIndices)geom.verticesIndices.length = 0;
    else geom.verticesIndices = [];

    const vertInd = [];
    if (drawBottom.get()) vertInd.push(0, 1, 4, 1, 5, 4);
    if (drawRight.get()) vertInd.push(1, 2, 5, 5, 2, 6);
    if (drawTop.get()) vertInd.push(7, 6, 3, 6, 2, 3);
    if (drawLeft.get()) vertInd.push(0, 4, 3, 4, 7, 3);
    geom.verticesIndices = vertInd;

    if (geom.texCoords.length === 0)
    {
        const tc = [];
        for (let i = 0, j = 0; i < geom.vertices.length; i += 3, j += 2)
        {
            tc[j] = geom.vertices[i + 0] / w - 0.5;
            tc[j + 1] = geom.vertices[i + 1] / h - 0.5;
        }
        geom.texCoords = tc;
    }

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);

    geomOut.set(null);
    geomOut.set(geom);
}


};

Ops.Gl.Meshes.RectangleFrame.prototype = new CABLES.Op();
CABLES.OPS["e3a24a1a-a74b-4c38-b492-63abca68f6d1"]={f:Ops.Gl.Meshes.RectangleFrame,objName:"Ops.Gl.Meshes.RectangleFrame"};




// **************************************************************
// 
// Ops.Gl.Meshes.RectangleRounded
// 
// **************************************************************

Ops.Gl.Meshes.RectangleRounded = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render = op.inTrigger('render');
const inSegments = op.inValueInt('Segments', 24);
const trigger = op.outTrigger('trigger');
const sizeW = op.inValueFloat('width', 1);
const sizeH = op.inValueFloat('height', 1);
const borderRadius = op.inValueSlider('border radius', 0.5);

const geom = new CGL.Geometry('triangle');
const geomOut = op.outObject('geometry');

geomOut.ignoreValueSerialize = true;

op.setPortGroup('Size', [sizeW, sizeH, borderRadius, inSegments]);

const inTopLeftCorner = op.inValueBool('Top Left', true);
const inTopRightCorner = op.inValueBool('Top Right', true);
const inBottomLeftCorner = op.inValueBool('Bottom Left', true);
const inBottomRightCorner = op.inValueBool('Bottom Right', true);
const CORNER_PORTS = [inTopLeftCorner, inTopRightCorner, inBottomLeftCorner, inBottomRightCorner];
CORNER_PORTS.forEach((port) => {
  port.onChange = create;
});

op.setPortGroup('Round Corner', CORNER_PORTS);

const draw = op.inValueBool('Draw', true);
op.setPortGroup('Draw', [draw]);

const cgl = op.patch.cgl;
let mesh = null;
sizeW.onChange = create;
sizeH.onChange = create;
borderRadius.onChange = create;
inSegments.onChange = create;

create();

render.onTriggered = function () {
  if (draw.get()) mesh.render(cgl.getShader());
  trigger.trigger();
};

function create() {
  const w = Math.abs(sizeW.get());
  const h = Math.abs(sizeH.get());

  const r = w < h ? (borderRadius.get() * w) / 2 : (borderRadius.get() * h) / 2;

  const wi = w - 2 * r;
  const hi = h - 2 * r;
  const wiHalf = wi / 2;
  const hiHalf = hi / 2;

  const segments = Math.abs(inSegments.get() || 1);

  const topLeftCircleMiddle = [-1 * wiHalf, hiHalf, 0];
  const bottomLeftCircleMiddle = [-1 * wiHalf, -1 * hiHalf, 0];
  const topRightCircleMiddle = [wiHalf, hiHalf, 0];
  const bottomRightCircleMiddle = [wiHalf, -1 * hiHalf, 0];

  const circleVerts = [];
  let lastX = 0;
  let lastY = 0;

  // top left circle
  if (inTopLeftCorner.get()) {
    for (let i = 0; i <= segments; i += 1) {
      const x = topLeftCircleMiddle[0] + (0 - r * Math.cos((i * Math.PI) / 2 / segments));
      const y = topLeftCircleMiddle[1] + r * Math.sin((i * Math.PI) / 2 / segments);

      circleVerts.push(x, y, 0);

      if (i > 1) {
        circleVerts.push(lastX, lastY, 0);
      }

      if (i <= segments - 1) circleVerts.push(...topLeftCircleMiddle);

      lastX = x;
      lastY = y;
    }
  } else {
    circleVerts.push(...topLeftCircleMiddle);
    circleVerts.push(-wiHalf, hiHalf + r, 0);
    circleVerts.push(-wiHalf - r, hiHalf + r, 0);

    circleVerts.push(...topLeftCircleMiddle);
    circleVerts.push(-wiHalf - r, hiHalf + r, 0);
    circleVerts.push(-wiHalf - r, hiHalf, 0);
  }

  if (inTopRightCorner.get()) {
    // top right circle
    for (let i = 0; i <= segments; i += 1) {
      const x = topRightCircleMiddle[0] + r * Math.cos((i * Math.PI) / 2 / segments);
      const y = topRightCircleMiddle[1] + r * Math.sin((i * Math.PI) / 2 / segments);

      if (i > 1) {
        circleVerts.push(...topRightCircleMiddle, lastX, lastY, 0);
      }

      circleVerts.push(x, y, 0);

      if (i === segments - 1) circleVerts.push(...topRightCircleMiddle);

      lastX = x;
      lastY = y;
    }
  } else {
    circleVerts.push(...topRightCircleMiddle);
    circleVerts.push(wiHalf + r, hiHalf, 0);
    circleVerts.push(wiHalf + r, hiHalf + r, 0);

    circleVerts.push(...topRightCircleMiddle);
    circleVerts.push(wiHalf + r, hiHalf + r, 0);
    circleVerts.push(wiHalf, hiHalf + r, 0);
  }

  if (inBottomRightCorner.get()) {
    // bottom right circle
    for (let i = 0; i <= segments; i += 1) {
      const x = bottomRightCircleMiddle[0] + r * Math.cos((i * Math.PI) / 2 / segments);
      const y = bottomRightCircleMiddle[1] + r * -1 * Math.sin((i * Math.PI) / 2 / segments);

      circleVerts.push(x, y, 0);

      if (i > 1) {
        circleVerts.push(lastX, lastY, 0);
      }

      if (i <= segments - 1) circleVerts.push(...bottomRightCircleMiddle);

      lastX = x;
      lastY = y;
    }
  } else {
    circleVerts.push(...bottomRightCircleMiddle);
    circleVerts.push(wiHalf + r, -hiHalf - r, 0);
    circleVerts.push(wiHalf + r, -hiHalf, 0);

    circleVerts.push(...bottomRightCircleMiddle);
    circleVerts.push(wiHalf, -hiHalf - r, 0);
    circleVerts.push(wiHalf + r, -hiHalf - r, 0);
  }

  if (inBottomLeftCorner.get()) {
    // bottom left circle
    for (let i = 0; i <= segments; i += 1) {
      const x = bottomLeftCircleMiddle[0] + r * -1 * Math.cos((i * Math.PI) / 2 / segments);
      const y = bottomLeftCircleMiddle[1] + r * -1 * Math.sin((i * Math.PI) / 2 / segments);

      if (i > 1) {
        circleVerts.push(lastX, lastY, 0);
      }

      circleVerts.push(x, y, 0);

      if (i <= segments - 1) circleVerts.push(...bottomLeftCircleMiddle);

      lastX = x;
      lastY = y;
    }
  } else {
    circleVerts.push(...bottomLeftCircleMiddle);
    circleVerts.push(-wiHalf - r, -hiHalf - r, 0);
    circleVerts.push(-wiHalf, -hiHalf - r, 0);

    circleVerts.push(...bottomLeftCircleMiddle);
    circleVerts.push(-wiHalf - r, -hiHalf, 0);
    circleVerts.push(-wiHalf - r, -hiHalf - r, 0);
  }

  geom.vertices = [
        //inner rectangle

        -1*wiHalf, -hiHalf, 0,
        wiHalf, hiHalf, 0,
        -1*wiHalf, hiHalf, 0,


        -1*wiHalf, -1*hiHalf,0,
        wiHalf, -1*hiHalf, 0,
        wiHalf, hiHalf, 0,

    // left rectangle

      -1*wiHalf-r, -1*hiHalf, 0,
      -1*wiHalf, -1*hiHalf, 0,
      -1*wiHalf-r, hiHalf, 0,

      -1*wiHalf-r, hiHalf, 0,
      -1*wiHalf, -1*hiHalf, 0,
      -1*wiHalf, hiHalf, 0,

        // top rectangle

      -1*wiHalf, hiHalf, 0,
      wiHalf, hiHalf+r, 0,
      -1*wiHalf, hiHalf+r, 0,

      wiHalf, hiHalf + r, 0,
      -1*wiHalf, hiHalf, 0,
      wiHalf, hiHalf, 0,

      // bottom rectangle
      -1*wiHalf, -1*hiHalf, 0,
      -1*wiHalf, -1*hiHalf-r, 0,
      wiHalf, -1*hiHalf-r, 0,

      wiHalf, -1*hiHalf, 0,
      -1*wiHalf, -1*hiHalf, 0,
      wiHalf, -1*hiHalf-r, 0,

      // right rectangle

      wiHalf+r, hiHalf, 0,
      wiHalf, hiHalf, 0,
      wiHalf+r, -1*hiHalf, 0,

      wiHalf+r, -1*hiHalf, 0,
      wiHalf, hiHalf, 0,
      wiHalf, -1*hiHalf, 0,
        ...circleVerts
    ]

    geom.texCoords = [];
  const wAbs = Math.abs(w);
  const hAbs = Math.abs(h);

  for (let i = 0; i < geom.vertices.length; i += 3) {
    geom.texCoords[(i / 3) * 2 + 0] = Math.abs(geom.vertices[i + 0] / -wAbs - 0.5);
    geom.texCoords[(i / 3) * 2 + 1] = Math.abs(geom.vertices[i + 1] / hAbs - 0.5);
  }


  geom.vertexNormals = geom.vertices.map((vert, i) => (i % 3 === 2 ? 1.0 : 0.0));
  geom.tangents = geom.vertices.map((vert, i) => (i % 3 === 0 ? -1.0 : 0.0));
  geom.biTangents = geom.vertices.map((vert, i) => (i % 3 === 1 ? -1.0 : 0.0));

  if (geom.vertices.length == 0) return;
  if (mesh) mesh.dispose();
  mesh = null;
  mesh = new CGL.Mesh(cgl, geom);
  geomOut.set(null);
  geomOut.set(geom);
}


};

Ops.Gl.Meshes.RectangleRounded.prototype = new CABLES.Op();
CABLES.OPS["86c99074-4929-44d0-a826-49e7f8bdf5c4"]={f:Ops.Gl.Meshes.RectangleRounded,objName:"Ops.Gl.Meshes.RectangleRounded"};




// **************************************************************
// 
// Ops.Gl.Meshes.Rectangle_v3
// 
// **************************************************************

Ops.Gl.Meshes.Rectangle_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    doRender = op.inValueBool("dorender", true),
    width = op.inValue("width", 1),
    height = op.inValue("height", 1),
    pivotX = op.inSwitch("pivot x", ["left", "center", "right"], "center"),
    pivotY = op.inSwitch("pivot y", ["top", "center", "bottom"], "center"),
    axis = op.inSwitch("axis", ["xy", "xz"], "xy"),
    flipTcX = op.inBool("Flip TexCoord X", false),
    flipTcY = op.inBool("Flip TexCoord Y", true),
    nColumns = op.inValueInt("num columns", 1),
    nRows = op.inValueInt("num rows", 1),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("geometry", null, "geometry");

geomOut.ignoreValueSerialize = true;

const geom = new CGL.Geometry("rectangle");

doRender.setUiAttribs({ "title": "Render" });
render.setUiAttribs({ "title": "Trigger" });
trigger.setUiAttribs({ "title": "Next" });
op.setPortGroup("Pivot", [pivotX, pivotY, axis]);
op.setPortGroup("Size", [width, height]);
op.setPortGroup("Structure", [nColumns, nRows]);
op.toWorkPortsNeedToBeLinked(render);

let mesh = null;
let needsRebuild = true;

axis.onChange =
    pivotX.onChange =
    pivotY.onChange =
    flipTcX.onChange =
    flipTcY.onChange =
    width.onChange =
    height.onChange =
    nRows.onChange =
    nColumns.onChange = rebuildLater;

function rebuildLater()
{
    needsRebuild = true;
}

render.onLinkChanged = () =>
{
    if (!trigger.isLinked())
    {
        if (mesh) mesh.dispose();
        mesh = null;
        geomOut.set(null);
        rebuildLater();
    }
};

op.preRender =
render.onTriggered = function ()
{
    if (needsRebuild) rebuild();
    if (mesh && doRender.get()) mesh.render(op.patch.cg.getShader());
    trigger.trigger();
};

op.onDelete = function ()
{
    if (mesh)mesh.dispose();
    rebuildLater();
};

function rebuild()
{
    let w = width.get();
    let h = parseFloat(height.get());
    let x = 0;
    let y = 0;

    if (typeof w == "string")w = parseFloat(w);
    if (typeof h == "string")h = parseFloat(h);

    if (pivotX.get() == "center") x = 0;
    else if (pivotX.get() == "right") x = -w / 2;
    else if (pivotX.get() == "left") x = +w / 2;

    if (pivotY.get() == "center") y = 0;
    else if (pivotY.get() == "top") y = -h / 2;
    else if (pivotY.get() == "bottom") y = +h / 2;

    const verts = [];
    const tc = [];
    const norms = [];
    const tangents = [];
    const biTangents = [];
    const indices = [];

    const numRows = Math.round(nRows.get());
    const numColumns = Math.round(nColumns.get());

    const stepColumn = w / numColumns;
    const stepRow = h / numRows;

    op.log("rect build");

    let c, r, a;
    a = axis.get();
    for (r = 0; r <= numRows; r++)
    {
        for (c = 0; c <= numColumns; c++)
        {
            verts.push(c * stepColumn - width.get() / 2 + x);
            if (a == "xz") verts.push(0.0);
            verts.push(r * stepRow - height.get() / 2 + y);
            if (a == "xy") verts.push(0.0);

            tc.push(c / numColumns);
            tc.push(r / numRows);

            if (a == "xy") // default
            {
                norms.push(0, 0, 1);
                tangents.push(1, 0, 0);
                biTangents.push(0, 1, 0);
            }
            else if (a == "xz")
            {
                norms.push(0, 1, 0);
                tangents.push(1, 0, 0);
                biTangents.push(0, 0, 1);
            }
        }
    }

    for (c = 0; c < numColumns; c++)
    {
        for (r = 0; r < numRows; r++)
        {
            const ind = c + (numColumns + 1) * r;
            const v1 = ind;
            const v2 = ind + 1;
            const v3 = ind + numColumns + 1;
            const v4 = ind + 1 + numColumns + 1;

            if (a == "xy") // default
            {
                indices.push(v1);
                indices.push(v2);
                indices.push(v3);

                indices.push(v3);
                indices.push(v2);
                indices.push(v4);
            }
            else
            if (a == "xz")
            {
                indices.push(v1);
                indices.push(v3);
                indices.push(v2);

                indices.push(v2);
                indices.push(v3);
                indices.push(v4);
            }
        }
    }

    if (flipTcY.get()) for (let i = 0; i < tc.length; i += 2)tc[i + 1] = 1.0 - tc[i + 1];
    if (flipTcX.get()) for (let i = 0; i < tc.length; i += 2)tc[i] = 1.0 - tc[i];

    geom.clear();
    geom.vertices = verts;
    geom.texCoords = tc;
    geom.verticesIndices = indices;
    geom.vertexNormals = norms;
    geom.tangents = tangents;
    geom.biTangents = biTangents;

    if (numColumns * numRows > 64000)geom.unIndex();

    const cgl = op.patch.cgl;

    if (!mesh) mesh = op.patch.cg.createMesh(geom);
    else mesh.setGeom(geom);

    geomOut.set(null);
    geomOut.set(geom);
    needsRebuild = false;
}


};

Ops.Gl.Meshes.Rectangle_v3.prototype = new CABLES.Op();
CABLES.OPS["82bb2f8a-77f4-4218-a3ae-8f158f1b7fb1"]={f:Ops.Gl.Meshes.Rectangle_v3,objName:"Ops.Gl.Meshes.Rectangle_v3"};




// **************************************************************
// 
// Ops.Gl.Meshes.SimpleSpline
// 
// **************************************************************

Ops.Gl.Meshes.SimpleSpline = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    inPoints = op.inArray("Points"),
    numPoints = op.inValueInt("Num Points"),
    strip = op.inBool("Line Strip", true),
    outGeom = op.outObject("Geometry"),
    // a=op.inSwitch("Mode",["Line Strip","Line Loop","Lines"]), // next version!
    texCoords = op.inSwitch("TexCoords", ["0", "0-1", "Random", "Fill"], "0"),
    inTexCoords = op.inArray("TexCoords Array"),
    inVertCols = op.inArray("Vertex Colors"),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;
const geom = new CGL.Geometry("simplespline");
outGeom.set(geom);

geom.vertices = [0, 0, 0, 0, 0, 0, 0, 0, 0];
const mesh = new CGL.Mesh(cgl, geom);
let buff = new Float32Array();
let bufTexCoord = new Float32Array();
let bufNorms = new Float32Array();
let needsRebuild = true;
let attr;
let currentTexCoords = "";

inVertCols.onChange =
inTexCoords.onChange =
texCoords.onChange =
    numPoints.onChange =
    inPoints.onChange =
    function () { needsRebuild = true; };

op.toWorkPortsNeedToBeLinked(inPoints);

function rebuild()
{
    const points = inPoints.get();

    if (!points || points.length === 0) return;

    const newLength = points.length;

    if (!(points instanceof Float32Array))
    {
        if (newLength != buff.length)
        {
            buff = new Float32Array(newLength);
            bufNorms = new Float32Array(newLength);
            mesh.setAttribute(CGL.SHADERVAR_VERTEX_NORMAL, bufNorms, 3);

            buff.set(points);
        }
        else
        {
            buff.set(points);
        }
    }
    else
    {
        buff = points;
    }

    attr = mesh.setAttribute(CGL.SHADERVAR_VERTEX_POSITION, buff, 3);

    if (inVertCols.get())
    {
        const attrTc = mesh.setAttribute(CGL.SHADERVAR_VERTEX_COLOR || "attrVertColor", inVertCols.get(), 4);
    }

    const numTc = (newLength / 3) * 2;

    if (inTexCoords.get())
    {
        const intc = inTexCoords.get();
        const attrTc = mesh.setAttribute(CGL.SHADERVAR_VERTEX_TEXCOORD, intc, 2);
    }
    else
    if (currentTexCoords != texCoords.get() || mesh.getAttribute(CGL.SHADERVAR_VERTEX_TEXCOORD).numItems != numTc / 2)
    {
        currentTexCoords = texCoords.get();

        if (bufTexCoord.length != numTc) bufTexCoord = new Float32Array(numTc);

        if (texCoords.get() == "0-1")
        {
            for (let i = 0; i < numTc; i += 2)
            {
                bufTexCoord[i] = i / numTc;
                // bufTexCoord[i+1] = i / numTc;
                bufTexCoord[i + 1] = 0.5;
            }
        }
        else if (texCoords.get() == "Fill")
        {
            const sizel = Math.sqrt(numTc / 2);

            let idx = 0;
            for (let j = 0; j < sizel; j++)
            {
                for (let i = 0; i < sizel; i++)
                {
                    idx++;
                    bufTexCoord[idx * 2 + 0] = i / sizel;
                    bufTexCoord[idx * 2 + 1] = j / sizel;
                }
            }
        }
        else if (texCoords.get() == "Random")
        {
            for (let i = 0; i < numTc; i += 2)
            {
                bufTexCoord[i] = Math.random();
                bufTexCoord[i + 1] = Math.random();
            }
        }
        else
        {
            for (let i = 0; i < numTc; i += 2)
            {
                bufTexCoord[i] = 0;
                bufTexCoord[i + 1] = 0;
            }
        }
        const attrTc = mesh.setAttribute(CGL.SHADERVAR_VERTEX_TEXCOORD, bufTexCoord, 2);
    }

    needsRebuild = false;
}

render.onTriggered = function ()
{
    if (!inPoints.get()) return;

    if (needsRebuild)rebuild();
    const shader = cgl.getShader();
    if (!shader) return;

    const oldPrim = shader.glPrimitive;
    if (strip.get()) shader.glPrimitive = cgl.gl.LINE_STRIP; // LINE_LOOP
    else shader.glPrimitive = cgl.gl.LINES;

    if (attr)
        if (numPoints.get() <= 0)attr.numItems = buff.length / 3;
        else attr.numItems = Math.min(numPoints.get(), buff.length / 3);

    if (mesh && buff.length !== 0) mesh.render(shader);

    shader.glPrimitive = oldPrim;

    next.trigger();
};


};

Ops.Gl.Meshes.SimpleSpline.prototype = new CABLES.Op();
CABLES.OPS["af3fd0e8-ef3d-4124-a6ee-3482e9a85b45"]={f:Ops.Gl.Meshes.SimpleSpline,objName:"Ops.Gl.Meshes.SimpleSpline"};




// **************************************************************
// 
// Ops.Gl.Meshes.SimpleWireframe
// 
// **************************************************************

Ops.Gl.Meshes.SimpleWireframe = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    inGeom = op.inObject("Geometry", null, "geometry"),
    next = op.outTrigger("Next");
const cgl = op.patch.cgl;

op.toWorkPortsNeedToBeLinked(inGeom);

render.onTriggered = doRender;

let mesh = null;
let verts = [];
let tc = [];
let normals = [];
let prim = cgl.gl.LINE_STRIP;

inGeom.onChange = function ()
{
    let geom = inGeom.get();
    if (!geom)
    {
        mesh = null;
        return;
    }

    verts.length = 0;
    normals.length = 0;
    tc.length = 0;
    let i = 0;

    if (geom.isIndexed())
    {
        for (i = 0; i < geom.verticesIndices.length; i += 3)
        {
            let index = geom.verticesIndices[i + 0];
            let index1 = geom.verticesIndices[i + 1];
            let index2 = geom.verticesIndices[i + 2];

            verts.push(geom.vertices[index * 3 + 0], geom.vertices[index * 3 + 1], geom.vertices[index * 3 + 2]);
            verts.push(geom.vertices[index1 * 3 + 0], geom.vertices[index1 * 3 + 1], geom.vertices[index1 * 3 + 2]);
            verts.push(geom.vertices[index1 * 3 + 0], geom.vertices[index1 * 3 + 1], geom.vertices[index1 * 3 + 2]);
            verts.push(geom.vertices[index2 * 3 + 0], geom.vertices[index2 * 3 + 1], geom.vertices[index2 * 3 + 2]);
            verts.push(geom.vertices[index2 * 3 + 0], geom.vertices[index2 * 3 + 1], geom.vertices[index2 * 3 + 2]);
            verts.push(geom.vertices[index * 3 + 0], geom.vertices[index * 3 + 1], geom.vertices[index * 3 + 2]);

            normals.push(geom.vertexNormals[index * 3 + 0], geom.vertexNormals[index * 3 + 1], geom.vertexNormals[index * 3 + 2]);
            normals.push(geom.vertexNormals[index1 * 3 + 0], geom.vertexNormals[index1 * 3 + 1], geom.vertexNormals[index1 * 3 + 2]);
            normals.push(geom.vertexNormals[index1 * 3 + 0], geom.vertexNormals[index1 * 3 + 1], geom.vertexNormals[index1 * 3 + 2]);
            normals.push(geom.vertexNormals[index2 * 3 + 0], geom.vertexNormals[index2 * 3 + 1], geom.vertexNormals[index2 * 3 + 2]);
            normals.push(geom.vertexNormals[index2 * 3 + 0], geom.vertexNormals[index2 * 3 + 1], geom.vertexNormals[index2 * 3 + 2]);
            normals.push(geom.vertexNormals[index * 3 + 0], geom.vertexNormals[index * 3 + 1], geom.vertexNormals[index * 3 + 2]);

            tc.push(geom.texCoords[index * 2 + 0], geom.texCoords[index * 2 + 1]);
            tc.push(geom.texCoords[index1 * 2 + 0], geom.texCoords[index1 * 2 + 1]);
            tc.push(geom.texCoords[index1 * 2 + 0], geom.texCoords[index1 * 2 + 1]);
            tc.push(geom.texCoords[index2 * 2 + 0], geom.texCoords[index2 * 2 + 1]);
            tc.push(geom.texCoords[index2 * 2 + 0], geom.texCoords[index2 * 2 + 1]);
            tc.push(geom.texCoords[index * 2 + 0], geom.texCoords[index * 2 + 1]);
        }
        prim = cgl.gl.LINES;
    }
    else
    {
        for (i = 0; i < geom.vertices.length; i += 9)
        {
            verts.push(geom.vertices[i + 0], geom.vertices[i + 1], geom.vertices[i + 2]);
            verts.push(geom.vertices[i + 3], geom.vertices[i + 4], geom.vertices[i + 5]);

            verts.push(geom.vertices[i + 3], geom.vertices[i + 4], geom.vertices[i + 5]);
            verts.push(geom.vertices[i + 6], geom.vertices[i + 7], geom.vertices[i + 8]);

            verts.push(geom.vertices[i + 6], geom.vertices[i + 7], geom.vertices[i + 8]);
            verts.push(geom.vertices[i + 0], geom.vertices[i + 1], geom.vertices[i + 2]);
        }

        prim = cgl.gl.LINES;
    }

    geom = new CGL.Geometry("wireframelinegeom");
    // if(verts.length>60000)geom.setVertices(verts);
    // else
    geom.setVertices(verts);
    geom.setTexCoords(tc);
    geom.vertexNormals = normals;

    mesh = new CGL.Mesh(cgl, geom, prim);
};

function doRender()
{
    let shader = cgl.getShader();
    if (!shader) return;

    let oldPrim = shader.glPrimitive;
    shader.glPrimitive = prim;
    if (mesh) mesh.render(shader);
    shader.glPrimitive = oldPrim;
    next.trigger();
}


};

Ops.Gl.Meshes.SimpleWireframe.prototype = new CABLES.Op();
CABLES.OPS["89264e0a-512f-48a4-a7bb-ec8f12aa19c1"]={f:Ops.Gl.Meshes.SimpleWireframe,objName:"Ops.Gl.Meshes.SimpleWireframe"};




// **************************************************************
// 
// Ops.Gl.Meshes.Sphere_v2
// 
// **************************************************************

Ops.Gl.Meshes.Sphere_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    TAU = Math.PI * 2,
    cgl = op.patch.cgl,
    inTrigger = op.inTrigger("render"),
    inRadius = op.inValue("radius", 0.5),
    inStacks = op.inValue("stacks", 32),
    inSlices = op.inValue("slices", 32),
    inStacklimit = op.inValueSlider("Filloffset", 1),
    inDraw = op.inValueBool("Render", true),
    outTrigger = op.outTrigger("trigger"),
    outGeometry = op.outObject("geometry", null, "geometry"),
    UP = vec3.fromValues(0, 1, 0),
    RIGHT = vec3.fromValues(1, 0, 0);

let
    geom = new CGL.Geometry("Sphere"),
    tmpNormal = vec3.create(),
    tmpVec = vec3.create(),
    needsRebuild = true,
    mesh;

function buildMesh()
{
    const
        stacks = Math.ceil(Math.max(inStacks.get(), 2)),
        slices = Math.ceil(Math.max(inSlices.get(), 3)),
        stackLimit = Math.min(Math.max(inStacklimit.get() * stacks, 1), stacks),
        radius = inRadius.get();
    let
        positions = [],
        texcoords = [],
        normals = [],
        tangents = [],
        biTangents = [],
        indices = [],
        x, y, z, d, t, a,
        o, u, v, i, j;
    for (i = o = 0; i < stacks + 1; i++)
    {
        v = (i / stacks - 0.5) * Math.PI;
        y = Math.sin(v);
        a = Math.cos(v);
        // for (j = 0; j < slices+1; j++) {
        for (j = slices; j >= 0; j--)
        {
            u = (j / slices) * TAU;
            x = Math.cos(u) * a;
            z = Math.sin(u) * a;

            positions.push(x * radius, y * radius, z * radius);
            // texcoords.push(i/(stacks+1),j/slices);
            texcoords.push(j / slices, i / (stacks + 1));

            d = Math.sqrt(x * x + y * y + z * z);
            normals.push(
                tmpNormal[0] = x / d,
                tmpNormal[1] = y / d,
                tmpNormal[2] = z / d
            );

            if (y == d) t = RIGHT;
            else t = UP;
            vec3.cross(tmpVec, tmpNormal, t);
            vec3.normalize(tmpVec, tmpVec);
            Array.prototype.push.apply(tangents, tmpVec);
            vec3.cross(tmpVec, tmpVec, tmpNormal);
            Array.prototype.push.apply(biTangents, tmpVec);
        }
        if (i == 0 || i > stackLimit) continue;
        for (j = 0; j < slices; j++, o++)
        {
            indices.push(
                o, o + 1, o + slices + 1,
                o + 1, o + slices + 2, o + slices + 1
            );
        }
        o++;
    }

    // set geometry
    geom.clear();
    geom.vertices = positions;
    geom.texCoords = texcoords;
    geom.vertexNormals = normals;
    geom.tangents = tangents;
    geom.biTangents = biTangents;
    geom.verticesIndices = indices;

    outGeometry.set(null);
    outGeometry.set(geom);

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);

    needsRebuild = false;
}

// set event handlers
inTrigger.onTriggered = function ()
{
    if (needsRebuild) buildMesh();
    if (inDraw.get()) mesh.render(cgl.getShader());
    outTrigger.trigger();
};

inStacks.onChange =
inSlices.onChange =
inStacklimit.onChange =
inRadius.onChange = function ()
{
    // only calculate once, even after multiple settings could were changed
    needsRebuild = true;
};

// set lifecycle handlers
op.onDelete = function () { if (mesh)mesh.dispose(); };


};

Ops.Gl.Meshes.Sphere_v2.prototype = new CABLES.Op();
CABLES.OPS["450b4d68-2278-4d9f-9849-0abdfa37ef69"]={f:Ops.Gl.Meshes.Sphere_v2,objName:"Ops.Gl.Meshes.Sphere_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.SplineMeshMaterial_v2
// 
// **************************************************************

Ops.Gl.Meshes.SplineMeshMaterial_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"splinemat_frag":"IN vec2 texCoord;\nIN float splineDoDrawFrag;\nUNI vec4 color;\nUNI sampler2D tex;\nUNI sampler2D texMask;\n\n{{MODULES_HEAD}}\n\nvoid main()\n{\n    vec4 col=color;\n\n    #ifdef USE_TEXTURE\n        #ifdef TEX_COLORIZE\n            col*=texture(tex,texCoord);\n        #endif\n        #ifndef TEX_COLORIZE\n            col=texture(tex,texCoord);\n        #endif\n    #endif\n\n    col.a=color.a;\n\n    #ifdef USE_TEXMASK\n        col.a*=texture(texMask,texCoord).r;\n        if(col.a==0.0) discard;\n    #endif\n\n    {{MODULE_COLOR}}\n\n    // if(splineDoDrawFrag==0.0) col.rgb=vec3(1.0,0.0,0.0);\n    if(splineDoDrawFrag==0.0) discard;\n\n    outColor = col;\n}","splinemat_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nIN float attrVertIndex;\nIN float splineProgress;\nIN vec3 spline,spline2,spline3;\nIN float splineDoDraw;\n\nOUT float splineDoDrawFrag;\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nUNI float width;\nUNI float texOffset;\n\n#define PI 3.1415926538\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat aspect=1.7777; // todo uniform ?\n\nvec2 fix( vec4 i )\n{\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n\nvoid main()\n{\n    texCoord=vPosition.xy;\n    texCoord.y=texCoord.y*0.5+0.5;\n    #ifdef TEX_MAP_FULL\n        texCoord.x=splineProgress;\n    #endif\n    texCoord.x+=texOffset;\n\n    mat4 mMatrix=modelMatrix;\n    mat4 mvMatrix=viewMatrix * mMatrix;\n\n    splineDoDrawFrag=splineDoDraw;\n\n    // vec4 pos=vec4((spline2+spline3+spline)/3.0*vPosition,1.0);\n    vec4 pos=vec4(spline2,1.0);\n\n    {{MODULE_VERTEX_POSITION}}\n\n    vec4 finalPosition  = projMatrix * mvMatrix * (vec4(spline2,1.0));\n    vec4 finalPosition2 = projMatrix * mvMatrix * (vec4(spline3,1.0));\n\n    vec2 screenPos =fix(projMatrix * mvMatrix * vec4(spline,1.0));\n    vec2 screenPos2=fix(projMatrix * mvMatrix * vec4(spline2,1.0));\n    vec2 screenPos3=fix(projMatrix * mvMatrix * vec4(spline3,1.0));\n\n    float wid=width/10.0;\n\n    #ifndef PERSPWIDTH\n        wid=width*finalPosition.w*0.0025;\n    #endif\n\n    vec2 dir1 = normalize( screenPos2 - screenPos );\n    vec2 dir2 = normalize( screenPos3 - screenPos2 );\n\n\tif( screenPos2 == screenPos ) dir1 = normalize( screenPos3 - screenPos2 );\n\n    vec2 normal = vec2( -dir1.y, dir1.x ) * 0.5 * wid;\n    vec2 normal2 = vec2( -dir2.y, dir2.x ) * 0.5 * wid;\n\n    vec4 offset = vec4( mix(normal,normal2,vPosition.x) * vPosition.y, 0.0, 1.0 );\n\n    finalPosition = mix(finalPosition,finalPosition2,vPosition.x);\n\tfinalPosition.xy += offset.xy;\n\n    gl_Position = finalPosition;\n}\n\n\n\n\n\n\n\n",};
const
    render = op.inTrigger("Render"),
    inWidth = op.inFloat("Width", 0.2),
    inPerspective = op.inBool("Width Perspective", true),
    inTexture = op.inTexture("Texture"),
    inTextureMask = op.inTexture("Texture Mask"),
    inTexMap = op.inSwitch("Mapping", ["Full", "Face"], "Full"),
    inTexColorize = op.inBool("Colorize Texture", false),
    inTexOffset = op.inFloat("Offset", 0),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    a = op.inValueSlider("a", 1),
    trigger = op.outTrigger("Trigger"),
    shaderOut = op.outObject("Shader");

r.setUiAttribs({ "colorPick": true });
shaderOut.ignoreValueSerialize = true;

const cgl = op.patch.cgl;

op.toWorkPortsNeedToBeLinked(render);
op.setPortGroup("Color", [r, g, b, a]);
op.setPortGroup("Texture", [inTexture, inTexMap, inTexColorize]);

const shader = new CGL.Shader(cgl, "splinemesh_material");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.splinemat_vert, attachments.splinemat_frag);
shaderOut.set(shader);

const uniTex = shader.addUniformFrag("t", "tex");
const uniTexMask = shader.addUniformFrag("t", "texMask");

shader.addUniformFrag("4f", "color", r, g, b, a);
shader.addUniformFrag("f", "width", inWidth);
shader.addUniformFrag("f", "texOffset", inTexOffset);
shader.toggleDefine("PERSPWIDTH", inPerspective);
shader.toggleDefine("USE_TEXTURE", inTexture);
shader.toggleDefine("TEX_COLORIZE", inTexColorize);
shader.toggleDefine("USE_TEXMASK", inTextureMask);

inTexMap.on("change", updateMapping);

render.onTriggered = doRender;
updateMapping();

function doRender()
{
    if (!shader) return;

    cgl.pushShader(shader);
    shader.popTextures();

    if (uniTex && inTexture.get()) shader.pushTexture(uniTex, inTexture.get().tex);
    if (uniTexMask && inTextureMask.get()) shader.pushTexture(uniTexMask, inTextureMask.get().tex);

    trigger.trigger();

    cgl.popShader();
}

function updateMapping()
{
    shader.toggleDefine("TEX_MAP_FULL", inTexMap.get() === "Full");
}


};

Ops.Gl.Meshes.SplineMeshMaterial_v2.prototype = new CABLES.Op();
CABLES.OPS["5ff7c643-cbea-44cc-9f34-fb18a44bcfff"]={f:Ops.Gl.Meshes.SplineMeshMaterial_v2,objName:"Ops.Gl.Meshes.SplineMeshMaterial_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.SplineMesh_v2
// 
// **************************************************************

Ops.Gl.Meshes.SplineMesh_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    inPoints = op.inArray("Points"),
    inHardEdges = op.inBool("Tesselate Edges", false),
    inRenderMesh = op.inBool("Render Mesh", true),
    next = op.outTrigger("Next");

const geom = new CGL.Geometry("splinemesh_2");
geom.vertices = [];
geom.clear();

let thePoints = [];
const cgl = op.patch.cgl;
let points = new Float32Array();
let points2 = new Float32Array();
let points3 = new Float32Array();
let doDraw = new Float32Array();
let splineIndex = null;

let pointsProgress = new Float32Array();
const pointsDoDraw = new Float32Array();
const arrEdges = [];

const verts = [0, 0, 0];

let mesh = new CGL.Mesh(cgl, geom);
mesh.addVertexNumbers = true;

let rebuildLater = true;

inHardEdges.onChange =
    inPoints.onChange = () => { rebuildLater = true; };

render.onTriggered = renderMesh;

let shader = null;

function renderMesh()
{
    if (rebuildLater)rebuild();
    if (mesh && inRenderMesh.get())
    {
        if (shader != cgl.getShader())
        {
            shader = cgl.getShader();
            if (!shader) return;
            if (shader.getName() != "splinemesh_material") op.setUiError("nosplinemat", "Splinemesh needs a SplineMeshMaterial!");
            else op.setUiError("nosplinemat");

            shader = cgl.getShader();
        }

        if (verts.length > 0) mesh.render(shader);
    }

    next.trigger();
}

function buildMesh()
{
    verts.length = 0;

    const max = 1;
    const min = -max;

    for (let i = 0; i < thePoints.length / 3; i++)
    {
        verts.push(
            max, min, 0, 0, min, 0, max, max, 0,
            0, min, 0, 0, max, 0, max, max, 0
        );
    }
    geom.vertices = verts;

    // if(mesh)mesh.dispose();
    if (!mesh) mesh = new CGL.Mesh(cgl, geom);

    mesh.addVertexNumbers = true;
    mesh.setGeom(geom);
    mesh.addVertexNumbers = true;
}

function rebuild()
{
    const inpoints = inPoints.get();

    if (!inpoints || inpoints.length === 0)
    {
        mesh = null;
        return;
    }

    if (inpoints[0].length)
    {
        const arr = [];
        splineIndex = [];
        let count = 0;

        for (let i = 0; i < inpoints.length; i++)
        {
            for (let j = 0; j < inpoints[i].length / 3; j++)
            {
                splineIndex[(count - 3) / 3] = i;// (i) / inpoints.length;

                arr[count++] = inpoints[i][j * 3 + 0];
                arr[count++] = inpoints[i][j * 3 + 1];
                arr[count++] = inpoints[i][j * 3 + 2];
            }
        }
        thePoints = arr;
    }
    else
    {
        splineIndex = null;
        thePoints = inpoints;
    }

    if (inHardEdges.get()) thePoints = tessEdges(thePoints);

    buildMesh();

    const newLength = thePoints.length * 6;
    let count = 0;
    let lastIndex = 0;
    let drawable = 0;

    if (points.length != newLength)
    {
        points = new Float32Array(newLength);
        points2 = new Float32Array(newLength);
        points3 = new Float32Array(newLength);

        doDraw = new Float32Array(newLength / 3);
        pointsProgress = new Float32Array(newLength / 3);

        for (let i = 0; i < newLength / 3; i++) pointsProgress[i] = i / (newLength / 3);
    }

    for (let i = 0; i < thePoints.length / 3; i++)
    {
        if (splineIndex)
        {
            if (i > 1 && lastIndex != splineIndex[i]) drawable = 0.0;
            else drawable = 1.0;
            lastIndex = splineIndex[i];
        }
        else drawable = 1.0;

        for (let j = 0; j < 6; j++)
        {
            doDraw[count / 3] = drawable;

            for (let k = 0; k < 3; k++)
            {
                points[count] = thePoints[(Math.max(0, i - 1)) * 3 + k];
                points2[count] = thePoints[(i + 0) * 3 + k];
                points3[count] = thePoints[(i + 1) * 3 + k];
                count++;
            }
        }
    }

    mesh.setAttribute("spline", points, 3);
    mesh.setAttribute("spline2", points2, 3);
    mesh.setAttribute("spline3", points3, 3);
    mesh.setAttribute("splineDoDraw", doDraw, 1);
    mesh.setAttribute("splineProgress", pointsProgress, 1);

    rebuildLater = false;
}

function ip(a, b, p)
{
    return a + p * (b - a);
}

function tessEdges(oldArr)
{
    let count = 0;
    const step = 0.001;
    const oneMinusStep = 1 - step;
    const l = oldArr.length * 3 - 3;
    arrEdges.length = l;

    const tessSplineIndex = [];

    if (splineIndex) tessSplineIndex[0] = splineIndex[1];

    for (let i = 0; i < oldArr.length - 3; i += 3)
    {
        arrEdges[count++] = oldArr[i + 0];
        arrEdges[count++] = oldArr[i + 1];
        arrEdges[count++] = oldArr[i + 2];
        if (splineIndex) tessSplineIndex[count / 3] = splineIndex[i / 3];

        arrEdges[count++] = ip(oldArr[i + 0], oldArr[i + 3], step);
        arrEdges[count++] = ip(oldArr[i + 1], oldArr[i + 4], step);
        arrEdges[count++] = ip(oldArr[i + 2], oldArr[i + 5], step);
        if (splineIndex) tessSplineIndex[count / 3] = splineIndex[i / 3];

        arrEdges[count++] = ip(oldArr[i + 0], oldArr[i + 3], oneMinusStep);
        arrEdges[count++] = ip(oldArr[i + 1], oldArr[i + 4], oneMinusStep);
        arrEdges[count++] = ip(oldArr[i + 2], oldArr[i + 5], oneMinusStep);
        if (splineIndex) tessSplineIndex[count / 3] = splineIndex[i / 3];
    }

    if (splineIndex) splineIndex = tessSplineIndex;

    return arrEdges;
}


};

Ops.Gl.Meshes.SplineMesh_v2.prototype = new CABLES.Op();
CABLES.OPS["287abf6c-5501-4bc9-a627-70ec3c3766d2"]={f:Ops.Gl.Meshes.SplineMesh_v2,objName:"Ops.Gl.Meshes.SplineMesh_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.Star
// 
// **************************************************************

Ops.Gl.Meshes.Star = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    segments = op.inValue("segments", 40),
    radius = op.inValue("radius", 1),
    shape = op.inValueSelect("Shape", ["Star", "Saw", "Gear"], "Star"),
    outerRadius = op.inValue("Length", 1.5),
    zDiff = op.inFloat("Peak Z Pos", 0),
    percent = op.inValueSlider("percent"),
    fill = op.inValueBool("Fill"),
    trigger = op.outTrigger("trigger"),
    geomOut = op.addOutPort(new CABLES.Port(op, "geometry", CABLES.OP_PORT_TYPE_OBJECT));

geomOut.ignoreValueSerialize = true;
let cgl = op.patch.cgl;

let oldPrim = 0;
let shader = null;
percent.set(1);

let geom = new CGL.Geometry("circle");
let mesh = null;
let lastSegs = -1;

zDiff.onChange =
    segments.onChange =
    radius.onChange =
    percent.onChange =
    shape.onChange =
    fill.onChange =
    outerRadius.onChange = calc;
calc();

render.onTriggered = function ()
{
    if (op.instanced(render)) return;

    shader = cgl.getShader();
    if (!shader) return;
    oldPrim = shader.glPrimitive;

    mesh.render(shader);
    trigger.trigger();

    shader.glPrimitive = oldPrim;
};

function calc()
{
    let segs = Math.max(3, Math.floor(segments.get()));

    geom.clear();

    let
        faces = [],
        normals = [],
        tangents = [],
        biTangents = [];
    let i = 0, degInRad = 0;
    let oldPosX = 0, oldPosY = 0;
    let oldPosXTexCoord = 0, oldPosYTexCoord = 0;

    let oldPosXIn = 0, oldPosYIn = 0;
    let oldPosXTexCoordIn = 0, oldPosYTexCoordIn = 0;

    let posxTexCoordIn = 0, posyTexCoordIn = 0;
    let posxTexCoord = 0, posyTexCoord = 0;
    let posx = 0, posy = 0;

    let verts = [];
    let outX = 0, outY = 0;

    let imode = 0;
    if (shape.get() == "Saw")imode = 1;
    if (shape.get() == "Gear")imode = 2;

    let cycleGear = true;

    for (i = 0; i <= segs * percent.get(); i++)
    {
        degInRad = (360 / segs) * i * CGL.DEG2RAD;
        posx = Math.cos(degInRad) * radius.get();
        posy = Math.sin(degInRad) * radius.get();

        // saw mode
        cycleGear = !cycleGear;

        switch (imode)
        {
        case 0:
            outX = ((posx + oldPosX) * 0.5) * outerRadius.get();
            outY = ((posy + oldPosY) * 0.5) * outerRadius.get();
            break;

        case 1:
            outX = (posx) * outerRadius.get();
            outY = (posy) * outerRadius.get();
            break;

        case 2:
            if (cycleGear)
            {
                outX = (posx) * outerRadius.get();
                outY = (posy) * outerRadius.get();

                degInRad = (360 / segs) * (i - 1) * CGL.DEG2RAD;
                let ooutX = Math.cos(degInRad) * radius.get();
                let ooutY = Math.sin(degInRad) * radius.get();

                ooutX *= outerRadius.get();
                ooutY *= outerRadius.get();

                faces.push(
                    [ooutX, ooutY, 0],
                    [outX, outY, 0],
                    [oldPosX, oldPosY, 0]
                );
                normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
                tangents.push(1, 0, 0, 1, 0, 0, 1, 0, 0);
                biTangents.push(0, 1, 0, 0, 1, 0, 0, 1, 0);
            }

            break;
        }

        if (fill.get())
        {
            faces.push(
                [posx, posy, 0],
                [oldPosX, oldPosY, 0],
                [0, 0, 0]
            );
            normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
            tangents.push(1, 0, 0, 1, 0, 0, 1, 0, 0);
            biTangents.push(0, 1, 0, 0, 1, 0, 0, 1, 0);
        }

        if (imode != 2 || cycleGear)
        {
            faces.push(
                [posx, posy, 0],
                [oldPosX, oldPosY, 0],
                [outX, outY, zDiff.get()]
            );
            normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
            tangents.push(1, 0, 0, 1, 0, 0, 1, 0, 0);
            biTangents.push(0, 1, 0, 0, 1, 0, 0, 1, 0);
        }

        oldPosX = posx;
        oldPosY = posy;
    }

    geom = CGL.Geometry.buildFromFaces(faces);
    geom.vertexNormals = normals;
    geom.tangents = tangents;
    geom.biTangents = biTangents;
    geom.mapTexCoords2d();

    geomOut.set(null);
    geomOut.set(geom);

    if (geom.vertices.length == 0) return;
    if (!mesh)mesh = new CGL.Mesh(cgl, geom);
    mesh.setGeom(geom);
}


};

Ops.Gl.Meshes.Star.prototype = new CABLES.Op();
CABLES.OPS["25feb18a-8df6-473f-b548-59c514c6f949"]={f:Ops.Gl.Meshes.Star,objName:"Ops.Gl.Meshes.Star"};




// **************************************************************
// 
// Ops.Gl.Meshes.SuperShape
// 
// **************************************************************

Ops.Gl.Meshes.SuperShape = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// from https://github.com/ahoiin/supershape.js/blob/master/js/objects.js

const render = op.inTrigger("render");

let pNormalizeSize = op.inValueBool("Normalize Size", true);
let asPointCloud = op.inValueBool("Point Cloud", false);
let pStep = op.inFloat("Step", 0.05);

let a1 = op.inFloat("a1", 1);
let b1 = op.inFloat("b1", 1);
let m1 = op.inFloat("m1", 5);
let n11 = op.inFloat("n11", 1);
let n21 = op.inFloat("n21", 1);
let n31 = op.inFloat("n31", 2);

let a2 = op.inFloat("a2", 1);
let b2 = op.inFloat("b2", 1);
let m2 = op.inFloat("m2", 5);
let n12 = op.inFloat("n12", 1);
let n22 = op.inFloat("n22", 1);
let n32 = op.inFloat("n32", 3);

let trigger = op.outTrigger("Trigger");
let outNumVerts = op.outNumber("Num Vertices");
let outGeom = op.outObject("geom", null, "geometry");

let needsUpdate = true;
let geometry = new CGL.Geometry(op.name);
let mesh = null;
let verts = [];

pNormalizeSize.onChange =
    pStep.onChange =
    a1.onChange =
    b1.onChange =
    m1.onChange =
    n11.onChange =
    n21.onChange =
    n31.onChange =
    a2.onChange =
    b2.onChange =
    m2.onChange =
    n12.onChange =
    n22.onChange =
    n32.onChange = doUpdate;

function doUpdate()
{
    needsUpdate = true;
}

asPointCloud.onChange = function ()
{
    mesh = null;
    needsUpdate = true;
};

render.onTriggered = function ()
{
    if (needsUpdate)update();
    if (mesh) mesh.render(op.patch.cgl.getShader());

    trigger.trigger();
};
function update()
{
    verts.length = 0;
    geometry.clear();
    // geometry=new CGL.Geometry(op.name);
    needsUpdate = false;
    // geometry.dynamic = true;
    let step = pStep.get();
    let q = parseInt(2 * Math.PI / step + 1.3462);
    let o = parseInt(Math.PI / step + 1.5);

    let resize = pNormalizeSize.get();
    let max = 0;

    for (let l = 0; l < (q); l++)
    {
        var u = -Math.PI + l * step;
        for (let h = 0; h < (o); h++)
        {
            var s = -Math.PI / 2 + h * step;
            var m, k, n, g, v, e, t;
            let f = 0;
            let p = 0;
            let w = 0;
            m = Math.cos(m1.get() * u / 4);
            m = 1 / a1.get() * Math.abs(m);
            m = Math.abs(m);
            k = Math.sin(m1.get() * u / 4);
            k = 1 / b1.get() * Math.abs(k);
            k = Math.abs(k);
            g = Math.pow(m, n21.get()) + Math.pow(k, n31.get());
            v = Math.abs(g);
            v = Math.pow(v, (-1 / n11.get()));
            m = Math.cos(m2.get() * s / 4);
            m = 1 / a2.get() * Math.abs(m);
            m = Math.abs(m);
            k = Math.sin(m2.get() * s / 4);
            k = 1 / b2.get() * Math.abs(k);
            k = Math.abs(k);
            e = Math.pow(m, n22.get()) + Math.pow(k, n32.get());
            t = Math.abs(e);
            t = Math.pow(t, (-1 / n12.get()));
            f = v * Math.cos(u) * t * Math.cos(s);
            p = v * Math.sin(u) * t * Math.cos(s);
            w = t * Math.sin(s);
            verts.push(f);
            verts.push(p);
            verts.push(w);

            if (resize)
            {
                max = Math.max(max, Math.abs(f));
                max = Math.max(max, Math.abs(p));
                max = Math.max(max, Math.abs(w));
            }
        }
    }

    if (resize && max > 1) for (let i = 0; i < verts.length; i++) verts[i] /= max;

    if (asPointCloud.get())
    {
        geometry.setPointVertices(verts);
        geometry.mapTexCoords2d();

        mesh = new CGL.Mesh(op.patch.cgl, geometry, op.patch.cgl.gl.POINTS);
        mesh.addVertexNumbers = true;
        mesh.setGeom(geometry);
    }
    else
    {
        for (var u = 0; u < (q - 1); u++)
        {
            for (var s = 0; s < (o - 1); s++)
            {
                let d = u * o + s;
                let c = u * o + s + 1;
                let b = (u + 1) * o + s + 1;
                let a = (u + 1) * o + s;
                // geometry.faces.push(new THREE.Face4(d, c, b, a));
                geometry.verticesIndices.push(d);
                geometry.verticesIndices.push(c);
                geometry.verticesIndices.push(b);

                geometry.verticesIndices.push(a);
                geometry.verticesIndices.push(b);
                geometry.verticesIndices.push(d);
            }
        }
        geometry.vertices = verts;
        geometry.mapTexCoords2d();

        outNumVerts.set(verts.length);

        geometry.calculateNormals({ "forceZUp": true });

        if (!mesh) mesh = new CGL.Mesh(op.patch.cgl, geometry);
        else mesh.setGeom(geometry);
    }

    outGeom.set(null);
    outGeom.set(geometry);
}


};

Ops.Gl.Meshes.SuperShape.prototype = new CABLES.Op();
CABLES.OPS["ed8b5db0-b928-4f5d-87d7-4b2491ae7b00"]={f:Ops.Gl.Meshes.SuperShape,objName:"Ops.Gl.Meshes.SuperShape"};




// **************************************************************
// 
// Ops.Gl.Meshes.TextMesh_v2
// 
// **************************************************************

Ops.Gl.Meshes.TextMesh_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"textmesh_frag":"UNI sampler2D tex;\n#ifdef DO_MULTEX\n    UNI sampler2D texMul;\n#endif\n#ifdef DO_MULTEX_MASK\n    UNI sampler2D texMulMask;\n#endif\nIN vec2 texCoord;\nIN vec2 texPos;\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n    col.a=col.r;\n    col.r*=r;\n    col.g*=g;\n    col.b*=b;\n    col*=a;\n\n    if(col.a==0.0)discard;\n\n    #ifdef DO_MULTEX\n        col*=texture(texMul,texPos);\n    #endif\n\n    #ifdef DO_MULTEX_MASK\n        col*=texture(texMulMask,texPos).r;\n    #endif\n\n    outColor=col;\n}","textmesh_vert":"UNI sampler2D tex;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nUNI float scale;\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN mat4 instMat;\nIN vec2 attrTexOffsets;\nIN vec2 attrTexSize;\nIN vec2 attrTexPos;\nOUT vec2 texPos;\n\nOUT vec2 texCoord;\n\nvoid main()\n{\n    texCoord=(attrTexCoord*(attrTexSize)) + attrTexOffsets;\n    mat4 instMVMat=instMat;\n    instMVMat[3][0]*=scale;\n\n    texPos=attrTexPos;\n\n    vec4 vert=vec4( vPosition.x*(attrTexSize.x/attrTexSize.y)*scale,vPosition.y*scale,vPosition.z*scale, 1. );\n\n    mat4 mvMatrix=viewMatrix * modelMatrix * instMVMat;\n\n    gl_Position = projMatrix * mvMatrix * vert;\n}\n",};
const
    render = op.inTrigger("Render"),
    str = op.inString("Text", "cables"),
    scale = op.inValueFloat("Scale", 1),
    inFont = op.inString("Font", "Arial"),
    align = op.inValueSelect("align", ["left", "center", "right"], "center"),
    valign = op.inValueSelect("vertical align", ["Top", "Middle", "Bottom"], "Middle"),
    lineHeight = op.inValueFloat("Line Height", 1),
    letterSpace = op.inValueFloat("Letter Spacing"),

    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "mipmap"),
    aniso = op.inSwitch("Anisotropic", [0, 1, 2, 4, 8, 16], 0),

    inMulTex = op.inTexture("Texture Color"),
    inMulTexMask = op.inTexture("Texture Mask"),
    next = op.outTrigger("Next"),
    textureOut = op.outTexture("texture"),
    outLines = op.outNumber("Total Lines", 0),
    outWidth = op.outNumber("Width", 0),
    loaded = op.outBoolNum("Font Available", 0);

const cgl = op.patch.cgl;

op.setPortGroup("Masking", [inMulTex, inMulTexMask]);

const textureSize = 1024;
let fontLoaded = false;
let needUpdate = true;

align.onChange =
    str.onChange =
    lineHeight.onChange = generateMeshLater;

function generateMeshLater()
{
    needUpdate = true;
}

let canvasid = null;
CABLES.OpTextureMeshCanvas = {};
let valignMode = 0;

const geom = null;
let mesh = null;

let createMesh = true;
let createTexture = true;

aniso.onChange =
tfilter.onChange = () =>
{
    getFont().texture = null;
    createTexture = true;
};

inMulTexMask.onChange =
inMulTex.onChange = function ()
{
    shader.toggleDefine("DO_MULTEX", inMulTex.get());
    shader.toggleDefine("DO_MULTEX_MASK", inMulTexMask.get());
};

textureOut.set(null);
inFont.onChange = function ()
{
    createTexture = true;
    createMesh = true;
    checkFont();
};

op.patch.on("fontLoaded", (fontName) =>
{
    if (fontName == inFont.get())
    {
        createTexture = true;
        createMesh = true;
    }
});

function checkFont()
{
    const oldFontLoaded = fontLoaded;
    try
    {
        fontLoaded = document.fonts.check("20px \"" + inFont.get() + "\"");
    }
    catch (ex)
    {
        op.logError(ex);
    }

    if (!oldFontLoaded && fontLoaded)
    {
        loaded.set(true);
        createTexture = true;
        createMesh = true;
    }

    if (!fontLoaded) setTimeout(checkFont, 250);
}

valign.onChange = function ()
{
    if (valign.get() == "Middle")valignMode = 0;
    else if (valign.get() == "Top")valignMode = 1;
    else if (valign.get() == "Bottom")valignMode = 2;
};

function getFont()
{
    canvasid = "" + inFont.get();
    if (CABLES.OpTextureMeshCanvas.hasOwnProperty(canvasid))
        return CABLES.OpTextureMeshCanvas[canvasid];

    const fontImage = document.createElement("canvas");
    fontImage.dataset.font = inFont.get();
    fontImage.id = "texturetext_" + CABLES.generateUUID();
    fontImage.style.display = "none";
    const body = document.getElementsByTagName("body")[0];
    body.appendChild(fontImage);
    const _ctx = fontImage.getContext("2d");
    CABLES.OpTextureMeshCanvas[canvasid] =
        {
            "ctx": _ctx,
            "canvas": fontImage,
            "chars": {},
            "characters": "",
            "fontSize": 320
        };
    return CABLES.OpTextureMeshCanvas[canvasid];
}

op.onDelete = function ()
{
    if (canvasid && CABLES.OpTextureMeshCanvas[canvasid])
        CABLES.OpTextureMeshCanvas[canvasid].canvas.remove();
};

const shader = new CGL.Shader(cgl, "TextMesh");
shader.setSource(attachments.textmesh_vert, attachments.textmesh_frag);
const uniTex = new CGL.Uniform(shader, "t", "tex", 0);
const uniTexMul = new CGL.Uniform(shader, "t", "texMul", 1);
const uniTexMulMask = new CGL.Uniform(shader, "t", "texMulMask", 2);
const uniScale = new CGL.Uniform(shader, "f", "scale", scale);

const
    r = op.inValueSlider("r", 1),
    g = op.inValueSlider("g", 1),
    b = op.inValueSlider("b", 1),
    a = op.inValueSlider("a", 1),
    runiform = new CGL.Uniform(shader, "f", "r", r),
    guniform = new CGL.Uniform(shader, "f", "g", g),
    buniform = new CGL.Uniform(shader, "f", "b", b),
    auniform = new CGL.Uniform(shader, "f", "a", a);
r.setUiAttribs({ "colorPick": true });

op.setPortGroup("Display", [scale, inFont]);
op.setPortGroup("Alignment", [align, valign]);
op.setPortGroup("Color", [r, g, b, a]);

let height = 0;
const vec = vec3.create();
let lastTextureChange = -1;
let disabled = false;

render.onTriggered = function ()
{
    if (needUpdate)
    {
        generateMesh();
        needUpdate = false;
    }
    const font = getFont();
    if (font.lastChange != lastTextureChange)
    {
        createMesh = true;
        lastTextureChange = font.lastChange;
    }

    if (createTexture) generateTexture();
    if (createMesh)generateMesh();

    if (mesh && mesh.numInstances > 0)
    {
        cgl.pushBlendMode(CGL.BLEND_NORMAL, true);
        cgl.pushShader(shader);
        cgl.setTexture(0, textureOut.get().tex);

        const mulTex = inMulTex.get();
        if (mulTex)cgl.setTexture(1, mulTex.tex);

        const mulTexMask = inMulTexMask.get();
        if (mulTexMask)cgl.setTexture(2, mulTexMask.tex);

        if (valignMode === 2) vec3.set(vec, 0, height, 0);
        else if (valignMode === 1) vec3.set(vec, 0, 0, 0);
        else if (valignMode === 0) vec3.set(vec, 0, height / 2, 0);

        vec[1] -= lineHeight.get();
        cgl.pushModelMatrix();
        mat4.translate(cgl.mMatrix, cgl.mMatrix, vec);
        if (!disabled)mesh.render(cgl.getShader());

        cgl.popModelMatrix();

        cgl.setTexture(0, null);
        cgl.popShader();
        cgl.popBlendMode();
    }

    next.trigger();
};

letterSpace.onChange = function ()
{
    createMesh = true;
};

function generateMesh()
{
    const theString = String(str.get() + "");
    if (!textureOut.get()) return;

    const font = getFont();
    if (!font.geom)
    {
        font.geom = new CGL.Geometry("textmesh");

        font.geom.vertices = [
            1.0, 1.0, 0.0,
            0.0, 1.0, 0.0,
            1.0, 0.0, 0.0,
            0.0, 0.0, 0.0
        ];

        font.geom.texCoords = new Float32Array([
            1.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            0.0, 0.0
        ]);

        font.geom.verticesIndices = [
            0, 1, 2,
            2, 1, 3
        ];
    }

    if (!mesh)mesh = new CGL.Mesh(cgl, font.geom);

    const strings = (theString).split("\n");
    outLines.set(strings.length);

    const transformations = [];
    const tcOffsets = [];// new Float32Array(str.get().length*2);
    const tcSize = [];// new Float32Array(str.get().length*2);
    const texPos = [];
    let charCounter = 0;
    createTexture = false;
    const m = mat4.create();

    let maxWidth = 0;

    for (let s = 0; s < strings.length; s++)
    {
        const txt = strings[s];
        const numChars = txt.length;

        let pos = 0;
        let offX = 0;
        let width = 0;

        for (let i = 0; i < numChars; i++)
        {
            const chStr = txt.substring(i, i + 1);
            const char = font.chars[String(chStr)];
            if (char)
            {
                width += (char.texCoordWidth / char.texCoordHeight);
                width += letterSpace.get();
            }
        }

        width -= letterSpace.get();

        height = 0;

        if (align.get() == "left") offX = 0;
        else if (align.get() == "right") offX = width;
        else if (align.get() == "center") offX = width / 2;

        height = (s + 1) * lineHeight.get();

        for (let i = 0; i < numChars; i++)
        {
            const chStr = txt.substring(i, i + 1);
            const char = font.chars[String(chStr)];

            if (!char)
            {
                createTexture = true;
                return;
            }
            else
            {
                texPos.push(pos / width * 0.99 + 0.005, (1.0 - (s / (strings.length - 1))) * 0.99 + 0.005);
                tcOffsets.push(char.texCoordX, 1 - char.texCoordY - char.texCoordHeight);
                tcSize.push(char.texCoordWidth, char.texCoordHeight);

                mat4.identity(m);
                mat4.translate(m, m, [pos - offX, 0 - s * lineHeight.get(), 0]);

                pos += (char.texCoordWidth / char.texCoordHeight) + letterSpace.get();
                maxWidth = Math.max(maxWidth, pos - offX);

                transformations.push(Array.prototype.slice.call(m));

                charCounter++;
            }
        }
    }

    const transMats = [].concat.apply([], transformations);

    disabled = false;
    if (transMats.length == 0)disabled = true;

    mesh.numInstances = transMats.length / 16;

    if (mesh.numInstances == 0)
    {
        disabled = true;
        return;
    }

    outWidth.set(maxWidth * scale.get());
    mesh.setAttribute("instMat", new Float32Array(transMats), 16, { "instanced": true });
    mesh.setAttribute("attrTexOffsets", new Float32Array(tcOffsets), 2, { "instanced": true });
    mesh.setAttribute("attrTexSize", new Float32Array(tcSize), 2, { "instanced": true });
    mesh.setAttribute("attrTexPos", new Float32Array(texPos), 2, { "instanced": true });

    createMesh = false;

    if (createTexture) generateTexture();
}

function printChars(fontSize, simulate)
{
    const font = getFont();
    if (!simulate) font.chars = {};

    const ctx = font.ctx;

    ctx.font = fontSize + "px " + inFont.get();
    ctx.textAlign = "left";

    let posy = 0;
    let posx = 0;
    const lineHeight = fontSize * 1.4;
    const result =
        {
            "fits": true
        };

    for (let i = 0; i < font.characters.length; i++)
    {
        const chStr = String(font.characters.substring(i, i + 1));
        const chWidth = (ctx.measureText(chStr).width);

        if (posx + chWidth >= textureSize)
        {
            posy += lineHeight + 2;
            posx = 0;
        }

        if (!simulate)
        {
            font.chars[chStr] =
                {
                    "str": chStr,
                    "texCoordX": posx / textureSize,
                    "texCoordY": posy / textureSize,
                    "texCoordWidth": chWidth / textureSize,
                    "texCoordHeight": lineHeight / textureSize,
                };

            ctx.fillText(chStr, posx, posy + fontSize);
        }

        posx += chWidth + 12;
    }

    if (posy > textureSize - lineHeight)
    {
        result.fits = false;
    }

    result.spaceLeft = textureSize - posy;

    return result;
}

function generateTexture()
{
    let filter = CGL.Texture.FILTER_LINEAR;
    if (tfilter.get() == "nearest") filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "mipmap") filter = CGL.Texture.FILTER_MIPMAP;

    const font = getFont();
    let string = String(str.get());
    if (string == null || string == undefined)string = "";
    for (let i = 0; i < string.length; i++)
    {
        const ch = string.substring(i, i + 1);
        if (font.characters.indexOf(ch) == -1)
        {
            font.characters += ch;
            createTexture = true;
        }
    }

    const ctx = font.ctx;
    font.canvas.width = font.canvas.height = textureSize;

    if (!font.texture)
        font.texture = CGL.Texture.createFromImage(cgl, font.canvas,
            {
                "filter": filter,
                "anisotropic": parseFloat(aniso.get())
            });

    font.texture.setSize(textureSize, textureSize);

    ctx.fillStyle = "transparent";
    ctx.clearRect(0, 0, textureSize, textureSize);
    ctx.fillStyle = "rgba(255,255,255,255)";

    let fontSize = font.fontSize + 40;
    let simu = printChars(fontSize, true);

    while (!simu.fits)
    {
        fontSize -= 5;
        simu = printChars(fontSize, true);
    }

    printChars(fontSize, false);

    ctx.restore();

    font.texture.initTexture(font.canvas, filter);
    font.texture.unpackAlpha = true;
    textureOut.set(font.texture);

    font.lastChange = CABLES.now();

    createMesh = true;
    createTexture = false;
}


};

Ops.Gl.Meshes.TextMesh_v2.prototype = new CABLES.Op();
CABLES.OPS["2390f6b3-2122-412e-8c8d-5c2f574e8bd1"]={f:Ops.Gl.Meshes.TextMesh_v2,objName:"Ops.Gl.Meshes.TextMesh_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.Torus
// 
// **************************************************************

Ops.Gl.Meshes.Torus = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    sides = op.inValue("sides", 32),
    rings = op.inValue("rings", 32),
    innerRadius = op.inValue("innerRadius", 0.5),
    outerRadius = op.inValue("outerRadius", 1),
    indraw = op.inBool("Draw", true),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("geometry");

const UP = vec3.fromValues(0, 1, 0), RIGHT = vec3.fromValues(1, 0, 0);
let tmpNormal = vec3.create(), tmpVec = vec3.create();

geomOut.ignoreValueSerialize = true;

let cgl = op.patch.cgl;
let mesh = null;
let geom = null;
let j = 0, i = 0, idx = 0;
let needsUpdate = true;

rings.onChange =
sides.onChange =
innerRadius.onChange =
outerRadius.onChange = function ()
{
    needsUpdate = true;
};

render.onTriggered = function ()
{
    if (needsUpdate) updateMesh();
    if (indraw.get() && mesh !== null) mesh.render(cgl.getShader());

    trigger.trigger();
};

function updateMesh()
{
    let nrings = Math.round(rings.get());
    let nsides = Math.round(sides.get());
    if (nrings < 2)nrings = 2;
    if (nsides < 2)nsides = 2;
    let r = innerRadius.get();
    let r2 = outerRadius.get();
    generateTorus(r, r2, nrings, nsides);
    needsUpdate = false;
}

function circleTable(n, halfCircle)
{
    let i;
    /* Table size, the sign of n flips the circle direction */
    let size = Math.abs(n);

    /* Determine the angle between samples */
    let angle = (halfCircle ? 1 : 2) * Math.PI / n;// ( n === 0 ) ? 1 : n ;

    /* Allocate memory for n samples, plus duplicate of first entry at the end */
    let sint = [];
    let cost = [];

    /* Compute cos and sin around the circle */
    sint[0] = 0.0;
    cost[0] = 1.0;

    for (i = 1; i < size; i++)
    {
        sint[i] = Math.sin(angle * i);
        cost[i] = Math.cos(angle * i);
    }

    if (halfCircle)
    {
        sint[size] = 0.0; /* sin PI */
        cost[size] = -1.0; /* cos PI */
    }
    else
    {
        /* Last sample is duplicate of the first (sin or cos of 2 PI) */
        sint[size] = sint[0];
        cost[size] = cost[0];
    }
    return { "cost": cost, "sint": sint };
}

function generateTorus(iradius, oradius, nRings, nSides)
{
    let table1 = circleTable(nRings, false);
    let table2 = circleTable(-nSides, false);
    let t;

    geom = new CGL.Geometry("torus");
    geom.glPrimitive = cgl.gl.TRIANGLE_STRIP;
    let tangents = [];
    let biTangents = [];
    let vertexNormals = [];
    let tc = [];

    for (j = 0; j < nRings; j++)
    {
        for (i = 0; i < nSides; i++)
        {
            var offset = 3 * (j * nSides + i);
            var offset2 = 2 * (j * nSides + i);

            geom.vertices[offset] = table1.cost[j] * (oradius + table2.cost[i] * iradius);
            geom.vertices[offset + 1] = table1.sint[j] * (oradius + table2.cost[i] * iradius);
            geom.vertices[offset + 2] = table2.sint[i] * iradius;
            vertexNormals[offset] = tmpNormal[0] = table1.cost[j] * table2.cost[i];
            vertexNormals[offset + 1] = tmpNormal[1] = table1.sint[j] * table2.cost[i];
            vertexNormals[offset + 2] = tmpNormal[2] = table2.sint[i];

            if (Math.abs(tmpNormal[1]) == 1) t = RIGHT;
            else t = UP;

            vec3.cross(tmpVec, tmpNormal, t);
            vec3.normalize(tmpVec, tmpVec);
            tangents[offset] = tmpVec[0];
            tangents[offset + 1] = tmpVec[1];
            tangents[offset + 2] = tmpVec[2];
            vec3.cross(tmpVec, tmpVec, tmpNormal);
            biTangents[offset] = tmpVec[0];
            biTangents[offset + 1] = tmpVec[1];
            biTangents[offset + 2] = tmpVec[2];

            tc[offset2] = j / (nRings - 1);
            tc[offset2 + 1] = i / (nSides - 1);
        }
    }

    for (i = 0, idx = 0; i < nSides; i++)
    {
        let ioff = 1;
        if (i == nSides - 1) ioff = -i;

        for (j = 0; j < nRings; j++, idx += 2)
        {
            var offset = j * nSides + i;
            geom.verticesIndices[idx] = offset;
            geom.verticesIndices[idx + 1] = offset + ioff;

            tc[offset2] = j / (nRings + 1);
            tc[offset2 + 1] = i / (nSides + 1);
        }

        /* repeat first to close off shape */
        geom.verticesIndices[idx] = i;
        geom.verticesIndices[idx + 1] = i + ioff;

        idx += 2;
    }

    if (geom.biTangents.length == biTangents.length)geom.biTangents.set(biTangents);
    else geom.biTangents = new Float32Array(biTangents);

    if (geom.tangents.length == tangents.length)geom.tangents.set(tangents);
    else geom.tangents = new Float32Array(tangents);

    if (geom.vertexNormals.length == vertexNormals.length)geom.vertexNormals.set(vertexNormals);
    else geom.vertexNormals = new Float32Array(vertexNormals);

    geom.setTexCoords(tc);

    geomOut.set(null);
    geomOut.set(geom);

    if (!mesh)mesh = new CGL.Mesh(cgl, geom, cgl.gl.TRIANGLE_STRIP);
    else mesh.setGeom(geom);
}


};

Ops.Gl.Meshes.Torus.prototype = new CABLES.Op();
CABLES.OPS["d921e008-21b9-4cf5-84a2-4dedca34f0c8"]={f:Ops.Gl.Meshes.Torus,objName:"Ops.Gl.Meshes.Torus"};




// **************************************************************
// 
// Ops.Gl.Meshes.Triangle
// 
// **************************************************************

Ops.Gl.Meshes.Triangle = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    sizeW = op.inValueFloat("width", 1),
    sizeH = op.inValueFloat("height", 1),
    draw = op.inValueBool("Draw", true),
    geom = new CGL.Geometry("triangle"),
    geomOut = op.outObject("geometry");

geomOut.ignoreValueSerialize = true;

op.setPortGroup("Size", [sizeW, sizeH]);

const cgl = op.patch.cgl;
let mesh = null;
sizeW.onChange = create;
sizeH.onChange = create;

create();

op.preRender = create;

render.onTriggered = function ()
{
    if (draw.get())mesh.render(cgl.getShader());
    trigger.trigger();
};

function create()
{
    geom.vertices = [
        0.0, sizeH.get(), 0.0,
        -sizeW.get(), -sizeH.get(), 0.0,
        sizeW.get(), -sizeH.get(), 0.0
    ];

    geom.vertexNormals = [
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 1.0
    ];
    geom.tangents = [
        1, 0, 0,
        1, 0, 0,
        1, 0, 0
    ];
    geom.biTangents = [
        0, 1, 0,
        0, 1, 0,
        0, 1, 0
    ];

    geom.texCoords = [
        0.5, 0.0,
        1.0, 1.0,
        0.0, 1.0,
    ];

    geom.verticesIndices = [
        0, 1, 2
    ];

    mesh = new CGL.Mesh(cgl, geom);
    geomOut.set(null);
    geomOut.set(geom);
}


};

Ops.Gl.Meshes.Triangle.prototype = new CABLES.Op();
CABLES.OPS["331bc9dc-d44c-43bd-be18-a2673fba124e"]={f:Ops.Gl.Meshes.Triangle,objName:"Ops.Gl.Meshes.Triangle"};




// **************************************************************
// 
// Ops.Gl.Meshes.TriangleArray_v2
// 
// **************************************************************

Ops.Gl.Meshes.TriangleArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    inArr = op.inArray("Points", 3),
    inVertCols = op.inArray("Vertex Colors", 4),
    inTexCoords = op.inArray("TexCoords", 2),
    inFlat = op.inValueBool("Flat", false),
    inRenderMesh = op.inBool("Render Mesh", true),
    next = op.outTrigger("Next"),
    geomOut = op.outObject("Geometry");

let geom = new CGL.Geometry("triangle array");

let mesh = null;
let verts = null;
let needsUpdate = true;
const cgl = op.patch.cgl;

op.toWorkPortsNeedToBeLinked(inArr, render);

inArr.onChange =
inVertCols.onChange =
inTexCoords.onChange = () =>
{
    needsUpdate = true;
};
inFlat.onChange = () =>
{
    geom = new CGL.Geometry("triangle array");
    update();
};

function update()
{
    op.setUiError("coordsMismatch", null);
    op.setUiError("colorsMismatch", null);

    verts = inArr.get();
    if (!verts) return;

    let num = verts.length / 3;
    num = Math.abs(Math.floor(num));

    let tc = [];
    const texCoords = inTexCoords.get();
    if (texCoords)
    {
        if (texCoords.length !== (num * 2))
        {
            op.setUiError("coordsMismatch", "Coords array does not have the correct length! (should be " + num * 2 + ")");
        }
        tc = texCoords;
    }
    else
    {
        for (let i = 0; i < verts.length / 3; i++)
        {
            tc.push(0, 0, 0, 1, 1, 1);
        }
    }

    geom.vertices = verts;
    geom.texCoords = tc;

    mesh = new CGL.Mesh(cgl, geom);

    const vertexColors = inVertCols.get();
    if (vertexColors)
    {
        if (vertexColors.length !== (num * 4))
        {
            op.setUiError("colorsMismatch", "Color array does not have the correct length! (should be " + num * 4 + ")");
            return;
        }
        geom.vertexColors = vertexColors;
    }

    if (!inFlat.get()) index(verts, geom);
    else
    {
        geom.vertices = verts;
    }

    geom.calculateNormals();
    geomOut.set(null);
    geomOut.set(geom);
    needsUpdate = false;
}

render.onTriggered = function ()
{
    if (needsUpdate)update();
    if (mesh && verts && inRenderMesh.get()) mesh.render(cgl.getShader());
    next.trigger();
};

function index(vertsToIndex, geometry)
{
    const num = vertsToIndex.length / 3;
    const arr = [];
    const ind = [];
    let delta = 0.0001;

    for (let i = 0; i < num; i++)
    {
        let found = false;

        for (let j = 0; j < arr.length; j += 3)
        {
            if (
                arr[j] < vertsToIndex[i * 3] + delta &&
                arr[j + 1] < vertsToIndex[i * 3 + 1] + delta &&
                arr[j + 2] < vertsToIndex[i * 3 + 2] + delta &&
                arr[j] > vertsToIndex[i * 3] - delta &&
                arr[j + 1] > vertsToIndex[i * 3 + 1] - delta &&
                arr[j + 2] > vertsToIndex[i * 3 + 2] - delta)
            {
                ind.push(j / 3);
                found = true;
            }
        }

        if (!found)
        {
            arr.push(vertsToIndex[i * 3]);
            arr.push(vertsToIndex[i * 3 + 1]);
            arr.push(vertsToIndex[i * 3 + 2]);
            ind.push(arr.length / 3 - 1);
        }
    }

    geometry.verticesIndices = ind;
    geometry.vertices = arr;
}


};

Ops.Gl.Meshes.TriangleArray_v2.prototype = new CABLES.Op();
CABLES.OPS["ee4d9fa8-996d-44a4-80a0-4f14bbd85502"]={f:Ops.Gl.Meshes.TriangleArray_v2,objName:"Ops.Gl.Meshes.TriangleArray_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.TriangleSphere
// 
// **************************************************************

Ops.Gl.Meshes.TriangleSphere = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// http://paulbourke.net/geometry/circlesphere/

// http://paulbourke.net/geometry/circlesphere/csource3.c
//! !!! http://paulbourke.net/geometry/circlesphere/csource2.c

const render = op.inTrigger("render");
const next = op.outTrigger("next");

const inIterations = op.inValue("Iterations", 4);
const geomOut = op.outObject("Geometry");

const flat = op.inValueBool("Flat", false);
const inDraw = op.inValueBool("Draw", true);

let verts = [];
let geom = null;
let mesh = null;
const cgl = op.patch.cgl;

inIterations.onChange = generate;

generate();

flat.onChange = generate;

render.onTriggered = function ()
{
    // cgl.gl.cullFace(cgl.gl.BACK);
    // cgl.gl.enable(cgl.gl.CULL_FACE);

    if (inDraw.get() && mesh) mesh.render(cgl.getShader());
    next.trigger();

    // cgl.gl.disable(cgl.gl.CULL_FACE);
};

function normalize(v)
{
    const len = Math.sqrt((v[0] * v[0]) + (v[1] * v[1]) + (v[2] * v[2]));
    v[0] /= len;
    v[1] /= len;
    v[2] /= len;
    return v;
}

function index(verts, geom)
{
    const num = verts.length / 3;
    const arr = [];
    const ind = [], tc = [];

    for (let i = 0; i < num; i++)
    {
        let found = false;

        for (let j = 0; j < arr.length; j += 3)
        {
            if (
                arr[j + 0] == verts[i * 3 + 0] &&
                arr[j + 1] == verts[i * 3 + 1] &&
                arr[j + 2] == verts[i * 3 + 2])
            {
                ind.push(j / 3);
                found = true;
                continue;
            }
        }

        if (!found)
        {
            arr.push(verts[i * 3 + 0]);
            arr.push(verts[i * 3 + 1]);
            arr.push(verts[i * 3 + 2]);
            ind.push(arr.length / 3 - 1);

            tc.push(verts[i * 3 + 0]);
            tc.push(verts[i * 3 + 1]);
        }
    }

    geom.verticesIndices = ind;
    geom.vertices = arr;
    geom.texCoords = tc;
}

function generate()
{
    let iterations = Math.max(1, Math.floor(inIterations.get()));
    iterations = Math.min(6, iterations);
    const f = [];
    let i, it;
    const p = [[0, 0, 1], [0, 0, -1], [-1, -1, 0], [1, -1, 0], [1, 1, 0], [-1, 1, 0]];

    let nt = 0, ntold;

    /* Create the level 0 object */
    const a = 1 / Math.sqrt(2.0);
    for (i = 0; i < 6; i++)
    {
        p[i][0] *= a;
        p[i][1] *= a;
    }

    for (i = 0; i < 8; i++)
    {
        f[i] = [[], [], []];
    }
    f[0][0] = p[0]; f[0][1] = p[3]; f[0][2] = p[4];
    f[1][0] = p[0]; f[1][1] = p[4]; f[1][2] = p[5];
    f[2][0] = p[0]; f[2][1] = p[5]; f[2][2] = p[2];
    f[3][0] = p[0]; f[3][1] = p[2]; f[3][2] = p[3];
    f[4][0] = p[1]; f[4][1] = p[4]; f[4][2] = p[3];
    f[5][0] = p[1]; f[5][1] = p[5]; f[5][2] = p[4];
    f[6][0] = p[1]; f[6][1] = p[2]; f[6][2] = p[5];
    f[7][0] = p[1]; f[7][1] = p[3]; f[7][2] = p[2];
    nt = 8;

    if (iterations > 1)
    {
        /* Bisect each edge and move to the surface of a unit sphere */
        for (it = 0; it < iterations; it++)
        {
            ntold = nt;
            for (i = 0; i < ntold; i++)
            {
                const pa = [], pb = [], pc = [];
                pa[0] = (f[i][0][0] + f[i][1][0]) / 2;
                pa[1] = (f[i][0][1] + f[i][1][1]) / 2;
                pa[2] = (f[i][0][2] + f[i][1][2]) / 2;
                pb[0] = (f[i][1][0] + f[i][2][0]) / 2;
                pb[1] = (f[i][1][1] + f[i][2][1]) / 2;
                pb[2] = (f[i][1][2] + f[i][2][2]) / 2;
                pc[0] = (f[i][2][0] + f[i][0][0]) / 2;
                pc[1] = (f[i][2][1] + f[i][0][1]) / 2;
                pc[2] = (f[i][2][2] + f[i][0][2]) / 2;

                normalize(pa);
                normalize(pb);
                normalize(pc);

                f.push([]);
                f[nt][0] = f[i][0]; f[nt][1] = pa; f[nt][2] = pc; nt++;
                f.push([]);
                f[nt][0] = pa; f[nt][1] = f[i][1]; f[nt][2] = pb; nt++;
                f.push([]);
                f[nt][0] = pb; f[nt][1] = f[i][2]; f[nt][2] = pc; nt++;

                f[i][0] = pa;
                f[i][1] = pb;
                f[i][2] = pc;
            }
        }
    }

    if (!geom)geom = new CGL.Geometry(op.name);
    geom.clear();

    verts = f.flat(Infinity);

    if (!flat.get()) index(verts, geom);
    else
    {
        geom.unIndex();
        const indices = [];
        for (i = 0; i < verts.length / 3; i++)indices.push(i);
        geom.vertices = verts;
        geom.verticesIndices = indices;
    }

    geom.calculateNormals({ "forceZUp": false });
    geom.calcTangentsBitangents();

    mesh = new CGL.Mesh(cgl, geom);
    geomOut.set(null);
    geomOut.set(geom);
}


};

Ops.Gl.Meshes.TriangleSphere.prototype = new CABLES.Op();
CABLES.OPS["ad0e8831-9554-46b3-ac03-c5c166921eda"]={f:Ops.Gl.Meshes.TriangleSphere,objName:"Ops.Gl.Meshes.TriangleSphere"};




// **************************************************************
// 
// Ops.Gl.NormalizeScreenCoordinates
// 
// **************************************************************

Ops.Gl.NormalizeScreenCoordinates = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inX = op.inValue("X"),
    inY = op.inValue("Y"),
    outX = op.outNumber("Result X"),
    outY = op.outNumber("Result Y"),
    range = op.inValueBool("-1 to 1");

inX.onChange =
    inY.onChange =
    range.onChange = update;

function update()
{
    let x = inX.get() / op.patch.cgl.canvas.width;
    let y = inY.get() / op.patch.cgl.canvas.height;

    outX.set(x);
    outY.set(y);

    if (range.get())
    {
        x = x * 2 - 1;
        y = y * 2 - 1;
    }

    outX.set(x);
    outY.set(y);
}


};

Ops.Gl.NormalizeScreenCoordinates.prototype = new CABLES.Op();
CABLES.OPS["84d4f2a6-5ab7-4c97-85e0-2985bfcba70d"]={f:Ops.Gl.NormalizeScreenCoordinates,objName:"Ops.Gl.NormalizeScreenCoordinates"};




// **************************************************************
// 
// Ops.Gl.OrTexture
// 
// **************************************************************

Ops.Gl.OrTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    str0 = op.inTexture("Texture 1"),
    str1 = op.inTexture("Texture 2"),
    str2 = op.inTexture("Texture 3"),
    str3 = op.inTexture("Texture 4"),
    str4 = op.inTexture("Texture 5"),
    str5 = op.inTexture("Texture 6"),
    str6 = op.inTexture("Texture 7"),
    str7 = op.inTexture("Texture 8"),
    result = op.outTexture("Result");

str0.onChange =
    str1.onChange =
    str2.onChange =
    str3.onChange =
    str4.onChange =
    str5.onChange =
    str6.onChange =
    str7.onChange = exec;

const emptyTex = CGL.Texture.getEmptyTexture(op.patch.cgl);
const defaultTex = CGL.Texture.getTempTexture(op.patch.cgl);

function exec()
{
    if (str0.get() && str0.get() != emptyTex && str0.get() != defaultTex) result.set(str0.get());
    else if (str1.get() && str1.get() != emptyTex && str1.get() != defaultTex) result.set(str1.get());
    else if (str2.get() && str2.get() != emptyTex && str2.get() != defaultTex) result.set(str2.get());
    else if (str3.get() && str3.get() != emptyTex && str3.get() != defaultTex) result.set(str3.get());
    else if (str4.get() && str4.get() != emptyTex && str4.get() != defaultTex) result.set(str4.get());
    else if (str5.get() && str5.get() != emptyTex && str5.get() != defaultTex) result.set(str5.get());
    else if (str6.get() && str6.get() != emptyTex && str6.get() != defaultTex) result.set(str6.get());
    else if (str7.get() && str7.get() != emptyTex && str7.get() != defaultTex) result.set(str7.get());
    else result.set(emptyTex);
}


};

Ops.Gl.OrTexture.prototype = new CABLES.Op();
CABLES.OPS["9a383587-272d-429b-95a3-5c9b6007f8ea"]={f:Ops.Gl.OrTexture,objName:"Ops.Gl.OrTexture"};




// **************************************************************
// 
// Ops.Gl.Orthogonal_v2
// 
// **************************************************************

Ops.Gl.Orthogonal_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    bounds = op.inValue("bounds", 2),
    fixAxis = op.inSwitch("Axis", ["X", "Y", "None"], "X"),
    zNear = op.inValue("frustum near", -100),
    zFar = op.inValue("frustum far", 100),
    trigger = op.outTrigger("trigger"),
    outRatio = op.outNumber("Ratio"),
    outWidth = op.outNumber("Width"),
    outHeight = op.outNumber("Height");
const cgl = op.patch.cgl;

render.onTriggered = function ()
{
    const vp = cgl.getViewPort();

    if (fixAxis.get() == "X")
    {
        const ratio = vp[3] / vp[2];

        cgl.pushPMatrix();
        mat4.ortho(
            cgl.pMatrix,
            -bounds.get(),
            bounds.get(),
            -bounds.get() * ratio,
            bounds.get() * ratio,
            parseFloat(zNear.get()),
            parseFloat(zFar.get())
        );

        outWidth.set(bounds.get() * 2);
        outHeight.set(bounds.get() * ratio * 2);
        outRatio.set(ratio);
    }
    else if (fixAxis.get() == "Y")
    {
        const ratio = vp[2] / vp[3];

        cgl.pushPMatrix();
        mat4.ortho(
            cgl.pMatrix,
            -bounds.get() * ratio,
            bounds.get() * ratio,
            -bounds.get(),
            bounds.get(),
            parseFloat(zNear.get()),
            parseFloat(zFar.get())
        );

        outWidth.set(bounds.get() * ratio * 2);
        outHeight.set(bounds.get() * 2);
        outRatio.set(ratio);
    }
    else
    {
        cgl.pushPMatrix();
        mat4.ortho(
            cgl.pMatrix,
            -bounds.get(),
            bounds.get(),
            -bounds.get(),
            bounds.get(),
            parseFloat(zNear.get()),
            parseFloat(zFar.get())
        );

        outWidth.set(bounds.get() * 2);
        outHeight.set(bounds.get() * 2);
        outRatio.set(1);
    }

    trigger.trigger();
    cgl.popPMatrix();
};


};

Ops.Gl.Orthogonal_v2.prototype = new CABLES.Op();
CABLES.OPS["b9235490-eaf2-4960-b1be-4279a4051ec6"]={f:Ops.Gl.Orthogonal_v2,objName:"Ops.Gl.Orthogonal_v2"};




// **************************************************************
// 
// Ops.Gl.OverwriteViewportSize
// 
// **************************************************************

Ops.Gl.OverwriteViewportSize = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Exec"),
    next = op.outTrigger("next"),
    w = op.inValueInt("Width", 1920),
    h = op.inValueInt("Height", 1080);

render.onTriggered = doit;

let oldFunc = null;
let cgl = op.patch.cgl;
let vp = [0, 0, 0, 0];

function newGetViewPort()
{
    return vp;
}

function doit()
{
    let oldWidth = cgl.getViewPort()[2];
    let oldHeight = cgl.getViewPort()[3];

    // cgl.forceViewPortSize(0,0,w.get(),h.get());

    cgl.setViewPort(0, 0, w.get(), h.get());

    next.trigger();

    cgl.setViewPort(0, 0, oldWidth, oldHeight);
}


};

Ops.Gl.OverwriteViewportSize.prototype = new CABLES.Op();
CABLES.OPS["20e370c7-d6e9-4e29-acab-1dd2eb4b921f"]={f:Ops.Gl.OverwriteViewportSize,objName:"Ops.Gl.OverwriteViewportSize"};




// **************************************************************
// 
// Ops.Gl.Pbr.PbrEnvironmentLight
// 
// **************************************************************

Ops.Gl.Pbr.PbrEnvironmentLight = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"IBLLUT_frag":"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n#ifndef WEBGL1\n#define NUM_SAMPLES 1024u\n#else\n#define NUM_SAMPLES 1024\n#endif\n#define PI 3.14159265358\n\nIN vec3 P;\n{{MODULES_HEAD}}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/hdrFilteringFunctions.fx\n// modified to use different syntax for a number of variables\n#if NUM_SAMPLES > 0\n    #ifndef WEBGL1\n        // https://learnopengl.com/PBR/IBL/Specular-IBL\n        // Hammersley\n        float radicalInverse_VdC(uint bits)\n        {\n            bits = (bits << 16u) | (bits >> 16u);\n            bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n            bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n            bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n            bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n            return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n        }\n\n        vec2 hammersley(uint i, uint N)\n        {\n            return vec2(float(i)/float(N), radicalInverse_VdC(i));\n        }\n    #else\n        float vanDerCorpus(int n, int base)\n        {\n            float invBase = 1.0 / float(base);\n            float denom   = 1.0;\n            float result  = 0.0;\n\n            for(int i = 0; i < 32; ++i)\n            {\n                if(n > 0)\n                {\n                    denom   = mod(float(n), 2.0);\n                    result += denom * invBase;\n                    invBase = invBase / 2.0;\n                    n       = int(float(n) / 2.0);\n                }\n            }\n\n            return result;\n        }\n\n        vec2 hammersley(int i, int N)\n        {\n            return vec2(float(i)/float(N), vanDerCorpus(i, 2));\n        }\n    #endif\n\n\t// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/importanceSampling.fx\n\tvec3 hemisphereImportanceSampleDggx(vec2 u, float a) {\n\t\t// pdf = D(a) * cosTheta\n\t\tfloat phi = 2. * PI * u.x;\n\n\t\t// NOTE: (aa-1) == (a-1)(a+1) produces better fp accuracy\n\t\tfloat cosTheta2 = (1. - u.y) / (1. + (a + 1.) * ((a - 1.) * u.y));\n\t\tfloat cosTheta = sqrt(cosTheta2);\n\t\tfloat sinTheta = sqrt(1. - cosTheta2);\n\n\t\treturn vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t}\n\n\t// from https://google.github.io/filament/Filament.md.html#toc9.5\n\t// modified to use different syntax for a number of variables\n    const float NUM_SAMPLES_FLOAT = float(NUM_SAMPLES);\n    const float NUM_SAMPLES_FLOAT_INVERSED = 1. / NUM_SAMPLES_FLOAT;\n    const float NUM_SAMPLES_FLOAT_INVERSED4 = 4. / NUM_SAMPLES_FLOAT;\n\n    float Visibility(float NdotV, float NdotL, float alphaG)\n    {\n        // from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/pbrBRDFFunctions.fx\n        #ifdef WEBGL1\n            // Appply simplification as all squared root terms are below 1 and squared\n            float GGXV = NdotL * (NdotV * (1.0 - alphaG) + alphaG);\n            float GGXL = NdotV * (NdotL * (1.0 - alphaG) + alphaG);\n            return 0.5 / (GGXV + GGXL);\n        #else\n            float a2 = alphaG * alphaG;\n            float GGXV = NdotL * sqrt(NdotV * (NdotV - a2 * NdotV) + a2);\n            float GGXL = NdotV * sqrt(NdotL * (NdotL - a2 * NdotL) + a2);\n            return 0.5 / (GGXV + GGXL);\n        #endif\n    }\n\n\tvoid main()\n\t{\n\t    // actual implementation (not documentation) here: https://github.com/google/filament/blob/94ff2ea6b1e39d909e9066459f2ce8c2942eb876/libs/ibl/src/CubemapIBL.cpp\n\t\t{{MODULE_BEGIN_FRAG}}\n\t\tfloat NoV = P.x;\n\t\tfloat a   = P.y;\n\n\t\tvec3 V;\n\t\tV.x = sqrt(1.0 - NoV*NoV);\n\t\tV.y = 0.0;\n\t\tV.z = NoV;\n\n\t\tvec2 r = vec2(0.0);\n\n        #ifndef WEBGL1\n        for(uint i = 0u; i < NUM_SAMPLES; i++)\n        #else\n        for(int i = 0; i < NUM_SAMPLES; i++)\n        #endif\n        {\n\t\t\tvec2 Xi = hammersley(i, NUM_SAMPLES);\n\t\t\tvec3 H  = hemisphereImportanceSampleDggx(Xi, a);\n\t\t\tvec3 L  = 2.0 * dot(V, H) * H - V;\n\n\t\t\tfloat VoH = clamp(dot(V, H), 0.0, 1.0);\n\t\t\tfloat NoL = clamp(L.z, 0.0, 1.0);\n\t\t\tfloat NoH = clamp(H.z, 0.0, 1.0);\n\n\t\t\tif (NoL > 0.0) {\n\t\t\t\tfloat Gv = Visibility(NoV, NoL, a) * NoL * (VoH / NoH);\n\t\t\t\tfloat Fc = pow(1.0 - VoH, 5.0);\n\n\t\t\t\t// modified for multiscattering https://google.github.io/filament/Filament.md.html#toc5.3.4.7\n\t\t\t    r.x += Gv * Fc;\n\t\t\t\tr.y += Gv;\n\t\t\t}\n\t\t}\n\t\tr *= NUM_SAMPLES_FLOAT_INVERSED4;\n\n\t\t{{MODULE_COLOR}}\n\t\toutColor = vec4(r.x, r.y, 0.0, 1.0);\n\t}\n#endif\n","IBLLUT_vert":"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n{{MODULES_HEAD}}\nIN vec3 vPosition;\nOUT vec3 P;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n   vec4 pos     = vec4(vPosition,  1.0);\n   mat4 mMatrix = modelMatrix;\n\n   {{MODULE_VERTEX_POSITION}}\n\n   gl_Position  = pos;\n\n   P            = (vPosition + 1.0) * 0.5;\n}\n","irradiance_frag":"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/hdrFilteringFunctions.fx\n// modified to use different syntax for a number of variables, equirectangular projection and rgbe encoding\n{{MODULES_HEAD}}\n#ifndef WEBGL1\n#define NUM_SAMPLES 2048u\n#else\n#define NUM_SAMPLES 2048\n#endif\n#define PI 3.14159265358\n#define PI_TWO 2.*PI\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n\n\n#ifdef WEBGL1\n    #ifdef GL_EXT_shader_texture_lod\n        #define textureLod texture2DLodEXT\n    #endif\n#endif\n#define SAMPLETEX textureLod\n\n// set by cables\nUNI vec3 camPos;\n\nIN  vec3 FragPos;\nUNI float rotation;\nUNI vec2 filteringInfo;\nUNI sampler2D EquiCubemap;\n\nvec2 SampleSphericalMap(vec3 direction, float rotation)\n{\n    #ifndef WEBGL1\n        vec3 newDirection = normalize(direction);\n\t\tvec2 sampleUV;\n\t\tsampleUV.x = -1. * (atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5);\n\t\tsampleUV.y = asin( clamp(direction.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n    #endif\n\n    #ifdef WEBGL1\n        vec3 newDirection = normalize(direction);\n\t\tvec2 sampleUV = vec2(atan(newDirection.z, newDirection.x), asin(newDirection.y+1e-6));\n        sampleUV *= vec2(-0.1591, 0.3183);\n        sampleUV += 0.5;\n    #endif\n    sampleUV.x += rotation;\n    return sampleUV * vec2(-1.,1.);\n}\n\n// https://community.khronos.org/t/addition-of-two-hdr-rgbe-values/55669\nvec4 EncodeRGBE8(vec3 rgb)\n{\n    vec4 vEncoded;\n    float maxComponent = max(max(rgb.r, rgb.g), rgb.b);\n    float fExp = ceil(log2(maxComponent));\n    vEncoded.rgb = rgb / exp2(fExp);\n    vEncoded.a = (fExp + 128.0) / 255.0;\n    return vEncoded;\n}\n// https://enkimute.github.io/hdrpng.js/\nvec3 DecodeRGBE8(vec4 rgbe)\n{\n    vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n    return vDecoded;\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/importanceSampling.fx\nvec3 hemisphereCosSample(vec2 u) {\n    // pdf = cosTheta / M_PI;\n    float phi = 2. * PI * u.x;\n\n    float cosTheta2 = 1. - u.y;\n    float cosTheta = sqrt(cosTheta2);\n    float sinTheta = sqrt(1. - cosTheta2);\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n#ifndef WEBGL1\n    // https://learnopengl.com/PBR/IBL/Specular-IBL\n    // Hammersley\n    float radicalInverse_VdC(uint bits)\n    {\n        bits = (bits << 16u) | (bits >> 16u);\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n        return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n    }\n\n    vec2 hammersley(uint i, uint N)\n    {\n        return vec2(float(i)/float(N), radicalInverse_VdC(i));\n    }\n#else\n    float vanDerCorpus(int n, int base)\n    {\n        float invBase = 1.0 / float(base);\n        float denom   = 1.0;\n        float result  = 0.0;\n\n        for(int i = 0; i < 32; ++i)\n        {\n            if(n > 0)\n            {\n                denom   = mod(float(n), 2.0);\n                result += denom * invBase;\n                invBase = invBase / 2.0;\n                n       = int(float(n) / 2.0);\n            }\n        }\n\n        return result;\n    }\n\n    vec2 hammersley(int i, int N)\n    {\n        return vec2(float(i)/float(N), vanDerCorpus(i, 2));\n    }\n#endif\n\n// from https://github.com/google/filament/blob/main/shaders/src/light_indirect.fs\nfloat prefilteredImportanceSampling(float ipdf, float omegaP)\n{\n    // See: \"Real-time Shading with Filtered Importance Sampling\", Jaroslav Krivanek\n    // Prefiltering doesn't work with anisotropy\n    const float numSamples = float(NUM_SAMPLES);\n    const float invNumSamples = 1.0 / float(numSamples);\n    const float K = 4.0;\n    float omegaS = invNumSamples * ipdf;\n    float mipLevel = log2(K * omegaS / omegaP) * 0.5;    // log4\n    return mipLevel;\n}\n\nconst float NUM_SAMPLES_FLOAT = float(NUM_SAMPLES);\nconst float NUM_SAMPLES_FLOAT_INVERSED = 1. / NUM_SAMPLES_FLOAT;\n\nconst float K = 4.;\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n\n    vec3 n = normalize(FragPos);\n    vec3 tangent = normalize(cross(vec3(0.0, 0.0, 1.0), n));\n    vec3 bitangent = cross(n, tangent);\n    mat3 tbn = mat3(tangent, bitangent, n);\n\n    float maxLevel = filteringInfo.y;\n    float dim0 = filteringInfo.x;\n    float omegaP = (4. * PI) / (6. * dim0 * dim0);\n\n    #ifndef WEBGL1\n    for(uint i = 0u; i < NUM_SAMPLES; ++i)\n    #else\n    for(int i = 0; i < NUM_SAMPLES; ++i)\n    #endif\n    {\n        vec2 Xi = hammersley(i, NUM_SAMPLES);\n        vec3 Ls = hemisphereCosSample(Xi);\n\n        Ls = normalize(Ls);\n\n        vec3 Ns = vec3(0., 0., 1.);\n\n        float NoL = dot(Ns, Ls);\n\n        if (NoL > 0.) {\n            float pdf_inversed = PI / NoL;\n\n            float omegaS = NUM_SAMPLES_FLOAT_INVERSED * pdf_inversed;\n            // from https://github.com/google/filament/blob/main/shaders/src/light_indirect.fs\n            float l = log2(K * omegaS / omegaP) * 0.5;\n            float mipLevel = clamp(l + 1.0, 0.0, maxLevel);\n\n            #ifndef DONT_USE_RGBE_CUBEMAPS\n            vec3 c = DecodeRGBE8(SAMPLETEX(EquiCubemap, SampleSphericalMap(tbn * Ls, rotation), mipLevel)).rgb;\n            #else\n            vec3 c = SAMPLETEX(EquiCubemap, SampleSphericalMap(tbn * Ls, rotation), mipLevel).rgb;\n            #endif\n            col.rgb += c;\n        }\n    }\n\n    col = EncodeRGBE8(col.rgb * PI * NUM_SAMPLES_FLOAT_INVERSED);\n\n    {{MODULE_COLOR}}\n    outColor = col;\n}\n","irradiance_vert":"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n\n{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN float attrVertIndex;\n\nOUT vec3 FragPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\n\nvoid main()\n{\n    FragPos     = vPosition;\n\n    {{MODULE_VERTEX_POSITION}}\n    gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(vPosition, 1.0);\n    gl_Position = gl_Position.xyww;\n}\n","prefiltering_frag":"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/hdrFilteringFunctions.fx\n// modified to use different syntax for a number of variables, equirectangular projection and rgbe encoding\n{{MODULES_HEAD}}\n#ifndef WEBGL1\n#define NUM_SAMPLES 2048u\n#else\n#define NUM_SAMPLES 2048\n#endif\n#define PI 3.14159265358\n#define PI_TWO 2.*PI\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n#define MINIMUMVARIANCE 0.0005\n\n\n#ifdef WEBGL1\n    #ifdef GL_EXT_shader_texture_lod\n        #define textureLod texture2DLodEXT\n    #endif\n#endif\n#define SAMPLETEX textureLod\n\nIN  vec3 FragPos;\nUNI float roughness;\nUNI float rotation;\nUNI vec2 filteringInfo;\nUNI sampler2D EquiCubemap;\n\nvec2 SampleSphericalMap(vec3 direction, float rotation)\n{\n    #ifndef WEBGL1\n        vec3 newDirection = normalize(direction);\n\t\tvec2 sampleUV;\n\t\tsampleUV.x = -1. * (atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5);\n\t\tsampleUV.y = asin( clamp(direction.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n    #endif\n\n    #ifdef WEBGL1\n        vec3 newDirection = normalize(direction);\n\t\tvec2 sampleUV = vec2(atan(newDirection.z, newDirection.x), asin(newDirection.y+1e-6));\n        sampleUV *= vec2(-0.1591, 0.3183);\n        sampleUV += 0.5;\n    #endif\n    sampleUV.x += rotation;\n    return sampleUV * vec2(-1.,1.);\n}\n\n// https://community.khronos.org/t/addition-of-two-hdr-rgbe-values/55669\nvec4 EncodeRGBE8(vec3 rgb)\n{\n    vec4 vEncoded;\n    float maxComponent = max(max(rgb.r, rgb.g), rgb.b);\n    float fExp = ceil(log2(maxComponent));\n    vEncoded.rgb = rgb / exp2(fExp);\n    vEncoded.a = (fExp + 128.0) / 255.0;\n    return vEncoded;\n}\n// https://enkimute.github.io/hdrpng.js/\nvec3 DecodeRGBE8(vec4 rgbe)\n{\n    vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0-128.0);\n    return vDecoded;\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/importanceSampling.fx\nvec3 hemisphereImportanceSampleDggx(vec2 u, float a) {\n    // pdf = D(a) * cosTheta\n    float phi = 2. * PI * u.x;\n\n    // NOTE: (aa-1) == (a-1)(a+1) produces better fp accuracy\n    float cosTheta2 = (1. - u.y) / (1. + (a + 1.) * ((a - 1.) * u.y));\n    float cosTheta = sqrt(cosTheta2);\n    float sinTheta = sqrt(1. - cosTheta2);\n\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/pbrBRDFFunctions.fx\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH, float alphaG)\n{\n    // Note: alphaG is average slope (gradient) of the normals in slope-space.\n    // It is also the (trigonometric) tangent of the median distribution value, i.e. 50% of normals have\n    // a tangent (gradient) closer to the macrosurface than this slope.\n    float a2 = alphaG * alphaG;\n    float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\n    return a2 / (PI * d * d);\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/pbrHelperFunctions.fx\nfloat convertRoughnessToAverageSlope(float roughness)\n{\n    // Calculate AlphaG as square of roughness (add epsilon to avoid numerical issues)\n    return (roughness * roughness) + MINIMUMVARIANCE;\n}\n\n\n#ifndef WEBGL1\n    // https://learnopengl.com/PBR/IBL/Specular-IBL\n    // Hammersley\n    float radicalInverse_VdC(uint bits)\n    {\n        bits = (bits << 16u) | (bits >> 16u);\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n        return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n    }\n\n    vec2 hammersley(uint i, uint N)\n    {\n        return vec2(float(i)/float(N), radicalInverse_VdC(i));\n    }\n#else\n    float vanDerCorpus(int n, int base)\n    {\n        float invBase = 1.0 / float(base);\n        float denom   = 1.0;\n        float result  = 0.0;\n\n        for(int i = 0; i < 32; ++i)\n        {\n            if(n > 0)\n            {\n                denom   = mod(float(n), 2.0);\n                result += denom * invBase;\n                invBase = invBase / 2.0;\n                n       = int(float(n) / 2.0);\n            }\n        }\n\n        return result;\n    }\n\n    vec2 hammersley(int i, int N)\n    {\n        return vec2(float(i)/float(N), vanDerCorpus(i, 2));\n    }\n#endif\n\nfloat log4(float x)\n{\n    return log2(x) / 2.;\n}\n\nconst float NUM_SAMPLES_FLOAT = float(NUM_SAMPLES);\nconst float NUM_SAMPLES_FLOAT_INVERSED = 1. / NUM_SAMPLES_FLOAT;\n\nconst float K = 4.;\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec3 n = normalize(FragPos);\n    float alphaG = convertRoughnessToAverageSlope(roughness);\n    vec4 result = vec4(0.);\n\n    if (alphaG == 0.)\n    {\n        result = SAMPLETEX(EquiCubemap, SampleSphericalMap(n, rotation), 0.0);\n    }\n    else\n    {\n        vec3 tangent = abs(n.z) < 0.999 ? vec3(0., 0., 1.) : vec3(1., 0., 0.);\n        tangent = normalize(cross(tangent, n));\n        vec3 bitangent = cross(n, tangent);\n        mat3 tbn = mat3(tangent, bitangent, n);\n\n        float maxLevel = filteringInfo.y;\n        float dim0 = filteringInfo.x;\n        float omegaP = (4. * PI) / (6. * dim0 * dim0);\n\n        float weight = 0.;\n        #if defined(WEBGL2)\n        for(uint i = 0u; i < NUM_SAMPLES; ++i)\n        #else\n        for(int i = 0; i < NUM_SAMPLES; ++i)\n        #endif\n        {\n            vec2 Xi = hammersley(i, NUM_SAMPLES);\n            vec3 H = hemisphereImportanceSampleDggx(Xi, alphaG);\n\n            float NoV = 1.;\n            float NoH = H.z;\n            float NoH2 = H.z * H.z;\n            float NoL = 2. * NoH2 - 1.;\n            vec3 L = vec3(2. * NoH * H.x, 2. * NoH * H.y, NoL);\n            L = normalize(L);\n\n            if (NoL > 0.)\n            {\n                float pdf_inversed = 4. / normalDistributionFunction_TrowbridgeReitzGGX(NoH, alphaG);\n\n                float omegaS = NUM_SAMPLES_FLOAT_INVERSED * pdf_inversed;\n                float l = log4(omegaS) - log4(omegaP) + log4(K);\n                float mipLevel = clamp(l, 0.0, maxLevel);\n\n                weight += NoL;\n\n                #ifndef DONT_USE_RGBE_CUBEMAPS\n                vec3 c = DecodeRGBE8(SAMPLETEX(EquiCubemap, SampleSphericalMap(tbn * L, rotation), mipLevel)).rgb;\n                #else\n                vec3 c = SAMPLETEX(EquiCubemap, SampleSphericalMap(tbn * L, rotation), mipLevel).rgb;\n                #endif\n                result.rgb += c * NoL;\n            }\n        }\n\n        result = result / weight;\n        result = EncodeRGBE8(result.rgb);\n    }\n\n    {{MODULE_COLOR}}\n    outColor = result;\n}\n","prefiltering_vert":"precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\n{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN float attrVertIndex;\n\nOUT vec3 FragPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\n\nvoid main()\n{\n    FragPos     = vPosition;\n\n    {{MODULE_VERTEX_POSITION}}\n    gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(vPosition, 1.0);\n    gl_Position = gl_Position.xyww;\n}\n",};
// utility
const cgl = op.patch.cgl;
const IS_WEBGL_1 = cgl.glVersion == 1;

const BB = new CABLES.CG.BoundingBox();
const geometry = new CGL.Geometry("unit cube");
geometry.vertices = new Float32Array([
    -1.0, 1.0, -1.0,
    -1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    1.0, 1.0, -1.0,
    -1.0, 1.0, -1.0,

    -1.0, -1.0, 1.0,
    -1.0, -1.0, -1.0,
    -1.0, 1.0, -1.0,
    -1.0, 1.0, -1.0,
    -1.0, 1.0, 1.0,
    -1.0, -1.0, 1.0,

    1.0, -1.0, -1.0,
    1.0, -1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, -1.0,
    1.0, -1.0, -1.0,

    -1.0, -1.0, 1.0,
    -1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, -1.0, 1.0,
    -1.0, -1.0, 1.0,

    -1.0, 1.0, -1.0,
    1.0, 1.0, -1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    -1.0, 1.0, 1.0,
    -1.0, 1.0, -1.0,

    -1.0, -1.0, -1.0,
    -1.0, -1.0, 1.0,
    1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    -1.0, -1.0, 1.0,
    1.0, -1.0, 1.0
]);
const mesh = new CGL.Mesh(cgl, geometry);
const fullscreenRectangle = CGL.MESHES.getSimpleRect(cgl, "fullscreenRectangle");
// inputs
const inTrigger = op.inTrigger("render");
// const inTriggerRecapture = op.inTriggerButton("recapture");

const inCubemap = op.inTexture("RGBE Environment map");

const inIrradianceSize = op.inDropDown("Size Irradiance map", [16, 32, 64], 64);
const inPrefilteredSize = op.inDropDown("Size pre-filtered environment", [64, 128], 128);
const inIBLLUTSize = op.inDropDown("Size IBL LUT", [128, 256, 512, 1024], 256);
const inToggleRGBE = op.inBool("Environment map does not contain RGBE data", false);
const inRotation = op.inFloat("Rotation", 0.0);
const inUseParallaxCorrection = op.inValueBool("Use parallax correction", false);

const inPCOriginX = op.inFloat("center X", 0);
const inPCOriginY = op.inFloat("center Y", 1.8);
const inPCOriginZ = op.inFloat("center Z", 0);
const inPCboxMinX = op.inFloat("Box min X", -1);
const inPCboxMinY = op.inFloat("Box min Y", -1);
const inPCboxMinZ = op.inFloat("Box min Z", -1);
const inPCboxMaxX = op.inFloat("Box max X", 1);
const inPCboxMaxY = op.inFloat("Box max Y", 1);
const inPCboxMaxZ = op.inFloat("Box max Z", 1);

op.setPortGroup("Parallax Correction", [
    inUseParallaxCorrection,
    inPCOriginX,
    inPCOriginY,
    inPCOriginZ,
    inPCboxMinX,
    inPCboxMinY,
    inPCboxMinZ,
    inPCboxMaxX,
    inPCboxMaxY,
    inPCboxMaxZ
]);

let IrradianceSizeChanged = true;
let PrefilteredSizeChanged = true;
let IBLLUTSizeChanged = true;
inIrradianceSize.onChange = () => { IrradianceSizeChanged = true; };
inPrefilteredSize.onChange = () => { PrefilteredSizeChanged = true; };
inIBLLUTSize.onChange = () => { IBLLUTSizeChanged = true; };

// outputs
const outTrigger = op.outTrigger("next");

const outTexIBLLUT = op.outTexture("IBL LUT");
const outTexIrradiance = op.outTexture("cubemap (diffuse irradiance)");
const outTexPrefiltered = op.outTexture("cubemap (pre-filtered environment map)");
const outMipLevels = op.outNumber("Number of Pre-filtered mip levels");
// UI stuff
op.toWorkPortsNeedToBeLinked(inCubemap);

// globals
let irradianceFrameBuffer = null;
let PrefilteredTexture = null;
let prefilteredFrameBuffer = null;
let iblLutFrameBuffer = null;
let maxMipLevels = null;
const pbrEnv = {};
const IrradianceShader = new CGL.Shader(cgl, "IrradianceShader");
const PrefilteringShader = new CGL.Shader(cgl, "PrefilteringShader");
IrradianceShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
PrefilteringShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);

if (cgl.glVersion == 1)
{
    if (!cgl.gl.getExtension("EXT_shader_texture_lod"))
    {
        op.log("no EXT_shader_texture_lod texture extension");
        throw "no EXT_shader_texture_lod texture extension";
    }
    else
    {
        IrradianceShader.enableExtension("GL_EXT_shader_texture_lod");
        PrefilteringShader.enableExtension("GL_EXT_shader_texture_lod");
        cgl.gl.getExtension("OES_texture_float");
        cgl.gl.getExtension("OES_texture_float_linear");
        cgl.gl.getExtension("OES_texture_half_float");
        cgl.gl.getExtension("OES_texture_half_float_linear");

        cgl.gl.getExtension("WEBGL_color_buffer_float");

        IrradianceShader.enableExtension("GL_OES_standard_derivatives");
        IrradianceShader.enableExtension("GL_OES_texture_float");
        IrradianceShader.enableExtension("GL_OES_texture_float_linear");
        IrradianceShader.enableExtension("GL_OES_texture_half_float");
        IrradianceShader.enableExtension("GL_OES_texture_half_float_linear");
        PrefilteringShader.enableExtension("GL_OES_standard_derivatives");
        PrefilteringShader.enableExtension("GL_OES_texture_float");
        PrefilteringShader.enableExtension("GL_OES_texture_float_linear");
        PrefilteringShader.enableExtension("GL_OES_texture_half_float");
        PrefilteringShader.enableExtension("GL_OES_texture_half_float_linear");
    }
}

let filteringInfo = [0, 0];
IrradianceShader.offScreenPass = true;
const uniformIrradianceCubemap = new CGL.Uniform(IrradianceShader, "t", "EquiCubemap", 0);
const uniformFilteringInfo = new CGL.Uniform(IrradianceShader, "2f", "filteringInfo", filteringInfo);
const uniformRotation = new CGL.Uniform(IrradianceShader, "f", "rotation", 0);
IrradianceShader.setSource(attachments.irradiance_vert, attachments.irradiance_frag);

let prefilteringInfo = [0, 0];
PrefilteringShader.offScreenPass = true;
const uniformPrefilteringCubemap = new CGL.Uniform(PrefilteringShader, "t", "EquiCubemap", 0);
const uniformPrefilteringRoughness = new CGL.Uniform(PrefilteringShader, "f", "roughness", 0);
const uniformPrefilteringRotation = new CGL.Uniform(PrefilteringShader, "f", "rotation", 0);
const uniformPrefilteringInfo = new CGL.Uniform(PrefilteringShader, "2f", "filteringInfo", prefilteringInfo);
PrefilteringShader.setSource(attachments.prefiltering_vert, attachments.prefiltering_frag);

const IBLLUTShader = new CGL.Shader(cgl, "IBLLUTShader");
IBLLUTShader.offScreenPass = true;
IBLLUTShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
IBLLUTShader.setSource(attachments.IBLLUT_vert, attachments.IBLLUT_frag);

inToggleRGBE.onChange = () =>
{
    IrradianceShader.toggleDefine("DONT_USE_RGBE_CUBEMAPS", inToggleRGBE);
    PrefilteringShader.toggleDefine("DONT_USE_RGBE_CUBEMAPS", inToggleRGBE);

    IrradianceSizeChanged = true;
    PrefilteredSizeChanged = true;
};

inRotation.onChange = () =>
{
    PrefilteredSizeChanged =
    IrradianceSizeChanged = true;
};

// utility functions
function captureIrradianceCubemap(size)
{
    if (irradianceFrameBuffer) irradianceFrameBuffer.dispose();

    irradianceFrameBuffer = new CGL.CubemapFramebuffer(cgl, Number(size), Number(size), {
        "isFloatingPointTexture": false,
        "clear": false,
        "filter": CGL.Texture.FILTER_NEAREST, // due to banding with rgbe
        "wrap": CGL.Texture.WRAP_CLAMP_TO_EDGE
    });

    filteringInfo[0] = size;
    filteringInfo[1] = 1.0 + Math.floor(Math.log(size) * 1.44269504088896340736);

    IrradianceShader.popTextures();
    IrradianceShader.pushTexture(uniformIrradianceCubemap, inCubemap.get().tex);
    uniformRotation.setValue(inRotation.get() / 360.0);

    irradianceFrameBuffer.renderStart(cgl);
    for (let i = 0; i < 6; i += 1)
    {
        irradianceFrameBuffer.renderStartCubemapFace(i);

        //  cgl.gl.clearColor(0, 0, 0, 0);
        // if(i==0) cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
        mesh.render(IrradianceShader);
        irradianceFrameBuffer.renderEndCubemapFace();
    }
    irradianceFrameBuffer.renderEnd();

    outTexIrradiance.set(null); // pandur
    outTexIrradiance.set(irradianceFrameBuffer.getTextureColor());
}

function capturePrefilteredCubemap(size)
{
    size = Number(size);
    let captureFBO = new CGL.CubemapFramebuffer(cgl, size, size, {
        // "isFloatingPointTexture": true,
        "clear": false,
        "filter": CGL.Texture.FILTER_LINEAR,
        "wrap": CGL.Texture.WRAP_CLAMP_TO_EDGE
    });

    if (prefilteredFrameBuffer) prefilteredFrameBuffer.dispose();

    prefilteredFrameBuffer = new CGL.CubemapFramebuffer(cgl, size, size, {
        "isFloatingPointTexture": false,
        "clear": false,
        "filter": CGL.Texture.FILTER_MIPMAP,
        "wrap": CGL.Texture.WRAP_CLAMP_TO_EDGE
    });

    cgl.gl.bindTexture(cgl.gl.TEXTURE_CUBE_MAP, prefilteredFrameBuffer.getTextureColor().tex);
    cgl.gl.texParameteri(cgl.gl.TEXTURE_CUBE_MAP, cgl.gl.TEXTURE_WRAP_R, cgl.gl.CLAMP_TO_EDGE);

    cgl.gl.texParameteri(cgl.gl.TEXTURE_CUBE_MAP, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.LINEAR_MIPMAP_LINEAR);
    cgl.gl.texParameteri(cgl.gl.TEXTURE_CUBE_MAP, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.LINEAR);
    cgl.gl.generateMipmap(cgl.gl.TEXTURE_CUBE_MAP); // make sure memory is assigned for mips

    maxMipLevels = 1.0 + Math.floor(Math.log(size) * 1.44269504088896340736);
    outMipLevels.set(maxMipLevels);
    prefilteringInfo[0] = size;
    prefilteringInfo[1] = maxMipLevels;

    PrefilteringShader.popTextures();
    PrefilteringShader.pushTexture(uniformPrefilteringCubemap, inCubemap.get().tex);
    uniformPrefilteringRotation.setValue(inRotation.get() / 360.0);

    for (let mip = 0; mip <= maxMipLevels; ++mip)
    {
        let currentMipSize = size * Math.pow(0.5, mip);
        let roughness = mip / (maxMipLevels - 1);
        uniformPrefilteringRoughness.setValue(roughness);

        captureFBO.setSize(Number(currentMipSize), Number(currentMipSize));
        captureFBO.renderStart(cgl);
        for (let i = 0; i < 6; i += 1)
        {
            captureFBO.renderStartCubemapFace(i);

            // if(i==0)cgl.gl.clearColor(0, 0.1, 0.2, 0);
            // if(i==0)cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);

            mesh.render(PrefilteringShader);
            cgl.gl.bindTexture(cgl.gl.TEXTURE_CUBE_MAP, prefilteredFrameBuffer.getTextureColor().tex);
            cgl.gl.copyTexImage2D(cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, mip, cgl.gl.RGBA, 0, 0, Number(currentMipSize), Number(currentMipSize), null);
            captureFBO.renderEndCubemapFace();
        }
        captureFBO.renderEnd();
    }
    captureFBO.delete();
    cgl.setTexture(0, null);

    outTexPrefiltered.set(null);
    outTexPrefiltered.set(prefilteredFrameBuffer.getTextureColor());
}

function computeIBLLUT(size)
{
    size = Number(size);
    if (iblLutFrameBuffer) iblLutFrameBuffer.dispose();

    if (IS_WEBGL_1)
    {
        iblLutFrameBuffer = new CGL.Framebuffer(cgl, size, size, {
            "isFloatingPointTexture": true,
            "filter": CGL.Texture.FILTER_LINEAR,
            "wrap": CGL.Texture.WRAP_CLAMP_TO_EDGE
        });
    }
    else
    {
        iblLutFrameBuffer = new CGL.Framebuffer2(cgl, size, size, {
            "isFloatingPointTexture": true,
            "filter": CGL.Texture.FILTER_LINEAR,
            "wrap": CGL.Texture.WRAP_CLAMP_TO_EDGE,
        });
    }

    cgl.frameStore.renderOffscreen = true;
    iblLutFrameBuffer.renderStart(cgl);
    fullscreenRectangle.render(IBLLUTShader);
    iblLutFrameBuffer.renderEnd();
    cgl.frameStore.renderOffscreen = false;
    outTexIBLLUT.set(iblLutFrameBuffer.getTextureColor());
}

inCubemap.onChange = () =>
{
    if (inCubemap.get())
        op.setUiError("nocubemapinput", null);

    PrefilteredSizeChanged =
    IrradianceSizeChanged = true;
};

function drawHelpers()
{
    gui.setTransformGizmo({
        "posX": inPCOriginX,
        "posY": inPCOriginY,
        "posZ": inPCOriginZ,
    });
    gui.setTransformGizmo({
        "posX": inPCboxMinX,
        "posY": inPCboxMinY,
        "posZ": inPCboxMinZ,
    }, 1);
    gui.setTransformGizmo({
        "posX": inPCboxMaxX,
        "posY": inPCboxMaxY,
        "posZ": inPCboxMaxZ,
    }, 2);
    if (CABLES.UI.renderHelper)
    {
        cgl.pushShader(CABLES.GL_MARKER.getDefaultShader(cgl));
    }
    else
    {
        cgl.pushShader(CABLES.GL_MARKER.getSelectedShader(cgl));
    }
    cgl.pushModelMatrix();
    // translate
    mat4.translate(cgl.mMatrix, cgl.mMatrix, [(inPCboxMinX.get() + inPCboxMaxX.get()) / 2.0, (inPCboxMinY.get() + inPCboxMaxY.get()) / 2.0, (inPCboxMinZ.get() + inPCboxMaxZ.get()) / 2.0]);
    // scale to bounds
    mat4.scale(cgl.mMatrix, cgl.mMatrix, [(inPCboxMaxX.get() - inPCboxMinX.get()) / 2.0, (inPCboxMaxY.get() - inPCboxMinY.get()) / 2.0, (inPCboxMaxZ.get() - inPCboxMinZ.get()) / 2.0]);
    // draw
    BB.render(cgl);
    cgl.popShader();
    cgl.popModelMatrix();
}

inUseParallaxCorrection.onChange = () =>
{
    const active = inUseParallaxCorrection.get();
    inPCOriginX.setUiAttribs({ "greyout": !active });
    inPCOriginY.setUiAttribs({ "greyout": !active });
    inPCOriginZ.setUiAttribs({ "greyout": !active });
    inPCboxMinX.setUiAttribs({ "greyout": !active });
    inPCboxMinY.setUiAttribs({ "greyout": !active });
    inPCboxMinZ.setUiAttribs({ "greyout": !active });
    inPCboxMaxX.setUiAttribs({ "greyout": !active });
    inPCboxMaxY.setUiAttribs({ "greyout": !active });
    inPCboxMaxZ.setUiAttribs({ "greyout": !active });
};

// onTriggered
inTrigger.onTriggered = function ()
{
    if (!inCubemap.get())
    {
        outTrigger.trigger();
        op.setUiError("nocubemapinput", "No Environment Texture connected");
        return;
    }

    uniformFilteringInfo.setValue(filteringInfo);
    uniformPrefilteringInfo.setValue(prefilteringInfo);

    if (!cgl.frameStore.shadowPass)
    {
        if (IBLLUTSizeChanged)
        {
            computeIBLLUT(Number(inIBLLUTSize.get()));
            IBLLUTSizeChanged = false;
        }

        if (PrefilteredSizeChanged)
        {
            capturePrefilteredCubemap(Number(inPrefilteredSize.get()));
            PrefilteredSizeChanged = false;
        }

        if (IrradianceSizeChanged)
        {
            captureIrradianceCubemap(Number(inIrradianceSize.get()));
            IrradianceSizeChanged = false;
        }
    }

    pbrEnv.texIBLLUT = outTexIBLLUT.get();
    pbrEnv.texDiffIrr = outTexIrradiance.get();
    pbrEnv.texPreFiltered = outTexPrefiltered.get();
    pbrEnv.texPreFilteredMipLevels = outMipLevels.get();

    pbrEnv.UseParallaxCorrection = inUseParallaxCorrection.get();
    pbrEnv.PCOrigin = [inPCOriginX.get(), inPCOriginY.get(), inPCOriginZ.get()];
    pbrEnv.PCboxMin = [inPCboxMinX.get(), inPCboxMinY.get(), inPCboxMinZ.get()];
    pbrEnv.PCboxMax = [inPCboxMaxX.get(), inPCboxMaxY.get(), inPCboxMaxZ.get()];

    cgl.frameStore.pbrEnvStack = cgl.frameStore.pbrEnvStack || [];
    cgl.frameStore.pbrEnvStack.push(pbrEnv);

    if (cgl.shouldDrawHelpers(op) && pbrEnv.UseParallaxCorrection && !cgl.frameStore.shadowPass) drawHelpers();

    outTrigger.trigger();
    cgl.frameStore.pbrEnvStack.pop();
};


};

Ops.Gl.Pbr.PbrEnvironmentLight.prototype = new CABLES.Op();
CABLES.OPS["7110f169-adfd-4649-a77a-c825751eaa9b"]={f:Ops.Gl.Pbr.PbrEnvironmentLight,objName:"Ops.Gl.Pbr.PbrEnvironmentLight"};




// **************************************************************
// 
// Ops.Gl.Pbr.PbrMaterial
// 
// **************************************************************

Ops.Gl.Pbr.PbrMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"BasicPBR_frag":"precision highp float;\nprecision highp int;\n{{MODULES_HEAD}}\n\n// set by cables\nUNI vec3 camPos;\n// utility maps\n#ifdef USE_ENVIRONMENT_LIGHTING\n    UNI sampler2D IBL_BRDF_LUT;\n#endif\n// mesh maps\n#ifdef USE_ALBEDO_TEX\n    UNI sampler2D _AlbedoMap;\n#else\n    UNI vec4 _Albedo;\n#endif\n#ifdef USE_NORMAL_TEX\n    UNI sampler2D _NormalMap;\n#endif\n#ifdef USE_HEIGHT_TEX\n    UNI sampler2D _HeightMap;\n#endif\n#ifdef USE_AORM_TEX\n    UNI sampler2D _AORMMap;\n#else\n    UNI float _Roughness;\n    UNI float _Metalness;\n#endif\n\n#ifdef USE_LIGHTMAP\n    #ifndef VERTEX_COLORS\n        UNI sampler2D _Lightmap;\n    #else\n        #ifndef VCOL_LIGHTMAP\n            UNI sampler2D _Lightmap;\n        #endif\n    #endif\n#endif\n#ifdef USE_CLEAR_COAT\n    UNI float _ClearCoatRoughness;\n#endif\n// IBL inputs\n#ifdef USE_ENVIRONMENT_LIGHTING\n    UNI samplerCube _irradiance;\n    UNI samplerCube _prefilteredEnvironmentColour;\n    UNI float MAX_REFLECTION_LOD;\n    UNI float diffuseIntensity;\n    UNI float specularIntensity;\n#endif\n#ifdef USE_LIGHTMAP\n    UNI float lightmapIntensity;\n#endif\nUNI float tonemappingExposure;\n#ifdef USE_HEIGHT_TEX\n    UNI float _HeightDepth;\n    #ifndef USE_OPTIMIZED_HEIGHT\n        UNI mat4 modelMatrix;\n    #endif\n#endif\n#ifdef USE_PARALLAX_CORRECTION\n    UNI vec3 _PCOrigin;\n    UNI vec3 _PCboxMin;\n    UNI vec3 _PCboxMax;\n#endif\n\nIN vec2 texCoord;\n#ifdef USE_LIGHTMAP\n    #ifndef ATTRIB_texCoord1\n    #ifndef VERTEX_COLORS\n        IN vec2 texCoord1;\n    #else\n        #ifndef VCOL_LIGHTMAP\n            IN vec2 texCoord1;\n        #endif\n    #endif\n    #endif\n#endif\nIN vec4 FragPos;\nIN mat3 TBN;\nIN vec3 norm;\nIN vec3 normM;\n#ifdef VERTEX_COLORS\n    IN vec4 vertCol;\n#endif\n#ifdef USE_HEIGHT_TEX\n    #ifdef USE_OPTIMIZED_HEIGHT\n        IN vec3 fragTangentViewDir;\n    #else\n        IN mat3 invTBN;\n    #endif\n#endif\n\n// structs\nstruct Light {\n    vec3 color;\n    vec3 position;\n    vec3 specular;\n\n    #define INTENSITY x\n    #define ATTENUATION y\n    #define FALLOFF z\n    #define RADIUS w\n    vec4 lightProperties;\n\n    int castLight;\n\n    vec3 conePointAt;\n    #define COSCONEANGLE x\n    #define COSCONEANGLEINNER y\n    #define SPOTEXPONENT z\n    vec3 spotProperties;\n};\n\n\n#ifdef WEBGL1\n    #ifdef GL_EXT_shader_texture_lod\n        #define textureLod textureCubeLodEXT\n    #endif\n#endif\n#define SAMPLETEX textureLod\n\n// https://community.khronos.org/t/addition-of-two-hdr-rgbe-values/55669\nhighp vec4 EncodeRGBE8(highp vec3 rgb)\n{\n    highp vec4 vEncoded;\n    float maxComponent = max(max(rgb.r, rgb.g), rgb.b);\n    float fExp = ceil(log2(maxComponent));\n    vEncoded.rgb = rgb / exp2(fExp);\n    vEncoded.a = (fExp + 128.0) / 255.0;\n    return vEncoded;\n}\n// https://enkimute.github.io/hdrpng.js/\nhighp vec3 DecodeRGBE8(highp vec4 rgbe)\n{\n    highp vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0-128.0);\n    return vDecoded;\n}\n\n// from https://github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/ShadersInclude/pbrIBLFunctions.fx\nfloat environmentRadianceOcclusion(float ambientOcclusion, float NdotVUnclamped) {\n    // Best balanced (implementation time vs result vs perf) analytical environment specular occlusion found.\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float temp = NdotVUnclamped + ambientOcclusion;\n    return clamp(temp * temp - 1.0 + ambientOcclusion, 0.0, 1.0);\n}\nfloat environmentHorizonOcclusion(vec3 view, vec3 normal, vec3 geometricNormal) {\n    // http://marmosetco.tumblr.com/post/81245981087\n    vec3 reflection = reflect(view, normal);\n    float temp = clamp(1.0 + 1.1 * dot(reflection, geometricNormal), 0.0, 1.0);\n    return temp * temp;\n}\n#ifdef ALPHA_DITHERED\n// from https://github.com/google/filament/blob/main/shaders/src/dithering.fs\n// modified to use this to discard based on factor instead of dithering\nfloat interleavedGradientNoise(highp vec2 n) {\n    return fract(52.982919 * fract(dot(vec2(0.06711, 0.00584), n)));\n}\nfloat Dither_InterleavedGradientNoise(float a) {\n    // Jimenez 2014, \"Next Generation Post-Processing in Call of Duty\"\n    highp vec2 uv = gl_FragCoord.xy;\n\n    // The noise variable must be highp to workaround Adreno bug #1096.\n    highp float noise = interleavedGradientNoise(uv);\n\n    return step(noise, a);\n}\n#endif\n\n#ifdef USE_HEIGHT_TEX\n#ifndef WEBGL1\n// based on Jasper Flicks great tutorials (:\nfloat getSurfaceHeight(sampler2D surfaceHeightMap, vec2 UV)\n{\n\treturn texture(surfaceHeightMap, UV).r;\n}\n\nvec2 RaymarchedParallax(vec2 UV, sampler2D surfaceHeightMap, float strength, vec3 viewDir)\n{\n    #ifndef USE_OPTIMIZED_HEIGHT\n\t#define PARALLAX_RAYMARCHING_STEPS 50\n    #else\n    #define PARALLAX_RAYMARCHING_STEPS 20\n    #endif\n\tvec2 uvOffset = vec2(0.0);\n\tfloat stepSize = 1.0 / float(PARALLAX_RAYMARCHING_STEPS);\n\tvec2 uvDelta = vec2(viewDir * (stepSize * strength));\n\tfloat stepHeight = 1.0;\n\tfloat surfaceHeight = getSurfaceHeight(surfaceHeightMap, UV);\n\n\tvec2 prevUVOffset = uvOffset;\n\tfloat prevStepHeight = stepHeight;\n\tfloat prevSurfaceHeight = surfaceHeight;\n\n    // doesnt work with webgl 1.0 as the && condition is not fixed length for loop\n\tfor (int i = 1; i < PARALLAX_RAYMARCHING_STEPS && stepHeight > surfaceHeight; ++i)\n\t{\n\t\tprevUVOffset = uvOffset;\n\t\tprevStepHeight = stepHeight;\n\t\tprevSurfaceHeight = surfaceHeight;\n\n\t\tuvOffset -= uvDelta;\n\t\tstepHeight -= stepSize;\n\t\tsurfaceHeight = getSurfaceHeight(surfaceHeightMap, UV + uvOffset);\n\t}\n\n\tfloat prevDifference = prevStepHeight - prevSurfaceHeight;\n\tfloat difference = surfaceHeight - stepHeight;\n\tfloat t = prevDifference / (prevDifference + difference);\n\tuvOffset = mix(prevUVOffset, uvOffset, t);\n\treturn uvOffset;\n}\n#endif // TODO: use non raymarched parallax mapping here if webgl 1.0?\n#endif\n\n#ifdef USE_PARALLAX_CORRECTION\nvec3 BoxProjection(vec3 direction, vec3 position, vec3 cubemapPosition, vec3 boxMin, vec3 boxMax)\n{\n\tboxMin -= position;\n\tboxMax -= position;\n\tfloat x = (direction.x > 0.0 ? boxMax.x : boxMin.x) / direction.x;\n\tfloat y = (direction.y > 0.0 ? boxMax.y : boxMin.y) / direction.y;\n\tfloat z = (direction.z > 0.0 ? boxMax.z : boxMin.z) / direction.z;\n\tfloat scalar = min(min(x, y), z);\n\n\treturn direction * scalar + (position - cubemapPosition);\n}\n#endif\n\n{{PBR_FRAGMENT_HEAD}}\nvoid main()\n{\n    vec4 col;\n\n    // set up interpolated vertex data\n    vec2 UV0             = texCoord;\n    #ifdef USE_LIGHTMAP\n        #ifndef VERTEX_COLORS\n            vec2 UV1             = texCoord1;\n        #else\n            #ifndef VCOL_LIGHTMAP\n                vec2 UV1             = texCoord1;\n            #endif\n        #endif\n    #endif\n    vec3 V               = normalize(camPos - FragPos.xyz);\n\n    #ifdef USE_HEIGHT_TEX\n        #ifndef USE_OPTIMIZED_HEIGHT\n            vec3 fragTangentViewDir = normalize(invTBN * (camPos - FragPos.xyz));\n        #endif\n        #ifndef WEBGL1\n            UV0 += RaymarchedParallax(UV0, _HeightMap, _HeightDepth * 0.1, fragTangentViewDir);\n        #endif\n    #endif\n\n    // load relevant mesh maps\n    #ifdef USE_ALBEDO_TEX\n        vec4 AlbedoMap   = texture(_AlbedoMap, UV0);\n    #else\n        vec4 AlbedoMap   = _Albedo;\n    #endif\n    #ifdef ALPHA_MASKED\n\tif ( AlbedoMap.a <= 0.5 )\n\t    discard;\n\t#endif\n\n\t#ifdef ALPHA_DITHERED\n\tif ( Dither_InterleavedGradientNoise(AlbedoMap.a) <= 0.5 )\n\t    discard;\n\t#endif\n\n    #ifdef USE_AORM_TEX\n        vec4 AORM        = texture(_AORMMap, UV0);\n    #else\n        vec4 AORM        = vec4(1.0, _Roughness, _Metalness, 1.0);\n    #endif\n    #ifdef USE_NORMAL_TEX\n        vec3 internalNormals = texture(_NormalMap, UV0).rgb;\n        internalNormals      = internalNormals * 2.0 - 1.0;\n        internalNormals      = normalize(TBN * internalNormals);\n    #else\n        vec3 internalNormals = normM;\n    #endif\n\t#ifdef USE_LIGHTMAP\n    \t#ifndef VERTEX_COLORS\n\t        #ifndef LIGHTMAP_IS_RGBE\n                vec3 Lightmap = texture(_Lightmap, UV1).rgb;\n            #else\n                vec3 Lightmap = DecodeRGBE8(texture(_Lightmap, UV1));\n            #endif\n        #else\n            #ifdef VCOL_LIGHTMAP\n                vec3 Lightmap = pow(vertCol.rgb, vec3(2.2));\n            #else\n  \t            #ifndef LIGHTMAP_IS_RGBE\n                    vec3 Lightmap = texture(_Lightmap, UV1).rgb;\n                #else\n                    vec3 Lightmap = DecodeRGBE8(texture(_Lightmap, UV1));\n                #endif\n            #endif\n        #endif\n    #endif\n    // initialize texture values\n    float AO             = AORM.r;\n    float specK          = AORM.g;\n    float metalness      = AORM.b;\n    vec3  N              = normalize(internalNormals);\n    vec3  albedo         = pow(AlbedoMap.rgb, vec3(2.2));\n\n    #ifdef VERTEX_COLORS\n        #ifdef VCOL_COLOUR\n            albedo.rgb *= pow(vertCol.rgb, vec3(2.2));\n            AlbedoMap.rgb *= pow(vertCol.rgb, vec3(2.2));\n        #endif\n        #ifdef VCOL_AORM\n            AO = vertCol.r;\n            specK = vertCol.g;\n            metalness = vertCol.b;\n        #endif\n        #ifdef VCOL_AO\n            AO = vertCol.r;\n        #endif\n        #ifdef VCOL_R\n            specK = vertCol.g;\n        #endif\n        #ifdef VCOL_M\n            metalness = vertCol.b;\n        #endif\n    #endif\n\n    // set up values for later calculations\n    float NdotV          = abs(dot(N, V));\n    vec3  F0             = mix(vec3(0.04), AlbedoMap.rgb, metalness);\n\n    #ifndef WEBGL1\n        #ifndef DONT_USE_GR\n            // from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/ShadersInclude/pbrHelperFunctions.fx\n            // modified to fit variable names\n            #ifndef DONT_USE_NMGR\n                vec3 nDfdx = dFdx(normM.xyz);\n                vec3 nDfdy = dFdy(normM.xyz);\n            #else\n                vec3 nDfdx = dFdx(N.xyz) + dFdx(normM.xyz);\n                vec3 nDfdy = dFdy(N.xyz) + dFdy(normM.xyz);\n            #endif\n            float slopeSquare = max(dot(nDfdx, nDfdx), dot(nDfdy, nDfdy));\n\n            // Vive analytical lights roughness factor.\n            float geometricRoughnessFactor = pow(clamp(slopeSquare, 0.0, 1.0), 0.333);\n\n            specK = max(specK, geometricRoughnessFactor);\n            #endif\n        #endif\n\n    \t// IBL\n    \t// from https://github.com/google/filament/blob/df6a100fcba66d9c99328a49d41fe3adecc0165d/shaders/src/light_indirect.fs\n    \t// and https://github.com/google/filament/blob/df6a100fcba66d9c99328a49d41fe3adecc0165d/shaders/src/shading_lit.fs\n    \t// modified to fit structure/variable names\n    \t#ifdef USE_ENVIRONMENT_LIGHTING\n        \tvec2 envBRDF = texture(IBL_BRDF_LUT, vec2(NdotV, specK)).xy;\n        \tvec3 E = mix(envBRDF.xxx, envBRDF.yyy, F0);\n        #endif\n\n        float specOcclusion    = environmentRadianceOcclusion(AO, NdotV);\n        float horizonOcclusion = environmentHorizonOcclusion(-V, N, normM);\n\n        #ifdef USE_ENVIRONMENT_LIGHTING\n            float envSampleSpecK = specK * MAX_REFLECTION_LOD;\n            vec3  R = reflect(-V, N);\n\n            #ifdef USE_PARALLAX_CORRECTION\n                R = BoxProjection(R, FragPos.xyz, _PCOrigin, _PCboxMin, _PCboxMax);\n            #endif\n\n    \t    vec3 prefilteredEnvColour = DecodeRGBE8(SAMPLETEX(_prefilteredEnvironmentColour, R, envSampleSpecK)) * specularIntensity;\n\n        \tvec3 Fr = E * prefilteredEnvColour;\n        \tFr *= specOcclusion * horizonOcclusion * (1.0 + F0 * (1.0 / envBRDF.y - 1.0));\n        \tFr *= 1.0 + F0; // TODO: this might be wrong, figure this out\n\n        \t#ifdef USE_LIGHTMAP\n                vec3 IBLIrradiance = Lightmap * lightmapIntensity;\n            #else\n                vec3 IBLIrradiance = DecodeRGBE8(SAMPLETEX(_irradiance, N, 0.0)) * diffuseIntensity;\n        #endif\n\t    vec3 Fd = (1.0 - metalness) * albedo * IBLIrradiance * (1.0 - E) * AO;\n    #endif\n    vec3 directLighting = vec3(0.0);\n\n    {{PBR_FRAGMENT_BODY}}\n\n    // combine IBL\n    col.rgb = directLighting;\n    #ifdef USE_ENVIRONMENT_LIGHTING\n        col.rgb += Fr + Fd;\n        #ifdef USE_CLEAR_COAT\n            float CCEnvSampleSpecK = _ClearCoatRoughness * MAX_REFLECTION_LOD;\n            vec3  CCR = reflect(-V, normM);\n\n            #ifdef USE_PARALLAX_CORRECTION\n                CCR = BoxProjection(CCR, FragPos.xyz, _PCOrigin, _PCboxMin, _PCboxMax);\n            #endif\n\n        \tvec3 CCPrefilteredEnvColour = DecodeRGBE8(SAMPLETEX(_prefilteredEnvironmentColour, CCR, CCEnvSampleSpecK));\n        \tvec3 CCFr = E * CCPrefilteredEnvColour;\n        \tCCFr *= specOcclusion * horizonOcclusion * (0.96 + (0.04 / envBRDF.y));\n        \tCCFr *= 1.04;\n        \tcol.rgb += CCFr;\n        #endif\n    #else\n        #ifdef USE_LIGHTMAP\n            col.rgb += (1.0 - metalness) * albedo * Lightmap * lightmapIntensity;\n        #endif\n    #endif\n    col.a   = 1.0;\n\n    #ifdef ALPHA_BLEND\n        col.a = AlbedoMap.a;\n    #endif\n\n    // from https://github.com/BabylonJS/Babylon.js/blob/5e6321d887637877d8b28b417410abbbeb651c6e/src/Shaders/tonemap.fragment.fx\n    // modified to fit variable names\n    #ifdef TONEMAP_HejiDawson\n        col.rgb *= tonemappingExposure;\n\n        vec3 X = max(vec3(0.0, 0.0, 0.0), col.rgb - 0.004);\n        vec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\n\n        col.rgb = retColor * retColor;\n    #elif defined(TONEMAP_Photographic)\n        col.rgb =  vec3(1.0, 1.0, 1.0) - exp2(-tonemappingExposure * col.rgb);\n    #else\n        col.rgb *= tonemappingExposure;\n        //col.rgb = clamp(col.rgb, vec3(0.0), vec3(1.0));\n    #endif\n\n    col.rgb = pow(col.rgb, vec3(1.0/2.2));\n    {{MODULE_COLOR}}\n\n    outColor = col;\n}\n","BasicPBR_vert":"precision highp float;\nprecision highp int;\n\nUNI vec3 camPos;\n\nIN vec3  vPosition;\nIN vec2  attrTexCoord;\n#ifdef USE_LIGHTMAP\n    #ifndef ATTRIB_attrTexCoord1\n        IN vec2 attrTexCoord1;\n        OUT vec2 texCoord1;\n        #define ATTRIB_attrTexCoord1\n        #define ATTRIB_texCoord1\n    #endif\n#endif\nIN vec3  attrVertNormal;\nIN vec3  attrTangent;\nIN vec3  attrBiTangent;\nIN float attrVertIndex;\n#ifdef VERTEX_COLORS\nIN vec4 attrVertColor;\n#endif\n\n{{MODULES_HEAD}}\n\nOUT vec2 texCoord;\n\nOUT vec4 FragPos;\nOUT mat3 TBN;\nOUT vec3 norm;\nOUT vec3 normM;\n#ifdef VERTEX_COLORS\nOUT vec4 vertCol;\n#endif\n#ifdef USE_HEIGHT_TEX\n#ifdef USE_OPTIMIZED_HEIGHT\nOUT vec3 fragTangentViewDir;\n#else\nOUT mat3 invTBN;\n#endif\n#endif\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    mat4 mMatrix = modelMatrix; // needed to make vertex effects work\n    #ifdef USE_LIGHTMAP\n        texCoord1 = attrTexCoord1;\n    #endif\n    texCoord = attrTexCoord;\n    texCoord.y = 1.0 - texCoord.y;\n    vec4 pos = vec4(vPosition,  1.0);\n    norm = attrVertNormal;\n    vec3 tangent = attrTangent;\n    vec3 bitangent = attrBiTangent;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef INSTANCING\n        FragPos = mMatrix * pos;\n    #else\n        FragPos = instMat * pos;\n    #endif\n\n    #ifndef INSTANCING\n        tangent = normalize(vec3(mMatrix * vec4(tangent,    0.0)));\n        vec3 N = normalize(vec3(mMatrix * vec4(norm, 0.0)));\n    #else\n        tangent = normalize(vec3(instMat * vec4(tangent,    0.0)));\n        vec3 N = normalize(vec3(instMat * vec4(norm, 0.0)));\n    #endif\n\n    #ifndef INSTANCING\n        bitangent = normalize(vec3(mMatrix * vec4(bitangent,  0.0)));\n    #else\n        bitangent = normalize(vec3(instMat * vec4(bitangent,  0.0)));\n    #endif\n\n    #ifdef VERTEX_COLORS\n        vertCol = attrVertColor;\n    #endif\n\n    TBN = mat3(tangent, bitangent, N);\n\n    #ifdef USE_HEIGHT_TEX\n    #ifndef WEBGL1\n    #ifdef USE_OPTIMIZED_HEIGHT\n    fragTangentViewDir = normalize(transpose(TBN) * (camPos - FragPos.xyz));\n    #else\n    invTBN = transpose(TBN);\n    #endif\n    #endif\n    #endif\n\n    normM = N;\n    gl_Position = projMatrix * (viewMatrix*mMatrix) * pos;\n}\n","light_body_directional_frag":"\nvec3 L{{LIGHT_INDEX}} = normalize(lightOP{{LIGHT_INDEX}}.position);\n#ifdef USE_ENVIRONMENT_LIGHTING\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, envBRDF.y, AO, false);\n#else\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, AO, false);\n#endif\n","light_body_point_frag":"\nvec3 L{{LIGHT_INDEX}} = normalize(lightOP{{LIGHT_INDEX}}.position - FragPos.xyz);\n#ifdef USE_ENVIRONMENT_LIGHTING\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, envBRDF.y, AO, true);\n#else\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, AO, true);\n#endif\n","light_body_spot_frag":"\nvec3 L{{LIGHT_INDEX}} = normalize(lightOP{{LIGHT_INDEX}}.position - FragPos.xyz);\nfloat spotIntensity{{LIGHT_INDEX}} = CalculateSpotLightEffect(\n    lightOP{{LIGHT_INDEX}}.position, lightOP{{LIGHT_INDEX}}.conePointAt, lightOP{{LIGHT_INDEX}}.spotProperties.COSCONEANGLE,\n    lightOP{{LIGHT_INDEX}}.spotProperties.COSCONEANGLEINNER, lightOP{{LIGHT_INDEX}}.spotProperties.SPOTEXPONENT,\n    L{{LIGHT_INDEX}}\n);\n#ifdef USE_ENVIRONMENT_LIGHTING\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, envBRDF.y, AO * spotIntensity{{LIGHT_INDEX}}, true);\n#else\ndirectLighting += evaluateLighting(lightOP{{LIGHT_INDEX}}, L{{LIGHT_INDEX}}, FragPos, V, N, albedo, specK, NdotV, F0, AO * spotIntensity{{LIGHT_INDEX}}, true);\n#endif\n","light_head_frag":"UNI Light lightOP{{LIGHT_INDEX}};\n","light_includes_frag":"\n#define PI 3.14159265359\n\n// from https://github.com/google/filament/blob/036bfa9b20d730bb8e5852ed449b024570167648/shaders/src/brdf.fs\n// modified to fit variable names / structure\nfloat F_Schlick(float f0, float f90, float VoH)\n{\n    return f0 + (f90 - f0) * pow(1.0 - VoH, 5.0);\n}\nvec3 F_Schlick(const vec3 f0, float VoH)\n{\n    float f = pow(1.0 - VoH, 5.0);\n    return f + f0 * (1.0 - f);\n}\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH)\n{\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\nfloat D_GGX(float roughness, float NoH, const vec3 h)\n{\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n\n    float a = NoH * roughness;\n    float k = roughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return clamp(d, 0.0, 1.0);\n}\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL)\n{\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = roughness * roughness;\n    // TODO: lambdaV can be pre-computed for all the lights, it should be moved out of this function\n    float lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    float v = 0.5 / (lambdaV + lambdaL);\n    // a2=0 => v = 1 / 4*NoL*NoV   => min=1/4, max=+inf\n    // a2=1 => v = 1 / 2*(NoL+NoV) => min=1/4, max=+inf\n    // clamp to the maximum value representable in mediump\n    return clamp(v, 0.0, 1.0);\n}\n// from https://github.com/google/filament/blob/73e339b05d67749e3b1d1d243650441162c10f8a/shaders/src/light_punctual.fs\n// modified to fit variable names\nfloat getSquareFalloffAttenuation(float distanceSquare, float falloff)\n{\n    float factor = distanceSquare * falloff;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    // We would normally divide by the square distance here\n    // but we do it at the call site\n    return smoothFactor * smoothFactor;\n}\n\nfloat getDistanceAttenuation(vec3 posToLight, float falloff, vec3 V, float volume)\n{\n    float distanceSquare = dot(posToLight, posToLight);\n    float attenuation = getSquareFalloffAttenuation(distanceSquare, falloff);\n    // light far attenuation\n    float d = dot(V, V);\n    float f = 100.0; // CONFIG_Z_LIGHT_FAR, ttps://github.com/google/filament/blob/df6a100fcba66d9c99328a49d41fe3adecc0165d/filament/src/details/Engine.h\n    vec2 lightFarAttenuationParams = 0.5 * vec2(10.0, 10.0 / (f * f));\n    attenuation *= clamp(lightFarAttenuationParams.x - d * lightFarAttenuationParams.y, 0.0, 1.0);\n    // Assume a punctual light occupies a min volume of 1cm to avoid a division by 0\n    return attenuation / max(distanceSquare, max(1e-4, volume));\n}\n\n#ifdef USE_CLEAR_COAT\n// from https://github.com/google/filament/blob/73e339b05d67749e3b1d1d243650441162c10f8a/shaders/src/shading_model_standard.fs\n// modified to fit variable names / structure\nfloat clearCoatLobe(vec3 shading_clearCoatNormal, vec3 h, float LoH, float CCSpecK)\n{\n    float clearCoatNoH = clamp(dot(shading_clearCoatNormal, h), 0.0, 1.0);\n\n    // clear coat specular lobe\n    float D = D_GGX(CCSpecK, clearCoatNoH, h);\n    // from https://github.com/google/filament/blob/036bfa9b20d730bb8e5852ed449b024570167648/shaders/src/brdf.fs\n    float V = clamp(0.25 / (LoH * LoH), 0.0, 1.0);\n    float F = F_Schlick(0.04, 1.0, LoH); // fix IOR to 1.5\n\n    return D * V * F;\n}\n#endif\n\n#ifdef USE_ENVIRONMENT_LIGHTING\nvec3 evaluateLighting(Light light, vec3 L, vec4 FragPos, vec3 V, vec3 N, vec3 albedo, float specK, float NdotV, vec3 F0, float envBRDFY, float AO, bool hasFalloff)\n#else\nvec3 evaluateLighting(Light light, vec3 L, vec4 FragPos, vec3 V, vec3 N, vec3 albedo, float specK, float NdotV, vec3 F0, float AO, bool hasFalloff)\n#endif\n{\n    vec3 directLightingResult = vec3(0.0);\n    if (light.castLight == 1)\n    {\n        specK = max(0.08, specK);\n        // from https://github.com/google/filament/blob/73e339b05d67749e3b1d1d243650441162c10f8a/shaders/src/shading_model_standard.fs\n        // modified to fit variable names / structure\n        vec3 H = normalize(V + L);\n\n        float NdotL = clamp(dot(N, L), 0.0, 1.0);\n        float NdotH = clamp(dot(N, H), 0.0, 1.0);\n        float LdotH = clamp(dot(L, H), 0.0, 1.0);\n\n        vec3 Fd = albedo * Fd_Burley(specK, NdotV, NdotL, LdotH);\n\n        float D  = D_GGX(specK, NdotH, H);\n        float V2 = V_SmithGGXCorrelated(specK, NdotV, NdotL);\n        vec3  F  = F_Schlick(F0, LdotH);\n\n        // TODO: modify this with the radius\n        vec3 Fr = (D * V2) * F;\n\n        #ifdef USE_ENVIRONMENT_LIGHTING\n        vec3 directLighting = Fd + Fr * (1.0 + F0 * (1.0 / envBRDFY - 1.0));\n        #else\n        vec3 directLighting = Fd + Fr;\n        #endif\n\n        float attenuation = getDistanceAttenuation(L, hasFalloff ? light.lightProperties.FALLOFF : 0.0, V, light.lightProperties.RADIUS);\n\n        directLightingResult = (directLighting * light.color) *\n                          (light.lightProperties.INTENSITY * attenuation * NdotL * AO);\n\n        #ifdef USE_CLEAR_COAT\n        directLightingResult += clearCoatLobe(normM, H, LdotH, _ClearCoatRoughness);\n        #endif\n    }\n    return directLightingResult;\n}\n\n// from phong OP to make sure the light parameters change lighting similar to what people are used to\nfloat CalculateSpotLightEffect(vec3 lightPosition, vec3 conePointAt, float cosConeAngle, float cosConeAngleInner, float spotExponent, vec3 lightDirection) {\n    vec3 spotLightDirection = normalize(lightPosition-conePointAt);\n    float spotAngle = dot(-lightDirection, spotLightDirection);\n    float epsilon = cosConeAngle - cosConeAngleInner;\n\n    float spotIntensity = clamp((spotAngle - cosConeAngle)/epsilon, 0.0, 1.0);\n    spotIntensity = pow(spotIntensity, max(0.01, spotExponent));\n\n    return max(0., spotIntensity);\n}\n",};
// utility
const cgl = op.patch.cgl;
// inputs
const inTrigger = op.inTrigger("render");

const inDiffuseR = op.inFloat("R", Math.random());
const inDiffuseG = op.inFloat("G", Math.random());
const inDiffuseB = op.inFloat("B", Math.random());
const inDiffuseA = op.inFloatSlider("A", 1);
const diffuseColors = [inDiffuseR, inDiffuseG, inDiffuseB, inDiffuseA];
op.setPortGroup("Diffuse Color", diffuseColors);

const inRoughness = op.inFloatSlider("Roughness", 0.5);
const inMetalness = op.inFloatSlider("Metalness", 0.0);
const inAlphaMode = op.inSwitch("Alpha Mode", ["Opaque", "Masked", "Dithered", "Blend"], "Blend");

const inTonemapping = op.inSwitch("Tonemapping", ["sRGB", "HejiDawson", "Photographic"], "sRGB");
const inTonemappingExposure = op.inFloat("Exposure", 1.0);

const inToggleGR = op.inBool("Disable geometric roughness", false);
const inToggleNMGR = op.inBool("Use roughness from normal map", false);
const inUseVertexColours = op.inValueBool("Use Vertex Colours", false);
const inVertexColourMode = op.inSwitch("Vertex Colour Mode", ["colour", "AORM", "AO", "R", "M", "lightmap"], "colour");
const inHeightDepth = op.inFloat("Height Intensity", 1.0);
const inUseOptimizedHeight = op.inValueBool("Faster heightmapping", false);
const inUseClearCoat = op.inValueBool("Use Clear Coat", false);
const inClearCoatRoughness = op.inFloatSlider("Clear Coat Roughness", 0.5);

// texture inputs
const inTexIBLLUT = op.inTexture("IBL LUT");
const inTexIrradiance = op.inTexture("Diffuse Irradiance");
const inTexPrefiltered = op.inTexture("Pre-filtered envmap");
const inMipLevels = op.inInt("Num mip levels");

const inTexAlbedo = op.inTexture("Albedo");
const inTexAORM = op.inTexture("AORM");
const inTexNormal = op.inTexture("Normal map");
const inTexHeight = op.inTexture("Height");
const inLightmap = op.inTexture("Lightmap");
const inDiffuseIntensity = op.inFloat("Diffuse Intensity", 1.0);
const inSpecularIntensity = op.inFloat("Specular Intensity", 1.0);
const inLightmapRGBE = op.inBool("Lightmap is RGBE", false);
const inLightmapIntensity = op.inFloat("Lightmap Intensity", 1.0);

inTrigger.onTriggered = doRender;

// outputs
const outTrigger = op.outTrigger("Next");
const shaderOut = op.outObject("Shader");
shaderOut.ignoreValueSerialize = true;
// UI stuff
op.toWorkPortsNeedToBeLinked(inTrigger);

inDiffuseR.setUiAttribs({ "colorPick": true });
op.setPortGroup("Shader Parameters", [inRoughness, inMetalness, inAlphaMode]);
op.setPortGroup("Advanced Shader Parameters", [inToggleGR, inToggleNMGR, inUseVertexColours, inVertexColourMode, inHeightDepth, inUseOptimizedHeight, inUseClearCoat, inClearCoatRoughness]);
op.setPortGroup("Textures", [inTexAlbedo, inTexAORM, inTexNormal, inTexHeight, inLightmap]);
op.setPortGroup("Lighting", [inDiffuseIntensity, inSpecularIntensity, inLightmapIntensity, inLightmapRGBE, inTexIBLLUT, inTexIrradiance, inTexPrefiltered, inMipLevels]);
op.setPortGroup("Tonemapping", [inTonemapping, inTonemappingExposure]);
// globals
const PBRShader = new CGL.Shader(cgl, "PBRShader");
PBRShader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
// light sources (except IBL)
let PBRLightStack = [];
const lightUniforms = [];
const LIGHT_INDEX_REGEX = new RegExp("{{LIGHT_INDEX}}", "g");
const FRAGMENT_HEAD_REGEX = new RegExp("{{PBR_FRAGMENT_HEAD}}", "g");
const FRAGMENT_BODY_REGEX = new RegExp("{{PBR_FRAGMENT_BODY}}", "g");
const lightFragmentHead = attachments.light_head_frag;
const lightFragmentBodies = {
    "point": attachments.light_body_point_frag,
    "directional": attachments.light_body_directional_frag,
    "spot": attachments.light_body_spot_frag,
};
const createLightFragmentHead = (n) => { return lightFragmentHead.replace("{{LIGHT_INDEX}}", n); };
const createLightFragmentBody = (n, type) =>
{ return (lightFragmentBodies[type] || "").replace(LIGHT_INDEX_REGEX, n); };
let currentLightCount = -1;
const defaultLightStack = [{
    "type": "point",
    "position": [5, 5, 5],
    "color": [1, 1, 1],
    "specular": [1, 1, 1],
    "intensity": 120,
    "attenuation": 0,
    "falloff": 0.5,
    "radius": 60,
    "castLight": 1,
}];

if (cgl.glVersion == 1)
{
    if (!cgl.gl.getExtension("EXT_shader_texture_lod"))
    {
        op.log("no EXT_shader_texture_lod texture extension");
        throw "no EXT_shader_texture_lod texture extension";
    }
    else
    {
        PBRShader.enableExtension("GL_EXT_shader_texture_lod");
        cgl.gl.getExtension("OES_texture_float");
        cgl.gl.getExtension("OES_texture_float_linear");
        cgl.gl.getExtension("OES_texture_half_float");
        cgl.gl.getExtension("OES_texture_half_float_linear");

        PBRShader.enableExtension("GL_OES_standard_derivatives");
        PBRShader.enableExtension("GL_OES_texture_float");
        PBRShader.enableExtension("GL_OES_texture_float_linear");
        PBRShader.enableExtension("GL_OES_texture_half_float");
        PBRShader.enableExtension("GL_OES_texture_half_float_linear");
    }
}

buildShader();
// uniforms
const inAlbedoUniform = new CGL.Uniform(PBRShader, "t", "_AlbedoMap", 0);
const inAORMUniform = new CGL.Uniform(PBRShader, "t", "_AORMMap", 0);
const inNormalUniform = new CGL.Uniform(PBRShader, "t", "_NormalMap", 0);
const inIBLLUTUniform = new CGL.Uniform(PBRShader, "t", "IBL_BRDF_LUT", 0);
const inIrradianceUniform = new CGL.Uniform(PBRShader, "tc", "_irradiance", 1);
const inPrefilteredUniform = new CGL.Uniform(PBRShader, "tc", "_prefilteredEnvironmentColour", 1);
const inMipLevelsUniform = new CGL.Uniform(PBRShader, "f", "MAX_REFLECTION_LOD", 0);

const inTonemappingExposureUniform = new CGL.Uniform(PBRShader, "f", "tonemappingExposure", inTonemappingExposure);
const inDiffuseIntensityUniform = new CGL.Uniform(PBRShader, "f", "diffuseIntensity", inDiffuseIntensity);
const inSpecularIntensityUniform = new CGL.Uniform(PBRShader, "f", "specularIntensity", inSpecularIntensity);

const inHeightUniform = new CGL.Uniform(PBRShader, "t", "_HeightMap", 0);
const inLightmapUniform = new CGL.Uniform(PBRShader, "t", "_Lightmap", 0);
const inLightmapIntensityUniform = new CGL.Uniform(PBRShader, "f", "lightmapIntensity", inLightmapIntensity);

const inDiffuseColor = new CGL.Uniform(PBRShader, "4f", "_Albedo", inDiffuseR, inDiffuseG, inDiffuseB, inDiffuseA);
const inRoughnessUniform = new CGL.Uniform(PBRShader, "f", "_Roughness", inRoughness);
const inMetalnessUniform = new CGL.Uniform(PBRShader, "f", "_Metalness", inMetalness);
const inHeightDepthUniform = new CGL.Uniform(PBRShader, "f", "_HeightDepth", inHeightDepth);
const inClearCoatRoughnessUniform = new CGL.Uniform(PBRShader, "f", "_ClearCoatRoughness", inClearCoatRoughness);

const inPCOrigin = new CGL.Uniform(PBRShader, "3f", "_PCOrigin", [0, 0, 0]);
const inPCboxMin = new CGL.Uniform(PBRShader, "3f", "_PCboxMin", [-1, -1, -1]);
const inPCboxMax = new CGL.Uniform(PBRShader, "3f", "_PCboxMax", [1, 1, 1]);

PBRShader.uniformColorDiffuse = inDiffuseColor;
PBRShader.uniformPbrMetalness = inMetalnessUniform;
PBRShader.uniformPbrRoughness = inRoughnessUniform;

inTexPrefiltered.onChange = updateIBLTexDefines;

inTexAORM.onChange =
    inLightmapRGBE.onChange =
    inUseClearCoat.onChange =
    inTexAlbedo.onChange =
    inTexNormal.onChange =
    inTexHeight.onChange =
    inAlphaMode.onChange =
    inToggleNMGR.onChange =
    inTonemapping.onChange =
    inLightmap.onChange =
    inUseOptimizedHeight.onChange =
    inUseVertexColours.onChange =
    inToggleGR.onChange =
    inVertexColourMode.onChange = updateDefines;

function updateDefines()
{
    PBRShader.toggleDefine("USE_OPTIMIZED_HEIGHT", inUseOptimizedHeight.get());
    PBRShader.toggleDefine("USE_CLEAR_COAT", inUseClearCoat.get());
    PBRShader.toggleDefine("LIGHTMAP_IS_RGBE", inLightmapRGBE.get());
    PBRShader.toggleDefine("USE_LIGHTMAP", inLightmap.isLinked() || inVertexColourMode.get() === "lightmap");
    PBRShader.toggleDefine("USE_NORMAL_TEX", inTexNormal.isLinked());
    PBRShader.toggleDefine("USE_HEIGHT_TEX", inTexHeight.isLinked());
    PBRShader.toggleDefine("DONT_USE_NMGR", inToggleNMGR.get());
    PBRShader.toggleDefine("DONT_USE_GR", inToggleGR.get());

    // VERTEX_COLORS
    PBRShader.toggleDefine("VCOL_COLOUR", inVertexColourMode.get() === "colour");
    PBRShader.toggleDefine("VCOL_AORM", inVertexColourMode.get() === "AORM");
    PBRShader.toggleDefine("VCOL_AO", inVertexColourMode.get() === "AO");
    PBRShader.toggleDefine("VCOL_R", inVertexColourMode.get() === "R");
    PBRShader.toggleDefine("VCOL_M", inVertexColourMode.get() === "M");
    PBRShader.toggleDefine("VCOL_LIGHTMAP", inVertexColourMode.get() === "lightmap");

    // ALBEDO TEX
    PBRShader.toggleDefine("USE_ALBEDO_TEX", inTexAlbedo.get());
    inDiffuseR.setUiAttribs({ "greyout": inTexAlbedo.isLinked() });
    inDiffuseG.setUiAttribs({ "greyout": inTexAlbedo.isLinked() });
    inDiffuseB.setUiAttribs({ "greyout": inTexAlbedo.isLinked() });
    inDiffuseA.setUiAttribs({ "greyout": inTexAlbedo.isLinked() });

    // AORM
    PBRShader.toggleDefine("USE_AORM_TEX", inTexAORM.get());
    inRoughness.setUiAttribs({ "greyout": inTexAORM.isLinked() });
    inMetalness.setUiAttribs({ "greyout": inTexAORM.isLinked() });

    // lightmaps
    PBRShader.toggleDefine("VERTEX_COLORS", inUseVertexColours.get());

    if (!inUseVertexColours.get())
    {
        PBRShader.toggleDefine("USE_LIGHTMAP", inLightmap.get());
    }
    else
    {
        if (inVertexColourMode.get() === "lightmap")
        {
            PBRShader.define("USE_LIGHTMAP");
        }
    }

    // alpha mode
    PBRShader.toggleDefine("ALPHA_MASKED", inAlphaMode.get() === "Masked");
    PBRShader.toggleDefine("ALPHA_DITHERED", inAlphaMode.get() === "Dithered");
    PBRShader.toggleDefine("ALPHA_BLEND", inAlphaMode.get() === "Blend");

    // tonemapping
    PBRShader.toggleDefine("TONEMAP_sRGB", inTonemapping.get() === "sRGB");
    PBRShader.toggleDefine("TONEMAP_HejiDawson", inTonemapping.get() === "HejiDawson");
    PBRShader.toggleDefine("TONEMAP_Photographic", inTonemapping.get() === "Photographic");
}

updateDefines();

function setEnvironmentLighting(enabled)
{
    PBRShader.toggleDefine("USE_ENVIRONMENT_LIGHTING", enabled);
}

op.preRender = function ()
{
    PBRShader.bind();
    doRender();
};

function updateIBLTexDefines()
{
    inMipLevels.setUiAttribs({ "greyout": !inTexPrefiltered.get() });
}

function updateLightUniforms()
{
    for (let i = 0; i < PBRLightStack.length; i += 1)
    {
        const light = PBRLightStack[i];
        light.isUsed = true;

        lightUniforms[i].position.setValue(light.position);
        lightUniforms[i].color.setValue(light.color);
        lightUniforms[i].specular.setValue(light.specular);

        lightUniforms[i].lightProperties.setValue([
            light.intensity,
            light.attenuation,
            light.falloff,
            light.radius,
        ]);

        lightUniforms[i].conePointAt.setValue(light.conePointAt);
        lightUniforms[i].spotProperties.setValue([
            light.cosConeAngle,
            light.cosConeAngleInner,
            light.spotExponent,
        ]);

        lightUniforms[i].castLight.setValue(light.castLight);
    }
}

function buildShader()
{
    const vertexShader = attachments.BasicPBR_vert;
    const lightIncludes = attachments.light_includes_frag;
    let fragmentShader = attachments.BasicPBR_frag;

    let fragmentHead = "";
    let fragmentBody = "";

    if (PBRLightStack.length > 0)
    {
        fragmentHead = fragmentHead.concat(lightIncludes);
    }

    for (let i = 0; i < PBRLightStack.length; i += 1)
    {
        const light = PBRLightStack[i];
        const type = light.type;

        fragmentHead = fragmentHead.concat(createLightFragmentHead(i) || "");
        fragmentBody = fragmentBody.concat(createLightFragmentBody(i, light.type) || "");
    }

    fragmentShader = fragmentShader.replace(FRAGMENT_HEAD_REGEX, fragmentHead || "");
    fragmentShader = fragmentShader.replace(FRAGMENT_BODY_REGEX, fragmentBody || "");

    PBRShader.setSource(vertexShader, fragmentShader);
    shaderOut.set(PBRShader);

    for (let i = 0; i < PBRLightStack.length; i += 1)
    {
        lightUniforms[i] = null;
        if (!lightUniforms[i])
        {
            lightUniforms[i] = {
                "color": new CGL.Uniform(PBRShader, "3f", "lightOP" + i + ".color", [1, 1, 1]),
                "position": new CGL.Uniform(PBRShader, "3f", "lightOP" + i + ".position", [0, 11, 0]),
                "specular": new CGL.Uniform(PBRShader, "3f", "lightOP" + i + ".specular", [1, 1, 1]),
                "lightProperties": new CGL.Uniform(PBRShader, "4f", "lightOP" + i + ".lightProperties", [1, 1, 1, 1]),

                "conePointAt": new CGL.Uniform(PBRShader, "3f", "lightOP" + i + ".conePointAt", vec3.create()),
                "spotProperties": new CGL.Uniform(PBRShader, "3f", "lightOP" + i + ".spotProperties", [0, 0, 0, 0]),
                "castLight": new CGL.Uniform(PBRShader, "i", "lightOP" + i + ".castLight", 1),

            };
        }
    }
}

function updateLights()
{
    if (cgl.frameStore.lightStack)
    {
        let changed = currentLightCount !== cgl.frameStore.lightStack.length;

        if (!changed)
        {
            for (let i = 0; i < cgl.frameStore.lightStack.length; i++)
            {
                if (PBRLightStack[i] != cgl.frameStore.lightStack[i])
                {
                    changed = true;
                    break;
                }
            }
        }

        if (changed)
        {
            PBRLightStack = cgl.frameStore.lightStack;
            buildShader();

            currentLightCount = cgl.frameStore.lightStack.length;
        }
    }
}

function doRender()
{
    cgl.pushShader(PBRShader);
    let useDefaultLight = false;

    PBRShader.popTextures();

    let numLights = 0;
    if (cgl.frameStore.lightStack)numLights = cgl.frameStore.lightStack.length;

    if ((!cgl.frameStore.pbrEnvStack || cgl.frameStore.pbrEnvStack.length == 0) &&
        !inLightmap.isLinked() && numLights == 0)

    {
        useDefaultLight = true;
        op.setUiError("deflight", "Default light is enabled. Please add lights or PBREnvironmentLights to your patch to make this warning disappear.", 1);
    }
    else op.setUiError("deflight", null);

    if (cgl.frameStore.pbrEnvStack && cgl.frameStore.pbrEnvStack.length > 0 &&
        cgl.frameStore.pbrEnvStack[cgl.frameStore.pbrEnvStack.length - 1].texIBLLUT.tex && cgl.frameStore.pbrEnvStack[cgl.frameStore.pbrEnvStack.length - 1].texDiffIrr.tex && cgl.frameStore.pbrEnvStack[cgl.frameStore.pbrEnvStack.length - 1].texPreFiltered.tex)
    {
        const pbrEnv = cgl.frameStore.pbrEnvStack[cgl.frameStore.pbrEnvStack.length - 1];

        PBRShader.pushTexture(inIBLLUTUniform, pbrEnv.texIBLLUT.tex);
        PBRShader.pushTexture(inIrradianceUniform, pbrEnv.texDiffIrr.tex, cgl.gl.TEXTURE_CUBE_MAP);
        PBRShader.pushTexture(inPrefilteredUniform, pbrEnv.texPreFiltered.tex, cgl.gl.TEXTURE_CUBE_MAP);
        inMipLevelsUniform.setValue(pbrEnv.texPreFilteredMipLevels || 7);

        PBRShader.toggleDefine("USE_PARALLAX_CORRECTION", pbrEnv.UseParallaxCorrection);
        if (pbrEnv.UseParallaxCorrection)
        {
            inPCOrigin.setValue(pbrEnv.PCOrigin);
            inPCboxMin.setValue(pbrEnv.PCboxMin);
            inPCboxMax.setValue(pbrEnv.PCboxMax);
        }

        setEnvironmentLighting(true);
    }
    else
    {
        setEnvironmentLighting(false);
    }

    if (useDefaultLight)
    {
        const iViewMatrix = mat4.create();
        mat4.invert(iViewMatrix, cgl.vMatrix);

        defaultLightStack[0].position = [iViewMatrix[12], iViewMatrix[13], iViewMatrix[14]];
        cgl.frameStore.lightStack = defaultLightStack;
    }

    if (inTexIBLLUT.get())
    {
        setEnvironmentLighting(true);
        PBRShader.pushTexture(inIBLLUTUniform, inTexIBLLUT.get().tex);
        inMipLevelsUniform.setValue(inMipLevels.get());
        if (inTexIrradiance.get()) PBRShader.pushTexture(inIrradianceUniform, inTexIrradiance.get().cubemap, cgl.gl.TEXTURE_CUBE_MAP);
        if (inTexPrefiltered.get()) PBRShader.pushTexture(inPrefilteredUniform, inTexPrefiltered.get().cubemap, cgl.gl.TEXTURE_CUBE_MAP);
    }

    if (inTexAlbedo.get()) PBRShader.pushTexture(inAlbedoUniform, inTexAlbedo.get().tex);
    if (inTexAORM.get()) PBRShader.pushTexture(inAORMUniform, inTexAORM.get().tex);
    if (inTexNormal.get()) PBRShader.pushTexture(inNormalUniform, inTexNormal.get().tex);
    if (inTexHeight.get()) PBRShader.pushTexture(inHeightUniform, inTexHeight.get().tex);
    if (inLightmap.get()) PBRShader.pushTexture(inLightmapUniform, inLightmap.get().tex);

    updateLights();
    updateLightUniforms();

    outTrigger.trigger();
    cgl.popShader();

    if (useDefaultLight) cgl.frameStore.lightStack = [];
}


};

Ops.Gl.Pbr.PbrMaterial.prototype = new CABLES.Op();
CABLES.OPS["a5234947-f65a-41e2-a691-b81382903a71"]={f:Ops.Gl.Pbr.PbrMaterial,objName:"Ops.Gl.Pbr.PbrMaterial"};




// **************************************************************
// 
// Ops.Gl.Performance
// 
// **************************************************************

Ops.Gl.Performance = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    inShow = op.inValueBool("Visible", true),
    next = op.outTrigger("childs"),
    position = op.inSwitch("Position", ["top", "bottom"], "top"),
    openDefault = op.inBool("Open", false),
    smoothGraph = op.inBool("Smooth Graph", true),
    inScaleGraph = op.inFloat("Scale", 4),
    inSizeGraph = op.inFloat("Size", 128),
    outCanv = op.outObject("Canvas"),
    outFPS = op.outNumber("FPS");

const cgl = op.patch.cgl;
const element = document.createElement("div");

let elementMeasures = null;
let ctx = null;
let opened = false;
let frameCount = 0;
let fps = 0;
let fpsStartTime = 0;
let childsTime = 0;
let avgMsChilds = 0;
const queue = [];
const timesMainloop = [];
const timesOnFrame = [];
const timesGPU = [];
let avgMs = 0;
let selfTime = 0;
let canvas = null;
let lastTime = 0;
let loadingCounter = 0;
const loadingChars = ["|", "/", "-", "\\"];
let initMeasures = true;

const colorRAFSlow = "#ffffff";
const colorBg = "#222222";
const colorRAF = "#003f5c"; // color: https://learnui.design/tools/data-color-picker.html
const colorMainloop = "#7a5195";
const colorOnFrame = "#ef5675";
const colorGPU = "#ffa600";

let startedQuery = false;

let currentTimeGPU = 0;
let currentTimeMainloop = 0;
let currentTimeOnFrame = 0;

const gl = op.patch.cgl.gl;
const glQueryExt = gl.getExtension("EXT_disjoint_timer_query_webgl2");
// let query = null;

exe.onLinkChanged =
    inShow.onChange = () =>
    {
        updateOpened();
        updateVisibility();
    };

position.onChange = updatePos;
inSizeGraph.onChange = updateSize;

element.id = "performance";
element.style.position = "absolute";
element.style.left = "0px";
element.style.opacity = "0.8";
element.style.padding = "10px";
element.style.cursor = "pointer";
element.style.background = "#222";
element.style.color = "white";
element.style["font-family"] = "monospace";
element.style["font-size"] = "12px";
element.style["z-index"] = "99999";

element.innerHTML = "&nbsp;";
element.addEventListener("click", toggleOpened);

const container = op.patch.cgl.canvas.parentElement;
container.appendChild(element);

updateSize();
updateOpened();
updatePos();
updateVisibility();

op.onDelete = function ()
{
    if (canvas)canvas.remove();
    if (element)element.remove();
};

function updatePos()
{
    canvas.style["pointer-events"] = "none";
    if (position.get() == "top")
    {
        canvas.style.top = element.style.top = "0px";
        canvas.style.bottom = element.style.bottom = "initial";
    }
    else
    {
        canvas.style.bottom = element.style.bottom = "0px";
        canvas.style.top = element.style.top = "initial";
    }
}

function updateVisibility()
{
    if (!inShow.get() || !exe.isLinked())
    {
        element.style.display = "none";
        element.style.opacity = 0;
        canvas.style.display = "none";
    }
    else
    {
        element.style.display = "block";
        element.style.opacity = 1;
        canvas.style.display = "block";
    }
}

function updateSize()
{
    if (!canvas) return;

    const num = Math.max(0, parseInt(inSizeGraph.get()));

    canvas.width = num;
    canvas.height = num;
    element.style.left = num + "px";

    queue.length = 0;
    timesMainloop.length = 0;
    timesOnFrame.length = 0;
    timesGPU.length = 0;

    for (let i = 0; i < num; i++)
    {
        queue[i] = -1;
        timesMainloop[i] = -1;
        timesOnFrame[i] = -1;
        timesGPU[i] = -1;
    }
}

openDefault.onChange = function ()
{
    opened = openDefault.get();
    updateOpened();
};

function toggleOpened()
{
    if (!inShow.get()) return;
    element.style.opacity = 1;
    opened = !opened;
    updateOpened();
}

function updateOpened()
{
    updateText();
    if (!canvas)createCanvas();
    if (opened)
    {
        canvas.style.display = "block";
        element.style.left = inSizeGraph.get() + "px";
        element.style["min-height"] = "56px";
    }
    else
    {
        canvas.style.display = "none";
        element.style.left = "0px";
        element.style["min-height"] = "auto";
    }
}

function updateCanvas()
{
    const height = canvas.height;
    const hmul = inScaleGraph.get();

    ctx.fillStyle = colorBg;
    ctx.fillRect(0, 0, canvas.width, height);
    ctx.fillStyle = colorRAF;

    let k = 0;
    const numBars = Math.max(0, parseInt(inSizeGraph.get()));

    for (k = numBars; k >= 0; k--)
    {
        if (queue[k] > 30)ctx.fillStyle = colorRAFSlow;
        ctx.fillRect(numBars - k, height - queue[k] * hmul, 1, queue[k] * hmul);
        if (queue[k] > 30)ctx.fillStyle = colorRAF;
    }

    for (k = numBars; k >= 0; k--)
    {
        let sum = 0;
        ctx.fillStyle = colorMainloop;
        sum = timesMainloop[k];
        ctx.fillRect(numBars - k, height - sum * hmul, 1, timesMainloop[k] * hmul);

        ctx.fillStyle = colorOnFrame;
        sum += timesOnFrame[k];
        ctx.fillRect(numBars - k, height - sum * hmul, 1, timesOnFrame[k] * hmul);

        ctx.fillStyle = colorGPU;
        sum += timesGPU[k];
        ctx.fillRect(numBars - k, height - sum * hmul, 1, timesGPU[k] * hmul);
    }
}

function createCanvas()
{
    canvas = document.createElement("canvas");
    canvas.id = "performance_" + op.patch.config.glCanvasId;
    canvas.width = inSizeGraph.get();
    canvas.height = inSizeGraph.get();
    canvas.style.display = "block";
    canvas.style.opacity = 0.9;
    canvas.style.position = "absolute";
    canvas.style.left = "0px";
    canvas.style.cursor = "pointer";
    canvas.style.top = "-64px";
    canvas.style["z-index"] = "99998";
    container.appendChild(canvas);
    ctx = canvas.getContext("2d");

    canvas.addEventListener("click", toggleOpened);

    updateSize();
}

function updateText()
{
    if (!inShow.get()) return;
    let warn = "";

    if (op.patch.cgl.profileData.profileShaderCompiles > 0)warn += "Shader compile (" + op.patch.cgl.profileData.profileShaderCompileName + ") ";
    if (op.patch.cgl.profileData.profileShaderGetUniform > 0)warn += "Shader get uni loc! (" + op.patch.cgl.profileData.profileShaderGetUniformName + ")";
    if (op.patch.cgl.profileData.profileTextureResize > 0)warn += "Texture resize! ";
    if (op.patch.cgl.profileData.profileFrameBuffercreate > 0)warn += "Framebuffer create! ";
    if (op.patch.cgl.profileData.profileEffectBuffercreate > 0)warn += "Effectbuffer create! ";
    if (op.patch.cgl.profileData.profileTextureDelete > 0)warn += "Texture delete! ";
    if (op.patch.cgl.profileData.profileNonTypedAttrib > 0)warn += "Not-Typed Buffer Attrib! " + op.patch.cgl.profileData.profileNonTypedAttribNames;
    if (op.patch.cgl.profileData.profileTextureNew > 0)warn += "new texture created! ";
    if (op.patch.cgl.profileData.profileGenMipMap > 0)warn += "generating mip maps!";

    if (warn.length > 0)
    {
        warn = "| <span style=\"color:#f80;\">WARNING: " + warn + "<span>";
    }

    let html = "";

    if (opened)
    {
        html += "<span style=\"color:" + colorRAF + "\">■</span> " + fps + " fps ";
        html += "<span style=\"color:" + colorMainloop + "\">■</span> " + Math.round(currentTimeMainloop * 100) / 100 + "ms mainloop ";
        html += "<span style=\"color:" + colorOnFrame + "\">■</span> " + Math.round((currentTimeOnFrame) * 100) / 100 + "ms onframe ";
        if (currentTimeGPU) html += "<span style=\"color:" + colorGPU + "\">■</span> " + Math.round(currentTimeGPU * 100) / 100 + "ms GPU";
        html += warn;
        element.innerHTML = html;
    }
    else
    {
        html += fps + " fps / ";
        html += "CPU: " + Math.round((currentTimeMainloop + op.patch.cgl.profileData.profileOnAnimFrameOps) * 100) / 100 + "ms / ";
        if (currentTimeGPU)html += "GPU: " + Math.round(currentTimeGPU * 100) / 100 + "ms  ";
        element.innerHTML = html;
    }

    if (op.patch.loading.getProgress() != 1.0)
    {
        element.innerHTML += "<br/>loading " + Math.round(op.patch.loading.getProgress() * 100) + "% " + loadingChars[(++loadingCounter) % loadingChars.length];
    }

    if (opened)
    {
        let count = 0;
        avgMs = 0;
        avgMsChilds = 0;
        for (let i = queue.length; i > queue.length - queue.length / 3; i--)
        {
            if (queue[i] > -1)
            {
                avgMs += queue[i];
                count++;
            }

            if (timesMainloop[i] > -1) avgMsChilds += timesMainloop[i];
        }

        avgMs /= count;
        avgMsChilds /= count;

        element.innerHTML += "<br/> " + cgl.canvasWidth + " x " + cgl.canvasHeight + " (x" + cgl.pixelDensity + ") ";
        element.innerHTML += "<br/>frame avg: " + Math.round(avgMsChilds * 100) / 100 + " ms (" + Math.round(avgMsChilds / avgMs * 100) + "%) / " + Math.round(avgMs * 100) / 100 + " ms";
        element.innerHTML += " (self: " + Math.round((selfTime) * 100) / 100 + " ms) ";

        element.innerHTML += "<br/>shader binds: " + Math.ceil(op.patch.cgl.profileData.profileShaderBinds / fps) +
            " uniforms: " + Math.ceil(op.patch.cgl.profileData.profileUniformCount / fps) +
            " mvp_uni_mat4: " + Math.ceil(op.patch.cgl.profileData.profileMVPMatrixCount / fps) +
            " num glPrimitives: " + Math.ceil(op.patch.cgl.profileData.profileMeshNumElements / (fps)) +

            " mesh.setGeom: " + op.patch.cgl.profileData.profileMeshSetGeom +
            " videos: " + op.patch.cgl.profileData.profileVideosPlaying +
            " tex preview: " + op.patch.cgl.profileData.profileTexPreviews;

        element.innerHTML +=
        " draw meshes: " + Math.ceil(op.patch.cgl.profileData.profileMeshDraw / fps) +
        " framebuffer blit: " + Math.ceil(op.patch.cgl.profileData.profileFramebuffer / fps) +
        " texeffect blit: " + Math.ceil(op.patch.cgl.profileData.profileTextureEffect / fps);

        element.innerHTML += " all shader compiletime: " + Math.round(op.patch.cgl.profileData.shaderCompileTime * 100) / 100;
    }

    op.patch.cgl.profileData.clear();
}

function styleMeasureEle(ele)
{
    ele.style.padding = "0px";
    ele.style.margin = "0px";
}

function addMeasureChild(m, parentEle, timeSum, level)
{
    const height = 20;
    m.usedAvg = (m.usedAvg || m.used);

    if (!m.ele || initMeasures)
    {
        const newEle = document.createElement("div");
        m.ele = newEle;

        if (m.childs && m.childs.length > 0) newEle.style.height = "500px";
        else newEle.style.height = height + "px";

        newEle.style.overflow = "hidden";
        newEle.style.display = "inline-block";

        if (!m.isRoot)
        {
            newEle.innerHTML = "<div style=\"min-height:" + height + "px;width:100%;overflow:hidden;color:black;position:relative\">&nbsp;" + m.name + "</div>";
            newEle.style["background-color"] = "rgb(" + m.colR + "," + m.colG + "," + m.colB + ")";
            newEle.style["border-left"] = "1px solid black";
        }

        parentEle.appendChild(newEle);
    }

    if (!m.isRoot)
    {
        if (performance.now() - m.lastTime > 200)
        {
            m.ele.style.display = "none";
            m.hidden = true;
        }
        else
        {
            if (m.hidden)
            {
                m.ele.style.display = "inline-block";
                m.hidden = false;
            }
        }

        m.ele.style.float = "left";
        m.ele.style.width = Math.floor((m.usedAvg / timeSum) * 98.0) + "%";
    }
    else
    {
        m.ele.style.width = "100%";
        m.ele.style.clear = "both";
        m.ele.style.float = "none";
    }

    if (m && m.childs && m.childs.length > 0)
    {
        let thisTimeSum = 0;
        for (var i = 0; i < m.childs.length; i++)
        {
            m.childs[i].usedAvg = (m.childs[i].usedAvg || m.childs[i].used) * 0.95 + m.childs[i].used * 0.05;
            thisTimeSum += m.childs[i].usedAvg;
        }
        for (var i = 0; i < m.childs.length; i++)
        {
            addMeasureChild(m.childs[i], m.ele, thisTimeSum, level + 1);
        }
    }
}

function clearMeasures(p)
{
    for (let i = 0; i < p.childs.length; i++) clearMeasures(p.childs[i]);
    p.childs.length = 0;
}

function measures()
{
    if (!CGL.performanceMeasures) return;

    if (!elementMeasures)
    {
        op.log("create measure ele");
        elementMeasures = document.createElement("div");
        elementMeasures.style.width = "100%";
        elementMeasures.style["background-color"] = "#444";
        elementMeasures.style.bottom = "10px";
        elementMeasures.style.height = "100px";
        elementMeasures.style.opacity = "1";
        elementMeasures.style.position = "absolute";
        elementMeasures.style["z-index"] = "99999";
        elementMeasures.innerHTML = "";
        container.appendChild(elementMeasures);
    }

    let timeSum = 0;
    const root = CGL.performanceMeasures[0];

    for (let i = 0; i < root.childs.length; i++) timeSum += root.childs[i].used;

    addMeasureChild(CGL.performanceMeasures[0], elementMeasures, timeSum, 0);

    root.childs.length = 0;

    clearMeasures(CGL.performanceMeasures[0]);

    CGL.performanceMeasures.length = 0;
    initMeasures = false;
}

exe.onTriggered = render;

function render()
{
    const selfTimeStart = performance.now();
    frameCount++;

    if (glQueryExt && inShow.get())op.patch.cgl.profileData.doProfileGlQuery = true;

    if (fpsStartTime === 0)fpsStartTime = Date.now();
    if (Date.now() - fpsStartTime >= 1000)
    {
        // query=null;
        fps = frameCount;
        frameCount = 0;
        // frames = 0;
        outFPS.set(fps);
        if (inShow.get())updateText();

        fpsStartTime = Date.now();
    }

    const glQueryData = op.patch.cgl.profileData.glQueryData;
    currentTimeGPU = 0;
    if (glQueryData)
    {
        let count = 0;
        for (let i in glQueryData)
        {
            count++;
            if (glQueryData[i].time)
                currentTimeGPU += glQueryData[i].time;
        }
    }

    if (inShow.get())
    {
        measures();

        if (opened && !op.patch.cgl.profileData.pause)
        {
            const timeUsed = performance.now() - lastTime;
            queue.push(timeUsed);
            queue.shift();

            timesMainloop.push(childsTime);
            timesMainloop.shift();

            timesOnFrame.push(op.patch.cgl.profileData.profileOnAnimFrameOps - op.patch.cgl.profileData.profileMainloopMs);
            timesOnFrame.shift();

            timesGPU.push(currentTimeGPU);
            timesGPU.shift();

            updateCanvas();
        }
    }

    lastTime = performance.now();
    selfTime = performance.now() - selfTimeStart;
    const startTimeChilds = performance.now();

    outCanv.set(null);
    outCanv.set(canvas);

    // startGlQuery();
    next.trigger();
    // endGlQuery();

    const nChildsTime = performance.now() - startTimeChilds;
    const nCurrentTimeMainloop = op.patch.cgl.profileData.profileMainloopMs;
    const nCurrentTimeOnFrame = op.patch.cgl.profileData.profileOnAnimFrameOps - op.patch.cgl.profileData.profileMainloopMs;

    if (smoothGraph.get())
    {
        childsTime = childsTime * 0.9 + nChildsTime * 0.1;
        currentTimeMainloop = currentTimeMainloop * 0.5 + nCurrentTimeMainloop * 0.5;
        currentTimeOnFrame = currentTimeOnFrame * 0.5 + nCurrentTimeOnFrame * 0.5;
    }
    else
    {
        childsTime = nChildsTime;
        currentTimeMainloop = nCurrentTimeMainloop;
        currentTimeOnFrame = nCurrentTimeOnFrame;
    }

    op.patch.cgl.profileData.clearGlQuery();
}


};

Ops.Gl.Performance.prototype = new CABLES.Op();
CABLES.OPS["9cd2d9de-000f-4a14-bd13-e7d5f057583c"]={f:Ops.Gl.Performance,objName:"Ops.Gl.Performance"};




// **************************************************************
// 
// Ops.Gl.PerformanceMeasure
// 
// **************************************************************

Ops.Gl.PerformanceMeasure = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Execute"),
    inName = op.inString("Name"),
    outNext = op.outTrigger("Childs"),
    outUsed = op.outNumber("Time Used");

inExec.onTriggered = update;

// var Measurement=function(_name)
// {
//     this.name=_name;
//     this.childs=[];
//     this.used=0;
//     this.lastTime=performance.now();
//     this.colR=Math.floor(Math.random()*100)+128;
//     this.colG=Math.floor(Math.random()*100)+128;
//     this.colB=Math.floor(Math.random()*100)+128;
// };

// inExec.onLinkChanged=removeEle;
// outNext.onLinkChanged=removeEle;
// op.onDelete=removeEle;

// function removeEle()
// {
//     theMeasure.used=0;
//     if(theMeasure.ele)
//         theMeasure.ele.remove();

//     theMeasure.ele=null;
// };

// inName.onChange=function()
// {
//     theMeasure.name=inName.get();
//     removeEle();
// };

// var theMeasure=new Measurement("m");

function update()
{
    // if(!CGL.performanceMeasures||CGL.performanceMeasures.length===0)
    // {

    //     CGL.rootMeasure=CGL.rootMeasure||new Measurement("Root");
    //     CGL.rootMeasure.isRoot=true;
    //     CGL.performanceMeasures=[];
    //     CGL.performanceMeasures.push(CGL.rootMeasure);
    //     CGL.currentPerfMeasurement=CGL.performanceMeasures[0];
    // }

    // theMeasure.childs.length=0;
    // var prevMeasure=CGL.currentPerfMeasurement;

    // CGL.currentPerfMeasurement.childs.push(theMeasure);
    // CGL.currentPerfMeasurement=theMeasure;
    const startTime = performance.now();
    outNext.trigger();
    const used = performance.now() - startTime;
    // theMeasure.used=(theMeasure.used*0.8+used*0.2);
    // theMeasure.used=used;
    // theMeasure.lastTime=performance.now();

    // CGL.currentPerfMeasurement=prevMeasure;
    outUsed.set(used);
}


};

Ops.Gl.PerformanceMeasure.prototype = new CABLES.Op();
CABLES.OPS["a2f90e82-a907-4984-a3a1-8e036cf2eee5"]={f:Ops.Gl.PerformanceMeasure,objName:"Ops.Gl.PerformanceMeasure"};




// **************************************************************
// 
// Ops.Gl.Perspective
// 
// **************************************************************

Ops.Gl.Perspective = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    inAxis = op.inSwitch("Axis", ["Vertical", "Horizontal"], "Vertical"),
    fovY = op.inValueFloat("fov y", 45),
    zNear = op.inValueFloat("frustum near", 0.1),
    zFar = op.inValueFloat("frustum far", 20),
    autoAspect = op.inValueBool("Auto Aspect Ratio", true),
    aspect = op.inValue("Aspect Ratio"),
    trigger = op.outTrigger("trigger"),
    outAsp = op.outNumber("Aspect");

fovY.onChange = zFar.onChange = zNear.onChange = changed;
fovY.setUiAttribs({ "title": "FOV Degrees" });

op.setPortGroup("Field of View", [fovY]);
op.setPortGroup("Frustrum", [zNear, zFar]);

let asp = 0;
let axis = 0;

changed();

inAxis.onChange = () =>
{
    axis = 0;
    if (inAxis.get() == "Horizontal")axis = 1;
};

render.onTriggered = function ()
{
    const cg = op.patch.cg;

    asp = cg.getViewPort()[2] / cg.getViewPort()[3];
    if (!autoAspect.get())asp = aspect.get();
    outAsp.set(asp);

    cg.pushPMatrix();

    if (axis == 0)
        mat4.perspective(cg.pMatrix, fovY.get() * 0.0174533, asp, zNear.get(), zFar.get());
    else
        perspectiveFovX(cg.pMatrix, fovY.get() * 0.0174533, asp, zNear.get(), zFar.get());

    trigger.trigger();

    cg.popPMatrix();
};

function changed()
{
    op.patch.cgl.frameStore.perspective =
    {
        "fovy": fovY.get(),
        "zFar": zFar.get(),
        "zNear": zNear.get(),
    };
}

function perspectiveFovX(out, fovx, aspect, near, far)
{
    let nf;
    let f = 1 / (fovx) * 2;
    // Math.tan(1 / fovx * 2),
    // f=Math.max(0,f);

    op.log(f);
    out[0] = f;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f / (1.0 / aspect);
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity)
    {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    }
    else
    {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}


};

Ops.Gl.Perspective.prototype = new CABLES.Op();
CABLES.OPS["7a78e163-d28c-4f70-a6d0-6d952da79f50"]={f:Ops.Gl.Perspective,objName:"Ops.Gl.Perspective"};




// **************************************************************
// 
// Ops.Gl.Phong.AmbientLight_v4
// 
// **************************************************************

Ops.Gl.Phong.AmbientLight_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inTrigger = op.inTrigger("Trigger In");
const inR = op.inValueSlider("R", 0.1);
inR.setUiAttribs({ "colorPick": true });
const inG = op.inValueSlider("G", 0.125);
const inB = op.inValueSlider("B", 0.15);
const inIntensity = op.inValueSlider("Intensity", 1);
const colorIn = [inR, inG, inB];
op.setPortGroup("Color", colorIn);

const outTrigger = op.outTrigger("Trigger Out");
// your new op
// have a look at the documentation at:
// https://docs.cables.gl/dev_hello_op/dev_hello_op.html

function Light(config)
{
    this.type = config.type || "point";
    this.color = config.color || [1, 1, 1];
    this.specular = config.specular || [0, 0, 0];
    this.position = config.position || null;
    this.intensity = config.intensity || 1;
    this.constantAttenuation = config.constantAttenuation || 0;
    this.linearAttenuation = config.linearAttenuation || 0;
    this.quadraticAttenuation = config.quadraticAttenuation || 0;
    this.radius = config.radius || 1;
    this.falloff = config.falloff || 1;
    this.spotExponent = config.spotExponent || 1;
    this.coneAngleInner = config.coneAngleInner || 0; // spot light
    this.coneAngle = config.coneAngle || 0; // spot light
    this.cosConeAngle = Math.cos(CGL.DEG2RAD * this.coneAngle);
    this.conePointAt = config.conePointAt || [0, 0, 0];

    // * shadow
    this.nearFar = [0, 0];
    this.shadowStrength = 0;
    this.shadowBias = 0;

    return this;
}

const cgl = op.patch.cgl;

const light = new Light({
    "type": "ambient",
    "color": [0, 1, 2].map(function (i) { return colorIn[i].get(); }),
    "intensity": inIntensity.get(),
});

const inLight = {
    "color": [inR, inG, inB],
    "intensity": inIntensity,
};

Object.keys(inLight).forEach(function (key)
{
    if (inLight[key].length)
    {
        for (let i = 0; i < inLight[key].length; i += 1)
        {
            inLight[key][i].onChange = function ()
            {
                light[key][i] = inLight[key][i].get();
            };
        }
    }
    else
    {
        inLight[key].onChange = function ()
        {
            light[key] = inLight[key].get();
        };
    }
});

inTrigger.onTriggered = function ()
{
    if (!cgl.frameStore.lightStack) cgl.frameStore.lightStack = [];

    cgl.frameStore.lightStack.push(light);
    outTrigger.trigger();
    cgl.frameStore.lightStack.pop();
};


};

Ops.Gl.Phong.AmbientLight_v4.prototype = new CABLES.Op();
CABLES.OPS["235a18d1-a8de-4034-962d-2848017e27cd"]={f:Ops.Gl.Phong.AmbientLight_v4,objName:"Ops.Gl.Phong.AmbientLight_v4"};




// **************************************************************
// 
// Ops.Gl.Phong.DirectionalLight_v5
// 
// **************************************************************

Ops.Gl.Phong.DirectionalLight_v5 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;

// * OP START *
const inTrigger = op.inTrigger("Trigger In");

const inCastLight = op.inBool("Cast Light", true);
const inIntensity = op.inFloat("Intensity", 1);
const attribIns = [inCastLight, inIntensity];
op.setPortGroup("Light Attributes", attribIns);

const inPosX = op.inFloat("X", 0);
const inPosY = op.inFloat("Y", 3);
const inPosZ = op.inFloat("Z", 5);

const positionIn = [inPosX, inPosY, inPosZ];
op.setPortGroup("Direction", positionIn);

const inR = op.inFloat("R", 1);
const inG = op.inFloat("G", 1);
const inB = op.inFloat("B", 1);

inR.setUiAttribs({ "colorPick": true });
const colorIn = [inR, inG, inB];
op.setPortGroup("Color", colorIn);

const inSpecularR = op.inFloat("Specular R", 0.2);
const inSpecularG = op.inFloat("Specular G", 0.2);
const inSpecularB = op.inFloat("Specular B", 0.2);

inSpecularR.setUiAttribs({ "colorPick": true });
const colorSpecularIn = [inSpecularR, inSpecularG, inSpecularB];
op.setPortGroup("Specular Color", colorSpecularIn);

const inCastShadow = op.inBool("Cast Shadow", false);
const inRenderMapActive = op.inBool("Rendering Active", true);
const inMapSize = op.inSwitch("Map Size", [256, 512, 1024, 2048], 512);
const inShadowStrength = op.inFloatSlider("Shadow Strength", 1);
const inLRBT = op.inFloat("LR-BottomTop", 8);
const inNear = op.inFloat("Near", 0.1);
const inFar = op.inFloat("Far", 30);
const inBias = op.inFloatSlider("Bias", 0.004);
const inPolygonOffset = op.inInt("Polygon Offset", 0);
const inNormalOffset = op.inFloatSlider("Normal Offset", 0);
const inBlur = op.inFloatSlider("Blur Amount", 0);
op.setPortGroup("", [inCastShadow]);
op.setPortGroup("Shadow Map Settings", [inMapSize, inRenderMapActive, inShadowStrength, inLRBT, inNear, inFar, inBias, inPolygonOffset, inNormalOffset, inBlur]);

inMapSize.setUiAttribs({ "greyout": true });
inRenderMapActive.setUiAttribs({ "greyout": true });
inShadowStrength.setUiAttribs({ "greyout": true });
inLRBT.setUiAttribs({ "greyout": true, "hidePort": true });
inNear.setUiAttribs({ "greyout": true, "hidePort": true });
inFar.setUiAttribs({ "greyout": true, "hidePort": true });
inBias.setUiAttribs({ "greyout": true, "hidePort": true });
inNormalOffset.setUiAttribs({ "greyout": true, "hidePort": true });
inPolygonOffset.setUiAttribs({ "greyout": true, "hidePort": true });
inBlur.setUiAttribs({ "greyout": true });

const inAdvanced = op.inBool("Enable Advanced", false);
const inMSAA = op.inSwitch("MSAA", ["none", "2x", "4x", "8x"], "none");
const inFilterType = op.inSwitch("Texture Filter", ["Linear", "Nearest", "Mip Map"], "Linear");
const inAnisotropic = op.inSwitch("Anisotropic", [0, 1, 2, 4, 8, 16], "0");
inMSAA.setUiAttribs({ "greyout": true, "hidePort": true });
inFilterType.setUiAttribs({ "greyout": true, "hidePort": true });
inAnisotropic.setUiAttribs({ "greyout": true, "hidePort": true });
op.setPortGroup("Advanced Options", [inAdvanced, inMSAA, inFilterType, inAnisotropic]);

inAdvanced.onChange = function ()
{
    inMSAA.setUiAttribs({ "greyout": !inAdvanced.get() });
    inFilterType.setUiAttribs({ "greyout": !inAdvanced.get() });
    inAnisotropic.setUiAttribs({ "greyout": !inAdvanced.get() });
};

const outTrigger = op.outTrigger("Trigger Out");
const outTexture = op.outTexture("Shadow Map");

let texelSize = 1 / Number(inMapSize.get());

const newLight = new CGL.Light(cgl, {
    "type": "directional",
    "position": [0, 1, 2].map(function (i) { return positionIn[i].get(); }),
    "color": [0, 1, 2].map(function (i) { return colorIn[i].get(); }),
    "specular": [0, 1, 2].map(function (i) { return colorSpecularIn[i].get(); }),
    "intensity": inIntensity.get(),
    "castShadow": false,
    "shadowStrength": inShadowStrength.get(),
});
newLight.castLight = inCastLight.get();

let updating = false;

function updateBuffers()
{
    updating = true;
    const MSAA = Number(inMSAA.get().charAt(0));

    let filterType = null;
    const anisotropyFactor = Number(inAnisotropic.get());

    if (inFilterType.get() == "Linear")
    {
        filterType = CGL.Texture.FILTER_LINEAR;
    }
    else if (inFilterType.get() == "Nearest")
    {
        filterType = CGL.Texture.FILTER_NEAREST;
    }
    else if (inFilterType.get() == "Mip Map")
    {
        filterType = CGL.Texture.FILTER_MIPMAP;
    }

    const mapSize = Number(inMapSize.get());
    const textureOptions = {
        "isFloatingPointTexture": true,
        "filter": filterType,
    };

    if (MSAA) Object.assign(textureOptions, { "multisampling": true, "multisamplingSamples": MSAA });
    Object.assign(textureOptions, { "anisotropic": anisotropyFactor });

    newLight.createFramebuffer(mapSize, mapSize, textureOptions);
    newLight.createBlurEffect(textureOptions);
    updating = false;
}

function updateShadowMapFramebuffer()
{
    const size = Number(inMapSize.get());
    texelSize = 1 / size;

    if (inCastShadow.get())
    {
        newLight.createFramebuffer(Number(inMapSize.get()), Number(inMapSize.get()), {});
        newLight.createShadowMapShader();
        newLight.createBlurEffect({});
        newLight.createBlurShader();
        newLight.updateProjectionMatrix(inLRBT.get(), inNear.get(), inFar.get(), null);
    }

    if (inAdvanced.get()) updateBuffers();

    updating = false;
    updateLight = true;
}

inMSAA.onChange = inAnisotropic.onChange = inFilterType.onChange = inMapSize.onChange = function ()
{
    updating = true;
};

inR.onChange = inG.onChange = inB.onChange = inSpecularR.onChange = inSpecularG.onChange = inSpecularB.onChange
= inPosX.onChange = inPosY.onChange = inPosZ.onChange
= inBias.onChange = inIntensity.onChange = inCastLight.onChange = inShadowStrength.onChange = inNormalOffset.onChange = updateLightParameters;

let updateLight = false;
function updateLightParameters(param)
{
    updateLight = true;
}

inCastShadow.onChange = function ()
{
    updating = true;
    updateLight = true;

    const castShadow = inCastShadow.get();

    inMapSize.setUiAttribs({ "greyout": !castShadow });
    inRenderMapActive.setUiAttribs({ "greyout": !castShadow });
    inShadowStrength.setUiAttribs({ "greyout": !castShadow });
    inLRBT.setUiAttribs({ "greyout": !castShadow });
    inNear.setUiAttribs({ "greyout": !castShadow });
    inFar.setUiAttribs({ "greyout": !castShadow });
    inBlur.setUiAttribs({ "greyout": !castShadow });
    inBias.setUiAttribs({ "greyout": !castShadow });
    inNormalOffset.setUiAttribs({ "greyout": !castShadow });
    inPolygonOffset.setUiAttribs({ "greyout": !castShadow });
};

inLRBT.onChange = inNear.onChange = inFar.onChange = function ()
{
    updateLight = true;
};

function drawHelpers()
{
    if (cgl.shouldDrawHelpers(op))
    {
        gui.setTransformGizmo({
            "posX": inPosX,
            "posY": inPosY,
            "posZ": inPosZ,
        });
        CABLES.GL_MARKER.drawLineSourceDest(
            op,
            -200 * newLight.position[0],
            -200 * newLight.position[1],
            -200 * newLight.position[2],
            200 * newLight.position[0],
            200 * newLight.position[1],
            200 * newLight.position[2],
        );
    }
}

let errorActive = false;
inTrigger.onTriggered = function ()
{
    if (updating)
    {
        if (cgl.frameStore.shadowPass) return;
        updateShadowMapFramebuffer();
    }

    if (!cgl.frameStore.shadowPass)
    {
        if (!newLight.isUsed && !errorActive)
        {
            op.setUiError("lightUsed", "No operator is using this light. Make sure this op is positioned before an operator that uses lights. Also make sure there is an operator that uses lights after this.", 1); // newLight.isUsed = false;
            errorActive = true;
        }
        else if (!newLight.isUsed && errorActive) {}
        else if (newLight.isUsed && errorActive)
        {
            op.setUiError("lightUsed", null);
            errorActive = false;
        }
        else if (newLight.isUsed && !errorActive) {}
        newLight.isUsed = false;
    }

    if (updateLight)
    {
        newLight.color = [inR.get(), inG.get(), inB.get()];
        newLight.specular = [inSpecularR.get(), inSpecularG.get(), inSpecularB.get()];
        newLight.intensity = inIntensity.get();
        newLight.castLight = inCastLight.get();
        newLight.position = [inPosX.get(), inPosY.get(), inPosZ.get()];
        newLight.updateProjectionMatrix(inLRBT.get(), inNear.get(), inFar.get(), null);
        newLight.castShadow = inCastShadow.get();

        newLight.normalOffset = inNormalOffset.get();
        newLight.shadowBias = inBias.get();
        newLight.shadowStrength = inShadowStrength.get();
        updateLight = false;
    }

    if (!cgl.frameStore.lightStack) cgl.frameStore.lightStack = [];

    if (!cgl.frameStore.shadowPass) drawHelpers();

    cgl.frameStore.lightStack.push(newLight);

    if (inCastShadow.get())
    {
        const blurAmount = 1.5 * inBlur.get() * texelSize;
        if (inRenderMapActive.get()) newLight.renderPasses(inPolygonOffset.get(), blurAmount, function () { outTrigger.trigger(); });
        newLight.blurAmount = inBlur.get();
        outTexture.set(null);
        outTexture.set(newLight.getShadowMapDepth());
        // remove light from stack and readd it with shadow map & mvp matrix
        cgl.frameStore.lightStack.pop();

        cgl.frameStore.lightStack.push(newLight);
    }
    else
    {
        outTexture.set(null);
    }

    outTrigger.trigger();

    cgl.frameStore.lightStack.pop();
};


};

Ops.Gl.Phong.DirectionalLight_v5.prototype = new CABLES.Op();
CABLES.OPS["9f41bf91-f4e0-4ce4-89d8-72627b76261e"]={f:Ops.Gl.Phong.DirectionalLight_v5,objName:"Ops.Gl.Phong.DirectionalLight_v5"};




// **************************************************************
// 
// Ops.Gl.Phong.LambertMaterial_v2
// 
// **************************************************************

Ops.Gl.Phong.LambertMaterial_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"lambert_frag":"{{MODULES_HEAD}}\n\n#define AMBIENT 0\n#define POINT 1\n#define DIRECTIONAL 2\n#define SPOT 3\n\nIN vec3 norm;\nIN vec4 modelPos;\n\n// UNI mat4 normalMatrix;\nIN mat3 normalMatrix; // when instancing...\n\nIN vec2 texCoord;\n\nIN vec3 mvNormal;\nIN vec3 mvTangent;\nIN vec3 mvBiTangent;\n\nUNI vec4 materialColor;//r,g,b,a;\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    // * SPOT LIGHT * //\n    #ifdef HAS_SPOT\n        vec3 conePointAt;\n        #define COSCONEANGLE x\n        #define COSCONEANGLEINNER y\n        #define SPOTEXPONENT z\n        vec3 spotProperties;\n    #endif\n\n    #define INTENSITY x\n    #define ATTENUATION y\n    #define FALLOFF z\n    #define RADIUS w\n    vec4 lightProperties;\n\n    int type;\n    int castLight;\n    #define CASTLIGHT x\n    #define TYPE y\n    ivec2 castLightType;\n};\n#ifdef HAS_TEXTURES\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D texDiffuse;\n    #endif\n#endif\n\nUNI Light lights[NUM_LIGHTS];\n\n// * UTILITY FUNCTIONS */\nfloat when_gt(float x, float y) { return max(sign(x - y), 0.0); } // comparator function\nfloat when_eq(float x, float y) { return 1. - abs(sign(x - y)); } // comparator function\nfloat when_neq(float x, float y) { return abs(sign(x - y)); } // comparator function\n\n\n// * LIGHT CALCULATIONS */\nfloat CalculateFalloff(float radius, float falloff, float distLight)\n{\n    float denom = distLight / radius + 1.0;\n    float attenuation = 1.0 / (denom*denom);\n    float t = (attenuation - 0.1) / (1.0 - 0.1);\n\n    t = t * (20.0 * (1. - falloff) * 20.0 * (1. - falloff));\n\n    return min(1.0,max(t, 0.0));\n}\n\nfloat Falloff2(vec3 lightDirection, float falloff) {\n    float distanceSquared = dot(lightDirection, lightDirection);\n    float factor = distanceSquared * falloff;\n    float smoothFactor = clamp(1. - factor * factor, 0., 1.);\n    float attenuation = smoothFactor * smoothFactor;\n\n    return attenuation * 1. / max(distanceSquared, 0.00001);\n}\n\n#ifdef HAS_SPOT\n    float CalculateSpotLightEffect(vec3 lightPosition, vec3 conePointAt, float cosConeAngle, float cosConeAngleInner, float spotExponent, vec3 lightDirection) {\n        vec3 spotLightDirection = normalize(lightPosition-conePointAt);\n        float spotAngle = dot(-lightDirection, spotLightDirection);\n        float epsilon = cosConeAngle - cosConeAngleInner;\n\n        float spotIntensity = clamp((spotAngle - cosConeAngle)/epsilon, 0.0, 1.0);\n        spotIntensity = pow(spotIntensity, max(0.01, spotExponent));\n\n        return max(0., spotIntensity);\n    }\n#endif\nvec3 CalculateDiffuseColor(vec3 lightDirection, vec3 normal, vec3 lightColor, vec3 materialColor, inout float lambert) {\n    lambert = clamp(dot(lightDirection, normal), 0., 1.);\n    vec3 diffuseColor = lambert * lightColor * materialColor;\n    return diffuseColor;\n}\n\n\n// MAIN\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n\n    vec4 col=vec4(0.0);\n    vec3 normal = normalize(mat3(normalMatrix)*norm);\n\n    #ifdef DOUBLE_SIDED\n        if(!gl_FrontFacing) normal = normal*-1.0;\n    #endif\n\n    vec3 matColor = materialColor.rgb;\n\n    #ifdef HAS_TEXTURES\n        #ifdef HAS_TEXTURE_DIFFUSE\n            matColor = texture(texDiffuse, texCoord).rgb;\n            #ifdef COLORIZE_TEXTURE\n                matColor *= materialColor.rgb;\n            #endif\n        #endif\n    #endif\n\n    for(int l=0;l<NUM_LIGHTS;l++) {\n        if (lights[l].castLightType.TYPE == AMBIENT) {\n            col.rgb += lights[l].lightProperties.INTENSITY * lights[l].color;\n        } else {\n            if (lights[l].castLightType.CASTLIGHT == 0) continue;\n\n            vec3 lightModelDiff= lights[l].position - modelPos.xyz;\n            vec3 lightDirection = normalize(lightModelDiff);\n\n            if (lights[l].castLightType.TYPE == DIRECTIONAL) lightDirection = lights[l].position;\n\n            float lambert = 1.; // inout variable\n            vec3 diffuseColor = CalculateDiffuseColor(lightDirection, normal, lights[l].color, matColor, lambert);\n\n            if (lights[l].castLightType.TYPE != DIRECTIONAL) diffuseColor *= Falloff2(lightDirection, lights[l].lightProperties.FALLOFF);\n\n            #ifdef HAS_SPOT\n                if (lights[l].castLightType.TYPE == SPOT) diffuseColor *= CalculateSpotLightEffect(\n                    lights[l].position, lights[l].conePointAt, lights[l].spotProperties.COSCONEANGLE,\n                    lights[l].spotProperties.COSCONEANGLEINNER, lights[l].spotProperties.SPOTEXPONENT,\n                    lightDirection\n                );\n            #endif\n\n            diffuseColor *= lights[l].lightProperties.INTENSITY;\n            col.rgb += diffuseColor;\n        }\n    }\n\n\n    col.a = materialColor.a;\n\n    {{MODULE_COLOR}}\n\n    // col.rgb=norm.rgb;\n\n    outColor = col;\n}\n","lambert_vert":"#define TEX_REPEAT_X x;\n#define TEX_REPEAT_Y y;\n#define TEX_OFFSET_X z;\n#define TEX_OFFSET_Y w;\n\nIN vec3 vPosition;\nIN vec3 attrVertNormal;\nIN vec2 attrTexCoord;\n\nIN vec3 attrTangent;\nIN vec3 attrBiTangent;\nIN float attrVertIndex;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nOUT vec3 norm;\nOUT mat4 mvMatrix;\nOUT mat3 normalMatrix;\nOUT vec4 modelPos;\nOUT vec2 texCoord;\n{{MODULES_HEAD}}\n\nmat3 transposeMat3(mat3 m)\n{\n    return mat3(m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\nmat3 inverseMat3(mat3 m)\n{\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n        b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n        b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main()\n{\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mMatrix=modelMatrix;\n    vec3 tangent=attrTangent,\n        bitangent=attrBiTangent;\n\n    texCoord=attrTexCoord;\n    texCoord.y = 1. - texCoord.y;\n\n    norm=attrVertNormal;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    normalMatrix = transposeMat3(inverseMat3(mat3(mMatrix)));\n\n\n    // this needs only to be done when instancing....\n\n    mvMatrix=viewMatrix*mMatrix;\n    modelPos=mMatrix*pos;\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
const LIGHT_TYPES = { "ambient": 0, "point": 1, "directional": 2, "spot": 3 };
const execute = op.inTrigger("Execute");
const r = op.inValueSlider("Diffuse R", Math.random());
const g = op.inValueSlider("Diffuse G", Math.random());
const b = op.inValueSlider("Diffuse B", Math.random());
const a = op.inValueSlider("Diffuse A", 1.0);
r.setUiAttribs({ "colorPick": true });
op.setPortGroup("Diffuse Color", [r, g, b, a]);
const inToggleDoubleSided = op.inBool("Double Sided", false);
inToggleDoubleSided.setUiAttribs({ "hidePort": true });
inToggleDoubleSided.onChange = function ()
{
    shader.toggleDefine("DOUBLE_SIDED", inToggleDoubleSided.get());
};
op.setPortGroup("Material Properties", [inToggleDoubleSided]);

const inDiffuseTexture = op.inTexture("Diffuse Texture");
let diffuseTextureUniform = null;
const textureTransformsUniform = null;
inDiffuseTexture.onChange = updateDiffuseTexture;

// TEXTURE TRANSFORMS
const inColorizeTexture = op.inBool("Colorize Texture", false);
inColorizeTexture.onChange = function ()
{
    shader.toggleDefine("COLORIZE_TEXTURE", inColorizeTexture.get());
};

op.setPortGroup("Texture", [
    inDiffuseTexture,
    inColorizeTexture
]);

function updateDiffuseTexture()
{
    if (inDiffuseTexture.get())
    {
        if (!shader.hasDefine("HAS_TEXTURE_DIFFUSE"))
        {
            shader.define("HAS_TEXTURE_DIFFUSE");
            if (!diffuseTextureUniform) diffuseTextureUniform = new CGL.Uniform(shader, "t", "texDiffuse", 0);
        }
    }
    else
    {
        shader.removeUniform("texDiffuse");
        shader.removeDefine("HAS_TEXTURE_DIFFUSE");
        diffuseTextureUniform = null;
    }
}

const next = op.outTrigger("next");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "LambertMaterial");
shader.define("NUM_LIGHTS", "1");

const colUni = new CGL.Uniform(shader, "4f", "materialColor", r, g, b, a);

shader.uniformColorDiffuse = colUni;

const outShader = op.outObject("Shader");
outShader.set(shader);

const MAX_UNIFORM_FRAGMENTS = cgl.maxUniformsFrag;
const MAX_LIGHTS = MAX_UNIFORM_FRAGMENTS === 64 ? 6 : 16;

shader.setSource(attachments.lambert_vert, attachments.lambert_frag);

const DEFAULT_LIGHTSTACK = [{
    "type": "point",
    "position": [0, 2, 1],
    "intensity": 1,
    "attenuation": 0,
    "falloff": 0.5,
    "radius": 80,
    "castLight": 1,
}];

shader.define("MAX_LIGHTS", MAX_LIGHTS.toString());

let defaultUniform = null;

function createDefaultUniform()
{
    defaultUniform = {
        "color": new CGL.Uniform(shader, "3f", "lights[0].color", [1, 1, 1]),
        "position": new CGL.Uniform(shader, "3f", "lights[0].position", [0, 11, 0]),

        // intensity, attenuation, falloff, radius
        "lightProperties": new CGL.Uniform(shader, "4f", "lights[0].lightProperties", [1, 1, 1, 1]),

        "conePointAt": new CGL.Uniform(shader, "3f", "lights[0].conePointAt", vec3.create()),
        "spotProperties": new CGL.Uniform(shader, "3f", "lights[0].spotProperties", [0, 0, 0, 0]),

        "castLightType": new CGL.Uniform(shader, "2i", "lights[0].castLightType", [0, 0])
    };
}

function setDefaultUniform(light)
{
    shader.define("NUM_LIGHTS", "1");
    if (shader.hasDefine("HAS_SPOT"))
    {
        shader.removeDefine("HAS_SPOT");
    }
    if (shader.hasDefine("HAS_DIRECTIONAL"))
    {
        shader.removeDefine("HAS_DIRECTIONAL");
    }
    if (shader.hasDefine("HAS_AMBIENT"))
    {
        shader.removeDefine("HAS_AMBIENT");
    }

    if (!shader.hasDefine("HAS_POINT")) shader.define("HAS_POINT");

    defaultUniform.position.setValue(light.position);
    defaultUniform.color.setValue(light.color);

    defaultUniform.lightProperties.setValue([
        light.intensity,
        light.attenuation,
        light.falloff,
        light.radius,
    ]);

    defaultUniform.castLightType.setValue([
        1,
        LIGHT_TYPES[light.type]
    ]);
    defaultUniform.conePointAt.setValue(light.conePointAt);
    defaultUniform.spotProperties.setValue([
        light.cosConeAngle,
        light.cosConeAngleInner,
        light.spotExponent,
    ]);
}

const lightUniforms = [];
const hasLight = {
    "directional": false,
    "spot": false,
    "ambient": false,
    "point": false,
};

function createUniforms(lightStack)
{
    for (let i = 0; i < lightUniforms.length; i += 1)
    {
        lightUniforms[i] = null;
    }

    hasLight.directional = false;
    hasLight.spot = false;
    hasLight.ambient = false;
    hasLight.point = false;

    for (let i = 0; i < lightStack.length; i += 1)
    {
        if (i === MAX_LIGHTS) return;
        lightUniforms[i] = null;

        const light = lightStack[i];
        const type = light.type;

        if (!hasLight[type]) hasLight[type] = true;

        if (!lightUniforms[i])
        {
            lightUniforms[i] = {
                "color": new CGL.Uniform(shader, "3f", "lights[" + i + "].color", [1, 1, 1]),
                "position": new CGL.Uniform(shader, "3f", "lights[" + i + "].position", [0, 11, 0]),
                // intensity, attenuation, falloff, radius
                "lightProperties": new CGL.Uniform(shader, "4f", "lights[" + i + "].lightProperties", [1, 1, 1, 1]),

                "conePointAt": new CGL.Uniform(shader, "3f", "lights[" + i + "].conePointAt", vec3.create()),
                "spotProperties": new CGL.Uniform(shader, "3f", "lights[" + i + "].spotProperties", [0, 0, 0, 0]),

                "castLightType": new CGL.Uniform(shader, "2i", "lights[" + i + "].castLightType", [0, 0])
            };
        }
    }

    for (let i = 0, keys = Object.keys(hasLight); i < keys.length; i += 1)
    {
        const key = keys[i];

        shader.toggleDefine("HAS_" + key.toUpperCase(), hasLight[key]);
        /* if (hasLight[key])
        {
            if (!shader.hasDefine("HAS_" + key.toUpperCase()))
            {
                shader.define("HAS_" + key.toUpperCase());
            }
        }
        else
        {
            if (shader.hasDefine("HAS_" + key.toUpperCase()))
            {
                shader.removeDefine("HAS_" + key.toUpperCase());
            }
        } */
    }
}

function setUniforms(lightStack)
{
    for (let i = 0; i < lightStack.length; i += 1)
    {
        const light = lightStack[i];
        light.isUsed = true; // this property is used to set UI warnings in the lights

        lightUniforms[i].position.setValue(light.position);
        lightUniforms[i].color.setValue(light.color);

        lightUniforms[i].lightProperties.setValue([
            light.intensity,
            light.attenuation,
            light.falloff,
            light.radius,
        ]);

        lightUniforms[i].conePointAt.setValue(light.conePointAt);
        lightUniforms[i].spotProperties.setValue([
            light.cosConeAngle,
            light.cosConeAngleInner,
            light.spotExponent,
        ]);

        lightUniforms[i].castLightType.setValue([
            Number(light.castLight),
            LIGHT_TYPES[light.type]
        ]);
    }
}

let oldCount = 0;
function compareLights(lightStack)
{
    if (lightStack.length !== oldCount)
    {
        createUniforms(lightStack);
        oldCount = lightStack.length;
        shader.define("NUM_LIGHTS", "" + Math.max(oldCount, 1));
        setUniforms(lightStack);
    }
    else
    {
        setUniforms(lightStack);
    }
}

const iViewMatrix = mat4.create();

function updateLights()
{
    if ((!cgl.frameStore.lightStack || !cgl.frameStore.lightStack.length))
    {
        // if no light in light stack, use default light & set count to -1
        // so when a new light gets added, the shader does recompile
        if (!defaultUniform) createDefaultUniform();

        mat4.invert(iViewMatrix, cgl.vMatrix);
        // set default light position to camera position
        DEFAULT_LIGHTSTACK[0].position = [iViewMatrix[12], iViewMatrix[13], iViewMatrix[14]];

        setDefaultUniform(DEFAULT_LIGHTSTACK[0]);
        oldCount = -1;
    }
    else
    {
        if (shader)
        {
            if (cgl.frameStore.lightStack)
            {
                if (cgl.frameStore.lightStack.length)
                {
                    defaultUniform = null;
                    compareLights(cgl.frameStore.lightStack);
                }
            }
        }
    }
}

execute.onTriggered = function ()
{
    if (!shader)
    {
        op.log("lambert has no shader...");
        return;
    }
    if (cgl.frameStore.lightStack)
    {
        if (cgl.frameStore.lightStack.length === 0) op.setUiError("deflight", "Default light is enabled. Please add lights to your patch to make this warning disappear.", 1);
        else op.setUiError("deflight", null);
    }
    cgl.pushShader(shader);
    shader.popTextures();
    updateLights();
    if (inDiffuseTexture.get()) shader.pushTexture(diffuseTextureUniform, inDiffuseTexture.get().tex);

    next.trigger();
    cgl.popShader();
};

updateDiffuseTexture();


};

Ops.Gl.Phong.LambertMaterial_v2.prototype = new CABLES.Op();
CABLES.OPS["d69316f1-bde9-4645-8280-c635a8982e0d"]={f:Ops.Gl.Phong.LambertMaterial_v2,objName:"Ops.Gl.Phong.LambertMaterial_v2"};




// **************************************************************
// 
// Ops.Gl.Phong.PhongMaterial_v6
// 
// **************************************************************

Ops.Gl.Phong.PhongMaterial_v6 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"phong_frag":"IN vec3 viewDirection;\nIN vec3 normInterpolated;\nIN vec2 texCoord;\n\n#ifdef ENABLE_FRESNEL\n    IN vec4 cameraSpace_pos;\n#endif\n\n// IN mat3 normalMatrix; // when instancing...\n\n#ifdef HAS_TEXTURE_NORMAL\n    IN mat3 TBN_Matrix; // tangent bitangent normal space transform matrix\n#endif\n\nIN vec3 fragPos;\nIN vec3 v_viewDirection;\n\nUNI vec4 inDiffuseColor;\nUNI vec4 inMaterialProperties;\n\n#ifdef ADD_EMISSIVE_COLOR\n    UNI vec4 inEmissiveColor; // .w = intensity\n#endif\n\n#ifdef ENABLE_FRESNEL\n    UNI mat4 viewMatrix;\n    UNI vec4 inFresnel;\n    UNI vec2 inFresnelWidthExponent;\n#endif\n\n#ifdef ENVMAP_MATCAP\n    IN vec3 viewSpaceNormal;\n    IN vec3 viewSpacePosition;\n#endif\n\nstruct Light {\n    vec3 color;\n    vec3 position;\n    vec3 specular;\n\n\n    // * SPOT LIGHT * //\n    #ifdef HAS_SPOT\n        vec3 conePointAt;\n        #define COSCONEANGLE x\n        #define COSCONEANGLEINNER y\n        #define SPOTEXPONENT z\n        vec3 spotProperties;\n    #endif\n\n    #define INTENSITY x\n    #define ATTENUATION y\n    #define FALLOFF z\n    #define RADIUS w\n    vec4 lightProperties;\n\n    int castLight;\n};\n\n/* CONSTANTS */\n#define NONE -1\n#define ALBEDO x\n#define ROUGHNESS y\n#define SHININESS z\n#define SPECULAR_AMT w\n#define NORMAL x\n#define AO y\n#define SPECULAR z\n#define EMISSIVE w\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = (2. * PI);\nconst float EIGHT_PI = (8. * PI);\n\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n\n// TEXTURES\n// #ifdef HAS_TEXTURES\n    UNI vec4 inTextureIntensities;\n\n    #ifdef HAS_TEXTURE_ENV\n        #ifdef TEX_FORMAT_CUBEMAP\n            UNI samplerCube texEnv;\n            #ifndef WEBGL1\n                #define SAMPLETEX textureLod\n            #endif\n            #ifdef WEBGL1\n                #define SAMPLETEX textureCubeLodEXT\n            #endif\n        #endif\n\n        #ifdef TEX_FORMAT_EQUIRECT\n            UNI sampler2D texEnv;\n            #ifdef WEBGL1\n                // #extension GL_EXT_shader_texture_lod : enable\n                #ifdef GL_EXT_shader_texture_lod\n                    #define textureLod texture2DLodEXT\n                #endif\n                // #define textureLod texture2D\n            #endif\n\n            #define SAMPLETEX sampleEquirect\n\n            const vec2 invAtan = vec2(0.1591, 0.3183);\n            vec4 sampleEquirect(sampler2D tex,vec3 direction,float lod)\n            {\n                #ifndef WEBGL1\n                    vec3 newDirection = normalize(direction);\n            \t\tvec2 sampleUV;\n            \t\tsampleUV.x = -1. * (atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.75);\n            \t\tsampleUV.y = asin( clamp(direction.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n                #endif\n\n                #ifdef WEBGL1\n                    vec3 newDirection = normalize(direction);\n                \t\tvec2 sampleUV = vec2(atan(newDirection.z, newDirection.x), asin(newDirection.y+1e-6));\n                        sampleUV *= vec2(0.1591, 0.3183);\n                        sampleUV += 0.5;\n                #endif\n                return textureLod(tex, sampleUV, lod);\n            }\n        #endif\n        #ifdef ENVMAP_MATCAP\n            UNI sampler2D texEnv;\n            #ifdef WEBGL1\n                // #extension GL_EXT_shader_texture_lod : enable\n                #ifdef GL_EXT_shader_texture_lod\n                    #define textureLod texture2DLodEXT\n                #endif\n                // #define textureLod texture2D\n            #endif\n\n\n            // * taken & modified from https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshmatcap_frag.glsl.js\n            vec2 getMatCapUV(vec3 viewSpacePosition, vec3 viewSpaceNormal) {\n                vec3 viewDir = normalize(-viewSpacePosition);\n            \tvec3 x = normalize(vec3(viewDir.z, 0.0, - viewDir.x));\n            \tvec3 y = normalize(cross(viewDir, x));\n            \tvec2 uv = vec2(dot(x, viewSpaceNormal), dot(y, viewSpaceNormal)) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n            \treturn uv;\n            }\n        #endif\n\n        UNI float inEnvMapIntensity;\n        UNI float inEnvMapWidth;\n    #endif\n\n    #ifdef HAS_TEXTURE_LUMINANCE_MASK\n        UNI sampler2D texLuminance;\n        UNI float inLuminanceMaskIntensity;\n    #endif\n\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D texDiffuse;\n    #endif\n\n    #ifdef HAS_TEXTURE_SPECULAR\n        UNI sampler2D texSpecular;\n    #endif\n\n    #ifdef HAS_TEXTURE_NORMAL\n        UNI sampler2D texNormal;\n    #endif\n\n    #ifdef HAS_TEXTURE_AO\n        UNI sampler2D texAO;\n    #endif\n\n    #ifdef HAS_TEXTURE_EMISSIVE\n        UNI sampler2D texEmissive;\n    #endif\n\n    #ifdef HAS_TEXTURE_EMISSIVE_MASK\n        UNI sampler2D texMaskEmissive;\n        UNI float inEmissiveMaskIntensity;\n    #endif\n    #ifdef HAS_TEXTURE_ALPHA\n        UNI sampler2D texAlpha;\n    #endif\n// #endif\n\n{{MODULES_HEAD}}\n\nfloat when_gt(float x, float y) { return max(sign(x - y), 0.0); } // comparator function\nfloat when_lt(float x, float y) { return max(sign(y - x), 0.0); }\nfloat when_eq(float x, float y) { return 1. - abs(sign(x - y)); } // comparator function\nfloat when_neq(float x, float y) { return abs(sign(x - y)); } // comparator function\nfloat when_ge(float x, float y) { return 1.0 - when_lt(x, y); }\nfloat when_le(float x, float y) { return 1.0 - when_gt(x, y); }\n\n#ifdef FALLOFF_MODE_A\n    float CalculateFalloff(float distance, vec3 lightDirection, float falloff, float radius) {\n        // * original falloff\n        float denom = distance / radius + 1.0;\n        float attenuation = 1.0 / (denom*denom);\n        float t = (attenuation - falloff) / (1.0 - falloff);\n        return max(t, 0.0);\n    }\n#endif\n\n#ifdef FALLOFF_MODE_B\n    float CalculateFalloff(float distance, vec3 lightDirection, float falloff, float radius) {\n        float distanceSquared = dot(lightDirection, lightDirection);\n        float factor = distanceSquared * falloff;\n        float smoothFactor = clamp(1. - factor * factor, 0., 1.);\n        float attenuation = smoothFactor * smoothFactor;\n\n        return attenuation * 1. / max(distanceSquared, 0.00001);\n    }\n#endif\n\n#ifdef FALLOFF_MODE_C\n    float CalculateFalloff(float distance, vec3 lightDirection, float falloff, float radius) {\n        // https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n        float falloffNumerator = 1. - pow(distance/radius, 4.);\n        falloffNumerator = clamp(falloffNumerator, 0., 1.);\n        falloffNumerator *= falloffNumerator;\n\n        float denominator = distance*distance + falloff;\n\n        return falloffNumerator/denominator;\n    }\n#endif\n\n#ifdef FALLOFF_MODE_D\n    float CalculateFalloff(float distance, vec3 lightDirection, float falloff, float radius) {\n        // inverse square falloff, \"physically correct\"\n        return 1.0 / max(distance * distance, 0.0001);\n    }\n#endif\n\n#ifdef ENABLE_FRESNEL\n    float CalculateFresnel(vec3 direction, vec3 normal)\n    {\n        vec3 nDirection = normalize( direction );\n        vec3 nNormal = normalize( mat3(viewMatrix) * normal );\n        vec3 halfDirection = normalize( nNormal + nDirection );\n\n        float cosine = dot( halfDirection, nDirection );\n        float product = max( cosine, 0.0 );\n        float factor = pow(product, inFresnelWidthExponent.y);\n\n        return 5. * factor;\n    }\n#endif\n\n#ifdef CONSERVE_ENERGY\n    // http://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/\n    // http://www.farbrausch.de/~fg/articles/phong.pdf\n    float EnergyConservation(float shininess) {\n        #ifdef SPECULAR_PHONG\n            return (shininess + 2.)/TWO_PI;\n        #endif\n        #ifdef SPECULAR_BLINN\n            return (shininess + 8.)/EIGHT_PI;\n        #endif\n\n        #ifdef SPECULAR_SCHLICK\n            return (shininess + 8.)/EIGHT_PI;\n        #endif\n\n        #ifdef SPECULAR_GAUSS\n            return (shininess + 8.)/EIGHT_PI;\n        #endif\n    }\n#endif\n\n#ifdef ENABLE_OREN_NAYAR_DIFFUSE\n    float CalculateOrenNayar(vec3 lightDirection, vec3 viewDirection, vec3 normal) {\n        float LdotV = dot(lightDirection, viewDirection);\n        float NdotL = dot(lightDirection, normal);\n        float NdotV = dot(normal, viewDirection);\n\n        float albedo = inMaterialProperties.ALBEDO;\n        albedo *= 1.8;\n        float s = LdotV - NdotL * NdotV;\n        float t = mix(1., max(NdotL, NdotV), step(0., s));\n\n        float roughness = inMaterialProperties.ROUGHNESS;\n        float sigma2 = roughness * roughness;\n        float A = 1. + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n        float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n        float factor = albedo * max(0., NdotL) * (A + B * s / t) / PI;\n\n        return factor;\n\n    }\n#endif\n\nvec3 CalculateDiffuseColor(\n    vec3 lightDirection,\n    vec3 viewDirection,\n    vec3 normal,\n    vec3 lightColor,\n    vec3 materialColor,\n    inout float lambert\n) {\n    #ifndef ENABLE_OREN_NAYAR_DIFFUSE\n        lambert = clamp(dot(lightDirection, normal), 0., 1.);\n    #endif\n\n    #ifdef ENABLE_OREN_NAYAR_DIFFUSE\n        lambert = CalculateOrenNayar(lightDirection, viewDirection, normal);\n    #endif\n\n    vec3 diffuseColor = lambert * lightColor * materialColor;\n    return diffuseColor;\n}\n\nvec3 CalculateSpecularColor(\n    vec3 specularColor,\n    float specularCoefficient,\n    float shininess,\n    vec3 lightDirection,\n    vec3 viewDirection,\n    vec3 normal,\n    float lambertian\n) {\n    vec3 resultColor = vec3(0.);\n\n    #ifdef SPECULAR_PHONG\n        vec3 reflectDirection = reflect(-lightDirection, normal);\n        float specularAngle = max(dot(reflectDirection, viewDirection), 0.);\n        float specularFactor = pow(specularAngle, max(0., shininess));\n    resultColor = lambertian * specularFactor * specularCoefficient * specularColor;\n    #endif\n\n    #ifdef SPECULAR_BLINN\n        vec3 halfDirection = normalize(lightDirection + viewDirection);\n        float specularAngle = max(dot(halfDirection, normal), 0.);\n        float specularFactor = pow(specularAngle, max(0., shininess));\n        resultColor = lambertian * specularFactor * specularCoefficient * specularColor;\n    #endif\n\n    #ifdef SPECULAR_SCHLICK\n        vec3 halfDirection = normalize(lightDirection + viewDirection);\n        float specularAngle = dot(halfDirection, normal);\n        float schlickShininess = max(0., shininess);\n        float specularFactor = specularAngle / (schlickShininess - schlickShininess*specularAngle + specularAngle);\n        resultColor = lambertian * specularFactor * specularCoefficient * specularColor;\n    #endif\n\n    #ifdef SPECULAR_GAUSS\n        vec3 halfDirection = normalize(lightDirection + viewDirection);\n        float specularAngle = acos(max(dot(halfDirection, normal), 0.));\n        float exponent = specularAngle * shininess * 0.17;\n        exponent = -(exponent*exponent);\n        float specularFactor = exp(exponent);\n\n        resultColor = lambertian * specularFactor * specularCoefficient * specularColor;\n    #endif\n\n    #ifdef CONSERVE_ENERGY\n        float conserveEnergyFactor = EnergyConservation(shininess);\n        resultColor = conserveEnergyFactor * resultColor;\n    #endif\n\n    return resultColor;\n}\n\n#ifdef HAS_SPOT\n    float CalculateSpotLightEffect(vec3 lightPosition, vec3 conePointAt, float cosConeAngle, float cosConeAngleInner, float spotExponent, vec3 lightDirection) {\n        vec3 spotLightDirection = normalize(lightPosition-conePointAt);\n        float spotAngle = dot(-lightDirection, spotLightDirection);\n        float epsilon = cosConeAngle - cosConeAngleInner;\n\n        float spotIntensity = clamp((spotAngle - cosConeAngle)/epsilon, 0.0, 1.0);\n        spotIntensity = pow(spotIntensity, max(0.01, spotExponent));\n\n        return max(0., spotIntensity);\n    }\n#endif\n\n\n\n{{PHONG_FRAGMENT_HEAD}}\n\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n\n    vec4 col=vec4(0., 0., 0., inDiffuseColor.a);\n    vec3 calculatedColor = vec3(0.);\n    vec3 normal = normalize(normInterpolated);\n    vec3 baseColor = inDiffuseColor.rgb;\n\n    {{MODULE_BASE_COLOR}}\n\n\n    vec3 viewDirection = normalize(v_viewDirection);\n\n    #ifdef DOUBLE_SIDED\n        if(!gl_FrontFacing) normal = normal * -1.0;\n    #endif\n\n    #ifdef HAS_TEXTURES\n        #ifdef HAS_TEXTURE_DIFFUSE\n            baseColor = texture(texDiffuse, texCoord).rgb;\n\n            #ifdef COLORIZE_TEXTURE\n                baseColor *= inDiffuseColor.rgb;\n            #endif\n        #endif\n\n        #ifdef HAS_TEXTURE_NORMAL\n            normal = texture(texNormal, texCoord).rgb;\n            normal = normalize(normal * 2. - 1.);\n            float normalIntensity = inTextureIntensities.NORMAL;\n            normal = normalize(mix(vec3(0., 0., 1.), normal, 2. * normalIntensity));\n            normal = normalize(TBN_Matrix * normal);\n        #endif\n    #endif\n\n    {{PHONG_FRAGMENT_BODY}}\n\n\n\n\n\n\n    #ifdef ENABLE_FRESNEL\n        calculatedColor += inFresnel.rgb * (CalculateFresnel(vec3(cameraSpace_pos), normal) * inFresnel.w * inFresnelWidthExponent.x);\n    #endif\n\n     #ifdef HAS_TEXTURE_ALPHA\n        #ifdef ALPHA_MASK_ALPHA\n            col.a*=texture(texAlpha,texCoord).a;\n        #endif\n        #ifdef ALPHA_MASK_LUMI\n            col.a*= dot(vec3(0.2126,0.7152,0.0722), texture(texAlpha,texCoord).rgb);\n        #endif\n        #ifdef ALPHA_MASK_R\n            col.a*=texture(texAlpha,texCoord).r;\n        #endif\n        #ifdef ALPHA_MASK_G\n            col.a*=texture(texAlpha,texCoord).g;\n        #endif\n        #ifdef ALPHA_MASK_B\n            col.a*=texture(texAlpha,texCoord).b;\n        #endif\n    #endif\n\n    #ifdef DISCARDTRANS\n        if(col.a<0.2) discard;\n    #endif\n\n\n    #ifdef HAS_TEXTURE_ENV\n        vec3 luminanceColor = vec3(0.);\n\n        #ifndef ENVMAP_MATCAP\n            float environmentMapWidth = inEnvMapWidth;\n            float glossyExponent = inMaterialProperties.SHININESS;\n            float glossyCoefficient = inMaterialProperties.SPECULAR_AMT;\n\n            vec3 envMapNormal =  normal;\n            vec3 reflectDirection = reflect(normalize(-viewDirection), normal);\n\n            float lambertianCoefficient = dot(viewDirection, reflectDirection); //0.44; // TODO: need prefiltered map for this\n            // lambertianCoefficient = 1.;\n            float specularAngle = max(dot(reflectDirection, viewDirection), 0.);\n            float specularFactor = pow(specularAngle, max(0., inMaterialProperties.SHININESS));\n\n            glossyExponent = specularFactor;\n\n            float maxMIPLevel = 10.;\n            float MIPlevel = log2(environmentMapWidth / 1024. * sqrt(3.)) - 0.5 * log2(glossyExponent + 1.);\n\n            luminanceColor = inEnvMapIntensity * (\n                inDiffuseColor.rgb *\n                SAMPLETEX(texEnv, envMapNormal, maxMIPLevel).rgb\n                +\n                glossyCoefficient * SAMPLETEX(texEnv, reflectDirection, MIPlevel).rgb\n            );\n        #endif\n        #ifdef ENVMAP_MATCAP\n            luminanceColor = inEnvMapIntensity * (\n                texture(texEnv, getMatCapUV(viewSpacePosition, viewSpaceNormal)).rgb\n                //inDiffuseColor.rgb\n                //* textureLod(texEnv, getMatCapUV(envMapNormal), maxMIPLevel).rgb\n                //+\n                //glossyCoefficient * textureLod(texEnv, getMatCapUV(reflectDirection), MIPlevel).rgb\n            );\n        #endif\n\n\n\n        #ifdef HAS_TEXTURE_LUMINANCE_MASK\n            luminanceColor *= texture(texLuminance, texCoord).r * inLuminanceMaskIntensity;\n        #endif\n\n        #ifdef HAS_TEXTURE_AO\n            // luminanceColor *= mix(vec3(1.), texture(texAO, texCoord).rgb, inTextureIntensities.AO);\n            luminanceColor *= texture(texAO, texCoord).g*inTextureIntensities.AO;\n        #endif\n\n        #ifdef ENV_BLEND_ADD\n            calculatedColor.rgb += luminanceColor;\n        #endif\n        #ifdef ENV_BLEND_MUL\n            calculatedColor.rgb *= luminanceColor;\n        #endif\n\n        #ifdef ENV_BLEND_MIX\n            calculatedColor.rgb=mix(luminanceColor,calculatedColor.rgb,luminanceColor);\n        #endif\n\n\n    #endif\n\n    #ifdef ADD_EMISSIVE_COLOR\n        vec3 emissiveRadiance = mix(calculatedColor, inEmissiveColor.rgb, inEmissiveColor.w); // .w = intensity of color;\n\n        #ifdef HAS_TEXTURE_EMISSIVE\n            float emissiveIntensity = inTextureIntensities.EMISSIVE;\n            emissiveRadiance = mix(calculatedColor, texture(texEmissive, texCoord).rgb, emissiveIntensity);\n        #endif\n\n        #ifdef HAS_TEXTURE_EMISSIVE_MASK\n           float emissiveMixValue = mix(1., texture(texMaskEmissive, texCoord).r, inEmissiveMaskIntensity);\n           calculatedColor = mix(calculatedColor, emissiveRadiance, emissiveMixValue);\n        #endif\n\n        #ifndef HAS_TEXTURE_EMISSIVE_MASK\n            calculatedColor = emissiveRadiance;\n        #endif\n    #endif\n\n    col.rgb = clamp(calculatedColor, 0., 1.);\n\n\n    {{MODULE_COLOR}}\n\n    outColor = col;\n}\n","phong_vert":"\n{{MODULES_HEAD}}\n\n#define NONE -1\n#define AMBIENT 0\n#define POINT 1\n#define DIRECTIONAL 2\n#define SPOT 3\n\n#define TEX_REPEAT_X x;\n#define TEX_REPEAT_Y y;\n#define TEX_OFFSET_X z;\n#define TEX_OFFSET_Y w;\n\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\nIN vec3 attrTangent;\nIN vec3 attrBiTangent;\n\nOUT vec2 texCoord;\nOUT vec3 normInterpolated;\nOUT vec3 fragPos;\n\n#ifdef HAS_TEXTURE_NORMAL\n    OUT mat3 TBN_Matrix; // tangent bitangent normal space transform matrix\n#endif\n\n#ifdef ENABLE_FRESNEL\n    OUT vec4 cameraSpace_pos;\n#endif\n\nOUT vec3 v_viewDirection;\nOUT mat3 normalMatrix;\nOUT mat4 mvMatrix;\n\n#ifdef HAS_TEXTURES\n    UNI vec4 inTextureRepeatOffset;\n#endif\n\nUNI vec3 camPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\n#ifdef ENVMAP_MATCAP\n    OUT vec3 viewSpaceNormal;\n    OUT vec3 viewSpacePosition;\n#endif\n\n\nmat3 transposeMat3(mat3 m)\n{\n    return mat3(m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\nmat3 inverseMat3(mat3 m)\n{\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n        b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n        b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    vec4 pos=vec4(vPosition,  1.0);\n\n    texCoord=attrTexCoord;\n    texCoord.y = 1. - texCoord.y;\n    vec3 norm=attrVertNormal;\n\n    vec3 tangent = attrTangent;\n    vec3 bitangent = attrBiTangent;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    normalMatrix = transposeMat3(inverseMat3(mat3(mMatrix)));\n    mvMatrix = (viewMatrix * mMatrix);\n\n\n\n    #ifdef ENABLE_FRESNEL\n        cameraSpace_pos = mvMatrix * pos;\n    #endif\n\n    #ifdef HAS_TEXTURES\n        float repeatX = inTextureRepeatOffset.TEX_REPEAT_X;\n        float offsetX = inTextureRepeatOffset.TEX_OFFSET_X;\n        float repeatY = inTextureRepeatOffset.TEX_REPEAT_Y;\n        float offsetY = inTextureRepeatOffset.TEX_OFFSET_Y;\n\n        texCoord.x *= repeatX;\n        texCoord.x += offsetX;\n        texCoord.y *= repeatY;\n        texCoord.y += offsetY;\n    #endif\n\n   normInterpolated = vec3(normalMatrix*norm);\n\n    #ifdef HAS_TEXTURE_NORMAL\n        vec3 normCameraSpace = normalize((vec4(normInterpolated, 0.0)).xyz);\n        vec3 tangCameraSpace = normalize((mMatrix * vec4(tangent, 0.0)).xyz);\n        vec3 bitangCameraSpace = normalize((mMatrix * vec4(bitangent, 0.0)).xyz);\n\n        // re orthogonalization for smoother normals\n        tangCameraSpace = normalize(tangCameraSpace - dot(tangCameraSpace, normCameraSpace) * normCameraSpace);\n        bitangCameraSpace = cross(normCameraSpace, tangCameraSpace);\n\n        TBN_Matrix = mat3(tangCameraSpace, bitangCameraSpace, normCameraSpace);\n    #endif\n\n    fragPos = vec3((mMatrix) * pos);\n    v_viewDirection = normalize(camPos - fragPos);\n    // modelPos=mMatrix*pos;\n\n    #ifdef ENVMAP_MATCAP\n        mat3 viewSpaceNormalMatrix = normalMatrix = transposeMat3(inverseMat3(mat3(mvMatrix)));\n        viewSpaceNormal = normalize(viewSpaceNormalMatrix * norm);\n        viewSpacePosition = vec3(mvMatrix * pos);\n    #endif\n    gl_Position = projMatrix * mvMatrix * pos;\n}\n","snippet_body_ambient_frag":"    // * AMBIENT LIGHT {{LIGHT_INDEX}} *\n    vec3 diffuseColor{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.lightProperties.INTENSITY*phongLight{{LIGHT_INDEX}}.color;\n    calculatedColor += diffuseColor{{LIGHT_INDEX}};\n","snippet_body_directional_frag":"    // * DIRECTIONAL LIGHT {{LIGHT_INDEX}} *\n\n    if (phongLight{{LIGHT_INDEX}}.castLight == 1) {\n        vec3 phongLightDirection{{LIGHT_INDEX}} = normalize(phongLight{{LIGHT_INDEX}}.position);\n\n        float phongLambert{{LIGHT_INDEX}} = 1.; // inout variable\n\n        vec3 lightColor{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.color;\n        vec3 lightSpecular{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.specular;\n\n        #ifdef HAS_TEXTURES\n            #ifdef HAS_TEXTURE_AO\n                // lightColor{{LIGHT_INDEX}} *= mix(vec3(1.), texture(texAO, texCoord).rgb, inTextureIntensities.AO);\n                lightColor{{LIGHT_INDEX}} *= texture(texAO, texCoord).g, inTextureIntensities.AO;\n\n            #endif\n\n            #ifdef HAS_TEXTURE_SPECULAR\n                lightSpecular{{LIGHT_INDEX}} *= mix(1., texture(texSpecular, texCoord).r, inTextureIntensities.SPECULAR);\n            #endif\n        #endif\n\n        vec3 diffuseColor{{LIGHT_INDEX}} = CalculateDiffuseColor(phongLightDirection{{LIGHT_INDEX}}, viewDirection, normal, lightColor{{LIGHT_INDEX}}, baseColor, phongLambert{{LIGHT_INDEX}});\n        vec3 specularColor{{LIGHT_INDEX}} = CalculateSpecularColor(\n            lightSpecular{{LIGHT_INDEX}},\n            inMaterialProperties.SPECULAR_AMT,\n            inMaterialProperties.SHININESS,\n            phongLightDirection{{LIGHT_INDEX}},\n            viewDirection,\n            normal,\n            phongLambert{{LIGHT_INDEX}}\n        );\n\n        vec3 combinedColor{{LIGHT_INDEX}} = (diffuseColor{{LIGHT_INDEX}} + specularColor{{LIGHT_INDEX}});\n\n        vec3 lightModelDiff{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.position - fragPos.xyz;\n\n        combinedColor{{LIGHT_INDEX}} *= phongLight{{LIGHT_INDEX}}.lightProperties.INTENSITY;\n        calculatedColor += combinedColor{{LIGHT_INDEX}};\n    }","snippet_body_point_frag":"// * POINT LIGHT {{LIGHT_INDEX}} *\n    if (phongLight{{LIGHT_INDEX}}.castLight == 1) {\n        vec3 phongLightDirection{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.position - fragPos.xyz;\n        // * get length before normalization for falloff calculation\n        phongLightDirection{{LIGHT_INDEX}} = normalize(phongLightDirection{{LIGHT_INDEX}});\n        float phongLightDistance{{LIGHT_INDEX}} = length(phongLightDirection{{LIGHT_INDEX}});\n\n        float phongLambert{{LIGHT_INDEX}} = 1.; // inout variable\n\n        vec3 lightColor{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.color;\n        vec3 lightSpecular{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.specular;\n\n        #ifdef HAS_TEXTURES\n            #ifdef HAS_TEXTURE_AO\n                // lightColor{{LIGHT_INDEX}} *= mix(vec3(1.), texture(texAO, texCoord).rgb, inTextureIntensities.AO);\n                lightColor{{LIGHT_INDEX}} *= texture(texAO, texCoord).g, inTextureIntensities.AO;\n\n            #endif\n\n            #ifdef HAS_TEXTURE_SPECULAR\n                lightSpecular{{LIGHT_INDEX}} *= mix(1., texture(texSpecular, texCoord).r, inTextureIntensities.SPECULAR);\n            #endif\n        #endif\n\n        vec3 diffuseColor{{LIGHT_INDEX}} = CalculateDiffuseColor(phongLightDirection{{LIGHT_INDEX}}, viewDirection, normal, lightColor{{LIGHT_INDEX}}, baseColor, phongLambert{{LIGHT_INDEX}});\n        vec3 specularColor{{LIGHT_INDEX}} = CalculateSpecularColor(\n            lightSpecular{{LIGHT_INDEX}},\n            inMaterialProperties.SPECULAR_AMT,\n            inMaterialProperties.SHININESS,\n            phongLightDirection{{LIGHT_INDEX}},\n            viewDirection,\n            normal,\n            phongLambert{{LIGHT_INDEX}}\n        );\n\n        vec3 combinedColor{{LIGHT_INDEX}} = (diffuseColor{{LIGHT_INDEX}} + specularColor{{LIGHT_INDEX}});\n\n        combinedColor{{LIGHT_INDEX}} *= phongLight{{LIGHT_INDEX}}.lightProperties.INTENSITY;\n\n        float attenuation{{LIGHT_INDEX}} = CalculateFalloff(\n            phongLightDistance{{LIGHT_INDEX}},\n            phongLightDirection{{LIGHT_INDEX}},\n            phongLight{{LIGHT_INDEX}}.lightProperties.FALLOFF,\n            phongLight{{LIGHT_INDEX}}.lightProperties.RADIUS\n        );\n\n        attenuation{{LIGHT_INDEX}} *= when_gt(phongLambert{{LIGHT_INDEX}}, 0.);\n        combinedColor{{LIGHT_INDEX}} *= attenuation{{LIGHT_INDEX}};\n\n        calculatedColor += combinedColor{{LIGHT_INDEX}};\n    }\n","snippet_body_spot_frag":"    // * SPOT LIGHT {{LIGHT_INDEX}} *\n    if (phongLight{{LIGHT_INDEX}}.castLight == 1) {\n        vec3 phongLightDirection{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.position - fragPos.xyz;\n        phongLightDirection{{LIGHT_INDEX}} = normalize( phongLightDirection{{LIGHT_INDEX}});\n        float phongLightDistance{{LIGHT_INDEX}} = length(phongLightDirection{{LIGHT_INDEX}});\n\n        float phongLambert{{LIGHT_INDEX}} = 1.; // inout variable\n\n        vec3 lightColor{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.color;\n        vec3 lightSpecular{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.specular;\n\n        #ifdef HAS_TEXTURES\n            #ifdef HAS_TEXTURE_AO\n                // lightColor{{LIGHT_INDEX}} *= mix(vec3(1.), texture(texAO, texCoord).rgb, inTextureIntensities.AO);\n                lightColor{{LIGHT_INDEX}} *= texture(texAO, texCoord).g, inTextureIntensities.AO;\n\n            #endif\n\n            #ifdef HAS_TEXTURE_SPECULAR\n                lightSpecular{{LIGHT_INDEX}} *= mix(1., texture(texSpecular, texCoord).r, inTextureIntensities.SPECULAR);\n            #endif\n        #endif\n\n        vec3 diffuseColor{{LIGHT_INDEX}} = CalculateDiffuseColor(phongLightDirection{{LIGHT_INDEX}}, viewDirection, normal, lightColor{{LIGHT_INDEX}}, baseColor, phongLambert{{LIGHT_INDEX}});\n        vec3 specularColor{{LIGHT_INDEX}} = CalculateSpecularColor(\n            lightSpecular{{LIGHT_INDEX}},\n            inMaterialProperties.SPECULAR_AMT,\n            inMaterialProperties.SHININESS,\n            phongLightDirection{{LIGHT_INDEX}},\n            viewDirection,\n            normal,\n            phongLambert{{LIGHT_INDEX}}\n        );\n\n        vec3 combinedColor{{LIGHT_INDEX}} = (diffuseColor{{LIGHT_INDEX}} + specularColor{{LIGHT_INDEX}});\n\n        float spotIntensity{{LIGHT_INDEX}} = CalculateSpotLightEffect(\n            phongLight{{LIGHT_INDEX}}.position, phongLight{{LIGHT_INDEX}}.conePointAt, phongLight{{LIGHT_INDEX}}.spotProperties.COSCONEANGLE,\n            phongLight{{LIGHT_INDEX}}.spotProperties.COSCONEANGLEINNER, phongLight{{LIGHT_INDEX}}.spotProperties.SPOTEXPONENT,\n            phongLightDirection{{LIGHT_INDEX}}\n        );\n\n        combinedColor{{LIGHT_INDEX}} *= spotIntensity{{LIGHT_INDEX}};\n\n        vec3 lightModelDiff{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.position - fragPos.xyz;\n\n        float attenuation{{LIGHT_INDEX}} = CalculateFalloff(\n            phongLightDistance{{LIGHT_INDEX}},\n            phongLightDirection{{LIGHT_INDEX}},\n            phongLight{{LIGHT_INDEX}}.lightProperties.FALLOFF,\n            phongLight{{LIGHT_INDEX}}.lightProperties.RADIUS\n        );\n\n        attenuation{{LIGHT_INDEX}} *= when_gt(phongLambert{{LIGHT_INDEX}}, 0.);\n\n        combinedColor{{LIGHT_INDEX}} *= attenuation{{LIGHT_INDEX}};\n\n        combinedColor{{LIGHT_INDEX}} *= phongLight{{LIGHT_INDEX}}.lightProperties.INTENSITY;\n        calculatedColor += combinedColor{{LIGHT_INDEX}};\n    }","snippet_head_frag":"UNI Light phongLight{{LIGHT_INDEX}};\n",};
const cgl = op.patch.cgl;

const attachmentFragmentHead = attachments.snippet_head_frag;
const snippets = {
    "point": attachments.snippet_body_point_frag,
    "spot": attachments.snippet_body_spot_frag,
    "ambient": attachments.snippet_body_ambient_frag,
    "directional": attachments.snippet_body_directional_frag,
    "area": attachments.snippet_body_area_frag,
};
const LIGHT_INDEX_REGEX = new RegExp("{{LIGHT_INDEX}}", "g");

const createFragmentHead = (n) => { return attachmentFragmentHead.replace("{{LIGHT_INDEX}}", n); };
const createFragmentBody = (n, type) => { return snippets[type].replace(LIGHT_INDEX_REGEX, n); };

function createDefaultShader()
{
    const vertexShader = attachments.phong_vert;
    let fragmentShader = attachments.phong_frag;
    let fragmentHead = "";
    let fragmentBody = "";

    fragmentHead = fragmentHead.concat(createFragmentHead(0));
    fragmentBody = fragmentBody.concat(createFragmentBody(0, DEFAULT_LIGHTSTACK[0].type));

    fragmentShader = fragmentShader.replace(FRAGMENT_HEAD_REGEX, fragmentHead);
    fragmentShader = fragmentShader.replace(FRAGMENT_BODY_REGEX, fragmentBody);

    shader.setSource(vertexShader, fragmentShader);
    shader.define("HAS_POINT");
    shader.removeDefine("HAS_SPOT");
    shader.removeDefine("HAS_DIRECTIONAL");
    shader.removeDefine("HAS_AMBIENT");
}

const inTrigger = op.inTrigger("Trigger In");

// * DIFFUSE *
const inDiffuseR = op.inFloat("R", Math.random());
const inDiffuseG = op.inFloat("G", Math.random());
const inDiffuseB = op.inFloat("B", Math.random());
const inDiffuseA = op.inFloatSlider("A", 1);
const diffuseColors = [inDiffuseR, inDiffuseG, inDiffuseB, inDiffuseA];
op.setPortGroup("Diffuse Color", diffuseColors);

const inToggleOrenNayar = op.inBool("Enable", false);
const inAlbedo = op.inFloatSlider("Albedo", 0.707);
const inRoughness = op.inFloatSlider("Roughness", 0.835);

inToggleOrenNayar.setUiAttribs({ "hidePort": true });
inAlbedo.setUiAttribs({ "greyout": true });
inRoughness.setUiAttribs({ "greyout": true });
inDiffuseR.setUiAttribs({ "colorPick": true });
op.setPortGroup("Oren-Nayar Diffuse", [inToggleOrenNayar, inAlbedo, inRoughness]);

inToggleOrenNayar.onChange = function ()
{
    shader.toggleDefine("ENABLE_OREN_NAYAR_DIFFUSE", inToggleOrenNayar);
    inAlbedo.setUiAttribs({ "greyout": !inToggleOrenNayar.get() });
    inRoughness.setUiAttribs({ "greyout": !inToggleOrenNayar.get() });
};

// * FRESNEL *
const inToggleFresnel = op.inValueBool("Active", false);
inToggleFresnel.setUiAttribs({ "hidePort": true });
const inFresnel = op.inValueSlider("Fresnel Intensity", 0.7);
const inFresnelWidth = op.inFloat("Fresnel Width", 1);
const inFresnelExponent = op.inFloat("Fresnel Exponent", 6);
const inFresnelR = op.inFloat("Fresnel R", 1);
const inFresnelG = op.inFloat("Fresnel G", 1);
const inFresnelB = op.inFloat("Fresnel B", 1);
inFresnelR.setUiAttribs({ "colorPick": true });

const fresnelArr = [inFresnel, inFresnelWidth, inFresnelExponent, inFresnelR, inFresnelG, inFresnelB];
fresnelArr.forEach(function (port) { port.setUiAttribs({ "greyout": true }); });
op.setPortGroup("Fresnel", fresnelArr.concat([inToggleFresnel]));

let uniFresnel = null;
let uniFresnelWidthExponent = null;
inToggleFresnel.onChange = function ()
{
    shader.toggleDefine("ENABLE_FRESNEL", inToggleFresnel);
    if (inToggleFresnel.get())
    {
        if (!uniFresnel) uniFresnel = new CGL.Uniform(shader, "4f", "inFresnel", inFresnelR, inFresnelG, inFresnelB, inFresnel);
        if (!uniFresnelWidthExponent) uniFresnelWidthExponent = new CGL.Uniform(shader, "2f", "inFresnelWidthExponent", inFresnelWidth, inFresnelExponent);
    }
    else
    {
        if (uniFresnel)
        {
            shader.removeUniform("inFresnel");
            uniFresnel = null;
        }

        if (uniFresnelWidthExponent)
        {
            shader.removeUniform("inFresnelWidthExponent");
            uniFresnelWidthExponent = null;
        }
    }

    fresnelArr.forEach(function (port) { port.setUiAttribs({ "greyout": !inToggleFresnel.get() }); });
};
// * EMISSIVE *
const inEmissiveActive = op.inBool("Emissive Active", false);
const inEmissiveColorIntensity = op.inFloatSlider("Color Intensity", 0.3);
const inEmissiveR = op.inFloatSlider("Emissive R", Math.random());
const inEmissiveG = op.inFloatSlider("Emissive G", Math.random());
const inEmissiveB = op.inFloatSlider("Emissive B", Math.random());
inEmissiveR.setUiAttribs({ "colorPick": true });
op.setPortGroup("Emissive Color", [inEmissiveActive, inEmissiveColorIntensity, inEmissiveR, inEmissiveG, inEmissiveB]);

inEmissiveColorIntensity.setUiAttribs({ "greyout": !inEmissiveActive.get() });
inEmissiveR.setUiAttribs({ "greyout": !inEmissiveActive.get() });
inEmissiveG.setUiAttribs({ "greyout": !inEmissiveActive.get() });
inEmissiveB.setUiAttribs({ "greyout": !inEmissiveActive.get() });

let uniEmissiveColor = null;

inEmissiveActive.onChange = () =>
{
    shader.toggleDefine("ADD_EMISSIVE_COLOR", inEmissiveActive);

    if (inEmissiveActive.get())
    {
        uniEmissiveColor = new CGL.Uniform(shader, "4f", "inEmissiveColor", inEmissiveR, inEmissiveG, inEmissiveB, inEmissiveColorIntensity);
        inEmissiveTexture.setUiAttribs({ "greyout": false });
        inEmissiveMaskTexture.setUiAttribs({ "greyout": false });

        if (inEmissiveTexture.get()) inEmissiveIntensity.setUiAttribs({ "greyout": false });
        if (inEmissiveMaskTexture.get()) inEmissiveMaskIntensity.setUiAttribs({ "greyout": false });
    }
    else
    {
        op.log("ayayay");
        inEmissiveTexture.setUiAttribs({ "greyout": true });
        inEmissiveMaskTexture.setUiAttribs({ "greyout": true });
        inEmissiveIntensity.setUiAttribs({ "greyout": true });
        inEmissiveMaskIntensity.setUiAttribs({ "greyout": true });

        shader.removeUniform("inEmissiveColor");
        uniEmissiveColor = null;
    }

    if (inEmissiveTexture.get())
    {
        inEmissiveColorIntensity.setUiAttribs({ "greyout": true });
        inEmissiveR.setUiAttribs({ "greyout": true });
        inEmissiveG.setUiAttribs({ "greyout": true });
        inEmissiveB.setUiAttribs({ "greyout": true });
    }
    else
    {
        if (inEmissiveActive.get())
        {
            inEmissiveColorIntensity.setUiAttribs({ "greyout": false });
            inEmissiveR.setUiAttribs({ "greyout": false });
            inEmissiveG.setUiAttribs({ "greyout": false });
            inEmissiveB.setUiAttribs({ "greyout": false });
        }
        else
        {
            inEmissiveColorIntensity.setUiAttribs({ "greyout": true });
            inEmissiveR.setUiAttribs({ "greyout": true });
            inEmissiveG.setUiAttribs({ "greyout": true });
            inEmissiveB.setUiAttribs({ "greyout": true });
        }
    }
};
// * SPECULAR *
const inShininess = op.inFloat("Shininess", 4);
const inSpecularCoefficient = op.inFloatSlider("Specular Amount", 0.5);
const inSpecularMode = op.inSwitch("Specular Model", ["Blinn", "Schlick", "Phong", "Gauss"], "Blinn");

inSpecularMode.setUiAttribs({ "hidePort": true });
const specularColors = [inShininess, inSpecularCoefficient, inSpecularMode];
op.setPortGroup("Specular", specularColors);

// * LIGHT *
const inEnergyConservation = op.inValueBool("Energy Conservation", false);
const inToggleDoubleSided = op.inBool("Double Sided Material", false);
const inFalloffMode = op.inSwitch("Falloff Mode", ["A", "B", "C", "D"], "A");
inEnergyConservation.setUiAttribs({ "hidePort": true });
inToggleDoubleSided.setUiAttribs({ "hidePort": true });
inFalloffMode.setUiAttribs({ "hidePort": true });
inFalloffMode.onChange = () =>
{
    const MODES = ["A", "B", "C", "D"];
    shader.define("FALLOFF_MODE_" + inFalloffMode.get());
    MODES.filter((mode) => { return mode !== inFalloffMode.get(); })
        .forEach((mode) => { return shader.removeDefine("FALLOFF_MODE_" + mode); });
};

const lightProps = [inEnergyConservation, inToggleDoubleSided, inFalloffMode];
op.setPortGroup("Light Options", lightProps);

// TEXTURES
const inDiffuseTexture = op.inTexture("Diffuse Texture");
const inSpecularTexture = op.inTexture("Specular Texture");
const inNormalTexture = op.inTexture("Normal Map");
const inAoTexture = op.inTexture("AO Texture");
const inEmissiveTexture = op.inTexture("Emissive Texture");
const inEmissiveMaskTexture = op.inTexture("Emissive Mask");
const inAlphaTexture = op.inTexture("Opacity Texture");
const inEnvTexture = op.inTexture("Environment Map");
const inLuminanceMaskTexture = op.inTexture("Env Map Mask");
op.setPortGroup("Textures", [inDiffuseTexture, inSpecularTexture, inNormalTexture, inAoTexture, inEmissiveTexture, inEmissiveMaskTexture, inAlphaTexture, inEnvTexture, inLuminanceMaskTexture]);

// TEXTURE TRANSFORMS
const inColorizeTexture = op.inBool("Colorize Texture", false);
const inDiffuseRepeatX = op.inFloat("Diffuse Repeat X", 1);
const inDiffuseRepeatY = op.inFloat("Diffuse Repeat Y", 1);
const inTextureOffsetX = op.inFloat("Texture Offset X", 0);
const inTextureOffsetY = op.inFloat("Texture Offset Y", 0);

const inSpecularIntensity = op.inFloatSlider("Specular Intensity", 1);
const inNormalIntensity = op.inFloatSlider("Normal Map Intensity", 0.5);
const inAoIntensity = op.inFloatSlider("AO Intensity", 1);
const inEmissiveIntensity = op.inFloatSlider("Emissive Intensity", 1);
const inEmissiveMaskIntensity = op.inFloatSlider("Emissive Mask Intensity", 1);
const inEnvMapIntensity = op.inFloatSlider("Env Map Intensity", 1);
const inEnvMapBlend = op.inSwitch("Env Map Blend", ["Add", "Multiply", "Mix"], "Add");
const inLuminanceMaskIntensity = op.inFloatSlider("Env Mask Intensity", 1);

inColorizeTexture.setUiAttribs({ "hidePort": true });
op.setPortGroup("Texture Transforms", [inColorizeTexture, inDiffuseRepeatY, inDiffuseRepeatX, inTextureOffsetY, inTextureOffsetX]);
op.setPortGroup("Texture Intensities", [inNormalIntensity, inAoIntensity, inSpecularIntensity, inEmissiveIntensity, inEnvMapBlend, inEmissiveMaskIntensity, inEnvMapIntensity, inLuminanceMaskIntensity]);
const alphaMaskSource = op.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A"], "Luminance");
alphaMaskSource.setUiAttribs({ "greyout": true });

const discardTransPxl = op.inValueBool("Discard Transparent Pixels");
discardTransPxl.setUiAttribs({ "hidePort": true });

op.setPortGroup("Opacity Texture", [alphaMaskSource, discardTransPxl]);

const outTrigger = op.outTrigger("Trigger Out");
const shaderOut = op.outObject("Shader", null, "shader");
shaderOut.ignoreValueSerialize = true;

const shader = new CGL.Shader(cgl, "phongmaterial_" + op.id);
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_BASE_COLOR"]);
shader.setSource(attachments.simosphong_vert, attachments.simosphong_frag);
let recompileShader = false;
shader.define("FALLOFF_MODE_A");

if (cgl.glVersion < 2)
{
    shader.enableExtension("GL_OES_standard_derivatives");

    if (cgl.gl.getExtension("OES_texture_float")) shader.enableExtension("GL_OES_texture_float");
    else op.log("error loading extension OES_texture_float");

    if (cgl.gl.getExtension("OES_texture_float_linear")) shader.enableExtension("GL_OES_texture_float_linear");
    else op.log("error loading extention OES_texture_float_linear");

    if (cgl.gl.getExtension("GL_OES_texture_half_float")) shader.enableExtension("GL_OES_texture_half_float");
    else op.log("error loading extention GL_OES_texture_half_float");

    if (cgl.gl.getExtension("GL_OES_texture_half_float_linear")) shader.enableExtension("GL_OES_texture_half_float_linear");
    else op.log("error loading extention GL_OES_texture_half_float_linear");
}

const FRAGMENT_HEAD_REGEX = new RegExp("{{PHONG_FRAGMENT_HEAD}}", "g");
const FRAGMENT_BODY_REGEX = new RegExp("{{PHONG_FRAGMENT_BODY}}", "g");

const hasLight = {
    "directional": false,
    "spot": false,
    "ambient": false,
    "point": false,
};

function createShader(lightStack)
{
    let fragmentShader = attachments.phong_frag;

    let fragmentHead = "";
    let fragmentBody = "";

    hasLight.directional = false;
    hasLight.spot = false;
    hasLight.ambient = false;
    hasLight.point = false;

    for (let i = 0; i < lightStack.length; i += 1)
    {
        const light = lightStack[i];

        const type = light.type;

        if (!hasLight[type])
        {
            hasLight[type] = true;
        }

        fragmentHead = fragmentHead.concat(createFragmentHead(i));
        fragmentBody = fragmentBody.concat(createFragmentBody(i, light.type));
    }

    fragmentShader = fragmentShader.replace(FRAGMENT_HEAD_REGEX, fragmentHead);
    fragmentShader = fragmentShader.replace(FRAGMENT_BODY_REGEX, fragmentBody);

    shader.setSource(attachments.phong_vert, fragmentShader);

    for (let i = 0, keys = Object.keys(hasLight); i < keys.length; i += 1)
    {
        const key = keys[i];

        if (hasLight[key])
        {
            if (!shader.hasDefine("HAS_" + key.toUpperCase()))
            {
                shader.define("HAS_" + key.toUpperCase());
            }
        }
        else
        {
            if (shader.hasDefine("HAS_" + key.toUpperCase()))
            {
                shader.removeDefine("HAS_" + key.toUpperCase());
            }
        }
    }
}

shaderOut.set(shader);

let diffuseTextureUniform = null;
let specularTextureUniform = null;
let normalTextureUniform = null;
let aoTextureUniform = null;
let emissiveTextureUniform = null;
let emissiveMaskTextureUniform = null;
let emissiveMaskIntensityUniform = null;
let alphaTextureUniform = null;
let envTextureUniform = null;
let inEnvMapIntensityUni = null;
let inEnvMapWidthUni = null;
let luminanceTextureUniform = null;
let inLuminanceMaskIntensityUniform = null;

inColorizeTexture.onChange = function ()
{
    shader.toggleDefine("COLORIZE_TEXTURE", inColorizeTexture.get());
};

function updateDiffuseTexture()
{
    if (inDiffuseTexture.get())
    {
        if (!shader.hasDefine("HAS_TEXTURE_DIFFUSE"))
        {
            shader.define("HAS_TEXTURE_DIFFUSE");
            if (!diffuseTextureUniform) diffuseTextureUniform = new CGL.Uniform(shader, "t", "texDiffuse", 0);
        }
    }
    else
    {
        shader.removeUniform("texDiffuse");
        shader.removeDefine("HAS_TEXTURE_DIFFUSE");
        diffuseTextureUniform = null;
    }
}

function updateSpecularTexture()
{
    if (inSpecularTexture.get())
    {
        inSpecularIntensity.setUiAttribs({ "greyout": false });
        if (!shader.hasDefine("HAS_TEXTURE_SPECULAR"))
        {
            shader.define("HAS_TEXTURE_SPECULAR");
            if (!specularTextureUniform) specularTextureUniform = new CGL.Uniform(shader, "t", "texSpecular", 0);
        }
    }
    else
    {
        inSpecularIntensity.setUiAttribs({ "greyout": true });
        shader.removeUniform("texSpecular");
        shader.removeDefine("HAS_TEXTURE_SPECULAR");
        specularTextureUniform = null;
    }
}

function updateNormalTexture()
{
    if (inNormalTexture.get())
    {
        inNormalIntensity.setUiAttribs({ "greyout": false });

        if (!shader.hasDefine("HAS_TEXTURE_NORMAL"))
        {
            shader.define("HAS_TEXTURE_NORMAL");
            if (!normalTextureUniform) normalTextureUniform = new CGL.Uniform(shader, "t", "texNormal", 0);
        }
    }
    else
    {
        inNormalIntensity.setUiAttribs({ "greyout": true });

        shader.removeUniform("texNormal");
        shader.removeDefine("HAS_TEXTURE_NORMAL");
        normalTextureUniform = null;
    }
}

aoTextureUniform = new CGL.Uniform(shader, "t", "texAO");

function updateAoTexture()
{
    shader.toggleDefine("HAS_TEXTURE_AO", inAoTexture.get());

    inAoIntensity.setUiAttribs({ "greyout": !inAoTexture.get() });

    // if (inAoTexture.get())
    // {
    //     // inAoIntensity.setUiAttribs({ "greyout": false });

    //     // if (!shader.hasDefine("HAS_TEXTURE_AO"))
    //     // {
    //         // shader.define("HAS_TEXTURE_AO");
    //         // if (!aoTextureUniform)
    //         aoTextureUniform = new CGL.Uniform(shader, "t", "texAO", 0);
    //     // }
    // }
    // else
    // {
    //     // inAoIntensity.setUiAttribs({ "greyout": true });

    //     shader.removeUniform("texAO");
    //     // shader.removeDefine("HAS_TEXTURE_AO");
    //     aoTextureUniform = null;
    // }
}

function updateEmissiveTexture()
{
    if (inEmissiveTexture.get())
    {
        inEmissiveR.setUiAttribs({ "greyout": true });
        inEmissiveG.setUiAttribs({ "greyout": true });
        inEmissiveB.setUiAttribs({ "greyout": true });
        inEmissiveColorIntensity.setUiAttribs({ "greyout": true });

        if (inEmissiveActive.get())
        {
            inEmissiveIntensity.setUiAttribs({ "greyout": false });
        }

        if (!shader.hasDefine("HAS_TEXTURE_EMISSIVE"))
        {
            shader.define("HAS_TEXTURE_EMISSIVE");
            if (!emissiveTextureUniform) emissiveTextureUniform = new CGL.Uniform(shader, "t", "texEmissive", 0);
        }
    }
    else
    {
        inEmissiveIntensity.setUiAttribs({ "greyout": true });

        if (inEmissiveActive.get())
        {
            inEmissiveR.setUiAttribs({ "greyout": false });
            inEmissiveG.setUiAttribs({ "greyout": false });
            inEmissiveB.setUiAttribs({ "greyout": false });
            inEmissiveColorIntensity.setUiAttribs({ "greyout": false });
        }
        else
        {
            inEmissiveTexture.setUiAttribs({ "greyout": true });
        }

        shader.removeUniform("texEmissive");
        shader.removeDefine("HAS_TEXTURE_EMISSIVE");
        emissiveTextureUniform = null;
    }
}

function updateEmissiveMaskTexture()
{
    if (inEmissiveMaskTexture.get())
    { // we have a emissive texture
        if (inEmissiveActive.get())
        {
            inEmissiveMaskIntensity.setUiAttribs({ "greyout": false });
        }

        if (!shader.hasDefine("HAS_TEXTURE_EMISSIVE_MASK"))
        {
            shader.define("HAS_TEXTURE_EMISSIVE_MASK");
            if (!emissiveMaskTextureUniform) emissiveMaskTextureUniform = new CGL.Uniform(shader, "t", "texMaskEmissive", 0);
            if (!emissiveMaskIntensityUniform) emissiveMaskIntensityUniform = new CGL.Uniform(shader, "f", "inEmissiveMaskIntensity", inEmissiveMaskIntensity);
        }
    }
    else
    {
        if (!inEmissiveActive.get())
        {
            inEmissiveMaskTexture.setUiAttribs({ "greyout": true });
        }
        inEmissiveMaskIntensity.setUiAttribs({ "greyout": true });
        shader.removeUniform("texMaskEmissive");
        shader.removeUniform("inEmissiveMaskIntensity");
        shader.removeDefine("HAS_TEXTURE_EMISSIVE_MASK");
        emissiveMaskTextureUniform = null;
        emissiveMaskIntensityUniform = null;
    }
}

let updateEnvTextureLater = false;
function updateEnvTexture()
{
    shader.toggleDefine("HAS_TEXTURE_ENV", inEnvTexture.get());

    inEnvMapIntensity.setUiAttribs({ "greyout": !inEnvTexture.get() });

    if (inEnvTexture.get())
    {
        if (!envTextureUniform) envTextureUniform = new CGL.Uniform(shader, "t", "texEnv", 0);

        shader.toggleDefine("TEX_FORMAT_CUBEMAP", inEnvTexture.get().cubemap);

        if (inEnvTexture.get().cubemap)
        {
            shader.removeDefine("TEX_FORMAT_EQUIRECT");
            shader.removeDefine("ENVMAP_MATCAP");
            if (!inEnvMapIntensityUni)inEnvMapIntensityUni = new CGL.Uniform(shader, "f", "inEnvMapIntensity", inEnvMapIntensity);
            if (!inEnvMapWidthUni)inEnvMapWidthUni = new CGL.Uniform(shader, "f", "inEnvMapWidth", inEnvTexture.get().cubemap.width);
        }
        else
        {
            const isSquare = inEnvTexture.get().width === inEnvTexture.get().height;
            shader.toggleDefine("TEX_FORMAT_EQUIRECT", !isSquare);
            shader.toggleDefine("ENVMAP_MATCAP", isSquare);

            if (!inEnvMapIntensityUni)inEnvMapIntensityUni = new CGL.Uniform(shader, "f", "inEnvMapIntensity", inEnvMapIntensity);
            if (!inEnvMapWidthUni) inEnvMapWidthUni = new CGL.Uniform(shader, "f", "inEnvMapWidth", inEnvTexture.get().width);
        }
    }
    else
    {
        shader.removeUniform("inEnvMapIntensity");
        shader.removeUniform("inEnvMapWidth");
        shader.removeUniform("texEnv");
        shader.removeDefine("HAS_TEXTURE_ENV");
        shader.removeDefine("ENVMAP_MATCAP");
        envTextureUniform = null;
        inEnvMapIntensityUni = null;
    }

    updateEnvTextureLater = false;
}

function updateLuminanceMaskTexture()
{
    if (inLuminanceMaskTexture.get())
    {
        inLuminanceMaskIntensity.setUiAttribs({ "greyout": false });
        if (!luminanceTextureUniform)
        {
            shader.define("HAS_TEXTURE_LUMINANCE_MASK");
            luminanceTextureUniform = new CGL.Uniform(shader, "t", "texLuminance", 0);
            inLuminanceMaskIntensityUniform = new CGL.Uniform(shader, "f", "inLuminanceMaskIntensity", inLuminanceMaskIntensity);
        }
    }
    else
    {
        inLuminanceMaskIntensity.setUiAttribs({ "greyout": true });
        shader.removeDefine("HAS_TEXTURE_LUMINANCE_MASK");
        shader.removeUniform("inLuminanceMaskIntensity");
        shader.removeUniform("texLuminance");
        luminanceTextureUniform = null;
        inLuminanceMaskIntensityUniform = null;
    }
}

// TEX OPACITY

function updateDefines()
{
    shader.toggleDefine("ENV_BLEND_ADD", inEnvMapBlend.get() == "Add");
    shader.toggleDefine("ENV_BLEND_MUL", inEnvMapBlend.get() == "Multiply");
    shader.toggleDefine("ENV_BLEND_MIX", inEnvMapBlend.get() == "Mix");

    shader.toggleDefine("ALPHA_MASK_ALPHA", alphaMaskSource.get() == "Alpha Channel");
    shader.toggleDefine("ALPHA_MASK_LUMI", alphaMaskSource.get() == "Luminance");
    shader.toggleDefine("ALPHA_MASK_R", alphaMaskSource.get() == "R");
    shader.toggleDefine("ALPHA_MASK_G", alphaMaskSource.get() == "G");
    shader.toggleDefine("ALPHA_MASK_B", alphaMaskSource.get() == "B");
}

inEnvMapBlend.onChange = updateDefines;
alphaMaskSource.onChange = updateDefines;

function updateAlphaTexture()
{
    if (inAlphaTexture.get())
    {
        if (alphaTextureUniform !== null) return;
        shader.removeUniform("texAlpha");
        shader.define("HAS_TEXTURE_ALPHA");
        if (!alphaTextureUniform) alphaTextureUniform = new CGL.Uniform(shader, "t", "texAlpha", 0);

        alphaMaskSource.setUiAttribs({ "greyout": false });
        discardTransPxl.setUiAttribs({ "greyout": false });
    }
    else
    {
        shader.removeUniform("texAlpha");
        shader.removeDefine("HAS_TEXTURE_ALPHA");
        alphaTextureUniform = null;

        alphaMaskSource.setUiAttribs({ "greyout": true });
        discardTransPxl.setUiAttribs({ "greyout": true });
    }
    updateDefines();
}

discardTransPxl.onChange = function ()
{
    shader.toggleDefine("DISCARDTRANS", discardTransPxl.get());
};

inDiffuseTexture.onChange = updateDiffuseTexture;
inSpecularTexture.onChange = updateSpecularTexture;
inNormalTexture.onChange = updateNormalTexture;
inAoTexture.onChange = updateAoTexture;
inEmissiveTexture.onChange = updateEmissiveTexture;
inEmissiveMaskTexture.onChange = updateEmissiveMaskTexture;
inAlphaTexture.onChange = updateAlphaTexture;
inEnvTexture.onChange = () => { updateEnvTextureLater = true; };
inLuminanceMaskTexture.onChange = updateLuminanceMaskTexture;

const MAX_UNIFORM_FRAGMENTS = cgl.maxUniformsFrag;
const MAX_LIGHTS = MAX_UNIFORM_FRAGMENTS === 64 ? 6 : 16;

shader.define("MAX_LIGHTS", MAX_LIGHTS.toString());
shader.define("SPECULAR_PHONG");

inSpecularMode.onChange = function ()
{
    if (inSpecularMode.get() === "Phong")
    {
        shader.define("SPECULAR_PHONG");
        shader.removeDefine("SPECULAR_BLINN");
        shader.removeDefine("SPECULAR_GAUSS");
        shader.removeDefine("SPECULAR_SCHLICK");
    }
    else if (inSpecularMode.get() === "Blinn")
    {
        shader.define("SPECULAR_BLINN");
        shader.removeDefine("SPECULAR_PHONG");
        shader.removeDefine("SPECULAR_GAUSS");
        shader.removeDefine("SPECULAR_SCHLICK");
    }
    else if (inSpecularMode.get() === "Gauss")
    {
        shader.define("SPECULAR_GAUSS");
        shader.removeDefine("SPECULAR_BLINN");
        shader.removeDefine("SPECULAR_PHONG");
        shader.removeDefine("SPECULAR_SCHLICK");
    }
    else if (inSpecularMode.get() === "Schlick")
    {
        shader.define("SPECULAR_SCHLICK");
        shader.removeDefine("SPECULAR_BLINN");
        shader.removeDefine("SPECULAR_PHONG");
        shader.removeDefine("SPECULAR_GAUSS");
    }
};

inEnergyConservation.onChange = function ()
{
    shader.toggleDefine("CONSERVE_ENERGY", inEnergyConservation.get());
};

inToggleDoubleSided.onChange = function ()
{
    shader.toggleDefine("DOUBLE_SIDED", inToggleDoubleSided.get());
};

// * INIT UNIFORMS *

const uniMaterialProps = new CGL.Uniform(shader, "4f", "inMaterialProperties", inAlbedo, inRoughness, inShininess, inSpecularCoefficient);
const uniDiffuseColor = new CGL.Uniform(shader, "4f", "inDiffuseColor", inDiffuseR, inDiffuseG, inDiffuseB, inDiffuseA);
const uniTextureIntensities = new CGL.Uniform(shader, "4f", "inTextureIntensities", inNormalIntensity, inAoIntensity, inSpecularIntensity, inEmissiveIntensity);
const uniTextureRepeatOffset = new CGL.Uniform(shader, "4f", "inTextureRepeatOffset", inDiffuseRepeatX, inDiffuseRepeatY, inTextureOffsetX, inTextureOffsetY);

shader.uniformColorDiffuse = uniDiffuseColor;

const lightUniforms = [];
let oldCount = 0;

function createUniforms(lightsCount)
{
    for (let i = 0; i < lightUniforms.length; i += 1)
    {
        lightUniforms[i] = null;
    }

    for (let i = 0; i < lightsCount; i += 1)
    {
        lightUniforms[i] = null;
        if (!lightUniforms[i])
        {
            lightUniforms[i] = {
                "color": new CGL.Uniform(shader, "3f", "phongLight" + i + ".color", [1, 1, 1]),
                "position": new CGL.Uniform(shader, "3f", "phongLight" + i + ".position", [0, 11, 0]),
                "specular": new CGL.Uniform(shader, "3f", "phongLight" + i + ".specular", [1, 1, 1]),
                // intensity, attenuation, falloff, radius
                "lightProperties": new CGL.Uniform(shader, "4f", "phongLight" + i + ".lightProperties", [1, 1, 1, 1]),

                "conePointAt": new CGL.Uniform(shader, "3f", "phongLight" + i + ".conePointAt", vec3.create()),
                "spotProperties": new CGL.Uniform(shader, "3f", "phongLight" + i + ".spotProperties", [0, 0, 0, 0]),
                "castLight": new CGL.Uniform(shader, "i", "phongLight" + i + ".castLight", 1),

            };
        }
    }
}

function setDefaultUniform(light)
{
    defaultUniform.position.setValue(light.position);
    defaultUniform.color.setValue(light.color);
    defaultUniform.specular.setValue(light.specular);
    defaultUniform.lightProperties.setValue([
        light.intensity,
        light.attenuation,
        light.falloff,
        light.radius,
    ]);

    defaultUniform.conePointAt.setValue(light.conePointAt);
    defaultUniform.spotProperties.setValue([
        light.cosConeAngle,
        light.cosConeAngleInner,
        light.spotExponent,
    ]);
}

function setUniforms(lightStack)
{
    for (let i = 0; i < lightStack.length; i += 1)
    {
        const light = lightStack[i];
        light.isUsed = true;

        lightUniforms[i].position.setValue(light.position);
        lightUniforms[i].color.setValue(light.color);
        lightUniforms[i].specular.setValue(light.specular);

        lightUniforms[i].lightProperties.setValue([
            light.intensity,
            light.attenuation,
            light.falloff,
            light.radius,
        ]);

        lightUniforms[i].conePointAt.setValue(light.conePointAt);
        lightUniforms[i].spotProperties.setValue([
            light.cosConeAngle,
            light.cosConeAngleInner,
            light.spotExponent,
        ]);

        lightUniforms[i].castLight.setValue(light.castLight);
    }
}

function compareLights(lightStack)
{
    if (lightStack.length !== oldCount)
    {
        createShader(lightStack);
        createUniforms(lightStack.length);
        oldCount = lightStack.length;
        setUniforms(lightStack);
        recompileShader = false;
    }
    else
    {
        if (recompileShader)
        {
            createShader(lightStack);
            createUniforms(lightStack.length);
            recompileShader = false;
        }
        setUniforms(lightStack);
    }
}

let defaultUniform = null;

function createDefaultUniform()
{
    defaultUniform = {
        "color": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".color", [1, 1, 1]),
        "specular": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".specular", [1, 1, 1]),
        "position": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".position", [0, 11, 0]),
        // intensity, attenuation, falloff, radius
        "lightProperties": new CGL.Uniform(shader, "4f", "phongLight" + 0 + ".lightProperties", [1, 1, 1, 1]),
        "conePointAt": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".conePointAt", vec3.create()),
        "spotProperties": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".spotProperties", [0, 0, 0, 0]),
        "castLight": new CGL.Uniform(shader, "i", "phongLight" + 0 + ".castLight", 1),
    };
}

const DEFAULT_LIGHTSTACK = [{
    "type": "point",
    "position": [5, 5, 5],
    "color": [1, 1, 1],
    "specular": [1, 1, 1],
    "intensity": 1,
    "attenuation": 0,
    "falloff": 0.5,
    "radius": 80,
    "castLight": 1,
}];

const iViewMatrix = mat4.create();

function updateLights()
{
    if (cgl.frameStore.lightStack)
    {
        if (cgl.frameStore.lightStack.length === 0)
        {
            op.setUiError("deflight", "Default light is enabled. Please add lights to your patch to make this warning disappear.", 1);
        }
        else op.setUiError("deflight", null);
    }

    if ((!cgl.frameStore.lightStack || !cgl.frameStore.lightStack.length))
    {
        // if no light in light stack, use default light & set count to -1
        // so when a new light gets added, the shader does recompile
        if (!defaultUniform)
        {
            createDefaultShader();
            createDefaultUniform();
        }

        mat4.invert(iViewMatrix, cgl.vMatrix);
        // set default light position to camera position
        DEFAULT_LIGHTSTACK[0].position = [iViewMatrix[12], iViewMatrix[13], iViewMatrix[14]];
        setDefaultUniform(DEFAULT_LIGHTSTACK[0]);

        oldCount = -1;
    }
    else
    {
        if (shader)
        {
            if (cgl.frameStore.lightStack)
            {
                if (cgl.frameStore.lightStack.length)
                {
                    defaultUniform = null;
                    compareLights(cgl.frameStore.lightStack);
                }
            }
        }
    }
}

const render = function ()
{
    if (!shader)
    {
        op.log("NO SHADER");
        return;
    }

    cgl.pushShader(shader);
    shader.popTextures();

    outTrigger.trigger();
    cgl.popShader();
};

op.preRender = function ()
{
    shader.bind();
    render();
};

/* transform for default light */
const inverseViewMat = mat4.create();
const vecTemp = vec3.create();
const camPos = vec3.create();

inTrigger.onTriggered = function ()
{
    if (!shader)
    {
        op.log("phong has no shader...");
        return;
    }

    if (updateEnvTextureLater)updateEnvTexture();

    cgl.pushShader(shader);

    shader.popTextures();

    if (inDiffuseTexture.get()) shader.pushTexture(diffuseTextureUniform, inDiffuseTexture.get());
    if (inSpecularTexture.get()) shader.pushTexture(specularTextureUniform, inSpecularTexture.get());
    if (inNormalTexture.get()) shader.pushTexture(normalTextureUniform, inNormalTexture.get());
    if (inAoTexture.get()) shader.pushTexture(aoTextureUniform, inAoTexture.get());
    if (inEmissiveTexture.get()) shader.pushTexture(emissiveTextureUniform, inEmissiveTexture.get());
    if (inEmissiveMaskTexture.get()) shader.pushTexture(emissiveMaskTextureUniform, inEmissiveMaskTexture.get());
    if (inAlphaTexture.get()) shader.pushTexture(alphaTextureUniform, inAlphaTexture.get());
    if (inEnvTexture.get())
    {
        if (inEnvTexture.get().cubemap) shader.pushTexture(envTextureUniform, inEnvTexture.get().cubemap, cgl.gl.TEXTURE_CUBE_MAP);
        else shader.pushTexture(envTextureUniform, inEnvTexture.get());
    }

    if (inLuminanceMaskTexture.get())
    {
        shader.pushTexture(luminanceTextureUniform, inLuminanceMaskTexture.get());
    }

    updateLights();

    outTrigger.trigger();

    cgl.popShader();
};

if (cgl.glVersion == 1)
{
    if (!cgl.gl.getExtension("EXT_shader_texture_lod"))
    {
        op.log("no EXT_shader_texture_lod texture extension");
        // throw "no EXT_shader_texture_lod texture extension";
    }
    else
    {
        shader.enableExtension("GL_EXT_shader_texture_lod");
        cgl.gl.getExtension("OES_texture_float");
        cgl.gl.getExtension("OES_texture_float_linear");
        cgl.gl.getExtension("OES_texture_half_float");
        cgl.gl.getExtension("OES_texture_half_float_linear");

        shader.enableExtension("GL_OES_standard_derivatives");
        shader.enableExtension("GL_OES_texture_float");
        shader.enableExtension("GL_OES_texture_float_linear");
        shader.enableExtension("GL_OES_texture_half_float");
        shader.enableExtension("GL_OES_texture_half_float_linear");
    }
}

updateDiffuseTexture();
updateSpecularTexture();
updateNormalTexture();
updateAoTexture();
updateAlphaTexture();
updateEmissiveTexture();
updateEmissiveMaskTexture();
updateEnvTexture();
updateLuminanceMaskTexture();


};

Ops.Gl.Phong.PhongMaterial_v6.prototype = new CABLES.Op();
CABLES.OPS["0d83ed06-cdbe-4fe0-87bb-0ccece7fb6e1"]={f:Ops.Gl.Phong.PhongMaterial_v6,objName:"Ops.Gl.Phong.PhongMaterial_v6"};




// **************************************************************
// 
// Ops.Gl.Phong.PointLight_v5
// 
// **************************************************************

Ops.Gl.Phong.PointLight_v5 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;
const gl = cgl.gl;
const mesh = CGL.MESHES.getSimpleRect(cgl, "fullscreenRectangle");

function Light(config)
{
    this.type = config.type || "point";
    this.color = config.color || [1, 1, 1];
    this.specular = config.specular || [0, 0, 0];
    this.position = config.position || null;
    this.intensity = config.intensity || 1;
    this.radius = config.radius || 1;
    this.falloff = config.falloff || 1;
    this.spotExponent = config.spotExponent || 1;
    this.cosConeAngle = Math.cos(CGL.DEG2RAD * this.coneAngle);
    this.conePointAt = config.conePointAt || [0, 0, 0];
    this.castShadow = config.castShadow || false;
    return this;
}

// * OP START *
const inTrigger = op.inTrigger("Trigger In");
const inCastLight = op.inBool("Cast Light", true);
const inIntensity = op.inFloat("Intensity", 2);
const inRadius = op.inFloat("Radius", 15);

const inPosX = op.inFloat("X", 0);
const inPosY = op.inFloat("Y", 2);
const inPosZ = op.inFloat("Z", 0.75);

const positionIn = [inPosX, inPosY, inPosZ];
op.setPortGroup("Position", positionIn);

const inR = op.inFloat("R", 0.8);
const inG = op.inFloat("G", 0.8);
const inB = op.inFloat("B", 0.8);

inR.setUiAttribs({ "colorPick": true });
const colorIn = [inR, inG, inB];
op.setPortGroup("Color", colorIn);

const inSpecularR = op.inFloat("Specular R", 1);
const inSpecularG = op.inFloat("Specular G", 1);
const inSpecularB = op.inFloat("Specular B", 1);

inSpecularR.setUiAttribs({ "colorPick": true });
const colorSpecularIn = [inSpecularR, inSpecularG, inSpecularB];
op.setPortGroup("Specular Color", colorSpecularIn);

const inFalloff = op.inFloatSlider("Falloff", 0.5);

const attribIns = [inIntensity, inCastLight, inRadius];
op.setPortGroup("Light Attributes", attribIns);

const inCastShadow = op.inBool("Cast Shadow", false);
const inRenderMapActive = op.inBool("Rendering Active", true);
const inMapSize = op.inSwitch("Map Size", [256, 512, 1024, 2048], 512);
const inShadowStrength = op.inFloatSlider("Shadow Strength", 1);
const inNear = op.inFloat("Near", 0.1);
const inFar = op.inFloat("Far", 30);
const inBias = op.inFloatSlider("Bias", 0.004);
const inPolygonOffset = op.inInt("Polygon Offset", 0);
op.setPortGroup("", [inCastShadow]);
op.setPortGroup("Shadow Map Settings", [inMapSize, inRenderMapActive, inShadowStrength, inNear, inFar, inBias, inPolygonOffset]);
const shadowProperties = [inNear, inFar];
inMapSize.setUiAttribs({ "greyout": !inCastShadow.get() });
inRenderMapActive.setUiAttribs({ "greyout": !inCastShadow.get() });
inShadowStrength.setUiAttribs({ "greyout": !inCastShadow.get() });
inNear.setUiAttribs({ "greyout": !inCastShadow.get() });
inBias.setUiAttribs({ "greyout": !inCastShadow.get() });
inFar.setUiAttribs({ "greyout": !inCastShadow.get() });
inPolygonOffset.setUiAttribs({ "greyout": !inCastShadow.get() });

let updating = false;

inCastShadow.onChange = function ()
{
    updating = true;
    updateLight = true;

    inMapSize.setUiAttribs({ "greyout": !inCastShadow.get() });
    inRenderMapActive.setUiAttribs({ "greyout": !inCastShadow.get() });
    inShadowStrength.setUiAttribs({ "greyout": !inCastShadow.get() });
    inNear.setUiAttribs({ "greyout": !inCastShadow.get() });
    inFar.setUiAttribs({ "greyout": !inCastShadow.get() });
    inBias.setUiAttribs({ "greyout": !inCastShadow.get() });
    inPolygonOffset.setUiAttribs({ "greyout": !inCastShadow.get() });
};

const outTrigger = op.outTrigger("Trigger Out");
const outCubemap = op.outObject("Cubemap", null, "texture");
const outWorldPosX = op.outNumber("World Position X");
const outWorldPosY = op.outNumber("World Position Y");
const outWorldPosZ = op.outNumber("World Position Z");

const newLight = new CGL.Light(cgl, {
    "type": "point",
    "position": [0, 1, 2].map(function (i) { return positionIn[i].get(); }),
    "color": [0, 1, 2].map(function (i) { return colorIn[i].get(); }),
    "specular": [0, 1, 2].map(function (i) { return colorSpecularIn[i].get(); }),
    "intensity": inIntensity.get(),
    "radius": inRadius.get(),
    "falloff": inFalloff.get(),
    "shadowStrength": inShadowStrength.get(),
    "shadowBias": inBias.get()
});
newLight.castLight = inCastLight.get();

let updateLight = false;

inPosX.onChange = inPosY.onChange = inPosZ.onChange = inR.onChange = inG.onChange = inB.onChange
= inSpecularR.onChange = inSpecularG.onChange = inSpecularB.onChange = inIntensity.onChange
= inCastLight.onChange = inRadius.onChange = inFalloff.onChange = inNear.onChange = inFar.onChange = inShadowStrength.onChange = function ()
        {
            updateLight = true;
        };

inMapSize.onChange = function ()
{
    // TODO: update this one
    updating = true;
};

function updateShadowMapFramebuffer()
{
    if (inCastShadow.get())
    {
        const size = inMapSize.get();
        newLight.createFramebuffer(size, size, {});
        newLight.createShadowMapShader();
    }
    updating = false;
}

const sc = vec3.create();
const result = vec3.create();
const position = vec3.create();
const transVec = vec3.create();

function drawHelpers()
{
    if (cgl.frameStore.shadowPass) return;
    if (cgl.shouldDrawHelpers(op))
    {
        gui.setTransformGizmo({
            "posX": inPosX,
            "posY": inPosY,
            "posZ": inPosZ,
        });

        cgl.pushModelMatrix();
        mat4.translate(cgl.mMatrix, cgl.mMatrix, transVec);
        CABLES.GL_MARKER.drawSphere(op, inRadius.get());
        cgl.popModelMatrix();
    }
}

let errorActive = false;

inTrigger.onTriggered = function ()
{
    if (updating)
    {
        if (cgl.frameStore.shadowPass) return;
        updateShadowMapFramebuffer();
    }

    if (!cgl.frameStore.shadowPass)
    {
        if (!newLight.isUsed && !errorActive)
        {
            op.setUiError("lightUsed", "No operator is using this light. Make sure this op is positioned before an operator that uses lights. Also make sure there is an operator that uses lights after this.", 1); // newLight.isUsed = false;
            errorActive = true;
        }
        else if (!newLight.isUsed && errorActive) {}
        else if (newLight.isUsed && errorActive)
        {
            op.setUiError("lightUsed", null);
            errorActive = false;
        }
        else if (newLight.isUsed && !errorActive) {}

        newLight.isUsed = false;
    }

    if (updateLight)
    {
        newLight.position = [0, 1, 2].map(function (i) { return positionIn[i].get(); });
        newLight.color = [0, 1, 2].map(function (i) { return colorIn[i].get(); });
        newLight.specular = [0, 1, 2].map(function (i) { return colorSpecularIn[i].get(); });
        newLight.intensity = inIntensity.get();
        newLight.radius = inRadius.get();
        newLight.falloff = inFalloff.get();
        newLight.castShadow = inCastShadow.get();
        newLight.castLight = inCastLight.get();
        newLight.updateProjectionMatrix(null, inNear.get(), inFar.get(), null);
        updateLight = false;
    }

    if (!cgl.frameStore.lightStack) cgl.frameStore.lightStack = [];

    vec3.set(transVec, inPosX.get(), inPosY.get(), inPosZ.get());
    vec3.transformMat4(position, transVec, cgl.mMatrix);

    newLight.position = position;

    outWorldPosX.set(newLight.position[0]);
    outWorldPosY.set(newLight.position[1]);
    outWorldPosZ.set(newLight.position[2]);

    if (!cgl.frameStore.shadowPass) drawHelpers();

    cgl.frameStore.lightStack.push(newLight);

    if (inCastShadow.get())
    {
        if (inRenderMapActive.get()) newLight.renderPasses(inPolygonOffset.get(), null, function () { outTrigger.trigger(); });

        if (!cgl.frameStore.shadowPass)
        {
            cgl.frameStore.lightStack.pop();
            newLight.castShadow = inCastShadow.get();
            newLight.shadowBias = inBias.get();
            newLight.shadowStrength = inShadowStrength.get();

            if (newLight.shadowCubeMap)
            {
                if (newLight.shadowCubeMap.cubemap)
                {
                    outCubemap.set(null);
                    outCubemap.set(newLight.shadowCubeMap);
                    if (inRenderMapActive.get())
                    {
                        // needs to be "cloned", cannot save reference.
                        newLight.positionForShadowMap = [newLight.position[0], newLight.position[1], newLight.position[2]];
                    }
                }
            }
            cgl.frameStore.lightStack.push(newLight);
        }
    }
    else
    {
        outCubemap.set(null);
    }

    outTrigger.trigger();
    cgl.frameStore.lightStack.pop();
};


};

Ops.Gl.Phong.PointLight_v5.prototype = new CABLES.Op();
CABLES.OPS["54e5d3f5-e3f4-4381-990d-d5e32b9a2d39"]={f:Ops.Gl.Phong.PointLight_v5,objName:"Ops.Gl.Phong.PointLight_v5"};




// **************************************************************
// 
// Ops.Gl.Phong.ResetLights
// 
// **************************************************************

Ops.Gl.Phong.ResetLights = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;
const inTrigger = op.inTrigger("Trigger In");
const inBool = op.inBool("Reset Lights", true);
const outTrigger = op.outTrigger("Trigger Out");

inTrigger.onTriggered = () =>
{
    if (inBool.get())
    {
        const oldStack = cgl.frameStore.lightStack;
        cgl.frameStore.lightStack = [];
        outTrigger.trigger();
        cgl.frameStore.lightStack = oldStack;
        return;
    }

    outTrigger.trigger();
};


};

Ops.Gl.Phong.ResetLights.prototype = new CABLES.Op();
CABLES.OPS["3954ca2b-56c8-4501-9b47-feeaba71d75f"]={f:Ops.Gl.Phong.ResetLights,objName:"Ops.Gl.Phong.ResetLights"};




// **************************************************************
// 
// Ops.Gl.Phong.SpotLight_v5
// 
// **************************************************************

Ops.Gl.Phong.SpotLight_v5 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;

// * OP START *
const inTrigger = op.inTrigger("Trigger In");

const inCastLight = op.inBool("Cast Light", true);
const inIntensity = op.inFloat("Intensity", 2);
const inRadius = op.inFloat("Radius", 10);

const inPosX = op.inFloat("X", 1);
const inPosY = op.inFloat("Y", 3);
const inPosZ = op.inFloat("Z", 1);

const positionIn = [inPosX, inPosY, inPosZ];
op.setPortGroup("Position", positionIn);

const inPointAtX = op.inFloat("Point At X", 0);
const inPointAtY = op.inFloat("Point At Y", 0);
const inPointAtZ = op.inFloat("Point At Z", 0);
const pointAtIn = [inPointAtX, inPointAtY, inPointAtZ];
op.setPortGroup("Point At", pointAtIn);

const inR = op.inFloatSlider("R", 1);
const inG = op.inFloatSlider("G", 1);
const inB = op.inFloatSlider("B", 1);
inR.setUiAttribs({ "colorPick": true });
const colorIn = [inR, inG, inB];
op.setPortGroup("Color", colorIn);

const inSpecularR = op.inFloatSlider("Specular R", 1);
const inSpecularG = op.inFloatSlider("Specular G", 1);
const inSpecularB = op.inFloatSlider("Specular B", 1);
inSpecularR.setUiAttribs({ "colorPick": true });
const colorSpecularIn = [inSpecularR, inSpecularG, inSpecularB];
op.setPortGroup("Specular Color", colorSpecularIn);

const inConeAngle = op.inFloat("Cone Angle", 120);
const inConeAngleInner = op.inFloat("Inner Cone Angle", 60);
const inSpotExponent = op.inFloat("Spot Exponent", 0.97);
const coneAttribsIn = [inConeAngle, inConeAngleInner, inSpotExponent];
op.setPortGroup("Cone Attributes", coneAttribsIn);

const inFalloff = op.inFloatSlider("Falloff", 0.00001);
const lightAttribsIn = [inCastLight, inIntensity, inRadius];
op.setPortGroup("Light Attributes", lightAttribsIn);

const inCastShadow = op.inBool("Cast Shadow", false);
const inRenderMapActive = op.inBool("Rendering Active", true);
const inMapSize = op.inSwitch("Map Size", [256, 512, 1024, 2048], 512);
const inShadowStrength = op.inFloatSlider("Shadow Strength", 0.99);
const inNear = op.inFloat("Near", 0.1);
const inFar = op.inFloat("Far", 30);
const inBias = op.inFloatSlider("Bias", 0.0001);
const inPolygonOffset = op.inInt("Polygon Offset", 0);
const inNormalOffset = op.inFloatSlider("Normal Offset", 0);
const inBlur = op.inFloatSlider("Blur Amount", 0);
op.setPortGroup("", [inCastShadow]);
op.setPortGroup("Shadow Map Settings", [
    inMapSize,
    inRenderMapActive,
    inShadowStrength,
    inNear,
    inFar,
    inBias,
    inPolygonOffset,
    inNormalOffset,
    inBlur
]);

inMapSize.setUiAttribs({ "greyout": true, "hidePort": true });
inRenderMapActive.setUiAttribs({ "greyout": true });
inShadowStrength.setUiAttribs({ "greyout": true });
inNear.setUiAttribs({ "greyout": true, "hidePort": true });
inFar.setUiAttribs({ "greyout": true, "hidePort": true });
inBlur.setUiAttribs({ "greyout": true, "hidePort": true });
inPolygonOffset.setUiAttribs({ "greyout": true, "hidePort": true });
inNormalOffset.setUiAttribs({ "greyout": true, "hidePort": true });
inBias.setUiAttribs({ "greyout": true, "hidePort": true });

const inAdvanced = op.inBool("Enable Advanced", false);
const inMSAA = op.inSwitch("MSAA", ["none", "2x", "4x", "8x"], "none");
const inFilterType = op.inSwitch("Texture Filter", ["Linear", "Nearest", "Mip Map"], "Linear");
const inAnisotropic = op.inSwitch("Anisotropic", [0, 1, 2, 4, 8, 16], "0");
inMSAA.setUiAttribs({ "greyout": true, "hidePort": true });
inFilterType.setUiAttribs({ "greyout": true, "hidePort": true });
inAnisotropic.setUiAttribs({ "greyout": true, "hidePort": true });
op.setPortGroup("Advanced Options", [inAdvanced, inMSAA, inFilterType, inAnisotropic]);

let updating = false;

inAdvanced.setUiAttribs({ "hidePort": true });

inAdvanced.onChange = function ()
{
    inMSAA.setUiAttribs({ "greyout": !inAdvanced.get() });
    inFilterType.setUiAttribs({ "greyout": !inAdvanced.get() });
    inAnisotropic.setUiAttribs({ "greyout": !inAdvanced.get() });
};

const outTrigger = op.outTrigger("Trigger Out");
const outTexture = op.outTexture("Shadow Map");
const outWorldPosX = op.outNumber("World Position X");
const outWorldPosY = op.outNumber("World Position Y");
const outWorldPosZ = op.outNumber("World Position Z");

const newLight = new CGL.Light(cgl, {
    "type": "spot",
    "position": [0, 1, 2].map(function (i) { return positionIn[i].get(); }),
    "color": [0, 1, 2].map(function (i) { return colorIn[i].get(); }),
    "specular": [0, 1, 2].map(function (i) { return colorSpecularIn[i].get(); }),
    "conePointAt": [0, 1, 2].map(function (i) { return pointAtIn[i].get(); }),
    "intensity": inIntensity.get(),
    "radius": inRadius.get(),
    "falloff": inFalloff.get(),
    "cosConeAngleInner": Math.cos(CGL.DEG2RAD * inConeAngleInner.get()),
    "cosConeAngle": Math.cos(CGL.DEG2RAD * inConeAngle.get()),
    "spotExponent": inSpotExponent.get(),
    "castShadow": false,
    "shadowStrength": inShadowStrength.get(),
    "shadowBias": inBias.get(),
    "normalOffset": inNormalOffset.get(),
});
newLight.castLight = inCastLight.get();

let updateLight = false;
inR.onChange = inG.onChange = inB.onChange = inSpecularR.onChange = inSpecularG.onChange = inSpecularB.onChange
= inPointAtX.onChange = inPointAtY.onChange = inPointAtZ.onChange = inPosX.onChange = inPosY.onChange = inPosZ.onChange;
inCastLight.onChange = inIntensity.onChange = inRadius.onChange = inFalloff.onChange = inConeAngle.onChange = inConeAngleInner.onChange
= inSpotExponent.onChange = inShadowStrength.onChange = inNear.onChange = inFar.onChange = updateLightParameters;

function updateLightParameters()
{
    updateLight = true;
}

inCastShadow.onChange = function ()
{
    updating = true;
    const castShadow = inCastShadow.get();

    inMapSize.setUiAttribs({ "greyout": !castShadow });
    inRenderMapActive.setUiAttribs({ "greyout": !castShadow });
    inShadowStrength.setUiAttribs({ "greyout": !castShadow });
    inNear.setUiAttribs({ "greyout": !castShadow });
    inFar.setUiAttribs({ "greyout": !castShadow });
    inNormalOffset.setUiAttribs({ "greyout": !castShadow });
    inBlur.setUiAttribs({ "greyout": !castShadow });
    inBias.setUiAttribs({ "greyout": !castShadow });
    inPolygonOffset.setUiAttribs({ "greyout": !castShadow });

    updateLight = true;
};

let texelSize = 1 / Number(inMapSize.get());

function updateBuffers()
{
    const MSAA = Number(inMSAA.get().charAt(0));

    let filterType = null;
    const anisotropyFactor = Number(inAnisotropic.get());

    if (inFilterType.get() == "Linear")
    {
        filterType = CGL.Texture.FILTER_LINEAR;
    }
    else if (inFilterType.get() == "Nearest")
    {
        filterType = CGL.Texture.FILTER_NEAREST;
    }
    else if (inFilterType.get() == "Mip Map")
    {
        filterType = CGL.Texture.FILTER_MIPMAP;
    }

    const mapSize = Number(inMapSize.get());
    const textureOptions = {
        "isFloatingPointTexture": true,
        "filter": filterType,
    };

    if (MSAA) Object.assign(textureOptions, { "multisampling": true, "multisamplingSamples": MSAA });
    Object.assign(textureOptions, { "anisotropic": anisotropyFactor });

    newLight.createFramebuffer(mapSize, mapSize, textureOptions);
    newLight.createBlurEffect(textureOptions);
}

inMSAA.onChange = inAnisotropic.onChange = inFilterType.onChange = inMapSize.onChange = function ()
{
    updating = true;
};

function updateShadowMapFramebuffer()
{
    const size = Number(inMapSize.get());
    texelSize = 1 / size;

    if (inCastShadow.get())
    {
        newLight.createFramebuffer(Number(inMapSize.get()), Number(inMapSize.get()), {});
        newLight.createShadowMapShader();
        newLight.createBlurEffect({});
        newLight.createBlurShader();
        newLight.updateProjectionMatrix(null, inNear.get(), inFar.get(), inConeAngle.get());
    }

    if (inAdvanced.get()) updateBuffers();

    updating = false;
}

const position = vec3.create();
const pointAtPos = vec3.create();
const resultPos = vec3.create();
const resultPointAt = vec3.create();

function drawHelpers()
{
    if (cgl.frameStore.shadowPass) return;
    if (cgl.shouldDrawHelpers(op))
    {
        gui.setTransformGizmo({
            "posX": inPosX,
            "posY": inPosY,
            "posZ": inPosZ,
        });

        CABLES.GL_MARKER.drawLineSourceDest(
            op,
            newLight.position[0],
            newLight.position[1],
            newLight.position[2],
            newLight.conePointAt[0],
            newLight.conePointAt[1],
            newLight.conePointAt[2],
        );
    }
}

let errorActive = false;
inTrigger.onTriggered = renderLight;

op.preRender = () =>
{
    updateShadowMapFramebuffer();
    renderLight();
};

function renderLight()
{
    if (updating)
    {
        if (cgl.frameStore.shadowPass) return;
        updateShadowMapFramebuffer();
    }

    if (!cgl.frameStore.shadowPass)
    {
        if (!newLight.isUsed && !errorActive)
        {
            op.setUiError("lightUsed", "No operator is using this light. Make sure this op is positioned before an operator that uses lights. Also make sure there is an operator that uses lights after this.", 1); // newLight.isUsed = false;
            errorActive = true;
        }
        else if (!newLight.isUsed && errorActive) {}
        else if (newLight.isUsed && errorActive)
        {
            op.setUiError("lightUsed", null);
            errorActive = false;
        }
        else if (newLight.isUsed && !errorActive) {}
        newLight.isUsed = false;
    }

    if (updateLight)
    {
        newLight.position = [0, 1, 2].map(function (i) { return positionIn[i].get(); });
        newLight.color = [0, 1, 2].map(function (i) { return colorIn[i].get(); });
        newLight.specular = [0, 1, 2].map(function (i) { return colorSpecularIn[i].get(); });
        newLight.conePointAt = [0, 1, 2].map(function (i) { return pointAtIn[i].get(); });
        newLight.intensity = inIntensity.get();
        newLight.castLight = inCastLight.get();
        newLight.radius = inRadius.get();
        newLight.falloff = inFalloff.get();
        newLight.cosConeAngleInner = Math.cos(CGL.DEG2RAD * inConeAngleInner.get());
        newLight.cosConeAngle = Math.cos(CGL.DEG2RAD * inConeAngle.get());
        newLight.spotExponent = inSpotExponent.get();
        newLight.castShadow = inCastShadow.get();
        newLight.updateProjectionMatrix(null, inNear.get(), inFar.get(), inConeAngle.get());
    }

    if (!cgl.frameStore.lightStack) cgl.frameStore.lightStack = [];

    vec3.set(position, inPosX.get(), inPosY.get(), inPosZ.get());
    vec3.set(pointAtPos, inPointAtX.get(), inPointAtY.get(), inPointAtZ.get());

    vec3.transformMat4(resultPos, position, cgl.mMatrix);
    vec3.transformMat4(resultPointAt, pointAtPos, cgl.mMatrix);

    newLight.position = resultPos;
    newLight.conePointAt = resultPointAt;

    outWorldPosX.set(newLight.position[0]);
    outWorldPosY.set(newLight.position[1]);
    outWorldPosZ.set(newLight.position[2]);

    if (!cgl.frameStore.shadowPass) drawHelpers();

    cgl.frameStore.lightStack.push(newLight);

    if (inCastShadow.get())
    {
        const blurAmount = 1.5 * inBlur.get() * texelSize;
        if (inRenderMapActive.get()) newLight.renderPasses(inPolygonOffset.get(), blurAmount, function () { outTrigger.trigger(); });
        outTexture.set(null);
        outTexture.set(newLight.getShadowMapDepth());

        // remove light from stack and readd it with shadow map & mvp matrix
        cgl.frameStore.lightStack.pop();

        newLight.castShadow = inCastShadow.get();
        newLight.blurAmount = inBlur.get();
        newLight.normalOffset = inNormalOffset.get();
        newLight.shadowBias = inBias.get();
        newLight.shadowStrength = inShadowStrength.get();
        cgl.frameStore.lightStack.push(newLight);
    }

    outTrigger.trigger();

    cgl.frameStore.lightStack.pop();
}


};

Ops.Gl.Phong.SpotLight_v5.prototype = new CABLES.Op();
CABLES.OPS["76418c17-abd5-401b-82e2-688db6f966ee"]={f:Ops.Gl.Phong.SpotLight_v5,objName:"Ops.Gl.Phong.SpotLight_v5"};




// **************************************************************
// 
// Ops.Gl.PixelProjection
// 
// **************************************************************

Ops.Gl.PixelProjection = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    useVPSize = op.inBool("use viewport size", true),
    width = op.inFloat("Width", 500),
    height = op.inFloat("Height", 500),
    zNear = op.inFloat("frustum near", -500),
    zFar = op.inFloat("frustum far", 500),
    fixAxis = op.inSwitch("Axis", ["X", "Y"], "X"),
    inAlign = op.inSwitch("Position 0,0", ["Top Left ", "Top Right", "Center", "Bottom Right", "Bottom Left"], "Bottom Left"),

    flipX = op.inBool("Flip X", false),
    flipY = op.inBool("Flip Y", false),
    zeroY = op.inBool("Zero Y", false),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;

op.setPortGroup("Canvas size", [useVPSize, width, height]);
op.setPortGroup("Clipping", [zNear, zFar]);
op.setPortGroup("Flip", [flipX, flipY]);
op.toWorkPortsNeedToBeLinked(render);

render.onTriggered = exec;
useVPSize.onChange = updateSizeUI;
updateSizeUI();

function updateSizeUI()
{
    width.setUiAttribs({ "greyout": useVPSize.get() });
    height.setUiAttribs({ "greyout": useVPSize.get() });
}

function exec()
{
    let xl = 0;
    let yt = 0;
    let xr = 0;
    let yb = 0;

    let w = width.get();
    let h = height.get();

    let x0 = 0;
    let y0 = 0;

    if (useVPSize.get())
    {
        xr = cgl.getViewPort()[2] / cgl.pixelDensity;
        yb = cgl.getViewPort()[3] / cgl.pixelDensity;
        w = cgl.getViewPort()[2] / cgl.pixelDensity;
        h = cgl.getViewPort()[3] / cgl.pixelDensity;
    }
    else
    {
        xr = w;
        yb = h;
    }

    if (flipX.get())
    {
        const temp = xr;
        xr = x0;
        xl = temp;
    }

    if (flipY.get())
    {
        const temp = yb;
        yb = y0;
        yt = temp;
    }

    if (inAlign.get() === "Center")
    {
        xl -= w / 2;
        xr -= w / 2;
        yt -= h / 2;
        yb -= h / 2;
    }
    else
    if (inAlign.get() === "Bottom Right")
    {
        xl -= w;
        xr = x0;
        yt = y0;
        yb = -h;
    }
    else
    if (inAlign.get() === "Top Right")
    {
        xl -= w;
        xr = x0;
        yt -= h;
        yb = y0;
    }
    if (inAlign.get() === "Top Left ")
    {
        xl = x0;
        xr = w;
        yt = -h;
        yb = y0;
    }

    cgl.pushPMatrix();

    mat4.ortho(
        cgl.pMatrix,
        xl,
        xr,
        yt,
        yb,
        parseFloat(zNear.get()),
        parseFloat(zFar.get())
    );

    trigger.trigger();
    cgl.popPMatrix();
}


};

Ops.Gl.PixelProjection.prototype = new CABLES.Op();
CABLES.OPS["949d6daf-d677-4ed6-a921-51a5732b64ac"]={f:Ops.Gl.PixelProjection,objName:"Ops.Gl.PixelProjection"};




// **************************************************************
// 
// Ops.Gl.PointCollector
// 
// **************************************************************

Ops.Gl.PointCollector = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    outPoints = op.outArray("Points", null, 3);
    // outPoints=op.addOutPort(new CABLES.Port(op,"Points",CABLES.OP_PORT_TYPE_ARRAY)),

outPoints.ignoreValueSerialize = true;

let inAbsolute = op.inValueBool("Absolute", true);

let points = [];
let cgl = op.patch.cgl;

let oldSplinePoints = null;

let pos = vec3.create();
let empty = vec3.create();
let m = mat4.create();

let mySplinePoints = [];

render.onTriggered = function ()
{
    if (cgl.frameStore.SplinePoints)
    {
        oldSplinePoints = cgl.frameStore.SplinePoints;
        cgl.frameStore.SplinePoints = [];
    }

    cgl.frameStore.SplinePointCounter = 0;

    cgl.frameStore.SplinePoints = mySplinePoints;// cgl.frameStore.SplinePoints||[];

    if (cgl.frameStore.SplinePointCounter != cgl.frameStore.SplinePoints.length)
        cgl.frameStore.SplinePoints.length = cgl.frameStore.SplinePointCounter;

    if (!inAbsolute.get())
    {
        mat4.invert(m, cgl.mMatrix);
        cgl.frameStore.SplinePointsInverseOriginalMatrix = m;
    }
    else
    {
        cgl.frameStore.SplinePointsInverseOriginalMatrix = null;
    }

    trigger.trigger();

    outPoints.set(null);
    outPoints.set(cgl.frameStore.SplinePoints);

    if (oldSplinePoints) cgl.frameStore.SplinePoints = oldSplinePoints;
};


};

Ops.Gl.PointCollector.prototype = new CABLES.Op();
CABLES.OPS["52f368ee-303b-4d84-919d-450b0c002e39"]={f:Ops.Gl.PointCollector,objName:"Ops.Gl.PointCollector"};




// **************************************************************
// 
// Ops.Gl.PointCollectorCollect
// 
// **************************************************************

Ops.Gl.PointCollectorCollect = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;

let pos = vec3.create();
let empty = vec3.create();
let tempMat = mat4.create();

render.onTriggered = function ()
{
    if (!cgl.frameStore.SplinePoints) return;

    if (cgl.frameStore.SplinePointsInverseOriginalMatrix)
    {
        mat4.multiply(tempMat, cgl.frameStore.SplinePointsInverseOriginalMatrix, cgl.mMatrix);
        vec3.transformMat4(pos, empty, tempMat);
    }
    else
    {
        vec3.transformMat4(pos, empty, cgl.mMatrix);
    }

    cgl.frameStore.SplinePoints[cgl.frameStore.SplinePointCounter + 0] = pos[0];
    cgl.frameStore.SplinePoints[cgl.frameStore.SplinePointCounter + 1] = pos[1];
    cgl.frameStore.SplinePoints[cgl.frameStore.SplinePointCounter + 2] = pos[2];

    cgl.frameStore.SplinePointCounter += 3;

    trigger.trigger();
};


};

Ops.Gl.PointCollectorCollect.prototype = new CABLES.Op();
CABLES.OPS["766147f4-94c5-4197-8e0b-f41320aac2c6"]={f:Ops.Gl.PointCollectorCollect,objName:"Ops.Gl.PointCollectorCollect"};




// **************************************************************
// 
// Ops.Gl.PointCollectorScreenCoords
// 
// **************************************************************

Ops.Gl.PointCollectorScreenCoords = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let render = op.inTrigger("render");
let trigger = op.outTrigger("trigger");

let cgl = op.patch.cgl;

let m = mat4.create();
let pos = [0, 0, 0];
let trans = vec3.create();

render.onTriggered = function ()
{
    if (!cgl.frameStore.SplinePoints) return;

    // vec3.transformMat4(pos, [0,0,0], cgl.mMatrix);

    mat4.multiply(m, cgl.vMatrix, cgl.mMatrix);
    vec3.transformMat4(pos, [0, 0, 0], m);

    vec3.transformMat4(trans, pos, cgl.pMatrix);

    let vp = cgl.getViewPort();

    cgl.frameStore.SplinePoints[cgl.frameStore.SplinePointCounter + 0] = vp[2] - (vp[2] * 0.5 - trans[0] * vp[2] * 0.5 / trans[2]);
    cgl.frameStore.SplinePoints[cgl.frameStore.SplinePointCounter + 1] = vp[3] - (vp[3] * 0.5 + trans[1] * vp[3] * 0.5 / trans[2]);

    cgl.frameStore.SplinePointCounter += 2;

    trigger.trigger();
};


};

Ops.Gl.PointCollectorScreenCoords.prototype = new CABLES.Op();
CABLES.OPS["ada03d29-07be-48f1-a428-7d0e8c52a163"]={f:Ops.Gl.PointCollectorScreenCoords,objName:"Ops.Gl.PointCollectorScreenCoords"};




// **************************************************************
// 
// Ops.Gl.RandomCluster
// 
// **************************************************************

Ops.Gl.RandomCluster = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    num = op.inValueInt("num"),
    seed = op.inValueFloat("random seed", 1.5),
    round = op.inValueBool("round", false),
    size = op.inValueFloat("size", 10),
    scaleX = op.inValueFloat("scaleX", 1),
    scaleY = op.inValueFloat("scaleY", 1),
    scaleZ = op.inValueFloat("scaleZ", 1),
    trigger = op.outTrigger("trigger"),
    idx = op.outNumber("index"),
    rnd = op.outNumber("rnd"),
    rotX = op.inValueSlider("Rotate X", 1),
    rotY = op.inValueSlider("Rotate Y", 1),
    rotZ = op.inValueSlider("Rotate Z", 1),
    scrollX = op.inValue("Scroll X", 0);

op.setPortGroup("Area", [size, scaleX, scaleY, scaleZ]);
op.setPortGroup("Rotation", [rotX, rotY, rotZ]);
op.setPortGroup("Parameters", [num, round, seed]);
op.toWorkPortsNeedToBeLinked(exe, trigger);

const cgl = op.patch.cgl;
const randoms = [];
const origRandoms = [];
const randomsRot = [];
const randomsFloats = [];

const transVec = vec3.create();
const mat = mat4.create();

function doRender()
{
    if (cgl.shouldDrawHelpers(op))
    {
        CABLES.GL_MARKER.drawCube(op,
            size.get() / 2 * scaleX.get(),
            size.get() / 2 * scaleY.get(),
            size.get() / 2 * scaleZ.get());
    }

    if (scrollX.get() != 0)
    {
        for (let i = 0; i < origRandoms.length; i++)
        {
            randoms[i][0] = origRandoms[i][0] + scrollX.get();
            randoms[i][0] = (randoms[i][0] % size.get()) - (size.get() / 2);
        }
    }

    for (let i = 0; i < randoms.length; i++)
    {
        cgl.pushModelMatrix();

        mat4.translate(cgl.mMatrix, cgl.mMatrix, randoms[i]);

        if (randomsRot[i][0]) mat4.rotateX(cgl.mMatrix, cgl.mMatrix, randomsRot[i][0]);
        if (randomsRot[i][1]) mat4.rotateY(cgl.mMatrix, cgl.mMatrix, randomsRot[i][1]);
        if (randomsRot[i][2]) mat4.rotateZ(cgl.mMatrix, cgl.mMatrix, randomsRot[i][2]);

        idx.set(i);
        rnd.set(randomsFloats[i]);

        trigger.trigger();
        // op.patch.instancing.increment();

        cgl.popModelMatrix();
    }
    // op.patch.instancing.popLoop();
}

exe.onTriggered = doRender;

function getRandomPos()
{
    return vec3.fromValues(
        scaleX.get() * (Math.seededRandom() - 0.5) * size.get(),
        scaleY.get() * (Math.seededRandom() - 0.5) * size.get(),
        scaleZ.get() * (Math.seededRandom() - 0.5) * size.get()
    );
}

function reset()
{
    randoms.length = 0;
    randomsRot.length = 0;
    randomsFloats.length = 0;
    origRandoms.length = 0;

    Math.randomSeed = seed.get();

    const makeRound = round.get();

    for (let i = 0; i < num.get(); i++)
    {
        randomsFloats.push(Math.seededRandom());

        let v = getRandomPos();

        if (makeRound && size.get() > 0)
            while (vec3.len(v) > size.get() / 2)
                v = getRandomPos();

        origRandoms.push([v[0], v[1], v[2]]);
        randoms.push(v);

        randomsRot.push(vec3.fromValues(
            Math.seededRandom() * 360 * CGL.DEG2RAD * rotX.get(),
            Math.seededRandom() * 360 * CGL.DEG2RAD * rotY.get(),
            Math.seededRandom() * 360 * CGL.DEG2RAD * rotZ.get()
        ));
    }
}

seed.onChange = reset;
num.onChange = reset;
size.onChange = reset;
scaleX.onChange = reset;
scaleZ.onChange = reset;
scaleY.onChange = reset;
round.onChange = reset;
rotX.onChange = reset;
rotY.onChange = reset;
rotZ.onChange = reset;

num.set(100);


};

Ops.Gl.RandomCluster.prototype = new CABLES.Op();
CABLES.OPS["ca3bc984-e596-48fb-b53d-502eb13979b0"]={f:Ops.Gl.RandomCluster,objName:"Ops.Gl.RandomCluster"};




// **************************************************************
// 
// Ops.Gl.RandomizeTriangles
// 
// **************************************************************

Ops.Gl.RandomizeTriangles = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inGeom = op.inObject("Geometry"),
    outGeom = op.outObject("Result"),
    inSeed = op.inValue("Seed", 1);

inGeom.ignoreValueSerialize = true;
outGeom.ignoreValueSerialize = true;

inSeed.onChange =
inGeom.onChange = function ()
{
    const geom = inGeom.get();
    if (!geom) return;
    if (geom.verticesIndices && geom.verticesIndices.length > 0)
    {
        op.logError("cannot randomize indexed geom ");
        return;
    }

    const newGeom = geom.copy();
    let order = [];
    let i = 0;
    order.length = geom.vertices.length / 9;
    for (i = 0; i < order.length; i++)order[i] = i;
    Math.randomSeed = inSeed.get();
    order = CABLES.shuffleArray(order);

    const verts = [];
    verts.length = geom.vertices.length;

    for (i = 0; i < order.length; i++)
    {
        const ind = order[i];
        for (let j = 0; j < 9; j++)
            verts[i * 9 + j] = geom.vertices[ind * 9 + j];
    }

    newGeom.setVertices(verts);

    outGeom.set(null);
    outGeom.set(newGeom);
};


};

Ops.Gl.RandomizeTriangles.prototype = new CABLES.Op();
CABLES.OPS["e8a27786-bd11-4818-88a6-74eeb52018bd"]={f:Ops.Gl.RandomizeTriangles,objName:"Ops.Gl.RandomizeTriangles"};




// **************************************************************
// 
// Ops.Gl.Render2Texture
// 
// **************************************************************

Ops.Gl.Render2Texture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;

const
    render = op.inTrigger("render"),
    useVPSize = op.inValueBool("use viewport size", true),
    width = op.inValueInt("texture width", 512),
    height = op.inValueInt("texture height", 512),
    aspect = op.inBool("Auto Aspect", false),
    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    twrap = op.inSwitch("Wrap", ["Clamp", "Repeat", "Mirror"], "Repeat"),
    msaa = op.inSwitch("MSAA", ["none", "2x", "4x", "8x"], "none"),
    trigger = op.outTrigger("trigger"),
    tex = op.outTexture("texture"),
    texDepth = op.outTexture("textureDepth"),
    fpTexture = op.inValueBool("HDR"),
    depth = op.inValueBool("Depth", true),
    clear = op.inValueBool("Clear", true);

let fb = null;
let reInitFb = true;
tex.set(CGL.Texture.getEmptyTexture(cgl));

op.setPortGroup("Size", [useVPSize, width, height, aspect]);

const prevViewPort = [0, 0, 0, 0];

fpTexture.setUiAttribs({ "title": "Pixelformat Float 32bit" });

fpTexture.onChange =
    depth.onChange =
    clear.onChange =
    tfilter.onChange =
    twrap.onChange =
    msaa.onChange = initFbLater;

useVPSize.onChange = updateVpSize;

render.onTriggered =
    op.preRender = doRender;

updateVpSize();

function updateVpSize()
{
    width.setUiAttribs({ "greyout": useVPSize.get() });
    height.setUiAttribs({ "greyout": useVPSize.get() });
    aspect.setUiAttribs({ "greyout": useVPSize.get() });
}

function initFbLater()
{
    reInitFb = true;
}

function doRender()
{
    const vp = cgl.getViewPort();
    prevViewPort[0] = vp[0];
    prevViewPort[1] = vp[1];
    prevViewPort[2] = vp[2];
    prevViewPort[3] = vp[3];

    if (!fb || reInitFb)
    {
        if (fb) fb.delete();

        let selectedWrap = CGL.Texture.WRAP_REPEAT;
        if (twrap.get() == "Clamp") selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;
        else if (twrap.get() == "Mirror") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;

        let selectFilter = CGL.Texture.FILTER_NEAREST;
        if (tfilter.get() == "nearest") selectFilter = CGL.Texture.FILTER_NEAREST;
        else if (tfilter.get() == "linear") selectFilter = CGL.Texture.FILTER_LINEAR;
        else if (tfilter.get() == "mipmap") selectFilter = CGL.Texture.FILTER_MIPMAP;

        if (fpTexture.get() && tfilter.get() == "mipmap") op.setUiError("fpmipmap", "Don't use mipmap and HDR at the same time, many systems do not support this.");
        else op.setUiError("fpmipmap", null);

        if (cgl.glVersion >= 2)
        {
            let ms = true;
            let msSamples = 4;

            if (msaa.get() == "none")
            {
                msSamples = 0;
                ms = false;
            }
            if (msaa.get() == "2x") msSamples = 2;
            if (msaa.get() == "4x") msSamples = 4;
            if (msaa.get() == "8x") msSamples = 8;

            fb = new CGL.Framebuffer2(cgl, 8, 8,
                {
                    "name": "render2texture " + op.id,
                    "isFloatingPointTexture": fpTexture.get(),
                    "multisampling": ms,
                    "wrap": selectedWrap,
                    "filter": selectFilter,
                    "depth": depth.get(),
                    "multisamplingSamples": msSamples,
                    "clear": clear.get()
                });
        }
        else
        {
            fb = new CGL.Framebuffer(cgl, 8, 8, { "isFloatingPointTexture": fpTexture.get(), "clear": clear.get() });
        }

        texDepth.set(fb.getTextureDepth());
        reInitFb = false;
    }

    if (useVPSize.get())
    {
        width.set(cgl.getViewPort()[2]);
        height.set(cgl.getViewPort()[3]);
    }

    if (fb.getWidth() != Math.ceil(width.get()) || fb.getHeight() != Math.ceil(height.get()))
    {
        fb.setSize(
            Math.max(1, Math.ceil(width.get())),
            Math.max(1, Math.ceil(height.get())));
    }

    fb.renderStart(cgl);

    if (aspect.get()) mat4.perspective(cgl.pMatrix, 45, width.get() / height.get(), 0.1, 1000.0);

    trigger.trigger();
    fb.renderEnd(cgl);

    // cgl.resetViewPort();
    cgl.setViewPort(prevViewPort[0], prevViewPort[1], prevViewPort[2], prevViewPort[3]);

    tex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
    tex.set(fb.getTextureColor());
}


};

Ops.Gl.Render2Texture.prototype = new CABLES.Op();
CABLES.OPS["d01fa820-396c-4cb5-9d78-6b14762852af"]={f:Ops.Gl.Render2Texture,objName:"Ops.Gl.Render2Texture"};




// **************************************************************
// 
// Ops.Gl.Render2Textures
// 
// **************************************************************

Ops.Gl.Render2Textures = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render = op.inTrigger("Render");
const trigger = op.outTrigger("Next");
const msaa = op.inValueSelect("MSAA", ["none", "2x", "4x", "8x"], "none");
const useVPSize = op.inValueBool("use viewport size");

const width = op.inValueInt("texture width");
const height = op.inValueInt("texture height");
const tfilter = op.inValueSelect("Filter", ["nearest", "linear", "mipmap"], "none");

const tex0 = op.outTexture("texture 0");
const tex1 = op.outTexture("texture 1");
const tex2 = op.outTexture("texture 2");
const tex3 = op.outTexture("texture 3");

const texDepth = op.outTexture("textureDepth");

const fpTexture = op.inValueBool("HDR");
const depth = op.inValueBool("Depth", true);
const clear = op.inValueBool("Clear", true);

const cgl = op.patch.cgl;

let fb = null;
width.set(512);
height.set(512);
useVPSize.set(true);
tfilter.set("linear");
let reInitFb = true;

render.onTriggered = doRender;
useVPSize.onChange = updateVpSize;

tfilter.onChange =
    fpTexture.onChange =
    depth.onChange =
    clear.onChange =
    msaa.onChange = reInitLater;

updateVpSize();

function updateVpSize()
{
    if (useVPSize.get())
    {
        width.setUiAttribs({ "hidePort": true, "greyout": true });
        height.setUiAttribs({ "hidePort": true, "greyout": true });
    }
    else
    {
        width.setUiAttribs({ "hidePort": false, "greyout": false });
        height.setUiAttribs({ "hidePort": false, "greyout": false });
    }
}

function reInitLater()
{
    reInitFb = true;
}

function doRender()
{
    if (!fb || reInitFb)
    {
        if (fb) fb.delete();
        if (cgl.glVersion >= 2)
        {
            let ms = true;
            let msSamples = 4;

            if (msaa.get() == "none")
            {
                msSamples = 0;
                ms = false;
            }
            if (msaa.get() == "2x")msSamples = 2;
            if (msaa.get() == "4x")msSamples = 4;
            if (msaa.get() == "8x")msSamples = 8;

            fb = new CGL.Framebuffer2(cgl, 8, 8,
                {
                    "numRenderBuffers": 4,
                    "isFloatingPointTexture": fpTexture.get(),
                    "multisampling": ms,
                    "depth": depth.get(),
                    "multisamplingSamples": msSamples,
                    "clear": clear.get()
                });
        }
        else
        {
            fb = new CGL.Framebuffer(cgl, 8, 8, { "isFloatingPointTexture": fpTexture.get() });
        }

        if (tfilter.get() == "nearest") fb.setFilter(CGL.Texture.FILTER_NEAREST);
        else if (tfilter.get() == "linear") fb.setFilter(CGL.Texture.FILTER_LINEAR);
        else if (tfilter.get() == "mipmap") fb.setFilter(CGL.Texture.FILTER_MIPMAP);

        tex0.set(fb.getTextureColorNum(0));
        tex1.set(fb.getTextureColorNum(1));
        tex2.set(fb.getTextureColorNum(2));
        tex3.set(fb.getTextureColorNum(3));
        texDepth.set(fb.getTextureDepth());
        reInitFb = false;
    }

    if (useVPSize.get())
    {
        width.set(cgl.getViewPort()[2]);
        height.set(cgl.getViewPort()[3]);
    }

    if (fb.getWidth() != Math.ceil(width.get()) || fb.getHeight() != Math.ceil(height.get())) fb.setSize(width.get(), height.get());

    fb.renderStart(cgl);
    trigger.trigger();
    fb.renderEnd(cgl);

    cgl.resetViewPort();
}


};

Ops.Gl.Render2Textures.prototype = new CABLES.Op();
CABLES.OPS["72f95dbd-7b36-4e88-9d59-1bb2d3f2144e"]={f:Ops.Gl.Render2Textures,objName:"Ops.Gl.Render2Textures"};




// **************************************************************
// 
// Ops.Gl.RenderAnim_v2
// 
// **************************************************************

Ops.Gl.RenderAnim_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Render"),
    next = op.outTrigger("Next"),
    inType = op.inDropDown("File Type", ["PNG", "JPG", "WebP", "WebM"], "PNG"),
    inZip = op.inBool("ZIP multiple files", false),
    inDownload = op.inBool("Download Files", true),
    inFilePrefix = op.inString("Filename", "cables"),
    inQuality = op.inFloatSlider("Quality", 0.8),
    inDurType = op.inSwitch("Duration Type", ["Seconds", "Frames"], "Seconds"),
    inDuration = op.inInt("Duration", 1),
    inFps = op.inInt("FPS", 30),
    inTransparency = op.inValueBool("Transparency", false),
    useCanvasSize = op.inValueBool("Use Canvas Size", true),
    inWidth = op.inValueInt("texture width", 512),
    inHeight = op.inValueInt("texture height", 512),
    inStart = op.inTriggerButton("Start"),
    outProgress = op.outNumber("Progress", 0),
    outFrame = op.outNumber("Frame", 0),
    outStatus = op.outString("Status", "Waiting"),
    outStarted = op.outBool("Started"),
    outUrl = op.outString("Data URL"),
    outFinished = op.outTrigger("Finished");

op.setPortGroup("File", [inType, inZip, inDownload, inFilePrefix, inQuality]);
op.setPortGroup("Size", [useCanvasSize, inWidth, inHeight]);
op.setPortGroup("Timing", [inFps, inDurType, inDuration]);

outUrl.ignoreValueSerialize = true;

exec.onTriggered = render;

let started = false;
let countFrames = 0;
const finished = true;
let fps = 30;
let numFrames = 31;

const cycle = false;
let shortId = CABLES.shortId();
let frameStarted = false;
const frames = [];
let lastFrame = -1;
let time = 0;

let filenamePrefix = "";

let zip = null;

let oldSizeW = op.patch.cgl.canvasWidth;
let oldSizeH = op.patch.cgl.canvasHeight;

inType.onChange = updateQuality;
useCanvasSize.onChange = updateSize;

updateQuality();
updateSize();

inZip.onChange = () =>
{
    zip = null;
};

function updateQuality()
{
    inQuality.setUiAttribs({ "greyout": inType.get() == "PNG" });
}

function updateSize()
{
    inWidth.setUiAttribs({ "greyout": useCanvasSize.get() });
    inHeight.setUiAttribs({ "greyout": useCanvasSize.get() });
}

inStart.onTriggered = function ()
{
    filenamePrefix = inFilePrefix.get();
    op.log("pref", filenamePrefix);
    frames.length = 0;
    outStatus.set("Starting");
    fps = inFps.get();
    numFrames = inDuration.get() * fps;
    if (inDurType.get() == "Frames")numFrames = inDuration.get();
    shortId = CABLES.shortId();
    updateTime();

    if (inZip.get()) zip = new JSZip();

    if (!useCanvasSize.get())
    {
        oldSizeW = CABLES.patch.cgl.canvasWidth;
        oldSizeH = CABLES.patch.cgl.canvasHeight;
        op.patch.cgl.setSize(inWidth.get() / CABLES.patch.cgl.pixelDensity, inHeight.get() / CABLES.patch.cgl.pixelDensity);
        op.patch.cgl.updateSize();
    }

    if (numFrames == 0)
    {
        countFrames = 0;
        started = true;
    }
    else
    {
        countFrames = -20;
        started = true;
        lastFrame = -9999;
    }
};

function updateTime()
{
    if (numFrames >= 0)
    {
        time = Math.max(0, countFrames * (1.0 / fps));
        op.patch.timer.setTime(time);
        CABLES.overwriteTime = time;// - 1 / fps;
        op.patch.freeTimer.setTime(time);
    }
}

function stopRendering()
{
    started = false;
    CABLES.overwriteTime = undefined;
    outStatus.set("Finished");
}

function render()
{
    outStarted.set(started);

    if (!started)
    {
        next.trigger();
        return;
    }

    const oldInternalNow = CABLES.internalNow;

    if (started)
    {
        CABLES.internalNow = function ()
        {
            return time * 1000;
        };

        updateTime();
        // CABLES.overwriteTime = time;
        // op.patch.timer.setTime(time);
        // op.patch.freeTimer.setTime(time);
    }

    if (lastFrame == countFrames)
    {
        next.trigger();
        return;
    }

    lastFrame = countFrames;

    let prog = countFrames / numFrames;
    if (prog < 0.0) prog = 0.0;
    outProgress.set(prog);
    outFrame.set(countFrames);

    next.trigger();

    CABLES.internalNow = oldInternalNow;

    frameStarted = false;
    if (countFrames > numFrames)
    {
        op.log("FINISHED...");
        op.log("ffmpeg -y -framerate 30 -f image2 -i " + filenamePrefix + "_%d.png  -b 9999k -vcodec mpeg4 " + shortId + ".mp4");

        if (!useCanvasSize.get())
        {
            op.patch.cgl.setSize(oldSizeW, oldSizeH);
            op.patch.cgl.updateSize();
        }

        if (zip)
        {
            zip.generateAsync({ "type": "blob" })
                .then(function (blob)
                {
                    const anchor = document.createElement("a");
                    anchor.download = filenamePrefix + ".zip";
                    anchor.href = URL.createObjectURL(blob);
                    if (inDownload.get())
                    {
                        anchor.click();
                    }
                    stopRendering();
                    if (outUrl.isLinked())
                    {
                        blobToDataURL(blob, (dataUrl) => { outUrl.set(dataUrl); outFinished.trigger(); });
                    }
                    else
                    {
                        outUrl.set(null);
                        outFinished.trigger();
                    }
                });
        }
        else
        if (inType.get() == "WebM")
        {
            try
            {
                outStatus.set("Creating Video File from frames");
                op.log("webm frames", frames.length);

                const video = Whammy.fromImageArray(frames, fps);
                const url = window.URL.createObjectURL(video);
                const anchor = document.createElement("a");

                anchor.setAttribute("download", filenamePrefix + ".webm");
                anchor.setAttribute("href", url);
                document.body.appendChild(anchor);
                if (inDownload.get())
                {
                    anchor.click();
                }
                stopRendering();
                if (outUrl.isLinked())
                {
                    blobToDataURL(video, (dataUrl) => { outUrl.set(dataUrl); outFinished.trigger(); });
                }
                else
                {
                    outUrl.set(null);
                    outFinished.trigger();
                }
            }
            catch (e)
            {
                op.logError(e);
            }

            frames.length = 0;
        }
        else
            stopRendering();

        return;
    }

    let mimetype = "image/png";
    let suffix = "png";

    if (inType.get() == "JPG")
    {
        mimetype = "image/jpeg";
        suffix = "jpg";
    }
    else if (inType.get() == "WebP")
    {
        mimetype = "image/webp";
        suffix = "webp";
    }

    if (countFrames > 0)
    {
        outStatus.set("Rendering Frame " + countFrames + " of " + numFrames);
        op.log("Rendering Frame " + countFrames + " of " + numFrames, time);
        if (inType.get() == "WebM")
        {
            frames.push(op.patch.cgl.canvas.toDataURL("image/webp", inQuality.get() * 0.999));
            countFrames++;
            updateTime();
        }
        else
        {
            op.log("screenshotting frame...", countFrames);
            op.patch.cgl.screenShot((blob) =>
            {
                if (blob)
                {
                    if (zip)
                    {
                        let filename = filenamePrefix + "_" + countFrames + "." + suffix;

                        zip.file(filename, blob, { "base64": false });
                        countFrames++;
                        updateTime();
                    }
                    else
                    {
                        let filename = filenamePrefix + "_" + shortId + "_" + countFrames + "." + suffix;

                        const anchor = document.createElement("a");
                        anchor.download = filename;
                        anchor.href = URL.createObjectURL(blob);

                        setTimeout(() =>
                        {
                            if (outUrl.isLinked())
                            {
                                blobToDataURL(blob, (dataUrl) => { outUrl.set(dataUrl); });
                            }
                            else
                            {
                                outUrl.set(null);
                            }
                            if (inDownload.get())
                            {
                                anchor.click();
                            }
                            countFrames++;
                            updateTime();
                        }, 200);
                    }
                }
                else
                {
                    op.log("screenshot: no blob");
                }
            }, !inTransparency.get(), mimetype, inQuality.get());
        }
    }
    else
    {
        outStatus.set("Prerendering...");
        op.log("pre ", countFrames, time);
        op.patch.cgl.screenShot((blob) =>
        {
            countFrames++;
            updateTime();
        });
    }
}

function blobToDataURL(blob, callback)
{
    let a = new FileReader();
    a.onload = function (e) { callback(e.target.result); };
    a.readAsDataURL(blob);
}


};

Ops.Gl.RenderAnim_v2.prototype = new CABLES.Op();
CABLES.OPS["c05e54a3-3ed5-4941-a412-01134f53f0ac"]={f:Ops.Gl.RenderAnim_v2,objName:"Ops.Gl.RenderAnim_v2"};




// **************************************************************
// 
// Ops.Gl.RenderGeometry
// 
// **************************************************************

Ops.Gl.RenderGeometry = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    geometry = op.inObject("Geometry", null, "geometry"),
    updateAll = op.inValueBool("Update All", true),
    updateFaces = op.inValueBool("Update Face Indices", false),
    updateVerts = op.inValueBool("Update Vertices", false),
    updateTexcoords = op.inValueBool("Update Texcoords", false),
    vertNums = op.inValueBool("Vertex Numbers", true),
    trigger = op.outTrigger("trigger");

geometry.ignoreValueSerialize = true;

vertNums.onChange =
    geometry.onChange = update;

let mesh = null;

op.toWorkPortsNeedToBeLinked(geometry, render);

render.onTriggered = function ()
{
    if (mesh) mesh.render(op.patch.cgl.getShader());
    trigger.trigger();
};

function update()
{
    const geom = geometry.get();
    if (geom && geom instanceof CGL.Geometry)
    {
        if (mesh)
        {
            mesh.dispose();
            mesh = null;
        }
        if (!mesh)
        {
            mesh = new CGL.Mesh(op.patch.cgl, geom);
            mesh.addVertexNumbers = vertNums.get();
            mesh.setGeom(geom);
        }

        if (updateFaces.get() || updateAll.get())
            mesh.setVertexIndices(geom.verticesIndices);

        if (updateTexcoords.get() || updateAll.get())
            mesh.updateTexCoords(geom);

        if (updateVerts.get() || updateAll.get())
            mesh.updateVertices(geom);

        mesh.addVertexNumbers = vertNums.get();

        if (updateAll.get())
        {
            if (geom.hasOwnProperty("tangents") && geom.tangents && geom.tangents.length > 0) mesh.setAttribute("attrTangent", geom.tangents, 3);
            if (geom.hasOwnProperty("biTangents") && geom.biTangents && geom.biTangents.length > 0) mesh.setAttribute("attrBiTangent", geom.biTangents, 3);
        }
    }
    else
    {
        mesh = null;
    }
}


};

Ops.Gl.RenderGeometry.prototype = new CABLES.Op();
CABLES.OPS["40fa6f13-ee0e-4386-a86b-711e1fbcf1bc"]={f:Ops.Gl.RenderGeometry,objName:"Ops.Gl.RenderGeometry"};




// **************************************************************
// 
// Ops.Gl.ResetTransform
// 
// **************************************************************

Ops.Gl.ResetTransform = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    trigger = op.outTrigger("trigger"),
    inM = op.inBool("Reset Model Transform", true),
    inV = op.inBool("Reset View Transform", true),
    inDV = op.inBool("Default View", true),
    cgl = op.patch.cgl;

let doView = false,
    doModel = false,
    vDefault = false;

const identView = vec3.create();
vec3.set(identView, 0, 0, -2);

exe.onTriggered = ex;

inM.onChange =
    inDV.onChange =
    inV.onChange = updateState;
updateState();

function updateState()
{
    doView = inV.get();
    doModel = inM.get();
    vDefault = inDV.get();
    inDV.setUiAttribs({ "greyout": !doView });
}


function ex()
{
    if (doView)
    {
        cgl.pushViewMatrix();
        mat4.identity(cgl.vMatrix);
        if (vDefault)
        {
            mat4.translate(cgl.vMatrix, cgl.vMatrix, identView);
        }
    }

    if (doModel)
    {
        cgl.pushModelMatrix();
        mat4.identity(cgl.mMatrix);
    }

    trigger.trigger();

    if (doView) cgl.popViewMatrix();
    if (doModel) cgl.popModelMatrix();
}


};

Ops.Gl.ResetTransform.prototype = new CABLES.Op();
CABLES.OPS["1bf7c63e-e2c2-42e2-abb3-42235e7e24f0"]={f:Ops.Gl.ResetTransform,objName:"Ops.Gl.ResetTransform"};




// **************************************************************
// 
// Ops.Gl.SaveScreenShot_v3
// 
// **************************************************************

Ops.Gl.SaveScreenShot_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    filename = op.inString("Filename", "cables"),
    exe = op.inTriggerButton("Screenshot"),
    outNext = op.outTrigger("Finished");


const cgl = op.patch.cgl;

exe.onTriggered = function ()
{
    cgl.saveScreenshot(
        filename.get(),
        function ()
        {
            outNext.trigger();

            op.patch.resume();
        }
    );
};



};

Ops.Gl.SaveScreenShot_v3.prototype = new CABLES.Op();
CABLES.OPS["76843a4d-947f-41ca-9c8f-0faa6ce7380a"]={f:Ops.Gl.SaveScreenShot_v3,objName:"Ops.Gl.SaveScreenShot_v3"};




// **************************************************************
// 
// Ops.Gl.Shader.AttributeAsColorMaterial
// 
// **************************************************************

Ops.Gl.Shader.AttributeAsColorMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"normalsmaterial_frag":"IN vec3 normal;\nIN vec3 outTangent;\nIN vec3 outBiTangent;\nIN mat4 mMatrix;\nIN vec2 texCoord;\nIN vec3 vert;\nIN mat4 mvMatrix;\n\n\n{{MODULES_HEAD}}\n\nvoid main()\n{\n    #ifdef MULMODEL\n        vec4 attr;\n        attr.w=1.0;\n    #endif\n    #ifndef MULMODEL\n        vec3 attr;\n    #endif\n\n    #ifdef SHOW_NORMALS\n        attr.xyz=normal;\n    #endif\n    #ifdef SHOW_BITANGENTS\n        attr.xyz=outBiTangent;\n    #endif\n    #ifdef SHOW_TANGENTS\n        attr.xyz=outTangent;\n    #endif\n    #ifdef SHOW_TEXCOORDS\n        attr.xy=texCoord;\n    #endif\n    #ifdef SHOW_POSITION\n        attr.xyz=vert;\n    #endif\n\n    #ifdef MULMODEL\n        attr*=mMatrix;\n        attr.xyz=normalize(vec3(attr.x,attr.y,attr.z));\n    #endif\n\n    vec4 col=vec4(attr.x,attr.y,attr.z,1.0);\n\n    #ifdef ABS\n        col=abs(col);\n    #endif\n\n    {{MODULE_COLOR}}\n\n    outColor=col;\n}","normalsmaterial_vert":"IN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal,attrTangent,attrBiTangent;\nOUT vec2 texCoord;\nOUT vec3 normal;\nOUT vec3 tangent;\nOUT vec3 bitangent;\nOUT vec3 outTangent,outBiTangent;\nOUT mat4 mMatrix;\nOUT vec3 vert;\nOUT mat4 mvMatrix;\nUNI mat4 projMatrix;\n\n// UNI mat4 mvMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n\n{{MODULES_HEAD}}\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    vec3 norm=attrVertNormal;\n    tangent=attrTangent;\n    bitangent=attrBiTangent;\n\n    vec4 pos=vec4(vPosition,1.0);\n    mMatrix=modelMatrix;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat4 mvMatrix=viewMatrix*mMatrix;\n\n    vert=pos.xyz;\n    normal=norm;\n    outTangent=tangent;\n    outBiTangent=bitangent;\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}",};
const
    render = op.inTrigger("render"),
    inAttr = op.inSwitch("Attribute", ["TexCoords", "Normals", "Tangents", "BiTangents"], "Normals"),
    inAbs = op.inBool("Absolute", false),
    inMulModel = op.inBool("World Space", false),
    trigger = op.outTrigger("trigger"),
    outShader = op.outObject("Shader");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(attachments.normalsmaterial_vert, attachments.normalsmaterial_frag);
outShader.set(shader);
render.onTriggered = doRender;
updateAttr();
inMulModel.onChange = inAbs.onChange = inAttr.onChange = updateAttr;

function updateAttr()
{
    shader.toggleDefine("SHOW_NORMALS", inAttr.get() == "Normals");
    shader.toggleDefine("SHOW_TANGENTS", inAttr.get() == "Tangents");
    shader.toggleDefine("SHOW_BITANGENTS", inAttr.get() == "BiTangents");
    shader.toggleDefine("SHOW_TEXCOORDS", inAttr.get() == "TexCoords");

    shader.toggleDefine("ABS", inAbs.get());
    shader.toggleDefine("MULMODEL", inMulModel.get());
}

function doRender()
{
    cgl.pushShader(shader);
    trigger.trigger();
    cgl.popShader();
}


};

Ops.Gl.Shader.AttributeAsColorMaterial.prototype = new CABLES.Op();
CABLES.OPS["2963fd23-a860-461a-a3cf-394b8261159f"]={f:Ops.Gl.Shader.AttributeAsColorMaterial,objName:"Ops.Gl.Shader.AttributeAsColorMaterial"};




// **************************************************************
// 
// Ops.Gl.Shader.BasicMaterial_v3
// 
// **************************************************************

Ops.Gl.Shader.BasicMaterial_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"basicmaterial_frag":"{{MODULES_HEAD}}\n\nIN vec2 texCoord;\n\n#ifdef VERTEX_COLORS\nIN vec4 vertCol;\n#endif\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoordOrig;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        UNI sampler2D texOpacity;\n   #endif\n#endif\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col=color;\n\n\n    #ifdef HAS_TEXTURES\n        vec2 uv=texCoord;\n\n        #ifdef CROP_TEXCOORDS\n            if(uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) discard;\n        #endif\n\n        #ifdef HAS_TEXTURE_DIFFUSE\n            col=texture(tex,uv);\n\n            #ifdef COLORIZE_TEXTURE\n                col.r*=color.r;\n                col.g*=color.g;\n                col.b*=color.b;\n            #endif\n        #endif\n        col.a*=color.a;\n        #ifdef HAS_TEXTURE_OPACITY\n            #ifdef TRANSFORMALPHATEXCOORDS\n                uv=texCoordOrig;\n            #endif\n            #ifdef ALPHA_MASK_IALPHA\n                col.a*=1.0-texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_ALPHA\n                col.a*=texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_LUMI\n                col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,uv).rgb);\n            #endif\n            #ifdef ALPHA_MASK_R\n                col.a*=texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_G\n                col.a*=texture(texOpacity,uv).g;\n            #endif\n            #ifdef ALPHA_MASK_B\n                col.a*=texture(texOpacity,uv).b;\n            #endif\n            // #endif\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    #ifdef DISCARDTRANS\n        if(col.a<0.2) discard;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        col*=vertCol;\n    #endif\n\n    outColor = col;\n}\n","basicmaterial_vert":"\n{{MODULES_HEAD}}\n\n// OUT vec3 norm;\nOUT vec2 texCoord;\nOUT vec2 texCoordOrig;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n#ifdef HAS_TEXTURES\n    UNI float diffuseRepeatX;\n    UNI float diffuseRepeatY;\n    UNI float texOffsetX;\n    UNI float texOffsetY;\n#endif\n\n#ifdef VERTEX_COLORS\n    in vec4 attrVertColor;\n    out vec4 vertCol;\n\n#endif\n\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    mat4 mvMatrix;\n\n    norm=attrVertNormal;\n    texCoordOrig=attrTexCoord;\n    texCoord=attrTexCoord;\n    #ifdef HAS_TEXTURES\n        texCoord.x=texCoord.x*diffuseRepeatX+texOffsetX;\n        texCoord.y=(1.0-texCoord.y)*diffuseRepeatY+texOffsetY;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        vertCol=attrVertColor;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.0);\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       mvMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * mvMatrix * vec4((\n           position.x * vec3(\n               mvMatrix[0][0],\n               mvMatrix[1][0],\n               mvMatrix[2][0] ) +\n           position.y * vec3(\n               mvMatrix[0][1],\n               mvMatrix[1][1],\n               mvMatrix[2][1]) ), 1.0);\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        mvMatrix=viewMatrix * mMatrix;\n    #endif\n\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * mvMatrix * pos;\n    #endif\n}\n",};
const render = op.inTrigger("render");

const trigger = op.outTrigger("trigger");
const shaderOut = op.outObject("shader", null, "shader");

shaderOut.ignoreValueSerialize = true;

op.toWorkPortsNeedToBeLinked(render);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "basicmaterialnew");
shader.addAttribute({ "type": "vec3", "name": "vPosition" });
shader.addAttribute({ "type": "vec2", "name": "attrTexCoord" });
shader.addAttribute({ "type": "vec3", "name": "attrVertNormal", "nameFrag": "norm" });
shader.addAttribute({ "type": "float", "name": "attrVertIndex" });

shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);

shader.setSource(attachments.basicmaterial_vert, attachments.basicmaterial_frag);

shaderOut.set(shader);

render.onTriggered = doRender;

// rgba colors
const r = op.inValueSlider("r", Math.random());
const g = op.inValueSlider("g", Math.random());
const b = op.inValueSlider("b", Math.random());
const a = op.inValueSlider("a", 1);
r.setUiAttribs({ "colorPick": true });

// const uniColor=new CGL.Uniform(shader,'4f','color',r,g,b,a);
const colUni = shader.addUniformFrag("4f", "color", r, g, b, a);

shader.uniformColorDiffuse = colUni;

// diffuse outTexture

const diffuseTexture = op.inTexture("texture");
let diffuseTextureUniform = null;
diffuseTexture.onChange = updateDiffuseTexture;

const colorizeTexture = op.inValueBool("colorizeTexture", false);
const vertexColors = op.inValueBool("Vertex Colors", false);

// opacity texture
const textureOpacity = op.inTexture("textureOpacity");
let textureOpacityUniform = null;

const alphaMaskSource = op.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A", "1-A"], "Luminance");
alphaMaskSource.setUiAttribs({ "greyout": true });
textureOpacity.onChange = updateOpacity;

const texCoordAlpha = op.inValueBool("Opacity TexCoords Transform", false);
const discardTransPxl = op.inValueBool("Discard Transparent Pixels");

// texture coords
const
    diffuseRepeatX = op.inValue("diffuseRepeatX", 1),
    diffuseRepeatY = op.inValue("diffuseRepeatY", 1),
    diffuseOffsetX = op.inValue("Tex Offset X", 0),
    diffuseOffsetY = op.inValue("Tex Offset Y", 0),
    cropRepeat = op.inBool("Crop TexCoords", false);

shader.addUniformFrag("f", "diffuseRepeatX", diffuseRepeatX);
shader.addUniformFrag("f", "diffuseRepeatY", diffuseRepeatY);
shader.addUniformFrag("f", "texOffsetX", diffuseOffsetX);
shader.addUniformFrag("f", "texOffsetY", diffuseOffsetY);

const doBillboard = op.inValueBool("billboard", false);

alphaMaskSource.onChange =
    doBillboard.onChange =
    discardTransPxl.onChange =
    texCoordAlpha.onChange =
    cropRepeat.onChange =
    vertexColors.onChange =
    colorizeTexture.onChange = updateDefines;

op.setPortGroup("Color", [r, g, b, a]);
op.setPortGroup("Color Texture", [diffuseTexture, vertexColors, colorizeTexture]);
op.setPortGroup("Opacity", [textureOpacity, alphaMaskSource, discardTransPxl, texCoordAlpha]);
op.setPortGroup("Texture Transform", [diffuseRepeatX, diffuseRepeatY, diffuseOffsetX, diffuseOffsetY, cropRepeat]);

updateOpacity();
updateDiffuseTexture();

op.preRender = function ()
{
    shader.bind();
    doRender();
};

function doRender()
{
    if (!shader) return;

    cgl.pushShader(shader);
    shader.popTextures();

    if (diffuseTextureUniform && diffuseTexture.get()) shader.pushTexture(diffuseTextureUniform, diffuseTexture.get());
    if (textureOpacityUniform && textureOpacity.get()) shader.pushTexture(textureOpacityUniform, textureOpacity.get());

    trigger.trigger();

    cgl.popShader();
}

function updateOpacity()
{
    if (textureOpacity.get())
    {
        if (textureOpacityUniform !== null) return;
        shader.removeUniform("texOpacity");
        shader.define("HAS_TEXTURE_OPACITY");
        if (!textureOpacityUniform)textureOpacityUniform = new CGL.Uniform(shader, "t", "texOpacity");

        alphaMaskSource.setUiAttribs({ "greyout": false });
        texCoordAlpha.setUiAttribs({ "greyout": false });
    }
    else
    {
        shader.removeUniform("texOpacity");
        shader.removeDefine("HAS_TEXTURE_OPACITY");
        textureOpacityUniform = null;

        alphaMaskSource.setUiAttribs({ "greyout": true });
        texCoordAlpha.setUiAttribs({ "greyout": true });
    }

    updateDefines();
}

function updateDiffuseTexture()
{
    if (diffuseTexture.get())
    {
        if (!shader.hasDefine("HAS_TEXTURE_DIFFUSE"))shader.define("HAS_TEXTURE_DIFFUSE");
        if (!diffuseTextureUniform)diffuseTextureUniform = new CGL.Uniform(shader, "t", "texDiffuse");

        diffuseRepeatX.setUiAttribs({ "greyout": false });
        diffuseRepeatY.setUiAttribs({ "greyout": false });
        diffuseOffsetX.setUiAttribs({ "greyout": false });
        diffuseOffsetY.setUiAttribs({ "greyout": false });
        colorizeTexture.setUiAttribs({ "greyout": false });
    }
    else
    {
        shader.removeUniform("texDiffuse");
        shader.removeDefine("HAS_TEXTURE_DIFFUSE");
        diffuseTextureUniform = null;

        diffuseRepeatX.setUiAttribs({ "greyout": true });
        diffuseRepeatY.setUiAttribs({ "greyout": true });
        diffuseOffsetX.setUiAttribs({ "greyout": true });
        diffuseOffsetY.setUiAttribs({ "greyout": true });
        colorizeTexture.setUiAttribs({ "greyout": true });
    }
}

function updateDefines()
{
    shader.toggleDefine("VERTEX_COLORS", vertexColors.get());
    shader.toggleDefine("CROP_TEXCOORDS", cropRepeat.get());
    shader.toggleDefine("COLORIZE_TEXTURE", colorizeTexture.get());
    shader.toggleDefine("TRANSFORMALPHATEXCOORDS", texCoordAlpha.get());
    shader.toggleDefine("DISCARDTRANS", discardTransPxl.get());
    shader.toggleDefine("BILLBOARD", doBillboard.get());

    shader.toggleDefine("ALPHA_MASK_ALPHA", alphaMaskSource.get() == "A");
    shader.toggleDefine("ALPHA_MASK_IALPHA", alphaMaskSource.get() == "1-A");
    shader.toggleDefine("ALPHA_MASK_LUMI", alphaMaskSource.get() == "Luminance");
    shader.toggleDefine("ALPHA_MASK_R", alphaMaskSource.get() == "R");
    shader.toggleDefine("ALPHA_MASK_G", alphaMaskSource.get() == "G");
    shader.toggleDefine("ALPHA_MASK_B", alphaMaskSource.get() == "B");
}


};

Ops.Gl.Shader.BasicMaterial_v3.prototype = new CABLES.Op();
CABLES.OPS["ec55d252-3843-41b1-b731-0482dbd9e72b"]={f:Ops.Gl.Shader.BasicMaterial_v3,objName:"Ops.Gl.Shader.BasicMaterial_v3"};




// **************************************************************
// 
// Ops.Gl.Shader.ChromaKeyMaterial
// 
// **************************************************************

Ops.Gl.Shader.ChromaKeyMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"chromakeymaterial_frag":"{{MODULE_BEGIN_FRAG}}\n\nIN vec2 texCoord;\n\nUNI sampler2D tex;\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float weightMul;\nUNI float white;\n\nvec3 rgb2hsv(vec4 rgb)\n{\n\tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n\tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n    float delta = Cmax - Cmin;\n\n\tvec3 hsv = vec3(0., 0., Cmax);\n\n\tif (Cmax > Cmin)\n\t{\n\t\thsv.y = delta / Cmax;\n\n\t\tif (rgb.r == Cmax)\n\t\t\thsv.x = (rgb.g - rgb.b) / delta;\n\t\telse\n\t\t{\n\t\t\tif (rgb.g == Cmax)\n\t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n\t\t\telse\n\t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n\t\t}\n\t\thsv.x = fract(hsv.x / 6.);\n\t}\n\treturn hsv;\n}\n\nfloat chromaKey(vec4 color)\n{\n    vec4 backgroundColor = vec4(r,g,b,0.0);\n    vec3 weights = vec3(4.*weightMul, 1., 2.*weightMul);\n\n    vec3 hsv = rgb2hsv(color);\n    vec3 target = rgb2hsv(backgroundColor);\n    float dist = length(weights * (target - hsv));\n\n    return 1. - clamp(3. * dist - 1.5, 0., 1.);\n}\n\nfloat random(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * (43758.5453));\n}\n\nvoid main()\n{\n    vec4 col=vec4(1.0,1.0,0.0,1.0);\n    {{MODULE_COLOR}}\n    col=texture(tex,texCoord);\n\n    #ifdef MODE_R\n       float maxrb = max( col.g, col.b );\n       float perc = min(1.0,(col.r*weightMul-maxrb)*2.0);\n    #endif\n\n    #ifdef MODE_G\n       float maxrb = max( col.r, col.b );\n       float perc = min(1.0,(col.g*weightMul-maxrb)*2.0);\n       col.g=min(maxrb,col.g);\n    #endif\n\n    #ifdef MODE_COLOR\n        float perc=chromaKey(col);\n    #endif\n\n    float len=length(col);\n    col=normalize(col)*len;\n\n    col.a=1.0-perc;\n    outColor= col;\n}\n","chromakeymaterial_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\nIN vec2 attrTexCoord;\nOUT vec2 texCoord;\n\nUNI float diffuseRepeatX;\nUNI float diffuseRepeatY;\nUNI float texOffsetX;\nUNI float texOffsetY;\n\nvoid main()\n{\n   texCoord=vec2(attrTexCoord.x,1.0-attrTexCoord.y);\n\n   texCoord.s=texCoord.s*diffuseRepeatX+texOffsetX;\n   texCoord.t=texCoord.t*diffuseRepeatY+texOffsetY;\n\n   vec4 pos=vec4(vPosition,  1.0);\n   {{MODULE_VERTEX_POSITION}}\n   gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
const render = op.inTrigger("render");
const texture = op.inTexture("texture");

const inMode = op.inValueSelect("Mode", ["G", "R", "COLOR"], "COLOR");
const trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;

render.onTriggered = doRender;

let textureUniform = null;
let shader = new CGL.Shader(cgl, "MinimalMaterial");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.chromakeymaterial_vert, attachments.chromakeymaterial_frag);
shader.define("MODE_COLOR");

op.toWorkPortsNeedToBeLinked(texture);

function doRender()
{
    if (shader)
    {
        cgl.pushShader(shader);
        shader.bindTextures();
        trigger.trigger();
        cgl.popShader();
    }
}

shader.bindTextures = function ()
{
    if (texture.get()) cgl.setTexture(0, texture.get().tex);
    // else cgl.setTexture(0, CGL.Texture.getTemporaryTexture());
};

inMode.onChange = function ()
{
    shader.removeDefine("MODE_G");
    shader.removeDefine("MODE_R");
    shader.removeDefine("MODE_COLOR");
    if (inMode.get() == "R") shader.define("MODE_R");
    else if (inMode.get() == "G") shader.define("MODE_G");
    else if (inMode.get() == "COLOR") shader.define("MODE_COLOR");
};

texture.onChange = function ()
{
    if (texture.get())
    {
        if (textureUniform !== null) return;
        shader.removeUniform("tex");
        shader.define("HAS_TEXTURE_DIFFUSE");
        textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
    }
    else
    {
        shader.removeUniform("tex");
        shader.removeDefine("HAS_TEXTURE_DIFFUSE");
        textureUniform = null;
    }
};

let w = op.inValueSlider("weightMul", 0.6);
w.uniform = new CGL.Uniform(shader, "f", "weightMul", w);

const r = op.inValueSlider("r", Math.random());
const g = op.inValueSlider("g", Math.random());
const b = op.inValueSlider("b", Math.random());
r.setUiAttribs({ "colorPick": true });

r.set(0.467);
r.uniform = new CGL.Uniform(shader, "f", "r", r);

g.set(0.836);
g.uniform = new CGL.Uniform(shader, "f", "g", g);

b.set(0.098);
b.uniform = new CGL.Uniform(shader, "f", "b", b);

let white = op.inValueSlider("white", 0);
white.uniform = new CGL.Uniform(shader, "f", "white", white);

const diffuseRepeatX = op.inValue("diffuseRepeatX", 1);
const diffuseRepeatY = op.inValue("diffuseRepeatY", 1);

const diffuseOffsetX = op.inValue("Tex Offset X", 0);
const diffuseOffsetY = op.inValue("Tex Offset Y", 0);

const diffuseRepeatXUniform = new CGL.Uniform(shader, "f", "diffuseRepeatX", diffuseRepeatX);
const diffuseRepeatYUniform = new CGL.Uniform(shader, "f", "diffuseRepeatY", diffuseRepeatY);
const diffuseOffsetXUniform = new CGL.Uniform(shader, "f", "texOffsetX", diffuseOffsetX);
const diffuseOffsetYUniform = new CGL.Uniform(shader, "f", "texOffsetY", diffuseOffsetY);


};

Ops.Gl.Shader.ChromaKeyMaterial.prototype = new CABLES.Op();
CABLES.OPS["20be6064-b332-447c-a220-e70d5bc506e0"]={f:Ops.Gl.Shader.ChromaKeyMaterial,objName:"Ops.Gl.Shader.ChromaKeyMaterial"};




// **************************************************************
// 
// Ops.Gl.Shader.CustomShader_v2
// 
// **************************************************************

Ops.Gl.Shader.CustomShader_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    fragmentShader = op.inStringEditor("Fragment Code"),
    vertexShader = op.inStringEditor("Vertex Code"),
    asMaterial = op.inValueBool("Use As Material", true),
    trigger = op.outTrigger("trigger"),
    outShader = op.outObject("Shader", null, "shader"),
    outErrors = op.outBool("Has Errors");

const cgl = op.patch.cgl;
const uniformInputs = [];
const uniformTextures = [];
const vectors = [];

op.toWorkPortsNeedToBeLinked(render);

fragmentShader.setUiAttribs({ "editorSyntax": "glsl" });
vertexShader.setUiAttribs({ "editorSyntax": "glsl" });

const shader = new CGL.Shader(cgl, op.name);

shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);

op.setPortGroup("Source Code", [fragmentShader, vertexShader]);
op.setPortGroup("Options", [asMaterial]);

fragmentShader.set(CGL.Shader.getDefaultFragmentShader());
vertexShader.set(CGL.Shader.getDefaultVertexShader());

fragmentShader.onChange = vertexShader.onChange = function ()
{
    if (fragmentShader.isLinked() && !fragmentShader.get()) return;
    needsUpdate = true;
};

render.onTriggered = doRender;

let needsUpdate = true;
op.onLoadedValueSet = initDataOnLoad;

function initDataOnLoad(data)
{
    updateShader();

    // set uniform values AFTER shader has been compiled and uniforms are extracted and uniform ports are created.
    for (let i = 0; i < uniformInputs.length; i++)
        for (let j = 0; j < data.portsIn.length; j++)
            if (uniformInputs[i] && uniformInputs[i].name == data.portsIn[j].name)
            {
                uniformInputs[i].set(data.portsIn[j].value);
                uniformInputs[i].deSerializeSettings(data.portsIn[j]);
            }
}

op.init = function ()
{
    updateShader();
};

function doRender()
{
    setVectorValues();
    if (needsUpdate)updateShader();
    if (asMaterial.get()) cgl.pushShader(shader);
    pushTextures();
    trigger.trigger();
    shader.popTextures();
    if (asMaterial.get()) cgl.popShader();
}

function pushTextures()
{
    for (let i = 0; i < uniformTextures.length; i++)
        if (uniformTextures[i] && uniformTextures[i].get() && uniformTextures[i].get().tex)
            shader.pushTexture(uniformTextures[i].uniform, uniformTextures[i].get().tex);
        else
            shader.pushTexture(uniformTextures[i], CGL.Texture.getEmptyTexture(cgl));
}

function bindTextures()// old - should be removed in next version ?
{
    for (let i = 0; i < uniformTextures.length; i++)
        if (uniformTextures[i] && uniformTextures[i].get() && uniformTextures[i].get().tex)
            cgl.setTexture(0 + i + 3, uniformTextures[i].get().tex);
}

function hasUniformInput(name)
{
    for (let i = 0; i < uniformInputs.length; i++) if (uniformInputs[i] && uniformInputs[i].name == name) return true;
    for (let i = 0; i < uniformTextures.length; i++) if (uniformTextures[i] && uniformTextures[i].name == name) return true;
    return false;
}

const tempMat4 = mat4.create();
const uniformNameBlacklist = [
    "modelMatrix",
    "viewMatrix",
    "normalMatrix",
    "mvMatrix",
    "projMatrix",
    "inverseViewMatrix",
    "camPos"
];

let countTexture = 0;
const foundNames = [];

function parseUniforms(src)
{
    const lblines = src.split("\n");
    const groupUniforms = [];

    for (let k = 0; k < lblines.length; k++)
    {
        const lines = lblines[k].split(";");

        for (let i = 0; i < lines.length; i++)
        {
            let words = lines[i].split(" ");

            for (let j = 0; j < words.length; j++) words[j] = (words[j] + "").trim();

            if (words[0] === "UNI" || words[0] === "uniform")
            {
                let varnames = words[2];
                if (words.length > 4) for (let j = 3; j < words.length; j++)varnames += words[j];

                words = words.filter(function (el) { return el !== ""; });
                const type = words[1];

                let names = [varnames];
                if (varnames.indexOf(",") > -1) names = varnames.split(",");

                for (let l = 0; l < names.length; l++)
                {
                    if (uniformNameBlacklist.indexOf(names[l]) > -1) continue;
                    const uniName = names[l].trim();

                    if (type === "float")
                    {
                        foundNames.push(uniName);
                        if (!hasUniformInput(uniName))
                        {
                            const newInput = op.inFloat(uniName, 0);
                            newInput.uniform = new CGL.Uniform(shader, "f", uniName, newInput);
                            uniformInputs.push(newInput);
                            groupUniforms.push(newInput);
                        }
                    }
                    else if (type === "int")
                    {
                        foundNames.push(uniName);
                        if (!hasUniformInput(uniName))
                        {
                            const newInput = op.inInt(uniName, 0);
                            newInput.uniform = new CGL.Uniform(shader, "i", uniName, newInput);
                            uniformInputs.push(newInput);
                            groupUniforms.push(newInput);
                        }
                    }
                    else if (type === "bool")
                    {
                        foundNames.push(uniName);
                        if (!hasUniformInput(uniName))
                        {
                            const newInput = op.inBool(uniName, false);
                            newInput.uniform = new CGL.Uniform(shader, "b", uniName, newInput);
                            uniformInputs.push(newInput);
                            groupUniforms.push(newInput);
                        }
                    }
                    else if (type === "mat4")
                    {
                        foundNames.push(uniName);
                        if (!hasUniformInput(uniName))
                        {
                            const newInput = op.inArray(uniName, 0);
                            newInput.uniform = new CGL.Uniform(shader, "m4", uniName, newInput);
                            uniformInputs.push(newInput);
                            groupUniforms.push(newInput);

                            const vec = {
                                "name": uniName,
                                "num": 16,
                                "port": newInput,
                                "uni": newInput.uniform,
                                "changed": false
                            };
                            newInput.onChange = function () { this.changed = true; }.bind(vec);

                            vectors.push(vec);
                        }
                    }
                    else if (type === "sampler2D" || type === "samplerCube")
                    {
                        foundNames.push(uniName);
                        if (!hasUniformInput(uniName))
                        {
                            const newInputTex = op.inObject(uniName);

                            let uniType = "t";
                            if (type === "samplerCube")uniType = "tc";

                            newInputTex.uniform = new CGL.Uniform(shader, uniType, uniName, 3 + uniformTextures.length);
                            uniformTextures.push(newInputTex);
                            groupUniforms.push(newInputTex);
                            newInputTex.set(CGL.Texture.getTempTexture(cgl));
                            newInputTex.on("change", (v, p) =>
                            {
                                if (!v)p.set(CGL.Texture.getTempTexture(cgl));
                            });
                            countTexture++;
                        }
                    }
                    else if (type === "vec3" || type === "vec2" || type === "vec4")
                    {
                        let num = 2;
                        if (type === "vec4")num = 4;
                        if (type === "vec3")num = 3;
                        foundNames.push(uniName + " X");
                        foundNames.push(uniName + " Y");
                        if (num > 2)foundNames.push(uniName + " Z");
                        if (num > 3)foundNames.push(uniName + " W");

                        if (!hasUniformInput(uniName + " X"))
                        {
                            const group = [];
                            const vec = {
                                "name": uniName,
                                "num": num,
                                "changed": false,
                            };
                            vectors.push(vec);
                            initVectorUniform(vec);

                            const newInputX = op.inFloat(uniName + " X", 0);
                            newInputX.onChange = function () { this.changed = true; }.bind(vec);
                            uniformInputs.push(newInputX);
                            group.push(newInputX);
                            vec.x = newInputX;

                            const newInputY = op.inFloat(uniName + " Y", 0);
                            newInputY.onChange = function () { this.changed = true; }.bind(vec);
                            uniformInputs.push(newInputY);
                            group.push(newInputY);
                            vec.y = newInputY;

                            if (num > 2)
                            {
                                const newInputZ = op.inFloat(uniName + " Z", 0);
                                newInputZ.onChange = function () { this.changed = true; }.bind(vec);
                                uniformInputs.push(newInputZ);
                                group.push(newInputZ);
                                vec.z = newInputZ;
                            }
                            if (num > 3)
                            {
                                const newInputW = op.inFloat(uniName + " W", 0);
                                newInputW.onChange = function () { this.changed = true; }.bind(vec);
                                uniformInputs.push(newInputW);
                                group.push(newInputW);
                                vec.w = newInputW;
                            }

                            op.setPortGroup(uniName, group);
                        }
                    }
                }
            }
        }
    }
    op.setPortGroup("uniforms", groupUniforms);
}

function updateShader()
{
    if (!shader) return;

    shader.bindTextures = bindTextures.bind(this);
    shader.setSource(vertexShader.get(), fragmentShader.get());

    if (cgl.glVersion == 1)
    {
        cgl.gl.getExtension("OES_standard_derivatives");
        // cgl.gl.getExtension('OES_texture_float');
        // cgl.gl.getExtension('OES_texture_float_linear');
        // cgl.gl.getExtension('OES_texture_half_float');
        // cgl.gl.getExtension('OES_texture_half_float_linear');

        shader.enableExtension("GL_OES_standard_derivatives");
    // shader.enableExtension("GL_OES_texture_float");
    // shader.enableExtension("GL_OES_texture_float_linear");
    // shader.enableExtension("GL_OES_texture_half_float");
    // shader.enableExtension("GL_OES_texture_half_float_linear");
    }

    countTexture = 0;
    foundNames.length = 0;

    parseUniforms(vertexShader.get());
    parseUniforms(fragmentShader.get());

    for (let j = 0; j < uniformTextures.length; j++)
        for (let i = 0; i < foundNames.length; i++)
            if (uniformTextures[j] && foundNames.indexOf(uniformTextures[j].name) == -1)
            {
                uniformTextures[j].remove();
                uniformTextures[j] = null;
            }

    for (let j = 0; j < uniformInputs.length; j++)
        for (let i = 0; i < foundNames.length; i++)
            if (uniformInputs[j] && foundNames.indexOf(uniformInputs[j].name) == -1)
            {
                uniformInputs[j].remove();
                uniformInputs[j] = null;
            }

    for (let j = 0; j < vectors.length; j++)
    {
        initVectorUniform(vectors[j]);
        vectors[j].changed = true;
    }

    for (let i = 0; i < uniformInputs.length; i++)
        if (uniformInputs[i] && uniformInputs[i].uniform)uniformInputs[i].uniform.needsUpdate = true;

    shader.compile();

    op.refreshParams();

    outShader.set(null);
    outShader.set(shader);
    needsUpdate = false;

    if (shader.hasErrors()) op.setUiError("compile", "Shader has errors");
    else op.setUiError("compile", null);

    outErrors.set(shader.hasErrors());
}

function initVectorUniform(vec)
{
    if (vec.num == 2) vec.uni = new CGL.Uniform(shader, "2f", vec.name, [0, 0]);
    else if (vec.num == 3) vec.uni = new CGL.Uniform(shader, "3f", vec.name, [0, 0, 0]);
    else if (vec.num == 4) vec.uni = new CGL.Uniform(shader, "4f", vec.name, [0, 0, 0, 0]);
}

function setVectorValues()
{
    for (let i = 0; i < vectors.length; i++)
    {
        const v = vectors[i];
        if (v.changed)
        {
            if (v.num === 2) v.uni.setValue([v.x.get(), v.y.get()]);
            else if (v.num === 3) v.uni.setValue([v.x.get(), v.y.get(), v.z.get()]);
            else if (v.num === 4) v.uni.setValue([v.x.get(), v.y.get(), v.z.get(), v.w.get()]);

            else if (v.num > 4)
            {
                v.uni.setValue(v.port.get());
            }

            v.changed = false;
        }
    }
}


};

Ops.Gl.Shader.CustomShader_v2.prototype = new CABLES.Op();
CABLES.OPS["a165fc89-a35b-4d39-8930-7345b098bd9d"]={f:Ops.Gl.Shader.CustomShader_v2,objName:"Ops.Gl.Shader.CustomShader_v2"};




// **************************************************************
// 
// Ops.Gl.Shader.ErrorMaterial
// 
// **************************************************************

Ops.Gl.Shader.ErrorMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "errormaterial");

shader.setSource(CGL.Shader.getDefaultVertexShader(), CGL.Shader.getErrorFragmentShader());
render.onTriggered = doRender;

function doRender()
{
    cgl.pushShader(shader);
    trigger.trigger();
    cgl.popShader();
}


};

Ops.Gl.Shader.ErrorMaterial.prototype = new CABLES.Op();
CABLES.OPS["a16c565a-574d-48d2-a95e-1bdce96dc00f"]={f:Ops.Gl.Shader.ErrorMaterial,objName:"Ops.Gl.Shader.ErrorMaterial"};




// **************************************************************
// 
// Ops.Gl.Shader.FrontBacksideMaterial
// 
// **************************************************************

Ops.Gl.Shader.FrontBacksideMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"frontbacksidematerial_frag":"void main()\n{\n   if(!gl_FrontFacing) outColor= vec4(1.0,0.0,0.0,1.0);\n   else outColor=vec4(0.0,1.0,0.0,1.0);\n}",};
const render=op.inTrigger("render");
const next=op.outTrigger("next");
const cgl=op.patch.cgl;

const shader=new CGL.Shader(cgl,'showtexcoords material');
shader.setSource(shader.getDefaultVertexShader(),attachments.frontbacksidematerial_frag);
render.onTriggered=doRender;

function doRender()
{
    cgl.pushShader(shader);
    next.trigger();
    cgl.popShader();
}



};

Ops.Gl.Shader.FrontBacksideMaterial.prototype = new CABLES.Op();
CABLES.OPS["beb92b81-8fe8-4871-b790-efb71bfeefc4"]={f:Ops.Gl.Shader.FrontBacksideMaterial,objName:"Ops.Gl.Shader.FrontBacksideMaterial"};




// **************************************************************
// 
// Ops.Gl.Shader.GetShader
// 
// **************************************************************

Ops.Gl.Shader.GetShader = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrigger = op.inTrigger("Update"),
    next = op.outTrigger("Next"),
    outShader = op.outObject("Shader");

inTrigger.onTriggered = () =>
{
    outShader.set(op.patch.cgl.getShader());
    next.trigger();
};


};

Ops.Gl.Shader.GetShader.prototype = new CABLES.Op();
CABLES.OPS["5cca905a-d72b-4a07-9574-d4e4f9a8f300"]={f:Ops.Gl.Shader.GetShader,objName:"Ops.Gl.Shader.GetShader"};




// **************************************************************
// 
// Ops.Gl.Shader.MatCapMaterialNew_v3
// 
// **************************************************************

Ops.Gl.Shader.MatCapMaterialNew_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"matcap_frag":"{{MODULES_HEAD}}\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoord;\n#endif\n\nIN vec3 transformedNormal;\nIN vec3 viewSpacePosition;\n\nUNI vec4 inColor;\n\nUNI sampler2D texMatcap;\n\n#ifdef HAS_DIFFUSE_TEXTURE\n   UNI sampler2D texDiffuse;\n#endif\n\n#ifdef USE_SPECULAR_TEXTURE\n   UNI sampler2D texSpec;\n   UNI sampler2D texSpecMatCap;\n#endif\n\n#ifdef HAS_AO_TEXTURE\n    UNI sampler2D texAo;\n    UNI float aoIntensity;\n#endif\n\n#ifdef HAS_NORMAL_TEXTURE\n    IN vec3 vBiTangent;\n    IN vec3 vTangent;\n    IN mat3 normalMatrix;\n\n    UNI sampler2D texNormal;\n    UNI float normalMapIntensity;\n#endif\n\n#ifdef HAS_TEXTURE_OPACITY\n    UNI sampler2D texOpacity;\n#endif\n\n#ifdef CALC_SSNORMALS\n    IN vec3 eye_relative_pos;\n\n    // from https://www.enkisoftware.com/devlogpost-20150131-1-Normal_generation_in_the_pixel_shader\n    vec3 CalculateScreenSpaceNormals() {\n    \tvec3 dFdxPos = dFdx(eye_relative_pos);\n    \tvec3 dFdyPos = dFdy(eye_relative_pos);\n    \tvec3 screenSpaceNormal = normalize( cross(dFdxPos, dFdyPos));\n        return normalize(screenSpaceNormal);\n    }\n#endif\n\n// * taken & modified from https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshmatcap_frag.glsl.js\nvec2 getMatCapUV(vec3 viewSpacePosition, vec3 normal) {\n    vec3 viewDir = normalize(-viewSpacePosition);\n\tvec3 x = normalize(vec3(viewDir.z, 0.0, - viewDir.x));\n\tvec3 y = normalize(cross(viewDir, x));\n\tvec2 uv = vec2(dot(x, normal), dot(y, normal)) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\treturn uv;\n}\n\nvoid main()\n{\n    vec3 viewSpaceNormal = normalize(transformedNormal);\n\n    #ifdef HAS_TEXTURES\n        vec2 texCoords = texCoord;\n        {{MODULE_BEGIN_FRAG}}\n    #endif\n\n\n    #ifdef CALC_SSNORMALS\n        viewSpaceNormal = CalculateScreenSpaceNormals();\n    #endif\n\n\n   #ifdef HAS_NORMAL_TEXTURE\n        vec3 normalFromMap = texture( texNormal, texCoord ).xyz * 2.0 - 1.0;\n        normalFromMap = normalize(normalFromMap);\n\n        vec3 tangent;\n        vec3 binormal;\n\n        #ifdef CALC_TANGENT\n            vec3 c1 = cross(normalFromMap, vec3(0.0, 0.0, 1.0));\n            vec3 c2 = cross(normalFromMap, vec3(0.0, 1.0, 0.0));\n\n            tangent = c1;\n            tangent = normalize(tangent);\n            binormal = cross(viewSpaceNormal, tangent);\n            binormal = normalize(binormal);\n        #endif\n\n        #ifndef CALC_TANGENT\n            tangent = normalize(normalMatrix * vTangent);\n            vec3 bitangent = normalize(normalMatrix * vBiTangent);\n            binormal = normalize(cross(viewSpaceNormal, bitangent));\n        #endif\n\n        normalFromMap = normalize(\n            tangent * normalFromMap.x\n            + binormal * normalFromMap.y\n            + viewSpaceNormal * normalFromMap.z\n        );\n\n        vec3 mixedNormal = normalize(viewSpaceNormal + normalFromMap * normalMapIntensity);\n\n        viewSpaceNormal = mixedNormal;\n    #endif\n\n    vec4 col = texture(texMatcap, getMatCapUV(viewSpacePosition, viewSpaceNormal));\n\n    #ifdef HAS_DIFFUSE_TEXTURE\n        col = col*texture(texDiffuse, texCoords);\n    #endif\n\n    col.rgb *= inColor.rgb;\n\n\n    #ifdef HAS_AO_TEXTURE\n        col = col\n            * mix(\n                vec4(1.0,1.0,1.0,1.0),\n                texture(texAo, texCoords),\n                aoIntensity\n            );\n    #endif\n\n    #ifdef USE_SPECULAR_TEXTURE\n        vec4 spec = texture(texSpecMatCap, getMatCapUV(viewSpacePosition, viewSpaceNormal));\n        spec *= texture(texSpec, texCoords);\n        col += spec;\n    #endif\n\n    col.a *= inColor.a;\n\n    #ifdef HAS_TEXTURE_OPACITY\n        #ifdef TRANSFORMALPHATEXCOORDS\n            texCoords=vec2(texCoord.s,1.0-texCoord.t);\n            texCoords.y = 1. - texCoords.y;\n        #endif\n        #ifdef ALPHA_MASK_ALPHA\n            col.a*=texture(texOpacity,texCoords).a;\n        #endif\n        #ifdef ALPHA_MASK_LUMI\n            col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,texCoords).rgb);\n        #endif\n        #ifdef ALPHA_MASK_R\n            col.a*=texture(texOpacity,texCoords).r;\n        #endif\n        #ifdef ALPHA_MASK_G\n            col.a*=texture(texOpacity,texCoords).g;\n        #endif\n        #ifdef ALPHA_MASK_B\n            col.a*=texture(texOpacity,texCoords).b;\n        #endif\n\n        #ifdef DISCARDTRANS\n            if(col.a < 0.2) discard;\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    outColor = col;\n}","matcap_vert":"IN vec3 vPosition;\n\n#ifdef HAS_TEXTURES\n    IN vec2 attrTexCoord;\n#endif\n\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\n\n#ifdef HAS_NORMAL_TEXTURE\n    IN vec3 attrTangent;\n    IN vec3 attrBiTangent;\n    OUT vec3 vBiTangent;\n    OUT vec3 vTangent;\n#endif\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nUNI vec3 camPos;\n\n#ifdef HAS_TEXTURES\n    UNI vec2 texOffset;\n    UNI vec2 texRepeat;\n    OUT vec2 texCoord;\n#endif\n\nOUT mat3 normalMatrix;\nOUT vec3 viewSpacePosition;\nOUT vec3 transformedNormal;\n\n{{MODULES_HEAD}}\n\n#ifdef CALC_SSNORMALS\n    // from https://www.enkisoftware.com/devlogpost-20150131-1-Normal_generation_in_the_pixel_shader\n    OUT vec3 eye_relative_pos;\n#endif\n\nmat3 transposeMat3(mat3 m) {\n    return mat3(m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\n mat3 inverseMat3(mat3 m) {\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n        b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n        b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main()\n{\n    #ifdef HAS_TEXTURES\n        texCoord = texRepeat * vec2(attrTexCoord.x, attrTexCoord.y) + texOffset;\n        texCoord.y = 1. - texCoord.y;\n    #endif\n\n    mat4 mMatrix = modelMatrix;\n    mat4 mvMatrix;\n\n    #ifdef HAS_NORMAL_TEXTURE\n        vec3 tangent = attrTangent;\n        vec3 bitangent = attrBiTangent;\n        vTangent = attrTangent;\n        vBiTangent = attrBiTangent;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.);\n    vec3 norm = attrVertNormal;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mvMatrix = viewMatrix * mMatrix;\n    vec3 normal = norm;\n\n    normalMatrix = transposeMat3(inverseMat3(mat3(mvMatrix)));\n\n    vec3 fragPos = vec3((mvMatrix) * pos);\n    viewSpacePosition = normalize(fragPos);\n\n    #ifdef CALC_SSNORMALS\n        eye_relative_pos = -(vec3(viewMatrix * vec4(camPos, 1.)) - fragPos);\n    #endif\n\n    transformedNormal = normalize(mat3(normalMatrix) * normal);\n\n   gl_Position = projMatrix * mvMatrix * pos;\n\n}",};
const cgl = op.patch.cgl;

const
    render = op.inTrigger("Render"),
    textureMatcap = op.inTexture("MatCap"),
    textureDiffuse = op.inTexture("Diffuse"),
    textureNormal = op.inTexture("Normal"),
    textureSpec = op.inTexture("Specular Mask"),
    textureSpecMatCap = op.inTexture("Specular MatCap"),
    textureAo = op.inTexture("AO Texture"),
    textureOpacity = op.inTexture("Opacity Texture"),
    r = op.inValueSlider("r", 1),
    g = op.inValueSlider("g", 1),
    b = op.inValueSlider("b", 1),
    pOpacity = op.inValueSlider("Opacity", 1),
    aoIntensity = op.inValueSlider("AO Intensity", 1.0),
    normalMapIntensity = op.inFloatSlider("Normal Map Intensity", 1),
    repeatX = op.inValue("Repeat X", 1),
    repeatY = op.inValue("Repeat Y", 1),
    offsetX = op.inValue("Offset X", 0),
    offsetY = op.inValue("Offset Y", 0),
    ssNormals = op.inValueBool("Screen Space Normals"),
    calcTangents = op.inValueBool("Calc normal tangents", true),
    texCoordAlpha = op.inValueBool("Opacity TexCoords Transform", false),
    discardTransPxl = op.inValueBool("Discard Transparent Pixels"),

    next = op.outTrigger("Next"),
    shaderOut = op.outObject("Shader");

r.setUiAttribs({ "colorPick": true });

const alphaMaskSource = op.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A"], "Luminance");
alphaMaskSource.setUiAttribs({ "greyout": true });

op.setPortGroup("Texture Opacity", [alphaMaskSource, texCoordAlpha, discardTransPxl]);
op.setPortGroup("Texture Transforms", [aoIntensity, normalMapIntensity, repeatX, repeatY, offsetX, offsetY, calcTangents, ssNormals]);
op.setPortGroup("Texture Maps", [textureDiffuse, textureNormal, textureSpec, textureSpecMatCap, textureAo, textureOpacity]);
op.setPortGroup("Color", [r, g, b, pOpacity]);

const shader = new CGL.Shader(cgl, "MatCapMaterialNew3");
const uniOpacity = new CGL.Uniform(shader, "f", "opacity", pOpacity);

shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.matcap_vert, attachments.matcap_frag);
shaderOut.set(shader);

const textureMatcapUniform = new CGL.Uniform(shader, "t", "texMatcap");
let textureDiffuseUniform = null;
let textureNormalUniform = null;
let normalMapIntensityUniform = null;
let textureSpecUniform = null;
let textureSpecMatCapUniform = null;
let textureAoUniform = null;
const offsetUniform = new CGL.Uniform(shader, "2f", "texOffset", offsetX, offsetY);
const repeatUniform = new CGL.Uniform(shader, "2f", "texRepeat", repeatX, repeatY);

const aoIntensityUniform = new CGL.Uniform(shader, "f", "aoIntensity", aoIntensity);
const colorUniform = new CGL.Uniform(shader, "4f", "inColor", r, g, b, pOpacity);

calcTangents.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    if (calcTangents.get()) shader.define("CALC_TANGENT");
    else shader.removeDefine("CALC_TANGENT");
}

ssNormals.onChange = function ()
{
    if (ssNormals.get())
    {
        if (cgl.glVersion < 2)
        {
            cgl.gl.getExtension("OES_standard_derivatives");
            shader.enableExtension("GL_OES_standard_derivatives");
        }

        shader.define("CALC_SSNORMALS");
    }
    else shader.removeDefine("CALC_SSNORMALS");
};

textureMatcap.onChange = updateMatcap;

function updateMatcap()
{
    if (!cgl.defaultMatcapTex3)
    {
        const pixels = new Uint8Array(256 * 4);
        for (let x = 0; x < 16; x++)
        {
            for (let y = 0; y < 16; y++)
            {
                let c = y * 16;
                c *= Math.min(1, (x + y / 3) / 8);
                pixels[(x + y * 16) * 4 + 0] = pixels[(x + y * 16) * 4 + 1] = pixels[(x + y * 16) * 4 + 2] = c;
                pixels[(x + y * 16) * 4 + 3] = 255;
            }
        }

        cgl.defaultMatcapTex3 = new CGL.Texture(cgl);
        cgl.defaultMatcapTex3.initFromData(pixels, 16, 16, CGL.Texture.FILTER_LINEAR, CGL.Texture.WRAP_REPEAT);
    }
}

textureDiffuse.onChange = function ()
{
    if (textureDiffuse.get())
    {
        if (textureDiffuseUniform !== null) return;
        shader.define("HAS_DIFFUSE_TEXTURE");
        shader.removeUniform("texDiffuse");
        textureDiffuseUniform = new CGL.Uniform(shader, "t", "texDiffuse");
    }
    else
    {
        shader.removeDefine("HAS_DIFFUSE_TEXTURE");
        shader.removeUniform("texDiffuse");
        textureDiffuseUniform = null;
    }
};

textureNormal.onChange = function ()
{
    if (textureNormal.get())
    {
        if (textureNormalUniform !== null) return;
        shader.define("HAS_NORMAL_TEXTURE");
        shader.removeUniform("texNormal");
        textureNormalUniform = new CGL.Uniform(shader, "t", "texNormal");
        if (!normalMapIntensityUniform) normalMapIntensityUniform = new CGL.Uniform(shader, "f", "normalMapIntensity", normalMapIntensity);
    }
    else
    {
        shader.removeDefine("HAS_NORMAL_TEXTURE");
        shader.removeUniform("texNormal");
        textureNormalUniform = null;
    }
};

textureAo.onChange = function ()
{
    if (textureAo.get())
    {
        if (textureAoUniform !== null) return;
        shader.define("HAS_AO_TEXTURE");
        shader.removeUniform("texAo");
        textureAoUniform = new CGL.Uniform(shader, "t", "texAo");
    }
    else
    {
        shader.removeDefine("HAS_AO_TEXTURE");
        shader.removeUniform("texAo");
        textureAoUniform = null;
    }
};

textureSpec.onChange = textureSpecMatCap.onChange = function ()
{
    if (textureSpec.get() && textureSpecMatCap.get())
    {
        if (textureSpecUniform !== null) return;
        shader.define("USE_SPECULAR_TEXTURE");
        shader.removeUniform("texSpec");
        shader.removeUniform("texSpecMatCap");
        textureSpecUniform = new CGL.Uniform(shader, "t", "texSpec");
        textureSpecMatCapUniform = new CGL.Uniform(shader, "t", "texSpecMatCap");
    }
    else
    {
        shader.removeDefine("USE_SPECULAR_TEXTURE");
        shader.removeUniform("texSpec");
        shader.removeUniform("texSpecMatCap");
        textureSpecUniform = null;
        textureSpecMatCapUniform = null;
    }
};

// TEX OPACITY

function updateAlphaMaskMethod()
{
    if (alphaMaskSource.get() == "Alpha Channel") shader.define("ALPHA_MASK_ALPHA");
    else shader.removeDefine("ALPHA_MASK_ALPHA");

    if (alphaMaskSource.get() == "Luminance") shader.define("ALPHA_MASK_LUMI");
    else shader.removeDefine("ALPHA_MASK_LUMI");

    if (alphaMaskSource.get() == "R") shader.define("ALPHA_MASK_R");
    else shader.removeDefine("ALPHA_MASK_R");

    if (alphaMaskSource.get() == "G") shader.define("ALPHA_MASK_G");
    else shader.removeDefine("ALPHA_MASK_G");

    if (alphaMaskSource.get() == "B") shader.define("ALPHA_MASK_B");
    else shader.removeDefine("ALPHA_MASK_B");
}
alphaMaskSource.onChange = updateAlphaMaskMethod;
textureOpacity.onChange = updateOpacity;

let textureOpacityUniform = null;

function updateOpacity()
{
    if (textureOpacity.get())
    {
        if (textureOpacityUniform !== null) return;
        shader.removeUniform("texOpacity");
        shader.define("HAS_TEXTURE_OPACITY");
        if (!textureOpacityUniform) textureOpacityUniform = new CGL.Uniform(shader, "t", "texOpacity");

        alphaMaskSource.setUiAttribs({ "greyout": false });
        discardTransPxl.setUiAttribs({ "greyout": false });
        texCoordAlpha.setUiAttribs({ "greyout": false });
    }
    else
    {
        shader.removeUniform("texOpacity");
        shader.removeDefine("HAS_TEXTURE_OPACITY");
        textureOpacityUniform = null;

        alphaMaskSource.setUiAttribs({ "greyout": true });
        discardTransPxl.setUiAttribs({ "greyout": true });
        texCoordAlpha.setUiAttribs({ "greyout": true });
    }
    updateAlphaMaskMethod();
}

discardTransPxl.onChange = function ()
{
    if (discardTransPxl.get()) shader.define("DISCARDTRANS");
    else shader.removeDefine("DISCARDTRANS");
};

texCoordAlpha.onChange = function ()
{
    if (texCoordAlpha.get()) shader.define("TRANSFORMALPHATEXCOORDS");
    else shader.removeDefine("TRANSFORMALPHATEXCOORDS");
};

function checkUiErrors()
{
    if (textureSpec.get() && !textureSpecMatCap.get())
    {
        op.setUiError("specNoMatCapSpec", "You connected a specular texture but have not connected a specular matcap texture. You need to connect both texture inputs for the specular input to work.", 1);
        op.setUiError("noSpecMatCapSpec", null);
    }
    else if (!textureSpec.get() && textureSpecMatCap.get())
    {
        op.setUiError("noSpecMatCapSpec", "You connected a specular matcap texture but have not connected a specular texture. You need to connect both texture inputs for the specular input to work.", 1);
        op.setUiError("specNoMatCapSpec", null);
    }
    else if (textureSpec.get() && textureSpecMatCap.get())
    {
        op.setUiError("specNoMatCapSpec", null);
        op.setUiError("noSpecMatCapSpec", null);
    }
    else
    {
        op.setUiError("specNoMatCapSpec", null);
        op.setUiError("noSpecMatCapSpec", null);
    }
}

render.onTriggered = function ()
{
    checkUiErrors();

    if (!cgl.defaultMatcapTex3) updateMatcap();
    shader.popTextures();

    const tex = textureMatcap.get() || cgl.defaultMatcapTex3;
    shader.pushTexture(textureMatcapUniform, tex.tex);

    if (textureDiffuse.get() && textureDiffuseUniform) shader.pushTexture(textureDiffuseUniform, textureDiffuse.get().tex);
    if (textureNormal.get() && textureNormalUniform) shader.pushTexture(textureNormalUniform, textureNormal.get().tex);
    if (textureSpec.get() && textureSpecUniform) shader.pushTexture(textureSpecUniform, textureSpec.get().tex);
    if (textureSpecMatCap.get() && textureSpecMatCapUniform) shader.pushTexture(textureSpecMatCapUniform, textureSpecMatCap.get().tex);
    if (textureAo.get() && textureAoUniform) shader.pushTexture(textureAoUniform, textureAo.get().tex);
    if (textureOpacity.get() && textureOpacityUniform) shader.pushTexture(textureOpacityUniform, textureOpacity.get().tex);

    cgl.pushShader(shader);
    next.trigger();
    cgl.popShader();
};


};

Ops.Gl.Shader.MatCapMaterialNew_v3.prototype = new CABLES.Op();
CABLES.OPS["c1dd6e76-61b4-471a-b8d1-f550a5a9a4f4"]={f:Ops.Gl.Shader.MatCapMaterialNew_v3,objName:"Ops.Gl.Shader.MatCapMaterialNew_v3"};




// **************************************************************
// 
// Ops.Gl.Shader.Picker
// 
// **************************************************************

Ops.Gl.Shader.Picker = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
op.render = op.inTrigger("render");

const useMouseCoords = op.inBool("Use Mouse Coordinates", true);

op.x = op.inFloat("x");
op.y = op.inFloat("y");
const inEnabled = op.inBool("enabled");
inEnabled.set(true);

op.trigger = op.outTrigger("trigger");
const somethingPicked = op.outBool("Something Picked");

const cursor = op.inDropDown("cursor", ["", "pointer", "auto", "default", "crosshair", "move", "n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize", "text", "wait", "help"]);

// inValueSelect
cursor.set("default");

const pixelRGB = new Uint8Array(4);
let fb = null;
const cgl = op.patch.cgl;
let lastReadPixel = 0;
let canceledTouch = false;
if (cgl.glVersion == 1) fb = new CGL.Framebuffer(cgl, 4, 4);
else
{
    fb = new CGL.Framebuffer2(cgl, 4, 4, { "multisampling": false });
}

const tex = op.outTexture("pick texture");
tex.set(fb.getTextureColor());
useMouseCoords.onChange = updateListeners;
updateListeners();

function renderPickingPass()
{
    cgl.frameStore.renderOffscreen = true;
    cgl.frameStore.pickingpass = true;
    cgl.frameStore.pickingpassNum = 0;
    op.trigger.trigger();
    cgl.frameStore.pickingpass = false;
    cgl.frameStore.renderOffscreen = false;
}

function mouseMove(e)
{
    if (e && e.hasOwnProperty("offsetX") >= 0)
    {
        op.x.set(e.offsetX * (window.devicePixelRatio || 1));
        op.y.set(e.offsetY * (window.devicePixelRatio || 1));
    }
}

function updateListeners()
{
    cgl.canvas.removeEventListener("mouseleave", mouseleave);
    cgl.canvas.removeEventListener("mousemove", mouseMove);
    cgl.canvas.removeEventListener("touchmove", ontouchmove);
    cgl.canvas.removeEventListener("touchstart", ontouchstart);
    cgl.canvas.removeEventListener("touchend", ontouchend);
    cgl.canvas.removeEventListener("touchcancel", ontouchend);

    if (useMouseCoords.get())
    {
        cgl.canvas.addEventListener("mouseleave", mouseleave);
        cgl.canvas.addEventListener("mousemove", mouseMove);
        cgl.canvas.addEventListener("touchmove", ontouchmove);
        cgl.canvas.addEventListener("touchstart", ontouchstart);
        cgl.canvas.addEventListener("touchend", ontouchend);
        cgl.canvas.addEventListener("touchcancel", ontouchend);
    }
}

function fixTouchEvent(touchEvent)
{
    if (touchEvent)
    {
        touchEvent.offsetX = touchEvent.pageX - touchEvent.target.offsetLeft;
        touchEvent.offsetY = touchEvent.pageY - touchEvent.target.offsetTop;

        if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))
        {
            touchEvent.offsetX *= (window.devicePixelRatio || 1);
            touchEvent.offsetY *= (window.devicePixelRatio || 1);
        }

        return touchEvent;
    }
}

function ontouchstart(event)
{
    canceledTouch = false;
    if (event.touches && event.touches.length > 0)
    {
        ontouchmove(event);
    }
}

function mouseleave(event)
{
    op.x.set(-1000);
    op.y.set(-1000);
}

function ontouchend(event)
{
    canceledTouch = true;
    op.x.set(-1000);
    op.y.set(-1000);
}

function ontouchmove(event)
{
    if (event.touches && event.touches.length > 0)
    {
        mouseMove(fixTouchEvent(event.touches[0]));
    }
}

const doRender = function ()
{
    if (cursor.get() != cgl.canvas.style.cursor)
    {
        cgl.canvas.style.cursor = cursor.get();
    }

    if (inEnabled.get() && op.x.get() >= 0 && !canceledTouch)
    {
        if (CABLES.now() - lastReadPixel >= 50)
        {
            const minimizeFB = 2;
            cgl.resetViewPort();

            const vpW = Math.floor(cgl.canvasWidth / minimizeFB);
            const vpH = Math.floor(cgl.canvasHeight / minimizeFB);

            if (vpW != fb.getWidth() || vpH != fb.getHeight())
            {
                tex.set(null);
                fb.setSize(vpW, vpH);
                tex.set(fb.getTextureColor());
            }

            cgl.pushModelMatrix();
            fb.renderStart();
            // cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT | cgl.gl.COLOR_BUFFER_BIT);

            renderPickingPass();

            let x = Math.floor(op.x.get() / minimizeFB);
            let y = Math.floor(vpH - op.y.get() / minimizeFB);
            if (x < 0)x = 0;
            if (y < 0)y = 0;

            cgl.gl.readPixels(x, y, 1, 1, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, pixelRGB);
            lastReadPixel = CABLES.now();

            fb.renderEnd();
            cgl.popModelMatrix();
        }

        cgl.frameStore.pickedColor = pixelRGB[0] + pixelRGB[2];

        if (cgl.frameStore.pickedColor)somethingPicked.set(true);
        else somethingPicked.set(false);

        cgl.frameStore.pickingpassNum = 0;
        op.trigger.trigger();
    }
    else
    {
        cgl.frameStore.pickedColor = -1000;
        op.trigger.trigger();
        somethingPicked.set(false);
    }
};

function preview()
{
    render();
    tex.get().preview();
}

// tex.onPreviewChanged = function ()
// {
//     if (tex.showPreview) op.render.onTriggered = doRender;
//     else op.render.onTriggered = doRender;
// };

op.render.onTriggered = doRender;


};

Ops.Gl.Shader.Picker.prototype = new CABLES.Op();
CABLES.OPS["09122fbf-3b6b-4a05-ac76-fca031b505b9"]={f:Ops.Gl.Shader.Picker,objName:"Ops.Gl.Shader.Picker"};




// **************************************************************
// 
// Ops.Gl.Shader.PickingMaterial
// 
// **************************************************************

Ops.Gl.Shader.PickingMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"pick_frag":"UNI float r;\n\nvoid main()\n{\n   outColor= vec4(r,1.0,r,1.0);\n}","pick_vert":"IN vec3 vPosition;\nUNI mat4 projMatrix;\n// UNI mat4 mvMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n{{MODULES_HEAD}}\n\nvoid main()\n{\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mMatrix=modelMatrix;\n\n    #ifdef BILLBOARD\n       mat4 mvMatrix=viewMatrix*mMatrix;\n\n        vec3 position=vPosition;\n        gl_Position = projMatrix * mvMatrix * vec4((\n           position.x * vec3(\n               mvMatrix[0][0],\n               mvMatrix[1][0],\n               mvMatrix[2][0] ) +\n           position.y * vec3(\n               mvMatrix[0][1],\n               mvMatrix[1][1],\n               mvMatrix[2][1]) ), 1.0);\n   #endif\n\n\n    {{MODULE_VERTEX_POSITION}}\n\n\n   #ifndef BILLBOARD\n\n       mat4 mvMatrix=viewMatrix*mMatrix;\n       gl_Position = projMatrix * mvMatrix * vec4(vPosition,  1.0);\n   #endif\n}",};
const cgl = op.patch.cgl;

const render = op.inTrigger("render");
const next = op.outTrigger("trigger");

const isPicked = op.outBool("is picked");

const pickedTrigger = op.outTrigger("On Picked");

const doBillboard = op.inBool("billboard", false); // op.addInPort(new CABLES.Port(op, "billboard", CABLES.OP_PORT_TYPE_VALUE, { "display": "bool" }));
doBillboard.set(false);

doBillboard.onChange = function ()
{
    if (doBillboard.get()) shader.define("BILLBOARD");
    else shader.removeDefine("BILLBOARD");
};

const cursor = op.inDropDown("cursor", ["pointer", "auto", "default", "crosshair", "move", "n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize", "text", "wait", "help"]);

cursor.set("pointer");

function doRender()
{
    cgl.frameStore.pickingpassNum += 2;
    const currentPickingColor = cgl.frameStore.pickingpassNum;

    if (cgl.frameStore.pickingpass)
    {
        // isPicked.set(false);

        pickColorUniformR.setValue(currentPickingColor / 511);
        cgl.pushShader(shader);
        next.trigger();
        cgl.popShader();
    }
    else
    {
        isPicked.set(cgl.frameStore.pickedColor == currentPickingColor);

        if (cgl.frameStore.pickedColor == currentPickingColor)
        {
            if (cursor.get().length > 0 && cgl.canvas.style.cursor != cursor.get())
            {
                cgl.canvas.style.cursor = cursor.get();
            }
            pickedTrigger.trigger();
        }
        else
        {
        }

        next.trigger();
    }
}

const srcVert = attachments.pick_vert;

const srcFrag = attachments.pick_frag;

const shader = new CGL.Shader(cgl, "PickingMaterial");
shader.offScreenPass = true;
shader.setSource(srcVert, srcFrag);

const pickColorUniformR = new CGL.Uniform(shader, "f", "r", 0);

render.onTriggered = doRender;
doRender();


};

Ops.Gl.Shader.PickingMaterial.prototype = new CABLES.Op();
CABLES.OPS["2b58daad-4dde-4edb-af22-03ac55ab06ab"]={f:Ops.Gl.Shader.PickingMaterial,objName:"Ops.Gl.Shader.PickingMaterial"};




// **************************************************************
// 
// Ops.Gl.Shader.PointMaterial_v4
// 
// **************************************************************

Ops.Gl.Shader.PointMaterial_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"pointmat_frag":"\n{{MODULES_HEAD}}\n\nUNI vec4 color;\n// IN vec2 pointCoord;\nIN float ps;\n\n#ifdef HAS_TEXTURE_DIFFUSE\n    UNI sampler2D diffTex;\n#endif\n#ifdef HAS_TEXTURE_MASK\n    UNI sampler2D texMask;\n#endif\n#ifdef HAS_TEXTURE_COLORIZE\n    IN vec4 colorize;\n#endif\n#ifdef HAS_TEXTURE_OPACITY\n    IN float opacity;\n#endif\n#ifdef VERTEX_COLORS\n    IN vec4 vertexColor;\n#endif\n\nvoid main()\n{\n    #ifdef FLIP_TEX\n        vec2 pointCoord=vec2(gl_PointCoord.x,(1.0-gl_PointCoord.y));\n    #endif\n    #ifndef FLIP_TEX\n        vec2 pointCoord=gl_PointCoord;\n    #endif\n    {{MODULE_BEGIN_FRAG}}\n\n    if(ps<1.0)discard;\n\n    vec4 col=color;\n\n    #ifdef HAS_TEXTURE_MASK\n        float mask;\n        #ifdef TEXTURE_MASK_R\n            mask=texture(texMask,pointCoord).r;\n        #endif\n        #ifdef TEXTURE_MASK_A\n            mask=texture(texMask,pointCoord).a;\n        #endif\n        #ifdef TEXTURE_MASK_LUMI\n        \tvec3 lumcoeff = vec3(0.299,0.587,0.114);\n        \tmask = dot(texture(texMask,pointCoord).rgb, lumcoeff);\n        #endif\n\n    #endif\n\n    #ifdef HAS_TEXTURE_DIFFUSE\n        col=texture(diffTex,pointCoord);\n        #ifdef COLORIZE_TEXTURE\n          col.rgb*=color.rgb;\n        #endif\n    #endif\n    col.a*=color.a;\n\n    {{MODULE_COLOR}}\n\n    #ifdef MAKE_ROUND\n\n        #ifndef MAKE_ROUNDAA\n            if ((gl_PointCoord.x-0.5)*(gl_PointCoord.x-0.5) + (gl_PointCoord.y-0.5)*(gl_PointCoord.y-0.5) > 0.25) discard; //col.a=0.0;\n        #endif\n\n        #ifdef MAKE_ROUNDAA\n            float circ=(gl_PointCoord.x-0.5)*(gl_PointCoord.x-0.5) + (gl_PointCoord.y-0.5)*(gl_PointCoord.y-0.5);\n\n            float a=smoothstep(0.25,0.25-fwidth(gl_PointCoord.x),circ);\n            if(a==0.0)discard;\n            col.a=a*color.a;\n        #endif\n    #endif\n\n    #ifdef HAS_TEXTURE_COLORIZE\n        col*=colorize;\n    #endif\n\n    #ifdef TEXTURE_COLORIZE_MUL\n        col*=color;\n    #endif\n\n    #ifdef HAS_TEXTURE_MASK\n        col.a*=mask;\n    #endif\n\n    #ifdef HAS_TEXTURE_OPACITY\n        col.a*=opacity;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        col.rgb = vertexColor.rgb;\n        col.a *= vertexColor.a;\n    #endif\n\n    if (col.a <= 0.0) discard;\n\n    #ifdef HAS_TEXTURE_COLORIZE\n        col*=colorize;\n    #endif\n\n    outColor = col;\n}\n","pointmat_vert":"{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN vec3 attrTangent;\nIN vec3 attrBiTangent;\n\n#ifdef VERTEX_COLORS\n    IN vec4 attrVertColor;\n    OUT vec4 vertexColor;\n#endif\n\nOUT vec3 norm;\nOUT float ps;\n\nOUT vec2 texCoord;\n\n\n#ifdef HAS_TEXTURES\n#endif\n\n#ifdef HAS_TEXTURE_COLORIZE\n   UNI sampler2D texColorize;\n   OUT vec4 colorize;\n#endif\n#ifdef HAS_TEXTURE_OPACITY\n    UNI sampler2D texOpacity;\n    OUT float opacity;\n#endif\n\n#ifdef HAS_TEXTURE_POINTSIZE\n   UNI sampler2D texPointSize;\n   UNI float texPointSizeMul;\n#endif\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nUNI float pointSize;\nUNI vec3 camPos;\n\nUNI float canvasWidth;\nUNI float canvasHeight;\nUNI float camDistMul;\nUNI float randomSize;\n\nIN float attrVertIndex;\n\n\n\nfloat rand(float n){return fract(sin(n) * 5711.5711123);}\n\n#define POINTMATERIAL\n\nvoid main()\n{\n    norm=attrVertNormal;\n    #ifdef PIXELSIZE\n        float psMul=1.0;\n    #endif\n\n    #ifndef PIXELSIZE\n        float psMul=sqrt(canvasWidth/canvasHeight)+0.00000000001;\n    #endif\n\n    // float sizeMultiply=1.0;\n\n    vec3 tangent=attrTangent;\n    vec3 bitangent=attrBiTangent;\n\n\n    #ifdef VERTEX_COLORS\n        vertexColor=attrVertColor;\n    #endif\n\n    // #ifdef HAS_TEXTURES\n        texCoord=attrTexCoord;\n    // #endif\n\n    #ifdef HAS_TEXTURE_OPACITY\n        // opacity=texture(texOpacity,vec2(rand(attrVertIndex+texCoord.x*texCoord.y+texCoord.y+texCoord.x),rand(texCoord.y*texCoord.x-texCoord.x-texCoord.y-attrVertIndex))).r;\n        opacity=texture(texOpacity,texCoord).r;\n    #endif\n\n\n    #ifdef HAS_TEXTURE_COLORIZE\n        #ifdef RANDOM_COLORIZE\n            colorize=texture(texColorize,vec2(rand(attrVertIndex+texCoord.x*texCoord.y+texCoord.y+texCoord.x),rand(texCoord.y*texCoord.x-texCoord.x-texCoord.y-attrVertIndex)));\n        #endif\n        #ifndef RANDOM_COLORIZE\n            colorize=texture(texColorize,texCoord);\n        #endif\n    #endif\n\n\n\n\n\n    mat4 mMatrix=modelMatrix;\n    vec4 pos = vec4( vPosition, 1. );\n\n    gl_PointSize=0.0;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    vec4 model=mMatrix * pos;\n\n    psMul+=rand(texCoord.x*texCoord.y+texCoord.y*3.0+texCoord.x*2.0+attrVertIndex)*randomSize;\n    // psMul*=sizeMultiply;\n\n    float addPointSize=0.0;\n    #ifdef HAS_TEXTURE_POINTSIZE\n\n        #ifdef POINTSIZE_CHAN_R\n            addPointSize=texture(texPointSize,texCoord).r;\n        #endif\n        #ifdef POINTSIZE_CHAN_G\n            addPointSize=texture(texPointSize,texCoord).g;\n        #endif\n        #ifdef POINTSIZE_CHAN_B\n            addPointSize=texture(texPointSize,texCoord).b;\n        #endif\n\n\n        #ifdef DOTSIZEREMAPABS\n            // addPointSize=(( (texture(texPointSize,texCoord).r) * texPointSizeMul)-0.5)*2.0;\n\n            addPointSize=1.0-(distance(addPointSize,0.5)*2.0);\n            // addPointSize=abs(1.0-(distance(addPointSize,0.5)*2.0));\n            addPointSize=addPointSize*addPointSize*addPointSize*2.0;\n\n            // addPointSize=(( (texture(texPointSize,texCoord).r) * texPointSizeMul)-0.5)*2.0;\n        #endif\n\n        addPointSize*=texPointSizeMul;\n\n    #endif\n\n    ps=0.0;\n    #ifndef SCALE_BY_DISTANCE\n        ps = (pointSize+addPointSize) * psMul;\n    #endif\n    #ifdef SCALE_BY_DISTANCE\n        float cameraDist = distance(model.xyz, camPos);\n        ps = ( (pointSize+addPointSize) / cameraDist) * psMul;\n    #endif\n\n    gl_PointSize += ps;\n\n\n    gl_Position = projMatrix * viewMatrix * model;\n}\n",};
const cgl = op.patch.cgl;

const
    render = op.inTrigger("render"),
    pointSize = op.inValueFloat("PointSize", 3),
    inPixelSize = op.inBool("Size in Pixels", false),
    randomSize = op.inValue("Random Size", 0),
    makeRound = op.inValueBool("Round", true),
    makeRoundAA = op.inValueBool("Round Antialias", false),
    doScale = op.inValueBool("Scale by Distance", false),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    a = op.inValueSlider("a", 1),
    vertCols = op.inBool("Vertex Colors", false),
    texture = op.inTexture("texture"),
    textureMulColor = op.inBool("Colorize Texture"),
    textureMask = op.inTexture("Texture Mask"),
    texMaskChan = op.inSwitch("Mask Channel", ["R", "A", "Luminance"], "R"),
    textureColorize = op.inTexture("Texture Colorize"),
    colorizeRandom = op.inValueBool("Colorize Randomize", true),
    textureOpacity = op.inTexture("Texture Opacity"),
    texturePointSize = op.inTexture("Texture Point Size"),
    texturePointSizeChannel = op.inSwitch("Point Size Channel", ["R", "G", "B"], "R"),
    texturePointSizeMul = op.inFloat("Texture Point Size Mul", 1),
    texturePointSizeMap = op.inSwitch("Map Size 0", ["Black", "Grey"], "Black"),
    flipTex = op.inValueBool("Flip Texture", false),

    trigger = op.outTrigger("trigger"),
    shaderOut = op.outObject("shader", null, "shader");

op.setPortGroup("Texture", [texture, textureMulColor, textureMask, texMaskChan, textureColorize, textureOpacity, colorizeRandom]);
op.setPortGroup("Color", [r, g, b, a, vertCols]);
op.setPortGroup("Size", [pointSize, randomSize, makeRound, makeRoundAA, doScale, inPixelSize, texturePointSize, texturePointSizeMul, texturePointSizeChannel, texturePointSizeMap]);
r.setUiAttribs({ "colorPick": true });

const shader = new CGL.Shader(cgl, "PointMaterial");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.define("MAKE_ROUND");

const
    uniPointSize = new CGL.Uniform(shader, "f", "pointSize", pointSize),
    texturePointSizeMulUniform = new CGL.Uniform(shader, "f", "texPointSizeMul", texturePointSizeMul),
    uniRandomSize = new CGL.Uniform(shader, "f", "randomSize", randomSize),
    uniColor = new CGL.Uniform(shader, "4f", "color", r, g, b, a),
    uniWidth = new CGL.Uniform(shader, "f", "canvasWidth", cgl.canvasWidth),
    uniHeight = new CGL.Uniform(shader, "f", "canvasHeight", cgl.canvasHeight),
    textureUniform = new CGL.Uniform(shader, "t", "diffTex"),
    textureColorizeUniform = new CGL.Uniform(shader, "t", "texColorize"),
    textureOpacityUniform = new CGL.Uniform(shader, "t", "texOpacity"),
    textureColoPointSize = new CGL.Uniform(shader, "t", "texPointSize"),
    texturePointSizeUniform = new CGL.Uniform(shader, "t", "texPointSize"),
    textureMaskUniform = new CGL.Uniform(shader, "t", "texMask");

shader.setSource(attachments.pointmat_vert, attachments.pointmat_frag);
shader.glPrimitive = cgl.gl.POINTS;
shaderOut.set(shader);
shaderOut.ignoreValueSerialize = true;

render.onTriggered = doRender;
doScale.onChange =
    makeRound.onChange =
    makeRoundAA.onChange =
    texture.onChange =
    textureColorize.onChange =
    textureMask.onChange =
    colorizeRandom.onChange =
    flipTex.onChange =
    texMaskChan.onChange =
    inPixelSize.onChange =
    textureOpacity.onChange =
    texturePointSize.onChange =
    texturePointSizeMap.onChange =
    texturePointSizeChannel.onChange =
    textureMulColor.onChange =
    vertCols.onChange = updateDefines;

updateUi();

op.preRender = function ()
{
    if (shader)shader.bind();
    doRender();
};

function doRender()
{
    uniWidth.setValue(cgl.canvasWidth);
    uniHeight.setValue(cgl.canvasHeight);

    cgl.pushShader(shader);
    shader.popTextures();
    if (texture.get() && !texture.get().deleted) shader.pushTexture(textureUniform, texture.get());
    if (textureMask.get()) shader.pushTexture(textureMaskUniform, textureMask.get());
    if (textureColorize.get()) shader.pushTexture(textureColorizeUniform, textureColorize.get());
    if (textureOpacity.get()) shader.pushTexture(textureOpacityUniform, textureOpacity.get());
    if (texturePointSize.get()) shader.pushTexture(texturePointSizeUniform, texturePointSize.get());

    trigger.trigger();

    cgl.popShader();
}

function updateUi()
{
    texMaskChan.setUiAttribs({ "greyout": !textureMask.isLinked() });

    texturePointSizeChannel.setUiAttribs({ "greyout": !texturePointSize.isLinked() });
    texturePointSizeMul.setUiAttribs({ "greyout": !texturePointSize.isLinked() });
    texturePointSizeMap.setUiAttribs({ "greyout": !texturePointSize.isLinked() });
}

function updateDefines()
{
    shader.toggleDefine("SCALE_BY_DISTANCE", doScale.get());
    shader.toggleDefine("MAKE_ROUND", makeRound.get());
    shader.toggleDefine("MAKE_ROUNDAA", makeRoundAA.get());

    shader.toggleDefine("VERTEX_COLORS", vertCols.get());
    shader.toggleDefine("RANDOM_COLORIZE", colorizeRandom.get());
    shader.toggleDefine("HAS_TEXTURE_DIFFUSE", texture.get());
    shader.toggleDefine("HAS_TEXTURE_MASK", textureMask.get());
    shader.toggleDefine("HAS_TEXTURE_COLORIZE", textureColorize.get());
    shader.toggleDefine("HAS_TEXTURE_OPACITY", textureOpacity.get());
    shader.toggleDefine("HAS_TEXTURE_POINTSIZE", texturePointSize.get());

    shader.toggleDefine("TEXTURE_COLORIZE_MUL", textureMulColor.get());

    shader.toggleDefine("FLIP_TEX", flipTex.get());
    shader.toggleDefine("TEXTURE_MASK_R", texMaskChan.get() == "R");
    shader.toggleDefine("TEXTURE_MASK_A", texMaskChan.get() == "A");
    shader.toggleDefine("TEXTURE_MASK_LUMI", texMaskChan.get() == "Luminance");
    shader.toggleDefine("PIXELSIZE", inPixelSize.get());

    shader.toggleDefine("POINTSIZE_CHAN_R", texturePointSizeChannel.get() == "R");
    shader.toggleDefine("POINTSIZE_CHAN_G", texturePointSizeChannel.get() == "G");
    shader.toggleDefine("POINTSIZE_CHAN_B", texturePointSizeChannel.get() == "B");

    shader.toggleDefine("DOTSIZEREMAPABS", texturePointSizeMap.get() == "Grey");
    updateUi();
}


};

Ops.Gl.Shader.PointMaterial_v4.prototype = new CABLES.Op();
CABLES.OPS["a7cb5d1c-cd4a-4c28-bb13-7bb9bda187ed"]={f:Ops.Gl.Shader.PointMaterial_v4,objName:"Ops.Gl.Shader.PointMaterial_v4"};




// **************************************************************
// 
// Ops.Gl.Shader.PositionAsColorMaterial
// 
// **************************************************************

Ops.Gl.Shader.PositionAsColorMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"pos_frag":"IN vec3 vert;\n\nvoid main()\n{\n   vec4 col=vec4(vert,1.0);\n\n\n   outColor= col;\n}","pos_vert":"IN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal,attrTangent,attrBiTangent;\nOUT mat4 mMatrix;\nOUT vec3 vert;\nOUT mat4 mvMatrix;\nUNI mat4 projMatrix;\n\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n{{MODULES_HEAD}}\n\nvoid main()\n{\n\n    vec4 pos=vec4(vPosition,1.0);\n    mMatrix=modelMatrix;\n\n\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat4 mvMatrix=viewMatrix*mMatrix;\n\n\n    vert=(mMatrix*pos).xyz;\n\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}",};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");
const cgl = op.patch.cgl;

function doRender()
{
    cgl.pushShader(shader);
    trigger.trigger();
    cgl.popShader();
}

const shader = new CGL.Shader(cgl, "showtexcoords material");

shader.setSource(attachments.pos_vert, attachments.pos_frag);

render.onTriggered = doRender;
doRender();


};

Ops.Gl.Shader.PositionAsColorMaterial.prototype = new CABLES.Op();
CABLES.OPS["a654bbb7-bbde-4178-9fef-3209d0c352a4"]={f:Ops.Gl.Shader.PositionAsColorMaterial,objName:"Ops.Gl.Shader.PositionAsColorMaterial"};




// **************************************************************
// 
// Ops.Gl.Shader.SetShader
// 
// **************************************************************

Ops.Gl.Shader.SetShader = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render = op.inTrigger("render");
const shader = op.inObject("shader", null, "shader");
const trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
shader.ignoreValueSerialize = true;
render.onTriggered = doRender;

function doRender()
{
    if (shader.get())
    {
        cgl.pushShader(shader.get());
        if (shader.get().bindTextures) shader.get().bindTextures();
        trigger.trigger();
        cgl.popShader();
    }
    else
    {
        trigger.trigger();
    }
}


};

Ops.Gl.Shader.SetShader.prototype = new CABLES.Op();
CABLES.OPS["11d24181-1f1b-4131-bba0-3df410385a66"]={f:Ops.Gl.Shader.SetShader,objName:"Ops.Gl.Shader.SetShader"};




// **************************************************************
// 
// Ops.Gl.Shader.SetUniformFloat_v2
// 
// **************************************************************

Ops.Gl.Shader.SetUniformFloat_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// should be called setuniformfloat ?

const
    inRender = op.inTrigger("Render"),
    inSelect = op.inValueSelect("Uniform"),
    inX = op.inValue("X", 1),
    inY = op.inValue("Y", 1),
    inZ = op.inValue("Z", 1),
    inW = op.inValue("W", 1),
    next = op.outTrigger("Next"),
    outType = op.outString("Type");

let shader = null;
const cgl = op.patch.cgl;
let doSetupUniform = true;
let uniform = null;
let shaderLastCompile = -1;
let unis = [];

inRender.onTriggered = function ()
{
    if (cgl.getShader() && (shader != cgl.getShader() || shader.lastCompile != shaderLastCompile))
    {
        shader = cgl.getShader();
        setupShader();
        doSetupUniform = true;
    }

    if (doSetupUniform) setupUniform();

    if (uniform)
    {
        outType.set(uniform.getType());
        const oldValue = uniform.getValue();

        uniform.setValue([inX.get(), inY.get(), inZ.get(), inW.get()]);

        next.trigger();
        uniform.setValue(oldValue);
    }
    else
    {
        next.trigger();
    }
};

inSelect.onChange = function ()
{
    doSetupUniform = true;
};

function setupUniform()
{
    if (shader)
    {
        uniform = shader.getUniform((inSelect.get() || "").split(" ")[0]);

        if (uniform)
        {
            inY.setUiAttribs({ "greyout": uniform.getType() == "f" });
            inZ.setUiAttribs({ "greyout": uniform.getType() == "f" || uniform.getType() == "2f" });
            inW.setUiAttribs({ "greyout": uniform.getType() == "f" || uniform.getType() == "2f" || uniform.getType() == "3f" });
        }

        if (!uniform) op.setUiError("nouni", "uniform unknown", 1);// op.uiAttr({ "error": "uniform unknown. maybe shader changed" });
        else op.setUiError("nouni", null);

        doSetupUniform = false;
    }
}

function setupShader()
{
    unis = shader.getUniforms();

    shaderLastCompile = shader.lastCompile;
    const names = ["..."];

    for (let i = 0; i < unis.length; i++)
    {
        if (unis[i].getType() == "f" || unis[i].getType() == "2f" || unis[i].getType() == "3f" || unis[i].getType() == "4f")
            names.push(unis[i].getName() + " (" + unis[i].getType() + ")");
    }

    inSelect.setUiAttribs({ "values": names });
}


};

Ops.Gl.Shader.SetUniformFloat_v2.prototype = new CABLES.Op();
CABLES.OPS["9e6328da-457d-4d80-a881-dcab25a0e0f8"]={f:Ops.Gl.Shader.SetUniformFloat_v2,objName:"Ops.Gl.Shader.SetUniformFloat_v2"};




// **************************************************************
// 
// Ops.Gl.Shader.SetUniformTexture
// 
// **************************************************************

Ops.Gl.Shader.SetUniformTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inRender = op.inTrigger("Render"),
    inSelect = op.inValueSelect("Uniform"),
    // inValue = op.inValue("Value"),
    inValue = op.inTexture("Texture"),
    next = op.outTrigger("Next"),
    outType = op.outString("Type");

let shader = null;
const cgl = op.patch.cgl;
let doSetupUniform = true;
let uniform = null;
let shaderLastCompile = -1;
let unis = [];
let old = null;

inRender.onTriggered = function ()
{
    if (cgl.getShader() && (shader != cgl.getShader() || shader.lastCompile != shaderLastCompile))
    {
        shader = cgl.getShader();
        setupShader();
        doSetupUniform = true;
    }

    if (doSetupUniform) setupUniform();

    if (uniform)
    {
        // outType.set(uniform.getType());
        // const oldValue = uniform.getValue();

        // shader.pushTexture(uniform, inValue.get());

        old = shader.setUniformTexture(uniform, inValue.get());
    }
    CGL.MESH.lastShader = null;
    CGL.MESH.lastMesh = null;

    next.trigger();

    if (uniform && old) shader.setUniformTexture(uniform, old);
    CGL.MESH.lastShader = null;
    CGL.MESH.lastMesh = null;
};

inSelect.onChange = function ()
{
    doSetupUniform = true;
};

function setupUniform()
{
    if (shader)
    {
        uniform = shader.getUniform((inSelect.get() || "").split(" ")[0]);

        if (!uniform) op.setUiError("nouni", "uniform unknown", 1);// op.uiAttr({ "error": "uniform unknown. maybe shader changed" });
        else op.setUiError("nouni", null);

        doSetupUniform = false;
    }
}

function setupShader()
{
    unis = shader.getUniforms();

    shaderLastCompile = shader.lastCompile;
    const names = ["..."];

    for (let i = 0; i < unis.length; i++)
        if (unis[i].getType() == "t")
            names.push(unis[i].getName() + " (" + unis[i].getType() + ")");

    inSelect.setUiAttribs({ "values": names });
}


};

Ops.Gl.Shader.SetUniformTexture.prototype = new CABLES.Op();
CABLES.OPS["e43be3e0-b75b-4881-95c3-2c6ee81bff8c"]={f:Ops.Gl.Shader.SetUniformTexture,objName:"Ops.Gl.Shader.SetUniformTexture"};




// **************************************************************
// 
// Ops.Gl.Shader.Shader2Texture
// 
// **************************************************************

Ops.Gl.Shader.Shader2Texture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Render"),
    inShader = op.inObject("Shader", null, "shader"),
    inVPSize = op.inValueBool("Use Viewport Size", true),
    inWidth = op.inValueInt("Width", 512),
    inHeight = op.inValueInt("Height", 512),
    tfilter = op.inValueSelect("filter", ["nearest", "linear", "mipmap"]),
    twrap = op.inValueSelect("wrap", ["clamp to edge", "repeat", "mirrored repeat"], "clamp to edge"),
    inFloatingPoint = op.inValueBool("Floating Point", false),
    inNumTex = op.inSwitch("Num Textures", ["1", "4"], "1"),
    next = op.outTrigger("Next"),
    outTex = op.outTexture("Texture"),
    outTex2 = op.outTexture("Texture 2"),
    outTex3 = op.outTexture("Texture 3"),
    outTex4 = op.outTexture("Texture 4");

op.setPortGroup("Texture Size", [inVPSize, inWidth, inHeight]);
op.setPortGroup("Texture settings", [tfilter, twrap, inFloatingPoint]);

let numTextures = 1;
const cgl = op.patch.cgl;
const prevViewPort = [0, 0, 0, 0];
const effect = null;
const drawBuffArr = [];
let lastShader = null;
let shader = null;

inWidth.onChange =
    inHeight.onChange =
    inFloatingPoint.onChange =
    tfilter.onChange =
    inNumTex.onChange =
    twrap.onChange = initFbLater;

inVPSize.onChange = updateUI;

const showingError = false;

let fb = null;
const tex = null;
let needInit = true;

const mesh = CGL.MESHES.getSimpleRect(cgl, "shader2texture rect");

op.toWorkPortsNeedToBeLinked(inShader);

tfilter.set("nearest");

updateUI();

function warning()
{
    if (tfilter.get() == "mipmap" && inFloatingPoint.get())
    {
        op.setUiError("warning", "HDR and mipmap filtering at the same time is not possible");
    }
    else
    {
        op.setUiError("warning", null);
    }
}

function updateUI()
{
    inWidth.setUiAttribs({ "greyout": inVPSize.get() });
    inHeight.setUiAttribs({ "greyout": inVPSize.get() });

    inWidth.set(cgl.getViewPort()[2]);
    inHeight.set(cgl.getViewPort()[3]);
}

function initFbLater()
{
    needInit = true;
    warning();
}

function resetShader()
{
    if (shader) shader.dispose();
    lastShader = null;
    shader = null;
}

function initFb()
{
    needInit = false;
    if (fb)fb.delete();

    const oldLen = drawBuffArr.length;
    numTextures = parseInt(inNumTex.get());
    drawBuffArr.length = 0;
    for (let i = 0; i < numTextures; i++)drawBuffArr[i] = true;

    if (oldLen != drawBuffArr.length)
    {
        resetShader();
    }

    fb = null;

    let w = inWidth.get();
    let h = inHeight.get();

    if (inVPSize.get())
    {
        w = cgl.getViewPort()[2];
        h = cgl.getViewPort()[3];
    }

    let filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") filter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") filter = CGL.Texture.FILTER_MIPMAP;

    let selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    if (twrap.get() == "repeat") selectedWrap = CGL.Texture.WRAP_REPEAT;
    if (twrap.get() == "mirrored repeat") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;

    if (cgl.glVersion >= 2)
    {
        fb = new CGL.Framebuffer2(cgl, w, h,
            {
                "isFloatingPointTexture": inFloatingPoint.get(),
                "multisampling": false,
                "numRenderBuffers": numTextures,
                "wrap": selectedWrap,
                "filter": filter,
                "depth": true,
                "multisamplingSamples": 0,
                "clear": true
            });
    }
    else
    {
        fb = new CGL.Framebuffer(cgl, inWidth.get(), inHeight.get(),
            {
                "isFloatingPointTexture": inFloatingPoint.get(),
                "filter": filter,
                "wrap": selectedWrap
            });
    }
}

exec.onTriggered = function ()
{
    const vp = cgl.getViewPort();

    if (!fb || needInit)initFb();
    if (inVPSize.get() && fb && (vp[2] != fb.getTextureColor().width || vp[3] != fb.getTextureColor().height)) initFb();

    if (!inShader.get() || !inShader.get().setDrawBuffers) return;

    if (inShader.get() != lastShader)
    {
        lastShader = inShader.get();
        shader = inShader.get().copy();

        shader.setDrawBuffers(drawBuffArr);
    }

    if (!shader)
    {
        outTex.set(null);
        return;
    }

    prevViewPort[0] = vp[0];
    prevViewPort[1] = vp[1];
    prevViewPort[2] = vp[2];
    prevViewPort[3] = vp[3];

    fb.renderStart(cgl);

    cgl.pushPMatrix();
    mat4.identity(cgl.pMatrix);

    cgl.pushViewMatrix();
    mat4.identity(cgl.vMatrix);

    cgl.pushModelMatrix();
    mat4.identity(cgl.mMatrix);

    cgl.pushShader(inShader.get());
    if (shader.bindTextures) shader.bindTextures();

    cgl.pushBlend(false);

    mesh.render(inShader.get());

    cgl.popBlend();

    cgl.popPMatrix();
    cgl.popModelMatrix();
    cgl.popViewMatrix();
    fb.renderEnd(cgl);

    if (numTextures >= 2)
    {
        outTex.set(fb.getTextureColorNum(0));
        outTex2.set(fb.getTextureColorNum(1));
        outTex3.set(fb.getTextureColorNum(2));
        outTex4.set(fb.getTextureColorNum(3));
    }
    else outTex.set(fb.getTextureColor());

    cgl.popShader();

    cgl.gl.viewport(prevViewPort[0], prevViewPort[1], prevViewPort[2], prevViewPort[3]);

    next.trigger();
};


};

Ops.Gl.Shader.Shader2Texture.prototype = new CABLES.Op();
CABLES.OPS["a3debb76-7d84-4548-9e7b-24891423dcce"]={f:Ops.Gl.Shader.Shader2Texture,objName:"Ops.Gl.Shader.Shader2Texture"};




// **************************************************************
// 
// Ops.Gl.Shader.ShaderDefine
// 
// **************************************************************

Ops.Gl.Shader.ShaderDefine = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inShader=op.inObject("Shader"),
    inDefineName=op.inString("Name"),
    inDefineValue=op.inString("Value"),
    inActive=op.inValueBool("Active")
    ;


inShader.onChange=
    inDefineName.onChange=
    inDefineValue.onChange=
    inActive.onChange=update;
update();

function update()
{
    var shader=inShader.get();
    if(!shader)
    {
        return;
    }

    if(!inActive.get()) shader.removeDefine(inDefineName.get());
        else  shader.define(inDefineName.get(),inDefineValue.get());

}

};

Ops.Gl.Shader.ShaderDefine.prototype = new CABLES.Op();
CABLES.OPS["1f870586-1ae4-4b7e-9dd7-24c300c989ba"]={f:Ops.Gl.Shader.ShaderDefine,objName:"Ops.Gl.Shader.ShaderDefine"};




// **************************************************************
// 
// Ops.Gl.Shader.ShaderInfo
// 
// **************************************************************

Ops.Gl.Shader.ShaderInfo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Exec"),
    showFrag = op.inTriggerButton("Show Fragment"),
    showVert = op.inTriggerButton("Show Vertex"),
    showModules = op.inTriggerButton("Show Modules"),
    showUniforms = op.inTriggerButton("Show Uniforms"),
    showState = op.inTriggerButton("State Info"),
    next = op.outTrigger("Next"),

    outSrcFrag = op.outString("Source Frag"),
    outSrcVert = op.outString("Source Vert"),

    outName = op.outString("Name"),
    outId = op.outString("Id"),
    outNeedsBarycentric = op.outBoolNum("needsBarycentric"),
    outNumUniforms = op.outNumber("Num Uniforms"),
    outNumAttributes = op.outNumber("Num Attributes"),
    outAttributeNames = op.outArray("Arributes Names"),
    outDefines = op.outArray("Num Defines");

const cgl = op.patch.cgl;
let shader = null;

function showCodeModal(title, code, type)
{
    if (!CABLES.UI || !CABLES.UI.ModalDialog)
    {
        op.log(title, code);
    }

    let html = "";
    html += "<h2>Code</h2>";
    html += "<b>" + title + "</b> ";
    html += "<br/><br/>";
    html += "<br/><br/>";

    code = code || "";
    code = code.replace(/\</g, "&lt;"); // for <
    code = code.replace(/\>/g, "&gt;"); // for >

    html += "<pre><code class=\"" + (type || "javascript") + "\">" + code + "</code></pre>";

    new CABLES.UI.ModalDialog({
        "title": title,
        "html": html
    });
}

showFrag.onTriggered = function ()
{
    if (CABLES.UI && shader) showCodeModal("fragment shader", shader.finalShaderFrag, "GLSL");
};

showVert.onTriggered = function ()
{
    if (CABLES.UI && shader) showCodeModal("vertex shader", shader.finalShaderVert, "GLSL");
};

let doStateDump = false;
let doUniformDump = false;

showState.onTriggered = function ()
{
    if (!CABLES.UI || !shader) return;
    doStateDump = true;
};

showUniforms.onTriggered = function ()
{
    if (!CABLES.UI || !shader) return;
    doUniformDump = true;
};

exec.onTriggered = function ()
{
    if (cgl.frameStore.shadowPass) return;
    shader = cgl.getShader();
    next.trigger();

    shader.bind();

    if (!shader.getProgram()) op.setUiError("prognull", "Shader is not compiled");
    else op.setUiError("prognull", null);

    if (!shader) op.setUiError("noshader", "No Shader..");
    else op.setUiError("noshader", null);

    if (shader && shader.getProgram())
    {
        const activeUniforms = cgl.gl.getProgramParameter(shader.getProgram(), cgl.gl.ACTIVE_UNIFORMS);
        outNumUniforms.set(activeUniforms);
        outNumAttributes.set(cgl.gl.getProgramParameter(shader.getProgram(), cgl.gl.ACTIVE_ATTRIBUTES));

        let i = 0;
        const attribNames = [];
        for (i = 0; i < cgl.gl.getProgramParameter(shader.getProgram(), cgl.gl.ACTIVE_ATTRIBUTES); i++)
        {
            const name = cgl.gl.getActiveAttrib(shader.getProgram(), i).name;
            attribNames.push(name);
        }
        outAttributeNames.set(attribNames);
        outDefines.set(shader.getDefines());
        outName.set(shader.getName());
        outNeedsBarycentric.set(shader.wireframe);
        outId.set(shader.id);

        op.setUiError("prognull", null);
    }
    else
    {
        outNumUniforms.set(0);
        outNumAttributes.set(0);
        outDefines.set(0);
        outAttributeNames.set(null);
    }

    if (doUniformDump)
    {
        const json = [];
        for (let i = 0; i < shader._uniforms.length; i++)
        {
            json.push({
                "validLoc": shader._uniforms[i]._isValidLoc(),
                "name": shader._uniforms[i]._name,
                "type": shader._uniforms[i]._type,
                "value": shader._uniforms[i]._value,
                "structName": shader._uniforms[i]._structName,
                "structUniformName": shader._uniforms[i]._structUniformName
            });
        }
        showCodeModal("shader uniforms", JSON.stringify(json, false, 2), "json");

        doUniformDump = false;
    }

    if (doStateDump)
    {
        doStateDump = false;
        stateDump();
    }

    outSrcFrag.set(shader.finalShaderFrag);
    outSrcVert.set(shader.finalShaderVert);
};

function stateDump()
{
    let txt = "";
    txt += "";

    txt += "defines (" + outDefines.get().length + ")\n\n";

    for (let i = 0; i < outDefines.get().length; i++)
    {
        txt += "- ";
        txt += outDefines.get()[i][0];
        if (outDefines.get()[i][1])
        {
            txt += ": ";
            txt += outDefines.get()[i][1];
        }
        txt += "\n";
    }

    txt += "\n\n";
    txt += "texturestack (" + shader._textureStackUni.length + ")\n\n";

    for (let i = 0; i < shader._textureStackUni.length; i++)
    {
        txt += "- ";
        txt += shader._textureStackUni[i]._name;
        txt += "(" + shader._textureStackUni[i].shaderType + ")\n";
        if (shader._textureStackTexCgl[i]) txt += JSON.stringify(shader._textureStackTexCgl[i].getInfo());
        txt += "\n";
    }

    txt += "\n\n";
    txt += "uniforms: (" + shader._uniforms.length + ")\n\n";

    for (let i = 0; i < shader._uniforms.length; i++)
    {
        txt += "- ";
        txt += shader._uniforms[i]._name;
        txt += ": ";
        txt += shader._uniforms[i].getValue();

        if (shader._uniforms[i].comment)
        {
            txt += " // ";
            txt += shader._uniforms[i].comment;
        }
        txt += "\n";
    }

    showCodeModal("state info", txt);
}

showModules.onTriggered = function ()
{
    if (!shader) return;
    const mods = shader.getCurrentModules();

    showCodeModal("vertex shader", JSON.stringify(mods, false, 4), "json");
};

//


};

Ops.Gl.Shader.ShaderInfo.prototype = new CABLES.Op();
CABLES.OPS["7afaa77e-a976-4e65-8eb1-a6302b91c0d3"]={f:Ops.Gl.Shader.ShaderInfo,objName:"Ops.Gl.Shader.ShaderInfo"};




// **************************************************************
// 
// Ops.Gl.Shader.SwitchShader
// 
// **************************************************************

Ops.Gl.Shader.SwitchShader = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    value = op.inValueBool("value"),
    shader = op.inObject("shader true"),
    shader2 = op.inObject("shader false"),
    trigger = op.outTrigger("trigger"),
    shaderOut = op.outObject("shaderOut");

const cgl = op.patch.cgl;

shaderOut.ignoreValueSerialize = true;
shader.ignoreValueSerialize = true;
shader2.ignoreValueSerialize = true;

render.onTriggered = doRender;
doRender();

function doRender()
{
    if (value.get())
    {
        if (shader.get())
        {
            cgl.pushShader(shader.get());
            shaderOut.set(shader.get());
            shader.get().bindTextures();
            trigger.trigger();
            cgl.popShader();
        }
    }
    else
    {
        if (shader2.get())
        {
            cgl.pushShader(shader2.get());
            shaderOut.set(shader2.get());
            shader2.get().bindTextures();
            trigger.trigger();
            cgl.popShader();
        }
    }
}


};

Ops.Gl.Shader.SwitchShader.prototype = new CABLES.Op();
CABLES.OPS["34ae93a7-ceb4-4e02-8d6f-a38f5e6c732b"]={f:Ops.Gl.Shader.SwitchShader,objName:"Ops.Gl.Shader.SwitchShader"};




// **************************************************************
// 
// Ops.Gl.Shader.VertexColorMaterial
// 
// **************************************************************

Ops.Gl.Shader.VertexColorMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"vertexcolor_frag":"{{MODULES_HEAD}}\n\nIN vec4 vertColor;\nUNI float opacity;\n\nvoid main()\n{\n{{MODULE_BEGIN_FRAG}}\n   vec4 col=vertColor;\n{{MODULE_COLOR}}\n\n   col.a=opacity;\n   outColor= col;\n}","vertexcolor_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nIN vec3 attrVertColor;\nOUT vec4 vertColor;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nIN vec3 attrVertNormal;\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    vertColor.rgb=attrVertColor;\n    vec3 norm=attrVertNormal;\n    vec4 pos = vec4( vPosition, 1. );\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat4 mvMatrix=viewMatrix*mMatrix;\n\n   gl_Position = projMatrix * mvMatrix * pos;\n}",};
const cgl = op.patch.cgl,
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    opacity = op.inValueFloat("opacity", 1);

const shader = new CGL.Shader(cgl, "vertex color material");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.uniOpacity = new CGL.Uniform(shader, "f", "opacity", opacity.get());
shader.setSource(attachments.vertexcolor_vert, attachments.vertexcolor_frag);

render.onTriggered = doRender;

opacity.onChange = function ()
{
    shader.uniOpacity.setValue(opacity.get());
};

function doRender()
{
    cgl.pushShader(shader);
    trigger.trigger();
    cgl.popShader();
}


};

Ops.Gl.Shader.VertexColorMaterial.prototype = new CABLES.Op();
CABLES.OPS["a01d592b-0e5e-48f3-a9fd-54b87ffd623b"]={f:Ops.Gl.Shader.VertexColorMaterial,objName:"Ops.Gl.Shader.VertexColorMaterial"};




// **************************************************************
// 
// Ops.Gl.Shader.VertexNumberMaterial
// 
// **************************************************************

Ops.Gl.Shader.VertexNumberMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;

const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");

const srcVert = ""
    .endl() + "IN float attrVertIndex;"
    .endl() + "UNI mat4 projMatrix;"
    .endl() + "UNI mat4 mvMatrix;"
    .endl() + "IN vec3 vPosition;"
    .endl() + "OUT float num;"

    .endl() + "void main()"
    .endl() + "{"
    .endl() + "   num=attrVertIndex;"
    .endl() + "   gl_Position = projMatrix * mvMatrix * vec4(vPosition,  1.0);"
    .endl() + "}";

const srcFrag = ""
    .endl() + "IN float num;"
    .endl() + "UNI float numVertices;"

    .endl() + "void main()"
    .endl() + "{"

    .endl() + "float c = num/numVertices/3.0;"
    .endl() + "c = mod(c,0.1)*10.0;"

    .endl() + "   outColor= vec4(c,c,c,1.0);"

    .endl() + "}";

function doRender()
{
    cgl.pushShader(shader);
    trigger.trigger();
    cgl.popShader();
}

const shader = new CGL.Shader(cgl, "vertexnumber material");
shader.setSource(srcVert, srcFrag);

render.onTriggered = doRender;

doRender();


};

Ops.Gl.Shader.VertexNumberMaterial.prototype = new CABLES.Op();
CABLES.OPS["732ff263-1aeb-4f39-969f-c781d7776cc8"]={f:Ops.Gl.Shader.VertexNumberMaterial,objName:"Ops.Gl.Shader.VertexNumberMaterial"};




// **************************************************************
// 
// Ops.Gl.Shader.WireframeMaterial
// 
// **************************************************************

Ops.Gl.Shader.WireframeMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"wireframe_frag":"{{MODULES_HEAD}}\n\nIN vec3 barycentric;\nUNI float width;\nUNI float opacity;\nUNI float r,g,b;\nUNI float fr,fg,fb;\nIN vec3 norm;\n\nfloat edgeFactor()\n{\n    vec3 d = fwidth(barycentric);\n    vec3 a3 = smoothstep(vec3(0.0), d*width*4.0, barycentric);\n    return min(min(a3.x, a3.y), a3.z);\n}\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n\n    vec4 col;\n\n    #ifdef WIREFRAME_FILL\n        float v=opacity*(1.0-edgeFactor())*0.95;\n        vec3 wire = vec3(fr, fg, fb);\n        col.rgb = vec3(r, g, b);\n        col.rgb = mix(wire,col.rgb,v);\n        col.a = opacity;\n    #endif\n\n    #ifndef WIREFRAME_FILL\n        col = vec4(r,g,b, opacity*(1.0-edgeFactor())*0.95);\n    #endif\n\n    {{MODULE_COLOR}}\n\n// col=vec4(1.0);\n    outColor=col;\n}","wireframe_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nOUT vec3 barycentric;\nIN vec2 attrTexCoord;\nOUT vec2 texCoord;\n\nIN vec3 attrBarycentric;\nIN vec3 attrVertNormal;\nOUT vec3 norm;\n\nvoid main()\n{\n    norm=attrVertNormal;\n    texCoord=attrTexCoord;\n    barycentric=attrBarycentric;\n    mat4 mMatrix=modelMatrix;\n    vec4 pos=vec4(vPosition, 1.0);\n\n    {{MODULE_VERTEX_POSITION}}\n\n    gl_Position = projMatrix * viewMatrix * mMatrix * pos;\n}\n",};
let cgl = op.patch.cgl;

let render = op.inTrigger("render");
let trigger = op.outTrigger("trigger");

let enableDepth = op.inValueBool("enable depth testing", true);

let fill = op.inValueBool("fill", true);

function setDefines()
{
    if (shader)
        if (fill.get()) shader.define("WIREFRAME_FILL");
        else shader.removeDefine("WIREFRAME_FILL");
}

fill.onChange = function ()
{
    setDefines();
};

let w = op.inValueSlider("width", 0.25);
w.onChange = function () { uniformWidth.setValue(w.get()); };

let opacity = op.inValueSlider("opacity", 1);
opacity.onChange = function () { uniformOpacity.setValue(opacity.get()); };

if (cgl.glVersion == 1 && !cgl.gl.getExtension("OES_standard_derivatives"))
{
    op.uiAttr({ "error": "no oes standart derivatives!" });
}
else
{
    op.uiAttr({ "error": null });
}

let doRender = function ()
{
    // if(true!==enableDepth.get()) cgl.gl.disable(cgl.gl.DEPTH_TEST);
    // else cgl.gl.enable(cgl.gl.DEPTH_TEST);
    cgl.pushDepthTest(enableDepth.get());

    cgl.pushShader(shader);
    trigger.trigger();
    cgl.popShader();

    // if(true!==enableDepth.get()) cgl.gl.enable(cgl.gl.DEPTH_TEST);
    cgl.popDepthTest();
};

const shader = new CGL.Shader(cgl, "Wireframe Material");

if (cgl.glVersion > 1)shader.glslVersion = 300;
const uniformWidth = new CGL.Uniform(shader, "f", "width", w.get());
const uniformOpacity = new CGL.Uniform(shader, "f", "opacity", opacity.get());

if (cgl.glVersion == 1)shader.enableExtension("OES_standard_derivatives");

shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.wireframe_vert || "", attachments.wireframe_frag || "");
shader.wireframe = true;
setDefines();

// diffuse color
let r = op.inValueSlider("diffuse r", Math.random());
let g = op.inValueSlider("diffuse g", Math.random());
let b = op.inValueSlider("diffuse b", Math.random());

r.setUiAttribs({ "colorPick": true });

g.uniform = new CGL.Uniform(shader, "f", "g", g);
r.uniform = new CGL.Uniform(shader, "f", "r", r);
b.uniform = new CGL.Uniform(shader, "f", "b", b);

{
    // diffuse color

    let fr = op.inValueSlider("Fill R", Math.random());
    fr.setUiAttribs({ "colorPick": true });
    fr.uniform = new CGL.Uniform(shader, "f", "fr", fr);

    let fg = op.inValueSlider("Fill G", Math.random());
    fg.uniform = new CGL.Uniform(shader, "f", "fg", fg);

    let fb = op.inValueSlider("Fill B", Math.random());
    fb.uniform = new CGL.Uniform(shader, "f", "fb", fb);
}

render.onTriggered = doRender;

doRender();


};

Ops.Gl.Shader.WireframeMaterial.prototype = new CABLES.Op();
CABLES.OPS["e5d64a7d-b161-4f85-907e-e10a34691733"]={f:Ops.Gl.Shader.WireframeMaterial,objName:"Ops.Gl.Shader.WireframeMaterial"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.AreaDiscardPixel_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.AreaDiscardPixel_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"areadiscard_frag":"\n\nfloat MOD_de=0.0;\n\n#ifdef MOD_AREA_SPHERE\n    MOD_de=distance(vec3(MOD_x,MOD_y,MOD_z)/MOD_sizeAxis,MOD_areaPos.xyz/MOD_sizeAxis);\n#endif\n\n#ifdef MOD_AREA_BOX\n    if( abs(MOD_y/MOD_sizeAxis.y-MOD_areaPos.y/(MOD_sizeAxis.y*MOD_size))>0.5 ||\n        abs(MOD_x/MOD_sizeAxis.x-MOD_areaPos.x/(MOD_sizeAxis.x*MOD_size))>0.5 ||\n        abs(MOD_z/MOD_sizeAxis.z-MOD_areaPos.z/(MOD_sizeAxis.z*MOD_size))>0.5 ) MOD_de=1.0;\n#endif\n\n#ifdef MOD_AREA_AXIS_X\n    MOD_de=abs(MOD_x-MOD_areaPos.x);\n#endif\n#ifdef MOD_AREA_AXIS_XY\n    MOD_de=abs(MOD_x-MOD_areaPos.x+MOD_areaPos.y);\n#endif\n#ifdef MOD_AREA_AXIS_XZ\n    MOD_de=abs(MOD_x-MOD_areaPos.x+MOD_areaPos.z);\n#endif\n#ifdef MOD_AREA_AXIS_YZ\n    MOD_de=abs(MOD_y-MOD_areaPos.y+MOD_areaPos.z);\n#endif\n#ifdef MOD_AREA_AXIS_Y\n    MOD_de=abs(MOD_y-MOD_areaPos.y);\n#endif\n#ifdef MOD_AREA_AXIS_Z\n    MOD_de=abs(MOD_z-MOD_areaPos.z);\n#endif\n\n#ifdef MOD_AREA_AXIS_X_INFINITE\n    MOD_de=MOD_x-MOD_areaPos.x;\n#endif\n#ifdef MOD_AREA_AXIS_Y_INFINITE\n    MOD_de=MOD_y-MOD_areaPos.y;\n#endif\n#ifdef MOD_AREA_AXIS_Z_INFINITE\n    MOD_de=MOD_z-MOD_areaPos.z;\n#endif\n\n#ifdef MOD_AREA_REPEAT\n    MOD_de=mod(MOD_de,MOD_size+MOD_repeat);\n#endif\n\nMOD_de=MOD_de/MOD_size;\n\n#ifdef MOD_AREA_INVERT\n    MOD_de=1.0-MOD_de;\n#endif\n\n\nif(MOD_de<=0.5) discard;\n\n","areadiscard_head_frag":"IN vec4 MOD_areaPos;\n",};
const
    render = op.inTrigger("render"),
    inInvert = op.inValueBool("Invert"),
    inArea = op.inValueSelect("Area", ["Sphere", "Box", "Axis X", "Axis Y", "Axis Z", "Axis XY", "Axis XZ", "Axis YZ", "Axis X Infinite", "Axis Y Infinite", "Axis Z Infinite"], "Sphere"),
    inSize = op.inValue("Size", 1),
    inSizeX = op.inValueFloat("Size X", 1),
    inSizeY = op.inValueFloat("Size Y", 1),
    inSizeZ = op.inValueFloat("Size Z", 1),
    inRepeat = op.inValueBool("Repeat"),
    inRepeatDist = op.inValueFloat("Repeat Distance", 0.0),
    x = op.inValue("x"),
    y = op.inValue("y"),
    z = op.inValue("z"),
    inWorldSpace = op.inValueBool("WorldSpace", true),
    next = op.outTrigger("trigger");

const cgl = op.patch.cgl;

op.setPortGroup("Size", [inSize, inSizeY, inSizeX, inSizeZ]);
op.setPortGroup("Position", [x, y, z, inWorldSpace]);


const srcHeadVert = ""
    .endl() + "OUT vec4 MOD_areaPos;"
    .endl();

const srcBodyVert = ""
    .endl() + "#ifndef MOD_WORLDSPACE"
    .endl() + "   MOD_areaPos=pos;"
    .endl() + "#endif"
    .endl() + "#ifdef MOD_WORLDSPACE"
    .endl() + "   MOD_areaPos=mMatrix*pos;"
    .endl() + "#endif"
    .endl();

inWorldSpace.onChange =
inInvert.onChange =
inRepeat.onChange =
inArea.onChange = updateDefines;

const mod = new CGL.ShaderModifier(cgl, op.name);

mod.addModule({
    "priority": 2,
    "title": op.objName,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": srcHeadVert,
    "srcBodyVert": srcBodyVert
});
mod.addModule({
    "title": op.objName,
    "name": "MODULE_COLOR",
    "srcHeadFrag": attachments.areadiscard_head_frag || "",
    "srcBodyFrag": attachments.areadiscard_frag || ""
});

mod.addUniformFrag("f", "MOD_size", inSize);
mod.addUniformFrag("f", "MOD_x", x);
mod.addUniformFrag("f", "MOD_y", y);
mod.addUniformFrag("f", "MOD_z", z);
mod.addUniformFrag("3f", "MOD_sizeAxis", inSizeX, inSizeY, inSizeZ);
mod.addUniformFrag("f", "MOD_repeat", inRepeatDist);

updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get());
    mod.toggleDefine("MOD_AREA_INVERT", inInvert.get());
    mod.toggleDefine("MOD_AREA_REPEAT", inRepeat.get());
    mod.toggleDefine("MOD_AREA_BOX", inArea.get() == "Box");
    mod.toggleDefine("MOD_AREA_SPHERE", inArea.get() == "Sphere");
    mod.toggleDefine("MOD_AREA_AXIS_X", inArea.get() == "Axis X");
    mod.toggleDefine("MOD_AREA_AXIS_Y", inArea.get() == "Axis Y");
    mod.toggleDefine("MOD_AREA_AXIS_Z", inArea.get() == "Axis Z");
    mod.toggleDefine("MOD_AREA_AXIS_XY", inArea.get() == "Axis XY");
    mod.toggleDefine("MOD_AREA_AXIS_XZ", inArea.get() == "Axis XZ");
    mod.toggleDefine("MOD_AREA_AXIS_YZ", inArea.get() == "Axis YZ");
    mod.toggleDefine("MOD_AREA_AXIS_X_INFINITE", inArea.get() == "Axis X Infinite");
    mod.toggleDefine("MOD_AREA_AXIS_Y_INFINITE", inArea.get() == "Axis Y Infinite");
    mod.toggleDefine("MOD_AREA_AXIS_Z_INFINITE", inArea.get() == "Axis Z Infinite");
}

render.onTriggered = function ()
{
    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": x,
                "posY": y,
                "posZ": z
            });

    if (cgl.shouldDrawHelpers(op)) CABLES.GL_MARKER.drawSphere(op, inSize.get());

    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.AreaDiscardPixel_v2.prototype = new CABLES.Op();
CABLES.OPS["0d39986b-c594-44d5-815d-c46a280fe16c"]={f:Ops.Gl.ShaderEffects.AreaDiscardPixel_v2,objName:"Ops.Gl.ShaderEffects.AreaDiscardPixel_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.AreaRotate_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.AreaRotate_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"area_rotate_vert":"\n\nvec4 MOD_scaler(vec4 pos,mat4 modelMatrix)\n{\n    vec3 forcePos=vec3(MOD_x,MOD_y,MOD_z);\n    vec3 vecToOrigin=(modelMatrix*pos).xyz-forcePos;\n    float dist=abs(length(vecToOrigin));\n    float distAlpha = (MOD_size - dist) ;\n\n    if(MOD_smooth) distAlpha=smoothstep(0.0,MOD_size,distAlpha);\n\n    // pos.xyz*=(1.0+(distAlpha*MOD_strength));\n\n    mat3 rotation = mat3(\n        vec3( cos(MOD_strength*distAlpha),  sin(MOD_strength*distAlpha),  0.0),\n        vec3(-sin(MOD_strength*distAlpha),  cos(MOD_strength*distAlpha),  0.0),\n        vec3(        0.0,         0.0,  1.0)\n    );\n    pos =vec4(rotation * pos.xyz, 1.0);\n\n\n    return pos;\n}\n",};
const
    render=op.inTrigger("render"),
    inSize=op.inValue("Size",1),
    inStrength=op.inValue("Strength",1),
    inSmooth=op.inValueBool("Smooth",true),
    x=op.inValue("x"),
    y=op.inValue("y"),
    z=op.inValue("z"),
    next=op.outTrigger("trigger");

const cgl=op.patch.cgl;
const srcBodyVert=''
    .endl()+'pos=MOD_scaler(pos,mMatrix);'
    .endl();

const mod = new CGL.ShaderModifier(cgl, op.name);

mod.addModule({
    "priority": 2,
    "title": "vert"+op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.area_rotate_vert,
    "srcBodyVert": srcBodyVert
});

mod.addUniform("f", "MOD_x", x);
mod.addUniform("f", "MOD_y", y);
mod.addUniform("f", "MOD_z", z);

mod.addUniform("f", "MOD_size", inSize);
mod.addUniform("f", "MOD_strength", inStrength);
mod.addUniform("b", "MOD_smooth", inSmooth);


render.onTriggered=function()
{
    if(!cgl.getShader())
    {
        next.trigger();
        return;
    }

    if(op.isCurrentUiOp()) gui.setTransformGizmo( {posX:x,posY:y,posZ:z });

    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.AreaRotate_v2.prototype = new CABLES.Op();
CABLES.OPS["ebfd3f0c-7a58-44d3-aba0-72d91fafd7ae"]={f:Ops.Gl.ShaderEffects.AreaRotate_v2,objName:"Ops.Gl.ShaderEffects.AreaRotate_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.AreaScaler_v3
// 
// **************************************************************

Ops.Gl.ShaderEffects.AreaScaler_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"areascale_vert":"\nvec4 MOD_scaler(vec4 pos,vec4 worldPos,vec3 normal,mat4 mMatrix)\n{\n    vec3 forcePos = vec3(MOD_x,MOD_y,MOD_z);\n\n    #ifdef MOD_OBJECT_POS\n        worldPos=mMatrix*vec4(0.0,0.0,0.0,1.0);\n    #endif\n\n    vec3 vecToOrigin = worldPos.xyz-forcePos;\n\n    float dist = abs(length(vecToOrigin)) ;\n\n\n    float distAlpha = (MOD_size - dist) ;\n\n    if(MOD_smooth) distAlpha = smoothstep(0.0,MOD_size,distAlpha);\n\n    float m = distAlpha * MOD_strength;\n\n    #ifdef MOD_TO_ZERO\n        m+=1.0;\n    #endif\n\n    if(m<0.0)m=0.0;\n\n    #ifdef MOD_CLAMP_SIZE\n        pos.xyz*=clamp(m,MOD_clampMin,MOD_clampMax);\n    #else\n        pos.xyz*=m ;\n    #endif\n\n    return pos;\n}\n",};
const
    exec = op.inTrigger("render"),
    inSize = op.inValue("Area size", 1),
    inSrc = op.inSwitch("Source", ["Vertex position", "Object position"], "Vertex position"),
    inStrength = op.inValue("Strength", 1),
    inSmooth = op.inValueBool("Smoothstep", false),
    inToZero = op.inValueBool("Min Size Original", false),
    inClampBool = op.inBool("Clamp size", false),
    inClampMin = op.inFloat("Clamp min", 0),
    inClampMax = op.inFloat("Clamp max", 1.0),
    x = op.inValue("Pos X"),
    y = op.inValue("Pos Y"),
    z = op.inValue("Pos Z"),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;
let needsUpdateToZero = true;
const mscaleUni = null;
let shader = null;

op.setPortGroup("Position", [x, y, z]);
op.setPortGroup("Influence", [inSrc, inStrength, inSmooth, inToZero]);

const srcBodyVert = ""
    .endl() + "pos=MOD_scaler(pos,mMatrix*pos,attrVertNormal,mMatrix);" // modelMatrix*
    .endl();

let moduleVert = null;

// op.onDelete = exec.onLinkChanged = removeModule;
inToZero.onChange = inSrc.onChange = inClampBool.onChange = updateToZero;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "priority": 2,
    "title": "vert_" + op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.areascale_vert,
    "srcBodyVert": srcBodyVert
});


mod.addUniform("f", "MOD_size", inSize);
mod.addUniform("f", "MOD_strength", inStrength);
mod.addUniform("b", "MOD_smooth", inSmooth);

mod.addUniform("f", "MOD_clampMin", inClampMin);
mod.addUniform("f", "MOD_clampMax", inClampMax);

mod.addUniform("f", "MOD_x", x);
mod.addUniform("f", "MOD_y", y);
mod.addUniform("f", "MOD_z", z);


// function removeModule()
// {
//     if (shader && moduleVert) shader.removeModule(moduleVert);
//     shader = null;
// }

function updateToZero()
{
    // if (!shader)
    // {
    //     needsUpdateToZero = true;
    //     return;
    // }

    mod.toggleDefine("MOD_TO_ZERO", inToZero.get());
    mod.toggleDefine("MOD_OBJECT_POS", inSrc.get() == "Object position");
    mod.toggleDefine("MOD_CLAMP_SIZE", inClampBool.get());

    needsUpdateToZero = false;

    inClampMin.setUiAttribs({ "greyout": !inClampBool.get() });
    inClampMax.setUiAttribs({ "greyout": !inClampBool.get() });
}


exec.onTriggered = function ()
{
    if (!cgl.getShader())
    {
        next.trigger();
        return;
    }

    if (CABLES.UI)
    {
        if (op.isCurrentUiOp()) gui.setTransformGizmo({ "posX": x, "posY": y, "posZ": z });

        if (cgl.shouldDrawHelpers(op))
        {
            cgl.pushModelMatrix();
            mat4.translate(cgl.mMatrix, cgl.mMatrix, [x.get(), y.get(), z.get()]);
            CABLES.GL_MARKER.drawSphere(op, inSize.get());
            cgl.popModelMatrix();
        }
    }

    // if (cgl.getShader() != shader)
    // {
    //     if (shader) removeModule();
    //     shader = cgl.getShader();

    //     moduleVert = shader.addModule(
    //         {
    //             "title": op.objName,
    //             "name": "MODULE_VERTEX_POSITION",
    //             "srcHeadVert": attachments.areascale_vert,
    //             "srcBodyVert": srcBodyVert
    //         });

    //     inSize.uniform = new CGL.Uniform(shader, "f", "MOD_size", inSize);
    //     inStrength.uniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "strength", inStrength);
    //     inSmooth.uniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "smooth", inSmooth);

    //     x.uniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "x", x);
    //     y.uniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "y", y);
    //     z.uniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "z", z);

    //     inClampMin.uniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "clampMin", inClampMin);
    //     inClampMax.uniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "clampMax", inClampMax);
    // }

    if (needsUpdateToZero)updateToZero();
    // if (!shader) return;


    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.AreaScaler_v3.prototype = new CABLES.Op();
CABLES.OPS["3b7c5601-881a-4748-91d1-aea4c7c1bf67"]={f:Ops.Gl.ShaderEffects.AreaScaler_v3,objName:"Ops.Gl.ShaderEffects.AreaScaler_v3"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.AreaTranslateFBMNoise
// 
// **************************************************************

Ops.Gl.ShaderEffects.AreaTranslateFBMNoise = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"areascale_vert":"UNI bool MOD_smooth;\nUNI float MOD_x,MOD_y,MOD_z;\nUNI float MOD_tx,MOD_ty,MOD_tz;\nUNI float MOD_strength;\nUNI float MOD_size;\nUNI float MOD_noiseScale;\n\n\n\n\nfloat MOD_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 MOD_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 MOD_perm(vec4 x){return MOD_mod289(((x * 34.0) + 1.0) * x);}\n\nfloat MOD_noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = MOD_perm(b.xyxy);\n    vec4 k2 = MOD_perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = MOD_perm(c);\n    vec4 k4 = MOD_perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n\n\nfloat MOD_fbm(vec3 x)\n{\n    const int NUM_OCTAVES=8;\n    float time=0.0;\n\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100.0+time);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * MOD_noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n\nmat4 MOD_rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t0.0,                                0.0,                                0.0,                                1.0\n\t);\n}\n\n\nmat4 MOD_translate(mat4 mat)\n{\n    vec3 forcePos=vec3(MOD_x,MOD_y,MOD_z);\n    vec3 noisePos=vec3(MOD_tx,MOD_ty,MOD_tz);\n    vec3 worldPos=vec3(mat[3][0],mat[3][1],mat[3][2]);\n    // vec3 worldPosInst=vec3(instMat[3][0],instMat[3][1],instMat[3][2]);\n\n    vec3 vecToOrigin=worldPos-forcePos;\n    float dist=abs(length(vecToOrigin));\n    float distAlpha = (MOD_size - dist) ;\n\n    if(MOD_smooth) distAlpha=smoothstep(0.0,MOD_size,distAlpha);\n    else\n    {\n        if(distAlpha>0.0) distAlpha=1.0;\n        else distAlpha=0.0;\n    }\n\n    distAlpha*=MOD_strength;\n\n    vec3 tr=vec3(distAlpha);\n\n    float nois=(MOD_fbm(MOD_noiseScale*(worldPos+noisePos))-0.5);\n    float nois2=(MOD_fbm(MOD_noiseScale*(worldPos+noisePos*5.711))-0.5);\n    float nois3=(MOD_fbm(MOD_noiseScale*(worldPos+noisePos*2.0))-0.5);\n    // tr=nois*tr;\n\n\n    #ifdef MOD_DO_ROTATE\n        if(distAlpha>0.0) mat*=MOD_rotation3d( vec3(distAlpha)*vec3(nois,nois2,nois3), MOD_strength/57.297);\n    #endif\n\n    #ifdef MOD_DO_TRANSLATE\n        mat[3][0] += nois*distAlpha;\n        mat[3][1] += nois2*distAlpha;\n        mat[3][2] += nois3*distAlpha;\n    #endif\n\n    return mat;\n}\n",};
const
    render = op.inTrigger("render"),
    next = op.outTrigger("trigger"),
    inMode = op.inSwitch("Mode", ["Rotate", "Translate"], "Translate"),
    inSize = op.inValue("Size", 1),
    inStrength = op.inValue("Strength", 1),
    inSmooth = op.inValueBool("Smooth", true),
    x = op.inValue("x"),
    y = op.inValue("y"),
    z = op.inValue("z"),
    inNoiseScale = op.inValue("Noise Scale", 0.5),
    tx = op.inValue("Noise X"),
    ty = op.inValue("Noise Y"),
    tz = op.inValue("Noise Z");

const cgl = op.patch.cgl;
op.setPortGroup("Noise", [inNoiseScale, tx, ty, tz]);
op.setPortGroup("Area Position", [x, y, z]);

let needsUpdateToZero = true;
let mscaleUni = null;
let shader = null;
let uniforms = {};
let srcHeadVert = attachments.areascale_vert;
let moduleVert = null;
let srcBodyVert = ""
    .endl() + "mMatrix=MOD_translate(mMatrix);" // modelMatrix*
    .endl();

render.onLinkChanged = removeModule;
inMode.onChange = updateMode;

function removeModule()
{
    if (shader && moduleVert) shader.removeModule(moduleVert);
    shader = null;
}

function updateMode()
{
    if (!shader) return;
    shader.toggleDefine(moduleVert.prefix + "DO_ROTATE", inMode.get() == "Rotate");
    shader.toggleDefine(moduleVert.prefix + "DO_TRANSLATE", inMode.get() == "Translate");
}

render.onTriggered = function ()
{
    if (!cgl.getShader())
    {
        next.trigger();
        return;
    }

    if (CABLES.UI)
    {
        if (op.isCurrentUiOp()) gui.setTransformGizmo({ "posX": x, "posY": y, "posZ": z });
        if (cgl.shouldDrawHelpers(op))
        {
            cgl.pushModelMatrix();
            mat4.translate(cgl.mMatrix, cgl.mMatrix, [x.get(), y.get(), z.get()]);
            CABLES.GL_MARKER.drawSphere(op, inSize.get());
            cgl.popModelMatrix();
        }
    }

    if (cgl.getShader() != shader)
    {
        if (shader) removeModule();
        shader = cgl.getShader();

        moduleVert = shader.addModule(
            {
                "title": op.objName,
                "name": "MODULE_VERTEX_POSITION",
                "srcHeadVert": srcHeadVert,
                "srcBodyVert": srcBodyVert
            });

        updateMode();

        uniforms.inSizeUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "size", inSize);
        uniforms.inStrengthUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "strength", inStrength);
        uniforms.inSmoothUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "smooth", inSmooth);
        uniforms.inNoiseScaleUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "noiseScale", inNoiseScale);

        uniforms.xUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "x", x);
        uniforms.yUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "y", y);
        uniforms.zUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "z", z);

        uniforms.txUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "tx", tx);
        uniforms.tyUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "ty", ty);
        uniforms.tzUniform = new CGL.Uniform(shader, "f", moduleVert.prefix + "tz", tz);
    }


    if (!shader) return;

    next.trigger();
};


};

Ops.Gl.ShaderEffects.AreaTranslateFBMNoise.prototype = new CABLES.Op();
CABLES.OPS["e755e88e-a2a7-4db2-84b3-0e76c423bdb6"]={f:Ops.Gl.ShaderEffects.AreaTranslateFBMNoise,objName:"Ops.Gl.ShaderEffects.AreaTranslateFBMNoise"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.AreaTranslateMeshes_v3
// 
// **************************************************************

Ops.Gl.ShaderEffects.AreaTranslateMeshes_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"areascale_vert":"\nmat4 MOD_translate(mat4 mat)\n{\n    // vec3 forcePos=vec3(MOD_posx,MOD_posy,MOD_posz);\n    vec3 worldPos=vec3(mat[3][0],mat[3][1],mat[3][2]);\n    vec3 vecToOrigin=worldPos-MOD_pos;\n    float dist=abs(length(vecToOrigin));\n    float distAlpha = (MOD_size - dist) ;\n\n    distAlpha=clamp(distAlpha,0.0,1.0);\n\n    distAlpha*=MOD_strength;\n\n    vec3 tr=normalize(vecToOrigin)*distAlpha;\n\ntr*=MOD_mul;\n\n    mat[3][0] += tr.x;\n    mat[3][1] += tr.y;\n    mat[3][2] += tr.z;\n\n    return mat;\n}\n\n",};
const
    render = op.inTrigger("render"),
    next = op.outTrigger("trigger"),
    inSize = op.inValue("Size", 1),
    inStrength = op.inValue("Strength", 0.5),
    x = op.inValue("x"),
    y = op.inValue("y"),
    z = op.inValue("z"),
    mulx = op.inValue("Multiply x", 1),
    muly = op.inValue("Multiply y", 1),
    mulz = op.inValue("Multiply z", 1);

const cgl = op.patch.cgl;

op.setPortGroup("Area Position", [x, y, z]);
op.setPortGroup("Axis Multiply", [mulx, muly, mulz]);

const needsUpdateToZero = true;
const mscaleUni = null;
let shader = null;
const srcHeadVert = attachments.areascale_vert;
const uniforms = {};
const srcBodyVert = ""
    .endl() + "mMatrix=MOD_translate(mMatrix);" // modelMatrix*
    .endl();

let moduleVert = null;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": srcHeadVert,
    "srcBodyVert": srcBodyVert
});

mod.addUniformVert("f", "MOD_size", inSize);
mod.addUniformVert("f", "MOD_strength", inStrength);

mod.addUniformVert("3f", "MOD_pos", x, y, z);
mod.addUniformVert("3f", "MOD_mul", mulx, muly, mulz);

render.onTriggered = function ()
{
    if (!cgl.getShader())
    {
        next.trigger();
        return;
    }

    if (CABLES.UI)
    {
        if (op.isCurrentUiOp())
            gui.setTransformGizmo(
                {
                    "posX": x,
                    "posY": y,
                    "posZ": z
                });

        if (cgl.shouldDrawHelpers(op))
        {
            cgl.pushModelMatrix();
            mat4.translate(cgl.mMatrix, cgl.mMatrix, [x.get(), y.get(), z.get()]);
            CABLES.GL_MARKER.drawSphere(op, inSize.get());
            cgl.popModelMatrix();
        }
    }

    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.AreaTranslateMeshes_v3.prototype = new CABLES.Op();
CABLES.OPS["69f7a5b5-4824-441a-960c-e7b13b17790d"]={f:Ops.Gl.ShaderEffects.AreaTranslateMeshes_v3,objName:"Ops.Gl.ShaderEffects.AreaTranslateMeshes_v3"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.Bend_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.Bend_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"bend_vert":"\n\nvoid MOD_bendDistort(inout vec3 pos, inout vec3 norm)\n{\n    pos = (MOD_transMatrix * vec4(pos, 1.0)).xyz;\n    norm = (vec4(norm, 0.0) * MOD_invTransMatrix).xyz;\n\n    float PI = 3.14159265;\n    if (abs(MOD_amount) > 1e-5) {\n        float bendAngle = MOD_amount;\n        float radius = 1.0 / bendAngle;\n\n        // float d = clamp(pos.x, MOD_range.x, MOD_range.y);\n        float d = clamp(pos.x, MOD_range.x, MOD_range.y);\n        float th = PI * 0.5 + (bendAngle * d);\n        float s = sin(th);\n        float c = cos(th);\n        pos.xy = vec2(s * (pos.x - d) - c * (radius + pos.y),\n                      c * (pos.x - d) + s * (radius + pos.y) - radius);\n        norm.xy = vec2(s * norm.x - c * norm.y,\n                       c * norm.x + s * norm.y);\n    }\n\n    pos = (MOD_invTransMatrix * vec4(pos, 1.0)).xyz;\n    norm = (vec4(norm, 0.0) * MOD_transMatrix).xyz;\n}\n",};
const render = op.inTrigger("render");
const amount = op.inValue("Amount");
const rotX = op.inValue("RotX");
const rotY = op.inValue("RotY");
const rotZ = op.inValue("RotZ");
const scale = op.inValue("Scale", 2);
const offset = op.inValue("Offset", 0.25);
const limited = op.inValueBool("Limited", true);

const next = op.outTrigger("trigger");

const srcHeadVert = attachments.bend_vert;
const srcBodyVert = ""
    .endl() + "   MOD_bendDistort(pos.xyz, norm);"
    .endl();

const uniAmount = null;
const uniRange = null;
const uniTransMatrix = null;
const uniInvTransMatrix = null;
const cgl = op.patch.cgl;

let matricesValid = false;
const transMatrix = mat4.create();
const invTransMatrix = mat4.create();
let amountRadians = 0;

function invalidateMatrices()
{
    matricesValid = false;
}

rotX.onChange = invalidateMatrices;
rotY.onChange = invalidateMatrices;
rotZ.onChange = invalidateMatrices;
scale.onChange = invalidateMatrices;
offset.onChange = invalidateMatrices;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.bend_vert,
    "srcBodyVert": srcBodyVert
});

mod.addUniformVert("f", "MOD_amount", 0);
mod.addUniformVert("2f", "MOD_range", [0, 1]);
mod.addUniformVert("m4", "MOD_transMatrix", transMatrix);
mod.addUniformVert("m4", "MOD_invTransMatrix", invTransMatrix);

amount.onChange = function () { amountRadians = amount.get() * CGL.DEG2RAD; };

mat4.identity(transMatrix);
mat4.identity(invTransMatrix);

const tvec = vec3.create();
const svec = vec4.create();
function updateMatrices()
{
    if (matricesValid) return;

    vec3.set(tvec, offset.get(), 0, 0);

    const s = 1 / scale.get();
    vec3.set(svec, s, s, s);

    mat4.identity(transMatrix);
    mat4.translate(transMatrix, transMatrix, tvec);

    mat4.rotateX(transMatrix, transMatrix, rotX.get() * CGL.DEG2RAD);
    mat4.rotateY(transMatrix, transMatrix, rotY.get() * CGL.DEG2RAD);
    mat4.rotateZ(transMatrix, transMatrix, rotZ.get() * CGL.DEG2RAD);

    mat4.scale(transMatrix, transMatrix, svec);

    mat4.invert(invTransMatrix, transMatrix);
    matricesValid = true;
}

render.onTriggered = function ()
{
    mod.setUniformValue("MOD_range", limited.get() ? [0, 1] : [-99999, 99999]);

    updateMatrices();

    mod.bind();
    mod.setUniformValue("MOD_amount", amountRadians);
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.Bend_v2.prototype = new CABLES.Op();
CABLES.OPS["7476156e-3ca3-445a-bd30-1b9373a6af4c"]={f:Ops.Gl.ShaderEffects.Bend_v2,objName:"Ops.Gl.ShaderEffects.Bend_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.ClampVertexPosition_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.ClampVertexPosition_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"restrictVertex_vert":"\n\n#ifndef RESTRICT_UPDATENORMALS\n\n    #ifdef MOD_RESTRICT_AXIS_X\n        pos.x=min(MOD_max,pos.x);\n        pos.x=max(MOD_min,pos.x);\n    #endif\n    #ifdef MOD_RESTRICT_AXIS_Y\n        pos.y=min(MOD_max,pos.y);\n        pos.y=max(MOD_min,pos.y);\n    #endif\n    #ifdef MOD_RESTRICT_AXIS_Z\n        pos.z=min(MOD_max,pos.z);\n        pos.z=max(MOD_min,pos.z);\n    #endif\n\n\n#endif\n\n#ifdef RESTRICT_UPDATENORMALS\n    #ifdef MOD_RESTRICT_AXIS_X\n        if(pos.x>MOD_max)\n        {\n            pos.x=MOD_max;\n            pos.y=0.0;\n            pos.z=0.0;\n            norm=vec3(0.0,1.0,0.0);\n        }\n        if(pos.x<MOD_min)\n        {\n            pos.x=MOD_min;\n            pos.y=0.0;\n            pos.z=0.0;\n            norm=vec3(0.0,-1.0,0.0);\n        }\n    #endif\n    \n    #ifdef MOD_RESTRICT_AXIS_Y\n        if(pos.y>MOD_max)\n        {\n            pos.y=MOD_max;\n            pos.x=0.0;\n            pos.z=0.0;\n            norm=vec3(0.0,0.0,1.0);\n        }\n        if(pos.y<MOD_min)\n        {\n            pos.y=MOD_min;\n            pos.x=0.0;\n            pos.z=0.0;\n            norm=vec3(0.0,0.0,-1.0);\n        }\n    #endif\n    \n    #ifdef MOD_RESTRICT_AXIS_Z\n        if(pos.z>MOD_max)\n        {\n            pos.z=MOD_max;\n            pos.y=0.0;\n            pos.x=0.0;\n            norm=vec3(1.0,0.0,0.0);\n        }\n        if(pos.z<MOD_min)\n        {\n            pos.z=MOD_min;\n            pos.y=0.0;\n            pos.x=0.0;\n            norm=vec3(-1.0,0.0,0.0);\n        }\n        \n    #endif\n#endif",};
const
    render = op.inTrigger("render"),
    next = op.outTrigger("trigger"),
    axis = op.inValueSelect("Axis", ["X", "Y", "Z"], "X"),
    min = op.inValue("min", 0),
    max = op.inValue("max", 1),
    inUpdateNormals = op.inValueBool("Update Normals");

const cgl = op.patch.cgl;

let shader = null;
let moduleVert = null;

const vertModTitle = "vert_" + op.name;
const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "priority": 2,
    "title": vertModTitle,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": "",
    "srcBodyVert": attachments.restrictVertex_vert
});

const minUniform = mod.addUniform("f", "MOD_min", min);
const maxUniform = mod.addUniform("f", "MOD_max", max);

axis.onChange =
    inUpdateNormals.onChange = updateDefines;

function updateDefines()
{
    mod.toggleDefine("RESTRICT_UPDATENORMALS", inUpdateNormals.get());
    mod.toggleDefine("MOD_RESTRICT_AXIS_X", axis.get() == "X");
    mod.toggleDefine("MOD_RESTRICT_AXIS_Y", axis.get() == "Y");
    mod.toggleDefine("MOD_RESTRICT_AXIS_Z", axis.get() == "Z");
}

render.onTriggered = function ()
{
    if (!cgl.getShader())
    {
        next.trigger();
        return;
    }

    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.ClampVertexPosition_v2.prototype = new CABLES.Op();
CABLES.OPS["fa0b0f9a-bac9-4efa-85ef-c5d87aaa9356"]={f:Ops.Gl.ShaderEffects.ClampVertexPosition_v2,objName:"Ops.Gl.ShaderEffects.ClampVertexPosition_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.ColorArea_v4
// 
// **************************************************************

Ops.Gl.ShaderEffects.ColorArea_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorarea_frag":"\nvec3 MOD_size=vec3(MOD_inSizeAmountFalloffSizeX.x);\n#ifdef MOD_DOSCALE\n    MOD_size=1.0/MOD_scale;\n#endif\n\nvec3 MOD_col=MOD_color;\n\n#ifdef MOD_USE_TEX\n    MOD_col=texture(MOD_tex,gl_FragCoord.xy/ float( textureSize(MOD_tex,0).xy) ).rgb;\n#endif\n\n#ifdef MOD_AREA_SPHERE\n    float MOD_de=distance(\n        MOD_pos*MOD_size,\n        MOD_vertPos.xyz*MOD_size\n        )/MOD_inSizeAmountFalloffSizeX.x;\n#endif\n\n#ifdef MOD_AREA_BOX\n    float MOD_de=1.0;\n\n    if(\n        abs((MOD_vertPos.xyz*MOD_size).x-(MOD_pos.xyz*MOD_size).x) > MOD_inSizeAmountFalloffSizeX.x ||\n        abs((MOD_vertPos.xyz*MOD_size).y-(MOD_pos.xyz*MOD_size).y) > MOD_inSizeAmountFalloffSizeX.x ||\n        abs((MOD_vertPos.xyz*MOD_size).z-(MOD_pos.xyz*MOD_size).z) > MOD_inSizeAmountFalloffSizeX.x )  MOD_de=0.0;\n#endif\n\n#ifdef MOD_AREA_AXIS_X\n    float MOD_de=abs(MOD_pos.x-MOD_vertPos.x);\n#endif\n#ifdef MOD_AREA_AXIS_Y\n    float MOD_de=abs(MOD_pos.y-MOD_vertPos.y);\n#endif\n#ifdef MOD_AREA_AXIS_Z\n    float MOD_de=abs(MOD_pos.z-MOD_vertPos.z);\n#endif\n\n#ifdef MOD_AREA_AXIS_X_INFINITE\n    float MOD_de=MOD_pos.x-MOD_vertPos.x;\n#endif\n#ifdef MOD_AREA_AXIS_Y_INFINITE\n    float MOD_de=MOD_pos.y-MOD_vertPos.y;\n#endif\n#ifdef MOD_AREA_AXIS_Z_INFINITE\n    float MOD_de=MOD_pos.z-MOD_vertPos.z;\n#endif\n\n#ifndef MOD_AREA_BOX\n    MOD_de=1.0-smoothstep(MOD_inSizeAmountFalloffSizeX.z*MOD_inSizeAmountFalloffSizeX.x,MOD_inSizeAmountFalloffSizeX.x,MOD_de);\n#endif\n\n#ifdef MOD_AREA_INVERT\n    MOD_de=1.0-MOD_de;\n#endif\n\n#ifdef MOD_BLEND_NORMAL\n    col.rgb=mix(col.rgb,MOD_col, MOD_de*MOD_inSizeAmountFalloffSizeX.y);\n#endif\n\n\n#ifdef MOD_BLEND_MULTIPLY\n    col.rgb=mix(col.rgb,col.rgb*MOD_col,MOD_de*MOD_inSizeAmountFalloffSizeX.y);\n#endif\n\n#ifdef MOD_BLEND_ADD\n    col.rgb+=MOD_de*MOD_inSizeAmountFalloffSizeX.y*MOD_col;\n#endif\n\n\n#ifdef MOD_BLEND_OPACITY\n    col.a*=(1.0-MOD_de*MOD_inSizeAmountFalloffSizeX.y);\n#endif\n\n#ifdef MOD_BLEND_DISCARD\n    if(MOD_de*MOD_inSizeAmountFalloffSizeX.y>=0.999)discard;\n#endif\n\n// col.rgb=vec3(distance(MOD_vertPos.xyz,MOD_pos.xyz))*0.1\n// col.rgb=MOD_pos.xyz;","colorarea_head_frag":"IN vec4 MOD_vertPos;\n",};
const
    render = op.inTrigger("Render"),
    inArea = op.inValueSelect("Area", ["Sphere", "Box", "Axis X", "Axis Y", "Axis Z", "Axis X Infinite", "Axis Y Infinite", "Axis Z Infinite"], "Sphere"),
    inSize = op.inValue("Size", 1),
    inAmount = op.inValueSlider("Amount", 0.5),
    inFalloff = op.inValueSlider("Falloff", 0),
    inInvert = op.inValueBool("Invert"),
    inBlend = op.inSwitch("Blend ", ["Normal", "Multiply", "Opacity", "Add", "Discard"], "Normal"),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    x = op.inValue("x"),
    y = op.inValue("y"),
    z = op.inValue("z"),
    doScale = op.inBool("Change Size", false),
    sizeX = op.inFloat("Size X", 1),
    sizeY = op.inFloat("Size Y", 1),
    sizeZ = op.inFloat("Size Z", 1),
    inTex = op.inTexture("Texture"),

    inWorldSpace = op.inValueBool("WorldSpace", true),
    inPrio = op.inBool("Priority", true),
    next = op.outTrigger("Next");

op.setPortGroup("Scale", [doScale, sizeX, sizeZ, sizeY]);
op.setPortGroup("Position", [x, y, z]);
op.setPortGroup("Color", [inBlend, r, g, b]);
r.setUiAttribs({ "colorPick": true });

const cgl = op.patch.cgl;

const srcHeadVert = ""
    .endl() + "OUT vec4 MOD_vertPos;"
    .endl();

const srcBodyVert = ""
    .endl() + "#ifndef MOD_WORLDSPACE"
    .endl() + "   MOD_vertPos=vec4(vPosition,1.0);"
    .endl() + "#endif"

    .endl() + "#ifdef MOD_WORLDSPACE"
    .endl() + "   MOD_vertPos=mMatrix*pos;"
    .endl() + "#endif"
    .endl();

inWorldSpace.onChange =
    inTex.onLinkChanged =
    inArea.onChange =
    inInvert.onChange =
    doScale.onChange =
    inBlend.onChange = updateDefines;

render.onTriggered = doRender;

const vertModTitle = "vert_" + op.name;
const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "priority": 2,
    "title": vertModTitle,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": srcHeadVert,
    "srcBodyVert": srcBodyVert
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": attachments.colorarea_head_frag,
    "srcBodyFrag": attachments.colorarea_frag
});

mod.addUniform("4f", "MOD_inSizeAmountFalloffSizeX", inSize, inAmount, inFalloff, 0);
mod.addUniform("3f", "MOD_color", r, g, b);
mod.addUniform("3f", "MOD_pos", x, y, z);
mod.addUniform("3f", "MOD_scale", sizeX, sizeY, sizeZ);
mod.addUniform("t", "MOD_tex");

updateDefines();

inPrio.onChange = updatePrio;
updatePrio();

function updatePrio()
{
    mod.removeModule(vertModTitle);

    const vmod = {
        // "priority": 0,
        "title": vertModTitle,
        "name": "MODULE_VERTEX_POSITION",
        srcHeadVert,
        srcBodyVert
    };

    if (inPrio.get()) vmod.priority = 2;

    mod.addModule(vmod);
}

function updateDefines()
{
    mod.toggleDefine("MOD_BLEND_NORMAL", inBlend.get() == "Normal");
    mod.toggleDefine("MOD_BLEND_OPACITY", inBlend.get() == "Opacity");
    mod.toggleDefine("MOD_BLEND_MULTIPLY", inBlend.get() == "Multiply");
    mod.toggleDefine("MOD_BLEND_DISCARD", inBlend.get() == "Discard");
    mod.toggleDefine("MOD_BLEND_ADD", inBlend.get() == "Add");

    mod.toggleDefine("MOD_AREA_SIZE", doScale.get());

    mod.toggleDefine("MOD_AREA_INVERT", inInvert.get());
    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get());

    mod.toggleDefine("MOD_AREA_AXIS_X", inArea.get() == "Axis X");
    mod.toggleDefine("MOD_AREA_AXIS_Y", inArea.get() == "Axis Y");
    mod.toggleDefine("MOD_AREA_AXIS_Z", inArea.get() == "Axis Z");
    mod.toggleDefine("MOD_AREA_AXIS_X_INFINITE", inArea.get() == "Axis X Infinite");
    mod.toggleDefine("MOD_AREA_AXIS_Y_INFINITE", inArea.get() == "Axis Y Infinite");
    mod.toggleDefine("MOD_AREA_AXIS_Z_INFINITE", inArea.get() == "Axis Z Infinite");
    mod.toggleDefine("MOD_AREA_SPHERE", inArea.get() == "Sphere");
    mod.toggleDefine("MOD_AREA_BOX", inArea.get() == "Box");

    mod.toggleDefine("MOD_DOSCALE", doScale.get());

    // mod.removeUniform("3f", "MOD_scale",sizeX,sizeY,sizeZ);
    sizeX.setUiAttribs({ "greyout": !doScale.get() });
    sizeY.setUiAttribs({ "greyout": !doScale.get() });
    sizeZ.setUiAttribs({ "greyout": !doScale.get() });

    mod.toggleDefine("MOD_USE_TEX", inTex.isLinked());
}

function drawHelpers()
{
    if (cgl.frameStore.shadowPass) return;
    if (cgl.shouldDrawHelpers(op)) gui.setTransformGizmo({ "posX": x, "posY": y, "posZ": z });
}

function doRender()
{
    // if(doScale.get()) mod.setUniformValue("MOD_scale",[sizeX.get(),sizeY.get(),sizeZ.get()]);
    mod.bind();

    if (inTex.isLinked())
    {
        let tex = inTex.get();

        if (!tex) tex = CGL.Texture.getEmptyTexture(cgl).tex;
        else tex = tex.tex;

        mod.pushTexture("MOD_tex", tex);
    }

    drawHelpers();
    next.trigger();

    mod.unbind();
}


};

Ops.Gl.ShaderEffects.ColorArea_v4.prototype = new CABLES.Op();
CABLES.OPS["83a4b2b8-23ff-4491-b538-e89ac7934d1a"]={f:Ops.Gl.ShaderEffects.ColorArea_v4,objName:"Ops.Gl.ShaderEffects.ColorArea_v4"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.ColorizeInstancedMeshes
// 
// **************************************************************

Ops.Gl.ShaderEffects.ColorizeInstancedMeshes = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorize_instances_frag":"\n\n// col.rgb*=MOD_random(vec2(instanceIndexFrag/1000.0,instanceIndexFrag/1000.0));\n\nfloat MOD_rand=fract(sin(instanceIndexFrag));\n\n#ifdef LOOKUPTEX\n    // col.rgb*= (texture( MOD_lut, vec2(MOD_rand,0.5) ).rgb-vec3(0.5))*2.0*MOD_strength;\n    col.rgb*=  ( (texture( MOD_lut, vec2(MOD_rand,0.5) ).rgb+0.5)*MOD_strength);\n    // col.rgb*=MOD_strength;\n#endif\n\n#ifdef MULCOLOR\n    col.rgb*=(MOD_rand*2.0)*MOD_strength;\n#endif\n\n",};
const cgl = op.patch.cgl;

op.render = op.inTrigger("render");
op.trigger = op.outTrigger("trigger");

const inStrength = op.inValueSlider("Amount", 1);
const mulColor = op.inValueBool("Multiply Color");
const inLookup = op.inTexture("Lookup Texture");

let shader = null;

let srcBodyVert = ""
    .endl() + "instanceIndexFrag=instanceIndex;"
    .endl();

let srcHeadVert = ""
    .endl() + "#ifndef ATTRIB_instanceIndex"
    .endl() + "  #define ATTRIB_instanceIndex"
    .endl() + "  IN float instanceIndex;"
    .endl() + "#endif"
    .endl() + "#ifndef ATTRIB_instanceIndexFrag"
    .endl() + "  #define ATTRIB_instanceIndexFrag"
    .endl() + "  OUT float instanceIndexFrag;"
    .endl() + "#endif"
    .endl();

let srcHeadFrag = ""

    .endl() + "UNI float MOD_strength;"
    .endl() + "#ifdef LOOKUPTEX"
    .endl() + "   UNI sampler2D MOD_lut;"
    .endl() + "#endif"
    .endl() + "#ifndef ATTRIB_instanceIndexFrag"
    .endl() + "  #define ATTRIB_instanceIndexFrag"
    .endl() + "  IN float instanceIndexFrag;"
    .endl() + "#endif"
    .endl() + "float MOD_random(vec2 co)"
    .endl() + "{"
    .endl() + "   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 437511.5453);"
    .endl() + "}"

    .endl();

let moduleVert = null;
let moduleFrag = null;
function removeModule()
{
    if (shader && moduleVert) shader.removeModule(moduleVert);
    if (shader && moduleFrag) shader.removeModule(moduleFrag);
    shader = null;
}

mulColor.onChange = updateMulColor;
function updateMulColor()
{
    if (shader)
        if (mulColor.get())shader.define("MULCOLOR");
        else shader.removeDefine("MULCOLOR");
}

op.render.onLinkChanged = removeModule;

inLookup.onChange = updateLookupTexture;
function updateLookupTexture()
{
    if (shader)
    {
        if (inLookup.get())shader.define("LOOKUPTEX");
        else shader.removeDefine("LOOKUPTEX");
        inLookup.uniform = new CGL.Uniform(shader, "t", moduleFrag.prefix + "lut", 5);
    }
}

op.render.onTriggered = function ()
{
    if (!cgl.getShader())
    {
        op.trigger.trigger();
        return;
    }

    if (cgl.getShader() != shader)
    {
        if (shader) removeModule();
        shader = cgl.getShader();

        moduleVert = shader.addModule(
            {
                "title": op.objName,
                "name": "MODULE_VERTEX_POSITION",
                "srcHeadVert": srcHeadVert,
                "srcBodyVert": srcBodyVert
            });

        moduleFrag = shader.addModule(
            {
                "title": op.objName,
                "name": "MODULE_COLOR",
                "srcHeadFrag": srcHeadFrag,
                "srcBodyFrag": attachments.colorize_instances_frag
            });

        inStrength.uniform = new CGL.Uniform(shader, "f", moduleFrag.prefix + "strength", inStrength);

        updateMulColor();
        updateLookupTexture();
    }

    if (inLookup.get())
    {
        cgl.setTexture(5, inLookup.get().tex);
        // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, inLookup.get().tex);
    }

    if (!shader) return;

    op.trigger.trigger();
};


};

Ops.Gl.ShaderEffects.ColorizeInstancedMeshes.prototype = new CABLES.Op();
CABLES.OPS["2939f8ec-dd70-40ad-999d-7242e87296b9"]={f:Ops.Gl.ShaderEffects.ColorizeInstancedMeshes,objName:"Ops.Gl.ShaderEffects.ColorizeInstancedMeshes"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.DeformArea
// 
// **************************************************************

Ops.Gl.ShaderEffects.DeformArea = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"deformarea_vert":"vec4 MOD_deform(vec4 pos,mat4 mMatrix)\n{\n    vec4 modelPos=pos;\n\n    #ifdef MOD_WORLDSPACE\n       modelPos=mMatrix*pos;\n    #endif\n\n    vec3 forcePos=vec3(MOD_x,MOD_y,MOD_z);\n    vec3 vecToOrigin=modelPos.xyz-forcePos;\n    float dist=abs(length(vecToOrigin));\n    float distAlpha = (MOD_size - dist) / MOD_size;\n\n    if(MOD_size > dist)\n    {\n        vec3 vecNormal=normalize(vecToOrigin);\n\n        if(MOD_smooth>0.0) distAlpha=smoothstep(0.0,MOD_size,distAlpha);\n\n        vec3 velocity = (vecNormal * distAlpha * MOD_strength );\n\n        pos.xyz+=velocity*0.1;\n    }\n\n    return pos;\n\n}\n",};
const
    render = op.inTrigger("render"),
    next = op.outTrigger("trigger"),
    inSize = op.inValue("Size", 1),
    inStrength = op.inValue("Strength", 0.5),
    inSmooth = op.inValueBool("Smooth", true),
    inWorldSpace = op.inValueBool("WorldSpace", false),
    x = op.inValue("x"),
    y = op.inValue("y"),
    z = op.inValue("z");

const cgl = op.patch.cgl;

inWorldSpace.onChange = updateWorldspace;

// let shader = null;
const srcHeadVert = attachments.deformarea_vert;

const srcBodyVert = ""
    .endl() + "pos=MOD_deform(pos,mMatrix);"
    .endl();

// let moduleVert = null;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.deformarea_vert,
    "srcBodyVert": srcBodyVert
});

mod.addUniformVert("f", "MOD_size", inSize);
mod.addUniformVert("f", "MOD_strength", inStrength);
mod.addUniformVert("f", "MOD_smooth", inSmooth);

mod.addUniformVert("f", "MOD_x", x);
mod.addUniformVert("f", "MOD_y", y);
mod.addUniformVert("f", "MOD_z", z);

render.onTriggered = function ()
{
    if (CABLES.UI)
    {
        if (op.isCurrentUiOp()) gui.setTransformGizmo({ "posX": x, "posY": y, "posZ": z });

        if (cgl.shouldDrawHelpers(op))
        {
            cgl.pushModelMatrix();
            mat4.translate(cgl.mMatrix, cgl.mMatrix, [x.get(), y.get(), z.get()]);
            CABLES.GL_MARKER.drawSphere(op, inSize.get());
            cgl.popModelMatrix();
        }
    }

    mod.bind();
    next.trigger();
    mod.unbind();
};

function updateWorldspace()
{
    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get());
}


};

Ops.Gl.ShaderEffects.DeformArea.prototype = new CABLES.Op();
CABLES.OPS["6c40cfcb-75c8-4c64-bc13-c37faaea73df"]={f:Ops.Gl.ShaderEffects.DeformArea,objName:"Ops.Gl.ShaderEffects.DeformArea"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.DiscardMaterialAlpha
// 
// **************************************************************

Ops.Gl.ShaderEffects.DiscardMaterialAlpha = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"alpha_frag":"\n\n#ifdef ALPHA_THRESHOLD\n    if(col.a<MOD_threshold) discard;\n#endif\n\n#ifdef ALPHA_ONE\n    col.a=1.0;\n#endif\n\n#ifdef ALPHA_DITHERED\n    if ( dither_InterleavedGradientNoise(col.a) <= 0.5 )\n        discard;\n#endif\n\n#ifdef ALPHA_COVERAGE_SHARP\n    // if(col.a<MOD_threshold) discard;\n\n    col.a = (col.a - MOD_threshold) / max(fwidth(col.a), 0.0001) + 0.5;\n#endif","alpha_head_frag":"#ifdef ALPHA_DITHERED\n// from https://github.com/google/filament/blob/main/shaders/src/dithering.fs\n// modified to use this to discard based on factor instead of dithering\nfloat interleavedGradientNoise(highp vec2 n) {\n    return fract(52.982919 * fract(dot(vec2(0.06711, 0.00584), n)));\n}\nfloat dither_InterleavedGradientNoise(float a) {\n    // Jimenez 2014, \"Next Generation Post-Processing in Call of Duty\"\n    highp vec2 uv = gl_FragCoord.xy;\n\n    // The noise variable must be highp to workaround Adreno bug #1096.\n    highp float noise = interleavedGradientNoise(uv);\n\n    return step(noise, a);\n}\n#endif",};
const
    render = op.inTrigger("render"),
    inMeth = op.inSwitch("Method", ["Normal", "Discard", "Coverage", "Cov. Sharp", "Dither", "None"], "Discard"),
    next = op.outTrigger("trigger"),
    inThresh = op.inValueSlider("Threshold", 0.3);

const cgl = op.patch.cgl;
const mod = new CGL.ShaderModifier(cgl, op.name);

let atc = false;

inMeth.onChange = updateDefines;

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": attachments.alpha_head_frag,
    "srcBodyFrag": attachments.alpha_frag
});

mod.addUniformFrag("f", "MOD_threshold", inThresh);

updateDefines();

function updateDefines()
{
    mod.toggleDefine("ALPHA_THRESHOLD", inMeth.get() == "Discard");
    mod.toggleDefine("ALPHA_ONE", inMeth.get() == "None");
    mod.toggleDefine("ALPHA_COVERAGE_SHARP", inMeth.get() == "Cov. Sharp");
    mod.toggleDefine("ALPHA_DITHERED", inMeth.get() == "Dither");

    inThresh.setUiAttribs({ "greyout": !(inMeth.get() == "Discard" || inMeth.get() == "Cov. Sharp") });

    atc = inMeth.get() == "Coverage" || inMeth.get() == "Cov. Sharp";
}

render.onTriggered = function ()
{
    if (atc) cgl.gl.enable(cgl.gl.SAMPLE_ALPHA_TO_COVERAGE);

    mod.bind();
    next.trigger();
    mod.unbind();

    cgl.gl.disable(cgl.gl.SAMPLE_ALPHA_TO_COVERAGE);
};


};

Ops.Gl.ShaderEffects.DiscardMaterialAlpha.prototype = new CABLES.Op();
CABLES.OPS["0cc7f41f-e933-4309-a63a-32a2446a5276"]={f:Ops.Gl.ShaderEffects.DiscardMaterialAlpha,objName:"Ops.Gl.ShaderEffects.DiscardMaterialAlpha"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.ExplodeDividedMesh_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.ExplodeDividedMesh_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"explode_divided_mesh_vert":"\nfloat MOD_rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 MOD_deform(vec4 pos,vec3 normal,float index)\n{\n    index=floor(index/3.0);\n\n    vec4 p=abs(pos);\n    p.x+=MOD_x+0.01;\n    p.y+=MOD_y+0.01;\n    p.z+=MOD_z+0.01;\n\n    vec4 pp=vec4(normal*(MOD_rand(vec2(index)) * MOD_dist-MOD_dist/2.0),1.0) * p;\n\n    #ifdef MOD_ABSOLUTE\n        pp=abs(pp);\n    #endif\n\n    pp.x*=MOD_mulx;\n    pp.y*=MOD_muly;\n    pp.z*=MOD_mulz;\n\n\n    float MOD_falloff=0.2;\n    float distMul=distance(vec3(MOD_posx,MOD_posy,MOD_posz),pos.xyz);\n    distMul=1.0-smoothstep(MOD_falloff*MOD_size,MOD_size,distMul);\n\n\n\n    pos.xyz += distMul*pp.xyz;\n\n    return pos;\n}\n",};
const
    render=op.inTrigger("Render"),
    inDistance=op.inValue("Distance",1),
    inSize=op.inValue("Size",1),

    inAbsolute=op.inValueBool("Absolute",false),
    x=op.inValue("add x"),
    y=op.inValue("add y"),
    z=op.inValue("add z"),

    mulx=op.inValue("mul x",1),
    muly=op.inValue("mul y",1),
    mulz=op.inValue("mul z",1),

    posx=op.inValue("x"),
    posy=op.inValue("y"),
    posz=op.inValue("z"),

    next=op.outTrigger("Next");

op.setPortGroup("Add",[x,z,y]);
op.setPortGroup("Multiply",[mulx,mulz,muly]);
op.setPortGroup("Position",[posx,posz,posy]);

const cgl=op.patch.cgl;
const srcHeadVert=attachments.explode_divided_mesh_vert;

const srcBodyVert=''
    .endl()+'pos=MOD_deform(pos,attrVertNormal,attrVertIndex);'
    .endl();

inAbsolute.onChange=function()
{
    mod.toggleDefine("MOD_ABSOLUTE",inAbsolute.get());
};

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    title:op.objName,
    name:'MODULE_VERTEX_POSITION',
    srcHeadVert:srcHeadVert,
    srcBodyVert:srcBodyVert
});

mod.addUniform('f','MOD_dist',inDistance);

mod.addUniform('f','MOD_x',x);
mod.addUniform('f','MOD_y',y);
mod.addUniform('f','MOD_z',z);

mod.addUniform('f','MOD_mulx',mulx);
mod.addUniform('f','MOD_muly',muly);
mod.addUniform('f','MOD_mulz',mulz);

mod.addUniform('f','MOD_posx',posx);
mod.addUniform('f','MOD_posy',posy);
mod.addUniform('f','MOD_posz',posz);

mod.addUniform('f','MOD_size',inSize);

render.onTriggered=function()
{
    if(op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                posX:posx,
                posY:posy,
                posZ:posz
            });

    mod.bind();
    next.trigger();
    mod.unbind();
};















};

Ops.Gl.ShaderEffects.ExplodeDividedMesh_v2.prototype = new CABLES.Op();
CABLES.OPS["a12f2aab-0cde-44ce-923e-f78a605c783c"]={f:Ops.Gl.ShaderEffects.ExplodeDividedMesh_v2,objName:"Ops.Gl.ShaderEffects.ExplodeDividedMesh_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.FogEffect
// 
// **************************************************************

Ops.Gl.ShaderEffects.FogEffect = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    id = "mod" + Math.floor(Math.random() * 10000),
    render = op.inTrigger("render"),
    next = op.outTrigger("trigger"),
    inMode = op.inSwitch("Mode", ["Color", "R-Opacity"], "Color"),
    inStart = op.inValue("Start", 2),
    inEnd = op.inValue("End", 12),
    inAmount = op.inValueSlider("Amount", 0.5),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random());

const cgl = op.patch.cgl;
r.setUiAttribs({ "colorPick": true });

const srcHeadVert = ""
    .endl() + "OUT vec4 MOD_fogPos;"
    .endl();

const srcBodyVert = ""
    .endl() + "MOD_fogPos=viewMatrix*mMatrix*pos;"
    .endl();

const srcHeadFrag = ""
    .endl() + "IN vec4 MOD_fogPos;"
    .endl();

const srcBodyFrag = ""
    .endl() + "   float MOD_de=(MOD_fogPos.z+MOD_start)/(-1.0*MOD_end);"
    .endl() + "   float mx=clamp(MOD_de*MOD_amount,0.0,1.0);"
// .endl() + "       mx=1.0-mx;"

    .endl() + "#ifdef MOD_FOGMODE_ALPHA"
    .endl() + "       col.a*=mix(col.a,MOD_color.r,mx);"
    .endl() + "#endif"

    .endl() + "#ifndef MOD_FOGMODE_ALPHA"
    .endl() + "       col.rgb=mix(col.rgb,vec3(MOD_color.r,MOD_color.g,MOD_color.b), mx);"
    .endl() + "#endif"

// .endl() + "   #ifdef MOD_ALPHA"
// .endl() + "       col.a=1.0-clamp(MOD_de*MOD_amount,0.0,1.0);"
// .endl() + "   #endif"

    .endl();

const moduleFrag = null;
const moduleVert = null;

const mod = new CGL.ShaderModifier(cgl, op.name);

mod.addModule(
    {
        "priority": 4,
        "title": op.name,
        "name": "MODULE_VERTEX_POSITION",
        "srcHeadVert": srcHeadVert,
        "srcBodyVert": srcBodyVert
    });

mod.addModule(
    {
        "title": op.name,
        "name": "MODULE_COLOR",
        "srcHeadFrag": srcHeadFrag,
        "srcBodyFrag": srcBodyFrag
    });

mod.addUniform("f", "MOD_amount", inAmount);
mod.addUniform("f", "MOD_start", inStart);
mod.addUniform("f", "MOD_end", inEnd);
mod.addUniform("3f", "MOD_color", r, g, b);

inMode.onChange = updateMode;

function updateMode()
{
    mod.toggleDefine("MOD_FOGMODE_ALPHA", inMode.get() == "R-Opacity");
}

render.onTriggered = function ()
{
    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.FogEffect.prototype = new CABLES.Op();
CABLES.OPS["ad61e198-f178-42d0-8be9-cc776365cd3b"]={f:Ops.Gl.ShaderEffects.FogEffect,objName:"Ops.Gl.ShaderEffects.FogEffect"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.FresnelGlow
// 
// **************************************************************

Ops.Gl.ShaderEffects.FresnelGlow = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"fresnel_body_frag":"#ifdef ENABLE_FRESNEL_MOD\n    vec3 MOD_fragNormal = normalize(MOD_norm);\n    col.rgb += MOD_inFresnel.rgb *\n        MOD_CalculateFresnel(vec3(MOD_cameraSpace_pos), MOD_fragNormal)\n        * MOD_inFresnel.w;\n#endif\n","fresnel_body_vert":"#ifdef ENABLE_FRESNEL_MOD\n    MOD_cameraSpace_pos = viewMatrix*mMatrix * pos;\n    MOD_norm = norm;\n    MOD_viewMatrix = mat3(viewMatrix);\n#endif","fresnel_head_frag":"IN vec4 MOD_cameraSpace_pos;\nIN mat3 MOD_viewMatrix;\nIN vec3 MOD_norm;\n\n#ifdef ENABLE_FRESNEL_MOD\n    float MOD_CalculateFresnel(vec3 cameraSpace_pos, vec3 normal)\n    {\n\n        vec3 nDirection = normalize(cameraSpace_pos);\n        vec3 nNormal = normalize(MOD_viewMatrix * normal);\n        vec3 halfDirection = normalize(nNormal + nDirection);\n\n        float cosine = dot(halfDirection, nDirection);\n        float product = max(cosine, 0.0);\n        float factor = pow(product, MOD_inFresnelExponent);\n\n        return 5. * factor;\n\n\n    }\n#endif\n","fresnel_head_vert":"#ifdef ENABLE_FRESNEL_MOD\n    OUT vec4 MOD_cameraSpace_pos;\n    OUT mat3 MOD_viewMatrix;\n    OUT vec3 MOD_norm;\n#endif",};
const cgl = op.patch.cgl;

const inTrigger = op.inTrigger("Trigger In");
const inActive = op.inBool("Active", true);
const inR = op.inFloatSlider("R", Math.random());
const inG = op.inFloatSlider("G", Math.random());
const inB = op.inFloatSlider("B", Math.random());
inR.setUiAttribs({ "colorPick": true });
op.setPortGroup("Color", [inR, inG, inB]);
const inIntensity = op.inFloat("Fresnel Intensity", 1);
const inExponent = op.inFloat("Fresnel Exponent", 2.5);
op.setPortGroup("Fresnel Settings", [inIntensity, inExponent]);

inActive.onChange = () =>
{
    mod.toggleDefine("ENABLE_FRESNEL_MOD", inActive);
    inR.setUiAttribs({ "greyout": !inActive.get() });
    inG.setUiAttribs({ "greyout": !inActive.get() });
    inB.setUiAttribs({ "greyout": !inActive.get() });
    inIntensity.setUiAttribs({ "greyout": !inActive.get() });
    inExponent.setUiAttribs({ "greyout": !inActive.get() });
};

const outTrigger = op.outTrigger("Trigger Out");


const mod = new CGL.ShaderModifier(cgl, "fresnelGlow");
mod.toggleDefine("ENABLE_FRESNEL_MOD", inActive);

mod.addModule({
    "priority": 2,
    "title": "fresnelGlow",
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.fresnel_head_vert,
    "srcBodyVert": attachments.fresnel_body_vert
});

mod.addModule({
    "title": "fresnelGlow",
    "name": "MODULE_COLOR",
    "srcHeadFrag": attachments.fresnel_head_frag,
    "srcBodyFrag": attachments.fresnel_body_frag
});

mod.addUniform("4f", "MOD_inFresnel", inR, inG, inB, inIntensity);
mod.addUniform("f", "MOD_inFresnelExponent", inExponent);

inTrigger.onTriggered = () =>
{
    mod.bind();
    outTrigger.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.FresnelGlow.prototype = new CABLES.Op();
CABLES.OPS["89979937-68a6-4736-8241-3c6b748103d4"]={f:Ops.Gl.ShaderEffects.FresnelGlow,objName:"Ops.Gl.ShaderEffects.FresnelGlow"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.InstancedDisplacementMap_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.InstancedDisplacementMap_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"displace_vert":"\n#ifdef INSTANCING\n\n    #ifdef MOD_SRC_INSTMAT\n        vec3 MOD_p=vec3(instMat[3][0],instMat[3][1],instMat[3][2]);\n    #endif\n\n    #ifdef MOD_SRC_MMAT\n        vec3 MOD_p=vec3(mMatrix[3][0],mMatrix[3][1],mMatrix[3][2]);\n    #endif\n    // vec3 MOD_p=(mMatrix*vec4(0.0,0.0,0.0,1.0)).xyz;//vec3(mMatrix[3][0],mMatrix[3][1],mMatrix[3][2]);\n\n    vec2 MOD_coord=MOD_p.xy*(1.0/MOD_scale)+MOD_offset-vec2(0.5,0.5);\n\n    // vec3 MOD_dis\n\n    #ifdef MOD_CHAN_R\n        vec3 MOD_dis=vec3( texture(MOD_texture,MOD_coord).r );\n    #endif\n    #ifdef MOD_CHAN_G\n        vec3 MOD_dis=vec3( texture(MOD_texture,MOD_coord).g );\n    #endif\n    #ifdef MOD_CHAN_B\n        vec3 MOD_dis=vec3( texture(MOD_texture,MOD_coord).b );\n    #endif\n\n    #ifdef MOD_CHAN_RGB\n        vec3 MOD_dis=vec3( texture(MOD_texture,MOD_coord).rgb );\n    #endif\n\n    #ifdef MOD_COLORIZE\n        MOD_dispColor=MOD_dis;\n    #endif\n\n    #ifdef MOD_DEBUG\n        MOD_dispColor.rg=mod(MOD_coord,1.0).rg;\n    #endif\n\n\n    #ifdef MOD_NORMALIZE\n        MOD_dis=(MOD_dis-0.5)*2.0;\n    #endif\n\n\n    #ifdef MOD_CLAMP\n    if(MOD_coord.x>1.0||MOD_coord.x<0.0|| MOD_coord.y>1.0 || MOD_coord.y<0.0)\n    {\n        MOD_dis=vec3(0.0);\n        #ifdef MOD_COLORIZE\n            MOD_dispColor=vec3(0.0);\n        #endif\n    }\n    #endif\n\n\n    #ifdef MOD_MODE_TRANS\n        MOD_dis*=MOD_strength;\n        MOD_dis+=MOD_min;\n\n        #ifdef MOD_AXIS_X\n            // pos.x+=MOD_dis;\n            mMatrix[3][0] += MOD_dis.x;\n        #endif\n        #ifdef MOD_AXIS_Y\n            // pos.y+=MOD_dis;\n            mMatrix[3][1] += MOD_dis.y;\n        #endif\n        #ifdef MOD_AXIS_Z\n            // pos.z+=MOD_dis;\n            mMatrix[3][2] += MOD_dis.z;\n        #endif\n    #endif\n\n    #ifdef MOD_MODE_SCALE\n        MOD_dis*=MOD_strength;\n        MOD_dis+=MOD_min;\n\n        #ifdef MOD_ABS\n            MOD_dis=abs(MOD_dis);\n        #endif\n\n        #ifdef MOD_AXIS_X\n            pos.x*=MOD_dis.x;\n        #endif\n        #ifdef MOD_AXIS_Y\n            pos.y*=MOD_dis.y;\n        #endif\n        #ifdef MOD_AXIS_Z\n            pos.z*=MOD_dis.z;\n        #endif\n    #endif\n\n    #ifdef MOD_MODE_ROT\n        #define MOD_PI 3.14159265358\n        MOD_dis*=MOD_strength;\n        MOD_dis+=MOD_min;\n\n        #ifdef MOD_AXIS_X\n            pos*=MOD_rot(vec3(1.0,0.0,0.0), MOD_dis.x*3.14);\n            norm=((vec4(norm,0.0)*MOD_rot(vec3(1.0,0.0,0.0), MOD_dis.x*MOD_PI)).xyz);\n        #endif\n        #ifdef MOD_AXIS_Y\n            pos*=MOD_rot(vec3(0.0,1.0,0.0), MOD_dis.y*MOD_PI);\n            norm=((vec4(norm,0.0)*MOD_rot(vec3(0.0,1.0,0.0), MOD_dis.y*MOD_PI)).xyz);\n        #endif\n        #ifdef MOD_AXIS_Z\n            pos*=MOD_rot(vec3(0.0,0.0,1.0), MOD_dis.z*MOD_PI);\n            norm=((vec4(norm,0.0)*MOD_rot(vec3(0.0,0.0,1.0), MOD_dis.z*MOD_PI)).xyz);\n        #endif\n\n        norm=normalize(norm);\n    #endif\n\n#endif\n","displace_head_vert":"\n#ifdef MOD_COLORIZE\nOUT vec3 MOD_dispColor;\n#endif\n\n\n\n#ifdef MOD_MODE_ROT\n\n    mat4 MOD_rot(vec3 axis, float angle)\n    {\n        axis = normalize(axis);\n        float s = sin(angle);\n        float c = cos(angle);\n        float oc = 1.0 - c;\n\n        return mat4(\n    \t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n            oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n            oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n    \t\t0.0,                                0.0,                                0.0,                                1.0\n    \t);\n    }\n\n#endif",};
const
    inTrigger = op.inTrigger("Trigger"),
    inTex = op.inTexture("Texture"),
    inSrc = op.inSwitch("Source", ["Model Pos", "Inst Pos"], "Model Pos"),
    inMode = op.inSwitch("Mode", ["Translate", "Scale", "Rotate"], "Translate"),
    inStrength = op.inFloat("Strength", 1),
    inMin = op.inFloat("Min", 0),
    inScale = op.inFloat("Scale", 1),
    inClamp = op.inBool("Clamp", false),
    inColorize = op.inBool("Colorize", false),
    inDebug = op.inBool("Debug Bounds", false),
    inNormalize = op.inBool("Normalize", false),
    inOffsetX = op.inFloat("Offset X", 0),
    inOffsetY = op.inFloat("Offset Y", 0),
    inAbs = op.inBool("Abs", false),
    inChannel = op.inSwitch("Channel", ["R", "G", "B", "RGB"], "R"),

    inAxisX = op.inBool("X", false),
    inAxisY = op.inBool("Y", false),
    inAxisZ = op.inBool("Z", true),

    next = op.outTrigger("Next");

inAxisX.onChange =
inTex.onChange =
    inAxisY.onChange =
    inAxisZ.onChange =
    inClamp.onChange =
    inMode.onChange =
    inNormalize.onChange =
    inDebug.onChange =
    inChannel.onChange =
    inAbs.onChange =
    inColorize.onChange = updateDefines;
inTrigger.onTriggered = render;

const cgl = op.patch.cgl;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.displace_head_vert || "",
    "srcBodyVert": attachments.displace_vert || ""
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": "#ifdef MOD_COLORIZE\nIN vec3 MOD_dispColor;\n#endif",
    "srcBodyFrag": "#ifdef MOD_COLORIZE\ncol.rgb*=MOD_dispColor;\n#endif"
});

mod.addUniformVert("t", "MOD_texture", 0);
mod.addUniformVert("2f", "MOD_offset", inOffsetX, inOffsetY);
mod.addUniformVert("f", "MOD_scale", inScale);
mod.addUniformVert("f", "MOD_strength", inStrength);
mod.addUniformVert("f", "MOD_min", inMin);
updateDefines();

function updateDefines()
{
    op.setUiAttrib({ "extendTitle": inMode.get() });

    mod.toggleDefine("MOD_MODE_TRANS", inMode.get() === "Translate");
    mod.toggleDefine("MOD_MODE_SCALE", inMode.get() === "Scale");
    mod.toggleDefine("MOD_MODE_ROT", inMode.get() === "Rotate");

    mod.toggleDefine("MOD_CHAN_R", inChannel.get() != "G" && inChannel.get() != "B" && inChannel.get() != "RGB");
    mod.toggleDefine("MOD_CHAN_G", inChannel.get() == "G");
    mod.toggleDefine("MOD_CHAN_B", inChannel.get() == "B");
    mod.toggleDefine("MOD_CHAN_RGB", inChannel.get() == "RGB");

    mod.toggleDefine("MOD_SRC_INSTMAT", inSrc.get() == "Inst Pos");
    mod.toggleDefine("MOD_SRC_MMAT", inSrc.get() == "Model Pos");

    mod.toggleDefine("MOD_AXIS_X", inAxisX.get());
    mod.toggleDefine("MOD_AXIS_Y", inAxisY.get());
    mod.toggleDefine("MOD_AXIS_Z", inAxisZ.get());

    mod.toggleDefine("MOD_ABS", inAbs.get());

    mod.toggleDefine("MOD_CLAMP", inClamp.get());
    mod.toggleDefine("MOD_COLORIZE", inColorize.get() || inDebug.get());
    mod.toggleDefine("MOD_NORMALIZE", inNormalize.get());

    mod.toggleDefine("MOD_DEBUG", inDebug.get());
}

function render()
{
    mod.bind();

    if (inTex.get()) mod.pushTexture("MOD_texture", inTex.get().tex);
    else mod.pushTexture("MOD_texture", CGL.Texture.getEmptyTexture(cgl).tex);

    next.trigger();
    mod.unbind();
}


};

Ops.Gl.ShaderEffects.InstancedDisplacementMap_v2.prototype = new CABLES.Op();
CABLES.OPS["e6ba9d95-20f3-4c1c-9967-26d48d278f0a"]={f:Ops.Gl.ShaderEffects.InstancedDisplacementMap_v2,objName:"Ops.Gl.ShaderEffects.InstancedDisplacementMap_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.InstancedPerlinPosition_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.InstancedPerlinPosition_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"perlin_instposition_vert":"\nfloat MOD_Interpolation_C2( float x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }   //  6x^5-15x^4+10x^3\t( Quintic Curve.  As used by Perlin in Improved Noise.  http://mrl.nyu.edu/~perlin/paper445.pdf )\nvec2 MOD_Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 MOD_Interpolation_C2( vec3 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 MOD_Interpolation_C2( vec4 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 MOD_Interpolation_C2_InterpAndDeriv( vec2 x ) { return x.xyxy * x.xyxy * ( x.xyxy * ( x.xyxy * ( x.xyxy * vec2( 6.0, 0.0 ).xxyy + vec2( -15.0, 30.0 ).xxyy ) + vec2( 10.0, -60.0 ).xxyy ) + vec2( 0.0, 30.0 ).xxyy ); }\nvec3 MOD_Interpolation_C2_Deriv( vec3 x ) { return x * x * (x * (x * 30.0 - 60.0) + 30.0); }\n\n\nvoid MOD_FAST32_hash_3D( \tvec3 gridcell,\n                        out vec4 lowz_hash_0,\n                        out vec4 lowz_hash_1,\n                        out vec4 lowz_hash_2,\n                        out vec4 highz_hash_0,\n                        out vec4 highz_hash_1,\n                        out vec4 highz_hash_2\t)\t\t//\tgenerates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\n\n//\n//\tPerlin Noise 3D  ( gradient noise )\n//\tReturn value range of -1.0->1.0\n//\thttp://briansharpe.files.wordpress.com/2011/11/perlinsample.jpg\n//\nfloat MOD_Perlin3D( vec3 P )\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n#if 1\n    //\n    //\tclassic noise.\n    //\trequires 3 random values per point.  with an efficent hash function will run faster than improved noise\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    MOD_FAST32_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n    //SGPP_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n\n    //\tcalculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n#if 1\n    //\tClassic Perlin Interpolation\n    vec3 blend = MOD_Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    final *= 1.1547005383792515290182975610039;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/sqrt(0.75)\n    return final;\n#else\n    //\tClassic Perlin Surflet\n    //\thttp://briansharpe.wordpress.com/2012/03/09/modifications-to-classic-perlin-noise/\n    Pf *= Pf;\n    Pf_min1 *= Pf_min1;\n    vec4 vecs_len_sq = vec4( Pf.x, Pf_min1.x, Pf.x, Pf_min1.x ) + vec4( Pf.yy, Pf_min1.yy );\n    float final = dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf.zzzz ) ), grad_results_0 ) + dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf_min1.zzzz ) ), grad_results_1 );\n    final *= 2.3703703703703703703703703703704;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/cube(0.75)\n    return final;\n#endif\n\n#else\n    //\n    //\timproved noise.\n    //\trequires 1 random value per point.  Will run faster than classic noise if a slow hashing function is used\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_lowz, hash_highz;\n    MOD_FAST32_hash_3D( Pi, hash_lowz, hash_highz );\n    //BBS_hash_3D( Pi, hash_lowz, hash_highz );\n    //SGPP_hash_3D( Pi, hash_lowz, hash_highz );\n\n    //\n    //\t\"improved\" noise using 8 corner gradients.  Faster than the 12 mid-edge point method.\n    //\tKen mentions using diagonals like this can cause \"clumping\", but we'll live with that.\n    //\t[1,1,1]  [-1,1,1]  [1,-1,1]  [-1,-1,1]\n    //\t[1,1,-1] [-1,1,-1] [1,-1,-1] [-1,-1,-1]\n    //\n    hash_lowz -= 0.5;\n    vec4 grad_results_0_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_lowz );\n    hash_lowz = abs( hash_lowz ) - 0.25;\n    vec4 grad_results_0_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_lowz );\n    vec4 grad_results_0_2 = Pf.zzzz * sign( abs( hash_lowz ) - 0.125 );\n    vec4 grad_results_0 = grad_results_0_0 + grad_results_0_1 + grad_results_0_2;\n\n    hash_highz -= 0.5;\n    vec4 grad_results_1_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_highz );\n    hash_highz = abs( hash_highz ) - 0.25;\n    vec4 grad_results_1_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_highz );\n    vec4 grad_results_1_2 = Pf_min1.zzzz * sign( abs( hash_highz ) - 0.125 );\n    vec4 grad_results_1 = grad_results_1_0 + grad_results_1_1 + grad_results_1_2;\n\n    //\tblend the gradients and return\n    vec3 blend = MOD_Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy ) * (2.0 / 3.0);\t//\t(optionally) mult by (2.0/3.0) to scale to a strict -1.0->1.0 range\n#endif\n}\n\nvec4 MOD_deform(mat4 mMatrix,mat4 instMat,vec4 pos)\n{\n\n    vec3 ppos=vec3(mMatrix[3][0]+instMat[3][0]*MOD_scale+MOD_scrollx,mMatrix[3][1]+instMat[3][1]*MOD_scale+MOD_scrolly,mMatrix[3][2]+instMat[3][2]*MOD_scale+MOD_scrollz);\n    float p=MOD_Perlin3D(ppos)*MOD_strength;\n\n    #ifdef MOD_METH_TRANSLATE\n        pos.x+=p*MOD_mulAxis.x;\n        pos.y+=p*MOD_mulAxis.y;\n        pos.z+=p*MOD_mulAxis.z;\n    #endif\n    #ifdef MOD_METH_SCALE\n        p=clamp(p,0.0,99999.0);\n        pos.x*=p*MOD_mulAxis.x+MOD_minScale;\n        pos.y*=p*MOD_mulAxis.y+MOD_minScale;\n        pos.z*=p*MOD_mulAxis.z+MOD_minScale;\n    #endif\n\n    return pos;\n}\n\n",};
const
    render = op.inTrigger("Render"),
    next = op.outTrigger("Next"),
    inStrength = op.inValue("Strength", 1),
    scrollx = op.inValue("Scroll X"),
    scrolly = op.inValue("Scroll Y"),
    scrollz = op.inValue("Scroll Z"),
    scale = op.inValue("Scale", 1),
    meth = op.inSwitch("Method", ["Translate", "Scale"], "Translate"),
    mulx = op.inValue("Mul X", 1),
    muly = op.inValue("Mul Y", 1),
    mulz = op.inValue("Mul Z", 1),
    minScale = op.inValue("Min Scale", 0),
    inWorldSpace = op.inValueBool("WorldSpace");

const cgl = op.patch.cgl;

let srcBodyVert = ""
    .endl() + "#ifdef INSTANCING"
    .endl() + "   pos=MOD_deform(mMatrix,instMat,pos);"
    .endl() + "#endif"
    .endl() + "#ifndef INSTANCING"
    .endl() + "   pos=MOD_deform(mMatrix,mMatrix,pos);"
    .endl() + "#endif"

    .endl();

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.perlin_instposition_vert,
    "srcBodyVert": srcBodyVert
});

mod.addUniform("f", "MOD_strength", inStrength);
mod.addUniform("f", "MOD_scrollx", scrollx);
mod.addUniform("f", "MOD_scrolly", scrolly);
mod.addUniform("f", "MOD_scrollz", scrollz);
mod.addUniform("f", "MOD_scale", scale);
mod.addUniform("f", "MOD_minScale", minScale);
mod.addUniform("3f", "MOD_mulAxis", mulx, muly, mulz);

meth.onChange =
inWorldSpace.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get());
    mod.toggleDefine("MOD_METH_TRANSLATE", meth.get() == "Translate");
    mod.toggleDefine("MOD_METH_SCALE", meth.get() == "Scale");
}

render.onTriggered = function ()
{
    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.InstancedPerlinPosition_v2.prototype = new CABLES.Op();
CABLES.OPS["716a9004-cbb8-4032-9f29-2b2f8c8973ba"]={f:Ops.Gl.ShaderEffects.InstancedPerlinPosition_v2,objName:"Ops.Gl.ShaderEffects.InstancedPerlinPosition_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.InstancedTextureColorize
// 
// **************************************************************

Ops.Gl.ShaderEffects.InstancedTextureColorize = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorize_frag":"\n\n\n\nvec4 MOD_col=texture(MOD_texture,MOD_coord);\n\n#ifdef METH_ADD\ncol.rgb+=MOD_col.rgb*MOD_strength;\n#endif\n#ifdef METH_MUL\ncol.rgb*=MOD_col.rgb*MOD_strength;\n#endif\n\n#ifdef MOD_DEBUG\n    col.rg=mod(MOD_coord,1.0).rg;\n#endif\n","colorize_head_frag":"\nIN vec2 MOD_coord;\n\nUNI sampler2D MOD_texture;\nUNI float MOD_strength;","displace_vert":"\n#ifdef INSTANCING\n\n    vec3 MOD_p=vec3(mMatrix[3][0],mMatrix[3][1],mMatrix[3][2]);\n    MOD_coord=MOD_p.xy*(1.0/MOD_scale)+MOD_offset-vec2(0.5,0.5);\n\n#endif\n\n","displace_head_vert":"OUT vec2 MOD_coord;\n\n",};
const
    inTrigger = op.inTrigger("Trigger"),
    inTex = op.inTexture("Texture"),
    inStrength = op.inFloatSlider("Strength", 1),
    inScale = op.inFloat("Scale", 1),
    inClamp = op.inBool("Clamp", false),
    inDebug = op.inBool("Debug Bounds", false),
    inOffsetX = op.inFloat("Offset X", 0),
    inOffsetY = op.inFloat("Offset Y", 0),
    inMode = op.inSwitch("Method", ["Add", "Mul"], "Add"),
    next = op.outTrigger("Next");

inTex.onChange =
    inClamp.onChange =
    inMode.onChange =
    inDebug.onChange = updateDefines;
inTrigger.onTriggered = render;

const cgl = op.patch.cgl;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.displace_head_vert || "",
    "srcBodyVert": attachments.displace_vert || ""
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": attachments.colorize_head_frag,
    "srcBodyFrag": attachments.colorize_frag
});

mod.addUniformVert("t", "MOD_texture", 0);
mod.addUniformVert("2f", "MOD_offset", inOffsetX, inOffsetY);
mod.addUniformVert("f", "MOD_scale", inScale);
mod.addUniformVert("f", "MOD_strength", inStrength);

function updateDefines()
{
    mod.toggleDefine("MOD_CLAMP", inClamp.get());
    mod.toggleDefine("MOD_DEBUG", inDebug.get());
    mod.toggleDefine("METH_ADD", inMode.get() == "Add");
    mod.toggleDefine("METH_MUL", inMode.get() == "Mul");
}

function render()
{
    mod.bind();

    if (inTex.get()) mod.pushTexture("MOD_texture", inTex.get().tex);
    else mod.pushTexture("MOD_texture", CGL.Texture.getEmptyTexture(cgl).tex);

    next.trigger();
    mod.unbind();
}


};

Ops.Gl.ShaderEffects.InstancedTextureColorize.prototype = new CABLES.Op();
CABLES.OPS["7a13a699-6a7f-4fd1-84bb-51dd6c13c820"]={f:Ops.Gl.ShaderEffects.InstancedTextureColorize,objName:"Ops.Gl.ShaderEffects.InstancedTextureColorize"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.LimitMeshByTexCoord
// 
// **************************************************************

Ops.Gl.ShaderEffects.LimitMeshByTexCoord = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"limitByTexCoords_frag":"\nfloat MOD_offset=0.0;\n\n#ifdef MOD_ANIN_SIN\n    #ifdef MOD_ANIN_SIN_TCX\n        MOD_offset=sin((texCoord.x)*MOD_freq+MOD_time)*(MOD_ampl/1000.0);\n    #endif\n    #ifdef MOD_ANIN_SIN_TCY\n        MOD_offset=sin((texCoord.y)*MOD_freq+MOD_time)*(MOD_ampl/1000.0);\n    #endif\n#endif\n\n#ifdef MOD_AXIS_X\n    if(texCoord.x+MOD_offset>=MOD_treshhold)discard;\n#endif\n#ifdef MOD_AXIS_Y\n    if(texCoord.y+MOD_offset>=MOD_treshhold)discard;\n#endif\n#ifdef MOD_AXIS_XY\n    if((texCoord.y+texCoord.x)/2.0+MOD_offset>=MOD_treshhold)discard;\n#endif\n#ifdef MOD_AXIS_X_INV\n    if(1.0-texCoord.x+MOD_offset>=MOD_treshhold)discard;\n#endif\n#ifdef MOD_AXIS_Y_INV\n    if(1.0-texCoord.y+MOD_offset>=MOD_treshhold)discard;\n#endif\n#ifdef MOD_AXIS_XY_INV\n    if(1.0-((texCoord.y+texCoord.x)/2.0)+MOD_offset>=MOD_treshhold)discard;\n#endif\n\n\n",};
op.render = op.inTrigger("render");
op.trigger = op.outTrigger("trigger");

const axis = op.inValueSelect("Axis", ["X", "Y", "XY", "X Inverted", "Y Inverted", "XY Inverted"], "X");
const inTreshhold = op.inValueSlider("treshhold", 0.3);

const inSinAnim = op.inValueBool("Sine Animation", false);
const inTime = op.inValueFloat("Time");
const inSinAxis = op.inValueSelect("Sine Source", ["Texcoord X", "Texcoord Y"], "Texcoord X");

const inFreq = op.inValueFloat("Frequency", 10);
const inAmpl = op.inValueFloat("Amplitude", 10);

op.setPortGroup("Sine Animation", [inTime, inSinAnim, inFreq, inAmpl, inSinAxis]);

const cgl = op.patch.cgl;
let shader = null;

let srcHeadFrag = ""
    .endl() + "UNI float MOD_treshhold;"
    .endl() + "UNI float MOD_time;"
    .endl() + "UNI float MOD_ampl;"
    .endl() + "UNI float MOD_freq;"
    .endl();

let moduleFrag = null;

inSinAxis.onChange = inSinAnim.onChange = axis.onChange = updateAxis;

function updateAxis()
{
    if (!shader) return;
    shader.toggleDefine(moduleFrag.prefix + "AXIS_X", axis.get() == "X");
    shader.toggleDefine(moduleFrag.prefix + "AXIS_Y", axis.get() == "Y");
    shader.toggleDefine(moduleFrag.prefix + "AXIS_XY", axis.get() == "XY");
    shader.toggleDefine(moduleFrag.prefix + "AXIS_X_INV", axis.get() == "X Inverted");
    shader.toggleDefine(moduleFrag.prefix + "AXIS_Y_INV", axis.get() == "Y Inverted");
    shader.toggleDefine(moduleFrag.prefix + "AXIS_XY_INV", axis.get() == "XY Inverted");

    shader.toggleDefine(moduleFrag.prefix + "ANIN_SIN", inSinAnim.get());

    shader.toggleDefine(moduleFrag.prefix + "ANIN_SIN_TCX", inSinAxis.get() == "Texcoord X");
    shader.toggleDefine(moduleFrag.prefix + "ANIN_SIN_TCY", inSinAxis.get() == "Texcoord Y");
}

function removeModule()
{
    if (shader && moduleFrag) shader.removeModule(moduleFrag);
    shader = null;
}

op.render.onLinkChanged = removeModule;
let
    uniTime = null,
    uniFreq = null,
    uniAmpl = null,
    uniTreshhold = null;

op.render.onTriggered = function ()
{
    if (!cgl.getShader())
    {
        op.trigger.trigger();
        return;
    }

    if (cgl.getShader() != shader)
    {
        if (shader) removeModule();
        shader = cgl.getShader();

        moduleFrag = shader.addModule(
            {
                "title": op.objName,
                "name": "MODULE_COLOR",
                "srcHeadFrag": srcHeadFrag,
                "srcBodyFrag": attachments.limitByTexCoords_frag || ""
            });

        uniTreshhold = new CGL.Uniform(shader, "f", moduleFrag.prefix + "treshhold", inTreshhold);
        uniTime = new CGL.Uniform(shader, "f", moduleFrag.prefix + "time", inTime);
        uniFreq = new CGL.Uniform(shader, "f", moduleFrag.prefix + "freq", inFreq);
        uniAmpl = new CGL.Uniform(shader, "f", moduleFrag.prefix + "ampl", inAmpl);

        updateAxis();
    }

    if (!shader) return;

    op.trigger.trigger();
};


};

Ops.Gl.ShaderEffects.LimitMeshByTexCoord.prototype = new CABLES.Op();
CABLES.OPS["b7482d75-913d-4564-92ae-81f8dbead3ce"]={f:Ops.Gl.ShaderEffects.LimitMeshByTexCoord,objName:"Ops.Gl.ShaderEffects.LimitMeshByTexCoord"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.MeshPixelNoise_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.MeshPixelNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"pixelnoise_frag":"IN vec4 MOD_pos;\n\nfloat MOD_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 MOD_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 MOD_perm(vec4 x){return MOD_mod289(((x * 34.0) + 1.0) * x);}\n\nfloat MOD_meshPixelNoise(vec3 p){\n    p+=vec3(MOD_x,MOD_y,MOD_z);\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = MOD_perm(b.xyxy);\n    vec4 k2 = MOD_perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = MOD_perm(c);\n    vec4 k4 = MOD_perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n",};
const
    render = op.inTrigger("render"),
    next = op.outTrigger("trigger"),
    inScale = op.inValue("Scale", 10),
    inAmount = op.inValueSlider("Amount", 0.3),
    inBlend = op.inSwitch("Blendmode", ["Sub", "Add", "Mul"], "Sub"),
    inWorldSpace = op.inValueBool("WorldSpace"),
    r = op.inValueSlider("r", 0),
    g = op.inValueSlider("g", 0),
    b = op.inValueSlider("b", 0),
    x = op.inFloat("x", 0),
    y = op.inFloat("y", 0),
    z = op.inFloat("z", 0);

r.setUiAttribs({ "colorPick": true });

op.setPortGroup("Color", [r, g, b]);
op.setPortGroup("Position", [x, y, z]);
const cgl = op.patch.cgl;

inBlend.onChange =
inWorldSpace.onChange = updateDefines;

const srcHeadVert = ""
    .endl() + "OUT vec4 MOD_pos;"
    .endl();

const srcBodyVert = ""
    .endl() + "#ifndef MOD_WORLDSPACE"
    .endl() + "   MOD_pos=vec4(pos.xyz,1.0);"
    .endl() + "#endif"
    .endl() + "#ifdef MOD_WORLDSPACE"
    .endl() + "   MOD_pos=vec4(pos.xyz,1.0)*mMatrix;"
    .endl() + "#endif"
    .endl();

const srcHeadFrag = attachments.pixelnoise_frag;

const srcBodyFrag = ""
    .endl() + "vec3 MOD_rndVal = vec3(1.-MOD_r,1.-MOD_g,1.-MOD_b)*MOD_meshPixelNoise(MOD_pos.xyz*MOD_scale)*MOD_amount/4.0;"

    .endl() + "#ifdef MOD_BLEND_MUL"
    .endl() + "   col.rgb *= MOD_rndVal;"
    .endl() + "#endif"
    .endl() + "#ifdef MOD_BLEND_SUB"
    .endl() + "   col.rgb -= MOD_rndVal;"
    .endl() + "#endif"
    .endl() + "#ifdef MOD_BLEND_ADD"
    .endl() + "   col.rgb += MOD_rndVal;"
    .endl() + "#endif"
    .endl();

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": srcHeadVert,
    "srcBodyVert": srcBodyVert
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": attachments.pixelnoise_frag,
    "srcBodyFrag": srcBodyFrag
});

mod.addUniformFrag("f", "MOD_scale", inScale);
mod.addUniformFrag("f", "MOD_amount", inAmount);
mod.addUniformFrag("f", "MOD_r", r);
mod.addUniformFrag("f", "MOD_g", g);
mod.addUniformFrag("f", "MOD_b", b);
mod.addUniformFrag("f", "MOD_x", x);
mod.addUniformFrag("f", "MOD_y", y);
mod.addUniformFrag("f", "MOD_z", z);
updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get());

    mod.toggleDefine("MOD_BLEND_ADD", inBlend.get() == "Add");
    mod.toggleDefine("MOD_BLEND_SUB", inBlend.get() == "Sub");
    mod.toggleDefine("MOD_BLEND_MUL", inBlend.get() == "Mul");
}

render.onTriggered = function ()
{
    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.MeshPixelNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["f6240484-56b5-4bb8-92e6-ead30431771a"]={f:Ops.Gl.ShaderEffects.MeshPixelNoise_v2,objName:"Ops.Gl.ShaderEffects.MeshPixelNoise_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.ModuloVertexPosition
// 
// **************************************************************

Ops.Gl.ShaderEffects.ModuloVertexPosition = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"trans_vert":"\n#ifdef MOD_AXIS_X\npos.x=mod(pos.x,MOD_modulo);\n#endif\n\n#ifdef MOD_AXIS_Y\npos.y=mod(pos.y,MOD_modulo);\n#endif\n\n#ifdef MOD_AXIS_Z\npos.z=mod(pos.z,MOD_modulo);\n#endif",};
const
    render = op.inTrigger("render"),
    axis = op.inValueSelect("Axis", ["X", "Y", "Z"], "X"),
    inModu = op.inFloat("Modulo", 1),
    trigger = op.outTrigger("Trigger");

const cgl = op.patch.cgl;
const mod = new CGL.ShaderModifier(cgl, op.name);

mod.addModule({
    "name": "MODULE_VERTEX_POSITION",
    "srcBodyVert": attachments.trans_vert || ""
});

mod.addUniformVert("f", "MOD_modulo", inModu);

axis.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_AXIS_X", axis.get() == "X");
    mod.toggleDefine("MOD_AXIS_Y", axis.get() == "Y");
    mod.toggleDefine("MOD_AXIS_Z", axis.get() == "Z");
}

render.onTriggered = function ()
{
    mod.bind();
    trigger.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.ModuloVertexPosition.prototype = new CABLES.Op();
CABLES.OPS["5b657c67-2d43-43b7-855d-76c8aad90a0d"]={f:Ops.Gl.ShaderEffects.ModuloVertexPosition,objName:"Ops.Gl.ShaderEffects.ModuloVertexPosition"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.PerlinAreaDeform_v4
// 
// **************************************************************

Ops.Gl.ShaderEffects.PerlinAreaDeform_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"perlindeform_vert":"vec3 MOD_newTangent,MOD_newBiTangent;\n\n#ifndef PERLINDEFORM\n#define PERLINDEFORM\nfloat Interpolation_C2( float x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }   //  6x^5-15x^4+10x^3\t( Quintic Curve.  As used by Perlin in Improved Noise.  http://mrl.nyu.edu/~perlin/paper445.pdf )\nvec2 Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 Interpolation_C2( vec3 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2( vec4 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2_InterpAndDeriv( vec2 x ) { return x.xyxy * x.xyxy * ( x.xyxy * ( x.xyxy * ( x.xyxy * vec2( 6.0, 0.0 ).xxyy + vec2( -15.0, 30.0 ).xxyy ) + vec2( 10.0, -60.0 ).xxyy ) + vec2( 0.0, 30.0 ).xxyy ); }\nvec3 Interpolation_C2_Deriv( vec3 x ) { return x * x * (x * (x * 30.0 - 60.0) + 30.0); }\n\n\nvoid FAST32_hash_3D( \tvec3 gridcell,\n                        out vec4 lowz_hash_0,\n                        out vec4 lowz_hash_1,\n                        out vec4 lowz_hash_2,\n                        out vec4 highz_hash_0,\n                        out vec4 highz_hash_1,\n                        out vec4 highz_hash_2\t)\t\t//\tgenerates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\n\n//\n//\tPerlin Noise 3D  ( gradient noise )\n//\tReturn value range of -1.0->1.0\n//\thttp://briansharpe.files.wordpress.com/2011/11/perlinsample.jpg\n//\nfloat Perlin3D( vec3 P )\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n#if 1\n    //\n    //\tclassic noise.\n    //\trequires 3 random values per point.  with an efficent hash function will run faster than improved noise\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n    //SGPP_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n\n    //\tcalculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n#if 1\n    //\tClassic Perlin Interpolation\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    final *= 1.1547005383792515290182975610039;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/sqrt(0.75)\n    return final;\n#else\n    //\tClassic Perlin Surflet\n    //\thttp://briansharpe.wordpress.com/2012/03/09/modifications-to-classic-perlin-noise/\n    Pf *= Pf;\n    Pf_min1 *= Pf_min1;\n    vec4 vecs_len_sq = vec4( Pf.x, Pf_min1.x, Pf.x, Pf_min1.x ) + vec4( Pf.yy, Pf_min1.yy );\n    float final = dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf.zzzz ) ), grad_results_0 ) + dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf_min1.zzzz ) ), grad_results_1 );\n    final *= 2.3703703703703703703703703703704;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/cube(0.75)\n    return final;\n#endif\n\n#else\n    //\n    //\timproved noise.\n    //\trequires 1 random value per point.  Will run faster than classic noise if a slow hashing function is used\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_lowz, hash_highz;\n    FAST32_hash_3D( Pi, hash_lowz, hash_highz );\n    //BBS_hash_3D( Pi, hash_lowz, hash_highz );\n    //SGPP_hash_3D( Pi, hash_lowz, hash_highz );\n\n    //\n    //\t\"improved\" noise using 8 corner gradients.  Faster than the 12 mid-edge point method.\n    //\tKen mentions using diagonals like this can cause \"clumping\", but we'll live with that.\n    //\t[1,1,1]  [-1,1,1]  [1,-1,1]  [-1,-1,1]\n    //\t[1,1,-1] [-1,1,-1] [1,-1,-1] [-1,-1,-1]\n    //\n    hash_lowz -= 0.5;\n    vec4 grad_results_0_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_lowz );\n    hash_lowz = abs( hash_lowz ) - 0.25;\n    vec4 grad_results_0_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_lowz );\n    vec4 grad_results_0_2 = Pf.zzzz * sign( abs( hash_lowz ) - 0.125 );\n    vec4 grad_results_0 = grad_results_0_0 + grad_results_0_1 + grad_results_0_2;\n\n    hash_highz -= 0.5;\n    vec4 grad_results_1_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_highz );\n    hash_highz = abs( hash_highz ) - 0.25;\n    vec4 grad_results_1_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_highz );\n    vec4 grad_results_1_2 = Pf_min1.zzzz * sign( abs( hash_highz ) - 0.125 );\n    vec4 grad_results_1 = grad_results_1_0 + grad_results_1_1 + grad_results_1_2;\n\n    //\tblend the gradients and return\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy ) * (2.0 / 3.0);\t//\t(optionally) mult by (2.0/3.0) to scale to a strict -1.0->1.0 range\n#endif\n}\n\n#endif\n\nvec3 MOD_deform(vec3 pos,vec3 norm)\n{\n    vec3 modelPos=pos;\n    vec3 forcePos=vec3(MOD_x,MOD_y,MOD_z);\n\n    vec3 vecToOrigin=modelPos-forcePos;\n    float dist=abs(length(vecToOrigin));\n    // float distAlpha = (MOD_size - dist) / MOD_size;\n\n    if(dist*MOD_mScale<MOD_size*MOD_mScale)\n    {\n        vec3 ppos=vec3(pos*MOD_scale*MOD_mScale);\n        ppos.x+=MOD_scrollx;\n        ppos.y+=MOD_scrolly;\n        ppos.z+=MOD_scrollz;\n\n        float p=(Perlin3D(ppos))*MOD_strength;\n\n        float dist=distance(vec3(MOD_x,MOD_y,MOD_z),modelPos);\n        float fallOff=1.0-smoothstep(MOD_fallOff*MOD_size,MOD_size,dist);\n\n        vec3 pnorm=norm;//normalize(pos.xyz);\n\n        #ifdef MOD_METH_MULNORM\n            pos.x+=p*pnorm.x*fallOff;\n            pos.y+=p*pnorm.y*fallOff;\n            pos.z+=p*pnorm.z*fallOff;\n        #endif\n        #ifdef MOD_METH_MULNORM_Y\n            pos.y+=p*pnorm.y*fallOff;\n        #endif\n\n        #ifdef MOD_METH_MUL_Z\n            pos.z+=p*pos.z*fallOff;\n        #endif\n\n        #ifdef MOD_METH_MUL_XYZ\n            pos.x+=p*pos.x*fallOff;\n            pos.y+=p*pos.y*fallOff;\n            pos.z+=p*pos.z*fallOff;\n\n        #endif\n\n        #ifdef MOD_METH_ADD_XYZ\n            pos.x+=p*fallOff;\n            pos.y+=p*fallOff;\n            pos.z+=p*fallOff;\n        #endif\n\n        #ifdef MOD_METH_ADD_Z\n            pos.z+=p*fallOff;\n        #endif\n        #ifdef MOD_METH_ADD_Y\n            pos.y+=p*fallOff;\n        #endif\n        #ifdef MOD_METH_ADD_X\n            pos.x+=p*fallOff;\n        #endif\n    }\n\n    return pos;\n}\n\n// LOOK AT THIS./....\n//https://github.com/spite/perlin-experiments/blob/master/chrome.html\n\n\nvec3 MOD_calcNormal(vec3 pos,vec3 norm,vec3 tangent,vec3 bitangent)\n{\n    //http://diary.conewars.com/vertex-displacement-shader/\n    vec4 position=vec4(MOD_deform(pos,norm),1.0);\n\n    vec3 positionAndTangent = MOD_deform( pos + tangent * 0.1,norm );\n    vec3 positionAndBitangent = MOD_deform( pos + bitangent * 0.1,norm );\n\n    MOD_newTangent = ( positionAndTangent - position.xyz ); // leaves just 'tangent'\n    MOD_newBiTangent = ( positionAndBitangent - position.xyz ); // leaves just 'bitangent'\n\n    vec3 newNormal = cross( MOD_newTangent.xyz, MOD_newBiTangent.xyz );\n    return normalize(newNormal.xyz);\n\n}\n\n","perlindeform_body_vert":"\n    vec4 MOD_p=pos;\n\n    #ifdef POS_ATTR\n        MOD_p=vec4(vPosition,1.0);\n    #endif\n\n#ifndef MOD_WORLDSPACE\n\n\n    pos.xyz=MOD_deform(MOD_p.xyz,norm.xyz);\n\n    #ifdef MOD_CALC_NORMALS\n        norm=MOD_calcNormal(MOD_p.xyz,norm.xyz,tangent,bitangent);\n    #endif\n#endif\n\n#ifdef MOD_WORLDSPACE\n    pos.xyz=MOD_deform( (mMatrix*MOD_p).xyz ,norm.xyz);\n\n    #ifdef MOD_CALC_NORMALS\n        norm=MOD_calcNormal( (mMatrix*MOD_p).xyz,norm.xyz,tangent,bitangent);\n    #endif\n#endif\n\n#ifdef MOD_CALC_NORMALS\n    tangent=MOD_newTangent;\n    bitangent=MOD_newBiTangent;\n#endif\n\n\n\n#ifdef MOD_FLIP_NORMALS\n    norm*=-1.0;\n#endif\n",};
const
    render = op.inTrigger("render"),
    next = op.outTrigger("trigger"),
    inScale = op.inValueFloat("Scale", 1),
    inSize = op.inValueFloat("Size", 1),
    inStrength = op.inValueFloat("Strength", 1),
    inCalcNormals = op.inValueBool("Calc Normals", false),
    inFlipNormals = op.inValueBool("Flip Normals", false),

    inFalloff = op.inValueSlider("Falloff", 0.5),
    output = op.inValueSelect("Output", ["Mul Normal", "Mul Z", "Mul XYZ",, "Mul Norm Y", "Add XYZ", "Add X", "Add Y", "Add Z"], "Add XYZ"),
    inPos = op.inSwitch("Source", ["Pos", "Orig Pos"], "Pos"),
    // inInstancer = op.inBool("For Instancing", false),
    x = op.inValueFloat("x"),
    y = op.inValueFloat("y"),
    z = op.inValueFloat("z"),
    scrollx = op.inValueFloat("Scroll X"),
    scrolly = op.inValueFloat("Scroll Y"),
    scrollz = op.inValueFloat("Scroll Z");

const cgl = op.patch.cgl;
const mod = new CGL.ShaderModifier(cgl, op.name);

inFlipNormals.onChange =
inCalcNormals.onChange = updateCalcNormals;
const inWorldSpace = op.inValueBool("WorldSpace");

const moduleVert = null;
inPos.onChange =
    output.onChange = updateOutput;

const mscaleUni = null;
inWorldSpace.onChange = updateWorldspace;

mod.addModule({
    "priority": 6,
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.perlindeform_vert,
    "srcBodyVert": attachments.perlindeform_body_vert
});

mod.addUniformVert("f", "MOD_size", inSize);
mod.addUniformVert("f", "MOD_strength", inStrength);
mod.addUniformVert("f", "MOD_scale", inScale);

mod.addUniformVert("f", "MOD_scrollx", scrollx);
mod.addUniformVert("f", "MOD_scrolly", scrolly);
mod.addUniformVert("f", "MOD_scrollz", scrollz);

mod.addUniformVert("f", "MOD_x", x);
mod.addUniformVert("f", "MOD_y", y);
mod.addUniformVert("f", "MOD_z", z);
mod.addUniformVert("f", "MOD_fallOff", inFalloff);

mod.addUniformVert("f", "MOD_mScale", 1);

updateOutput();
updateWorldspace();
updateCalcNormals();
// updatePrio();

// function updatePrio()
// {
//     let prio = 0;
//     if (inInstancer.get()) prio = -6;

//     mod.removeModule(op.name);

//     mod.addModule({
//         "priority": prio,
//         "title": op.name,
//         "name": "MODULE_VERTEX_POSITION",
//         "srcHeadVert": attachments.perlindeform_vert,
//         "srcBodyVert": attachments.perlindeform_body_vert
//     });

//     console.log("yeap",prio);
// }

function updateCalcNormals()
{
    mod.toggleDefine("MOD_FLIP_NORMALS", inFlipNormals.get());
    mod.toggleDefine("MOD_CALC_NORMALS", inCalcNormals.get());
}

function updateWorldspace()
{
    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get());
}

function updateOutput()
{
    mod.toggleDefine("POS_ATTR", inPos.get() == "Orig Pos");

    mod.toggleDefine("MOD_METH_MUL_XYZ", output.get() == "Mul XYZ");
    mod.toggleDefine("MOD_METH_ADD_XYZ", output.get() == "Add XYZ");
    mod.toggleDefine("MOD_METH_ADD_Z", output.get() == "Add Z");
    mod.toggleDefine("MOD_METH_MUL_Z", output.get() == "Mul Z");
    mod.toggleDefine("MOD_METH_ADD_Y", output.get() == "Add Y");
    mod.toggleDefine("MOD_METH_ADD_X", output.get() == "Add X");
    mod.toggleDefine("MOD_METH_MULNORM", output.get() == "Mul Normal");
    mod.toggleDefine("MOD_METH_MULNORM_Y", output.get() == "Mul Norm Y");
}

function getScaling(mat)
{
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    return Math.hypot(m31, m32, m33);
}

render.onTriggered = function ()
{
    if (!cgl.getShader())
    {
        next.trigger();
        return;
    }

    const modelScale = getScaling(cgl.mMatrix);
    if (mscaleUni)mscaleUni.setValue(modelScale);

    if (CABLES.UI)
    {
        cgl.pushModelMatrix();

        if (cgl.shouldDrawHelpers(op))
        {
            cgl.pushModelMatrix();
            mat4.translate(cgl.mMatrix, cgl.mMatrix, [x.get(), y.get(), z.get()]);
            CABLES.GL_MARKER.drawSphere(op, inSize.get());
            cgl.popModelMatrix();
        }

        if (op.isCurrentUiOp())
            gui.setTransformGizmo(
                {
                    "posX": x,
                    "posY": y,
                    "posZ": z
                });

        cgl.popModelMatrix();
    }

    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.PerlinAreaDeform_v4.prototype = new CABLES.Op();
CABLES.OPS["060ef3c1-bb79-46a5-9ec0-3272067fe504"]={f:Ops.Gl.ShaderEffects.PerlinAreaDeform_v4,objName:"Ops.Gl.ShaderEffects.PerlinAreaDeform_v4"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.Render2TexturesSlots_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.Render2TexturesSlots_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"slots_frag":"\n#ifdef SLOT_TEX_0_COLOR\n    outColor0=col;\n#endif\n#ifdef SLOT_TEX_1_COLOR\n    outColor1=col;\n#endif\n#ifdef SLOT_TEX_2_COLOR\n    outColor2=col;\n#endif\n#ifdef SLOT_TEX_3_COLOR\n    outColor3=col;\n#endif\n\n\n#ifdef SLOT_TEX_0_NORMAL\n    outColor0=vec4(norm,1.);\n#endif\n#ifdef SLOT_TEX_1_NORMAL\n    outColor1=vec4(norm,1.);\n#endif\n#ifdef SLOT_TEX_2_NORMAL\n    outColor2=vec4(norm,1.);\n#endif\n#ifdef SLOT_TEX_3_NORMAL\n    outColor3=vec4(norm,1.);\n#endif\n\n\n\n#ifdef SLOT_TEX_0_BLACK\n    outColor0=vec4(0.,0.,0.,1.);\n#endif\n#ifdef SLOT_TEX_1_BLACK\n    outColor1=vec4(0.,0.,0.,1.);\n#endif\n#ifdef SLOT_TEX_2_BLACK\n    outColor2=vec4(0.,0.,0.,1.);\n#endif\n#ifdef SLOT_TEX_3_BLACK\n    outColor3=vec4(0.,0.,0.,1.);\n#endif\n\n\n#ifdef SLOT_TEX_0_1\n    outColor0=vec4(1.);\n#endif\n#ifdef SLOT_TEX_1_1\n    outColor1=vec4(1.);\n#endif\n#ifdef SLOT_TEX_2_1\n    outColor2=vec4(1.);\n#endif\n#ifdef SLOT_TEX_3_1\n    outColor3=vec4(1.);\n#endif\n\n#ifdef SLOT_TEX_0_0\n    outColor0=vec4(0.);\n#endif\n#ifdef SLOT_TEX_1_0\n    outColor1=vec4(0.);\n#endif\n#ifdef SLOT_TEX_2_0\n    outColor2=vec4(0.);\n#endif\n#ifdef SLOT_TEX_3_0\n    outColor3=vec4(0.);\n#endif\n","slots_head_frag":"// ...",};
const
    render = op.inTrigger("Render"),
    next = op.outTrigger("Next");

const ports = [];
const cgl = op.patch.cgl;
const NUM_BUFFERS = 4;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "priority": 2,
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": attachments.slots_head_frag,
    "srcBodyFrag": attachments.slots_frag,
});

for (let i = 0; i < NUM_BUFFERS; i++)
{
    let slot = "Color";
    if (i != 0)slot = "0";
    const p = op.inDropDown("Texture " + i, ["0", "1", "Color", "Normal", "Black",], slot);
    p.onChange = updateDefines;
    ports.push(p);
}

updateDefines();

function updateDefines()
{
    let strExt = "";

    for (let i = 0; i < NUM_BUFFERS; i++)
    {
        mod.toggleDefine("SLOT_TEX_" + i + "_NORMAL", ports[i].get() == "Normal");
        mod.toggleDefine("SLOT_TEX_" + i + "_COLOR", ports[i].get() == "Color");
        mod.toggleDefine("SLOT_TEX_" + i + "_BLACK", ports[i].get() == "Black");
        mod.toggleDefine("SLOT_TEX_" + i + "_1", ports[i].get() == "1");
        mod.toggleDefine("SLOT_TEX_" + i + "_0", ports[i].get() == "0");

        strExt += ports[i].get();
        if (i != NUM_BUFFERS - 1)strExt += " | ";
    }

    op.setUiAttrib({ "extendTitle": strExt });
}

render.onTriggered = function ()
{
    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.Render2TexturesSlots_v2.prototype = new CABLES.Op();
CABLES.OPS["67714f3f-acac-4f0d-b862-b1d5b480fc4f"]={f:Ops.Gl.ShaderEffects.Render2TexturesSlots_v2,objName:"Ops.Gl.ShaderEffects.Render2TexturesSlots_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.ScaleByNormal_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.ScaleByNormal_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"scalebynormal_vert":"vec4 MOD_scaler(vec4 pos,vec3 normal)\n{\n    pos.xyz+=MOD_strength*(normal);\n    return pos;\n}\n",};
const
    render = op.inTrigger("render"),
    inStrength = op.inValue("Strength", 1),
    next = op.outTrigger("trigger"),
    cgl = op.patch.cgl;

const srcBodyVert = ""
    .endl() + "pos=MOD_scaler(pos,mat3(modelMatrix)*attrVertNormal);"
    .endl();

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addUniform("f", "MOD_strength", inStrength);
mod.addModule({
    "title": op.objName,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.scalebynormal_vert,
    "srcBodyVert": srcBodyVert
});

render.onTriggered = function ()
{
    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.ScaleByNormal_v2.prototype = new CABLES.Op();
CABLES.OPS["9c14f158-d634-4421-b581-51f3fd2044c5"]={f:Ops.Gl.ShaderEffects.ScaleByNormal_v2,objName:"Ops.Gl.ShaderEffects.ScaleByNormal_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.Shadow_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.Shadow_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"head_frag":"#define CAST_SHADOW y\n\n#define NEAR x\n#define FAR y\n#define MAP_SIZE z\n#define BIAS w\n\n#ifdef WEBGL2\n    #define textureCube texture\n#endif\n\nfloat MOD_when_gt(float x, float y) { return max(sign(x - y), 0.0); } // comparator function\nfloat MOD_when_eq(float x, float y) { return 1. - abs(sign(x - y)); } // comparator function\nfloat MOD_when_neq(float x, float y) { return abs(sign(x - y)); } // comparator function\n\n#ifdef MODE_VSM\n    float MOD_linstep(float value, float low, float high) {\n        return clamp((value - low)/(high-low), 0., 1.);\n    }\n#endif\n\n\n\n\n\n#ifdef MODE_DEFAULT\n    float MOD_ShadowFactorDefault(float shadowMapSample, float shadowMapDepth, float bias, float shadowStrength) {\n        return step(shadowMapDepth - bias, shadowMapSample);\n    }\n#endif\n\n#ifdef MODE_PCF\n\n    #ifdef WEBGL2\n        vec3 MOD_offsets[20] = vec3[]\n        (\n           vec3( 1,  1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1,  1,  1),\n           vec3( 1,  1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1,  1, -1),\n           vec3( 1,  1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1,  1,  0),\n           vec3( 1,  0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1,  0, -1),\n           vec3( 0,  1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0,  1, -1)\n        );\n    #endif\n    #ifdef WEBGL1\n        vec3 MOD_offsets[20];\n        int MOD_CALLED_FILL_PCF_ARRAY = 0;\n        void MOD_FillPCFArray() {\n            if (MOD_CALLED_FILL_PCF_ARRAY == 1) return;\n            MOD_offsets[0] = vec3( 1,  1,  1);\n            MOD_offsets[1] = vec3( 1, -1,  1);\n            MOD_offsets[2] = vec3(-1, -1,  1);\n            MOD_offsets[3] = vec3(-1,  1,  1);\n            MOD_offsets[4] = vec3( 1,  1, -1);\n            MOD_offsets[5] = vec3( 1, -1, -1);\n            MOD_offsets[6] = vec3(-1, -1, -1);\n            MOD_offsets[7] = vec3(-1,  1, -1);\n            MOD_offsets[8] = vec3( 1,  1,  0);\n            MOD_offsets[9] = vec3( 1, -1,  0);\n            MOD_offsets[10] = vec3(-1, -1,  0);\n            MOD_offsets[11] = vec3(-1,  1,  0);\n            MOD_offsets[12] = vec3( 1,  0,  1);\n            MOD_offsets[13] = vec3(-1,  0,  1);\n            MOD_offsets[14] = vec3( 1,  0, -1);\n            MOD_offsets[15] = vec3(-1,  0, -1);\n            MOD_offsets[16] = vec3( 0,  1,  1);\n            MOD_offsets[17] = vec3( 0, -1,  1);\n            MOD_offsets[18] = vec3( 0, -1, -1);\n            MOD_offsets[19] = vec3( 0,  1, -1);\n            MOD_CALLED_FILL_PCF_ARRAY = 1;\n        }\n    #endif\n    // float diskRadius = 0.05;\n    #define RIGHT_BOUND float((SAMPLE_AMOUNT-1.)/2.)\n    #define LEFT_BOUND -RIGHT_BOUND\n    #define PCF_DIVISOR float(SAMPLE_AMOUNT*SAMPLE_AMOUNT)\n\n    #define SAMPLE_AMOUNT_POINT int(SAMPLE_AMOUNT * 2. + 4.)\n    // https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows\n    float MOD_ShadowFactorPointPCF(\n        samplerCube shadowMap,\n        vec3 lightDirection,\n        float shadowMapDepth,\n        float nearPlane,\n        float farPlane,\n        float bias,\n        float shadowStrength,\n        vec3 modelPos,\n        vec3 camPos,\n        float sampleSpread\n    ) {\n        #ifdef WEBGL1\n            MOD_FillPCFArray();\n        #endif\n\n        float visibility  = 0.0;\n        float viewDistance = length(camPos - modelPos.xyz);\n        float diskRadius = (1.0 + ((viewDistance) / (farPlane - nearPlane))) / sampleSpread;\n\n        for (int i = 0; i < SAMPLE_AMOUNT_POINT; i++) {\n            float shadowMapSample = textureCube(shadowMap, -lightDirection + MOD_offsets[i] * diskRadius).r;\n            visibility += step(shadowMapDepth - bias, shadowMapSample);\n        }\n        visibility /= float(SAMPLE_AMOUNT_POINT);\n        return clamp(visibility, 0., 1.);\n    }\n\n    float MOD_ShadowFactorPCF(sampler2D shadowMap, vec2 shadowMapLookup, float shadowMapSize, float shadowMapDepth, float bias, float shadowStrength) {\n        float texelSize = 1. / shadowMapSize;\n        float visibility = 0.;\n\n        // sample neighbouring pixels & get mean value\n        for (float x = LEFT_BOUND; x <= RIGHT_BOUND; x += 1.0) {\n            for (float y = LEFT_BOUND; y <= RIGHT_BOUND; y += 1.0) {\n                float texelDepth = texture(shadowMap, shadowMapLookup + vec2(x, y) * texelSize).r;\n                visibility += step(shadowMapDepth - bias, texelDepth);\n            }\n        }\n\n        return clamp(visibility / PCF_DIVISOR, 0., 1.);\n    }\n#endif\n\n\n#ifdef MODE_POISSON\n    #ifdef WEBGL2\n        vec2 MOD_poissonDisk[16] = vec2[16](\n        vec2( -0.94201624, -0.39906216 ),\n        vec2( 0.94558609, -0.76890725 ),\n        vec2( -0.094184101, -0.92938870 ),\n        vec2( 0.34495938, 0.29387760 ),\n        vec2( -0.91588581, 0.45771432 ),\n        vec2( -0.81544232, -0.87912464 ),\n        vec2( -0.38277543, 0.27676845 ),\n        vec2( 0.97484398, 0.75648379 ),\n        vec2( 0.44323325, -0.97511554 ),\n        vec2( 0.53742981, -0.47373420 ),\n        vec2( -0.26496911, -0.41893023 ),\n        vec2( 0.79197514, 0.19090188 ),\n        vec2( -0.24188840, 0.99706507 ),\n        vec2( -0.81409955, 0.91437590 ),\n        vec2( 0.19984126, 0.78641367 ),\n        vec2( 0.14383161, -0.14100790 )\n        );\n    #endif\n    #ifdef WEBGL1\n    int MOD_CALLED_FILL_POISSON_ARRAY = 0;\n    // cannot allocate arrays like above in webgl1\n        vec2 MOD_poissonDisk[16];\n        void FillPoissonArray() {\n            if (MOD_CALLED_FILL_POISSON_ARRAY == 1) return;\n            MOD_poissonDisk[0] = vec2( -0.94201624, -0.39906216 );\n            MOD_poissonDisk[1] = vec2( 0.94558609, -0.76890725 );\n            MOD_poissonDisk[2] = vec2( -0.094184101, -0.92938870 );\n            MOD_poissonDisk[3] = vec2( 0.34495938, 0.29387760 );\n            MOD_poissonDisk[4] = vec2( -0.91588581, 0.45771432 );\n            MOD_poissonDisk[5] = vec2( -0.81544232, -0.87912464 );\n            MOD_poissonDisk[6] = vec2( -0.38277543, 0.27676845 );\n            MOD_poissonDisk[7] = vec2( 0.97484398, 0.75648379 );\n            MOD_poissonDisk[8] = vec2( 0.44323325, -0.97511554 );\n            MOD_poissonDisk[9] = vec2( 0.53742981, -0.47373420 );\n            MOD_poissonDisk[10] = vec2( -0.26496911, -0.41893023 );\n            MOD_poissonDisk[11] = vec2( 0.79197514, 0.19090188 );\n            MOD_poissonDisk[12] = vec2( -0.24188840, 0.99706507 );\n            MOD_poissonDisk[13] = vec2( -0.81409955, 0.91437590 );\n            MOD_poissonDisk[14] = vec2( 0.19984126, 0.78641367 );\n            MOD_poissonDisk[15] = vec2( 0.14383161, -0.14100790);\n            MOD_CALLED_FILL_POISSON_ARRAY = 1;\n        }\n    #endif\n#define SAMPLE_AMOUNT_INT int(SAMPLE_AMOUNT)\n#define INV_SAMPLE_AMOUNT 1./SAMPLE_AMOUNT\n    float MOD_ShadowFactorPointPoisson(samplerCube shadowCubeMap, vec3 lightDirection, float shadowMapDepth, float bias, float sampleSpread) {\n        float visibility = 1.;\n\n        for (int i = 0; i < SAMPLE_AMOUNT_INT; i++) {\n            visibility -= INV_SAMPLE_AMOUNT * step(textureCube(shadowCubeMap, (-lightDirection + MOD_poissonDisk[i].xyx/sampleSpread)).r, shadowMapDepth - bias);\n        }\n\n        return clamp(visibility, 0., 1.);\n    }\n\n    float MOD_ShadowFactorPoisson(sampler2D shadowMap, vec2 shadowMapLookup, float shadowMapDepth, float bias, float sampleSpread) {\n        float visibility = 1.;\n\n        for (int i = 0; i < SAMPLE_AMOUNT_INT; i++) {\n            visibility -= INV_SAMPLE_AMOUNT * step(texture(shadowMap, (shadowMapLookup + MOD_poissonDisk[i]/sampleSpread)).r, shadowMapDepth - bias);\n        }\n\n        return clamp(visibility, 0., 1.);\n    }\n#endif\n\n#ifdef MODE_VSM\n    float MOD_ShadowFactorVSM(vec2 moments, float shadowBias, float shadowMapDepth, float shadowStrength) {\n\n            float depthScale = shadowBias * 0.01 * shadowMapDepth; // - shadowBias;\n            float minVariance = depthScale*depthScale; // = 0.00001\n\n            float distanceTo = shadowMapDepth; //shadowMapDepth; // - shadowBias;\n\n                // retrieve previously stored moments & variance\n            float p = step(distanceTo, moments.x);\n            float variance =  max(moments.y - (moments.x * moments.x), 0.00001);\n\n            float distanceToMean = distanceTo - moments.x;\n\n            //there is a very small probability that something is being lit when its not\n            // little hack: clamp pMax 0.2 - 1. then subtract - 0,2\n            // bottom line helps make the shadows darker\n            // float pMax = linstep((variance - bias) / (variance - bias + (distanceToMean * distanceToMean)), 0.0001, 1.);\n            float pMax = MOD_linstep((variance) / (variance + (distanceToMean * distanceToMean)), shadowBias, 1.);\n            //float pMax = clamp(variance / (variance + distanceToMean*distanceToMean), 0.2, 1.) - 0.2;\n            //pMax = variance / (variance + distanceToMean*distanceToMean);\n            // visibility = clamp(pMax, 1., p);\n            float visibility = min(max(p, pMax), 1.);\n\n            return visibility;\n    }\n#endif\n","head_vert":"","shadow_body_directional_frag":"\n// FRAGMENT BODY type: DIRECTIONAL count: {{LIGHT_INDEX}}\n#ifdef RECEIVE_SHADOW\n    #ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n            if (MOD_light{{LIGHT_INDEX}}.typeCastShadow.CAST_SHADOW == 1) {\n                vec2 shadowMapLookup{{LIGHT_INDEX}} = MOD_shadowCoord{{LIGHT_INDEX}}.xy / MOD_shadowCoord{{LIGHT_INDEX}}.w;\n                float shadowMapDepth{{LIGHT_INDEX}} = MOD_shadowCoord{{LIGHT_INDEX}}.z  / MOD_shadowCoord{{LIGHT_INDEX}}.w;\n                float shadowStrength{{LIGHT_INDEX}} = MOD_light{{LIGHT_INDEX}}.shadowStrength;\n                vec2 shadowMapSample{{LIGHT_INDEX}} = texture(MOD_shadowMap{{LIGHT_INDEX}}, shadowMapLookup{{LIGHT_INDEX}}).rg;\n                float bias{{LIGHT_INDEX}} = MOD_light{{LIGHT_INDEX}}.shadowProperties.BIAS;\n\n                #ifdef MODE_DEFAULT\n                    float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorDefault(shadowMapSample{{LIGHT_INDEX}}.r, shadowMapDepth{{LIGHT_INDEX}}, bias{{LIGHT_INDEX}}, shadowStrength{{LIGHT_INDEX}});\n                    MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                    vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                    col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                #endif\n\n                #ifdef MODE_PCF\n                    float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorPCF(MOD_shadowMap{{LIGHT_INDEX}}, shadowMapLookup{{LIGHT_INDEX}}, MOD_light{{LIGHT_INDEX}}.shadowProperties.MAP_SIZE, shadowMapDepth{{LIGHT_INDEX}}, bias{{LIGHT_INDEX}}, shadowStrength{{LIGHT_INDEX}});\n                    MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                    vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                    col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                #endif\n\n                #ifdef MODE_POISSON\n                    #ifdef WEBGL1\n                        FillPoissonArray();\n                    #endif\n\n                    float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorPoisson(MOD_shadowMap{{LIGHT_INDEX}}, shadowMapLookup{{LIGHT_INDEX}}, shadowMapDepth{{LIGHT_INDEX}}, bias{{LIGHT_INDEX}}, MOD_sampleSpread);\n                    MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                    vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                    col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                #endif\n\n                #ifdef MODE_VSM\n                    float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorVSM(shadowMapSample{{LIGHT_INDEX}}, MOD_light{{LIGHT_INDEX}}.shadowProperties.BIAS, shadowMapDepth{{LIGHT_INDEX}}, shadowStrength{{LIGHT_INDEX}});\n                    MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                    vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                    col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                #endif\n            }\n    #endif\n#endif","shadow_body_directional_vert":"// VERTEX BODY type: DIRECTIONAL count: {{LIGHT_INDEX}}\n#ifdef RECEIVE_SHADOW\n    #ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n        MOD_modelPos{{LIGHT_INDEX}} = mMatrix*pos;\n        MOD_shadowCoord{{LIGHT_INDEX}} = MOD_lightMatrix{{LIGHT_INDEX}} * (MOD_modelPos{{LIGHT_INDEX}} + vec4(norm, 1) * MOD_normalOffset{{LIGHT_INDEX}});\n    #endif\n#endif\n","shadow_body_point_frag":"// FRAGMENT BODY type: POINT count: {{LIGHT_INDEX}}\n #ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n        if (MOD_light{{LIGHT_INDEX}}.typeCastShadow.CAST_SHADOW == 1) {\n            vec3 lightDirectionMOD{{LIGHT_INDEX}} = normalize(MOD_light{{LIGHT_INDEX}}.position - MOD_modelPos{{LIGHT_INDEX}}.xyz);\n            float shadowStrength{{LIGHT_INDEX}} = MOD_light{{LIGHT_INDEX}}.shadowStrength;\n\n            float cameraNear{{LIGHT_INDEX}} = MOD_light{{LIGHT_INDEX}}.shadowProperties.NEAR; // uniforms\n            float cameraFar{{LIGHT_INDEX}} =  MOD_light{{LIGHT_INDEX}}.shadowProperties.FAR;\n\n            float fromLightToFrag{{LIGHT_INDEX}} = (length(MOD_modelPos{{LIGHT_INDEX}}.xyz - MOD_light{{LIGHT_INDEX}}.position) - cameraNear{{LIGHT_INDEX}}) / (cameraFar{{LIGHT_INDEX}} - cameraNear{{LIGHT_INDEX}});\n\n            float shadowMapDepth{{LIGHT_INDEX}} = fromLightToFrag{{LIGHT_INDEX}};\n            // float bias{{LIGHT_INDEX}} = clamp(MOD_light{{LIGHT_INDEX}}.shadowProperties.BIAS, 0., 1.);\n            float lambert{{LIGHT_INDEX}} = clamp(dot(lightDirectionMOD{{LIGHT_INDEX}}, normalize(MOD_normal{{LIGHT_INDEX}})), 0., 1.);\n            float bias{{LIGHT_INDEX}} = clamp(MOD_light{{LIGHT_INDEX}}.shadowProperties.BIAS * tan(acos(lambert{{LIGHT_INDEX}})), 0., 0.1);\n            vec2 shadowMapSample{{LIGHT_INDEX}} = textureCube(MOD_shadowMapCube{{LIGHT_INDEX}}, -lightDirectionMOD{{LIGHT_INDEX}}).rg;\n\n\n\n\n            #ifdef MODE_DEFAULT\n                float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorDefault(shadowMapSample{{LIGHT_INDEX}}.r, shadowMapDepth{{LIGHT_INDEX}}, bias{{LIGHT_INDEX}}, shadowStrength{{LIGHT_INDEX}});\n                MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n            #endif\n            #ifdef MODE_PCF\n                 float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorPointPCF(\n                    MOD_shadowMapCube{{LIGHT_INDEX}},\n                    lightDirectionMOD{{LIGHT_INDEX}},\n                    shadowMapDepth{{LIGHT_INDEX}},\n                    cameraNear{{LIGHT_INDEX}},\n                    cameraFar{{LIGHT_INDEX}},\n                    bias{{LIGHT_INDEX}},\n                    shadowStrength{{LIGHT_INDEX}},\n                    MOD_modelPos{{LIGHT_INDEX}}.xyz,\n                    MOD_camPos,\n                    MOD_sampleSpread\n                );\n                MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n            #endif\n            #ifdef MODE_POISSON\n                #ifdef WEBGL1\n                    FillPoissonArray();\n                #endif\n\n                float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorPointPoisson(MOD_shadowMapCube{{LIGHT_INDEX}}, lightDirectionMOD{{LIGHT_INDEX}}, shadowMapDepth{{LIGHT_INDEX}}, bias{{LIGHT_INDEX}}, MOD_sampleSpread);\n                MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n            #endif\n\n            #ifdef MODE_VSM\n                float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorVSM(shadowMapSample{{LIGHT_INDEX}}, MOD_light{{LIGHT_INDEX}}.shadowProperties.BIAS, shadowMapDepth{{LIGHT_INDEX}}, shadowStrength{{LIGHT_INDEX}});\n                MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n            #endif\n        }\n#endif\n","shadow_body_point_vert":"// VERTEX BODY type: POINT count: {{LIGHT_INDEX}}\n#ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n    MOD_modelPos{{LIGHT_INDEX}} = mMatrix * pos;\n    MOD_normal{{LIGHT_INDEX}} = norm;\n#endif\n","shadow_body_spot_frag":"// FRAGMENT BODY type: SPOT count: {{LIGHT_INDEX}}\n #ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n        if (MOD_light{{LIGHT_INDEX}}.typeCastShadow.CAST_SHADOW == 1) {\n            vec3 lightDirectionMOD{{LIGHT_INDEX}} = normalize(MOD_light{{LIGHT_INDEX}}.position - MOD_modelPos{{LIGHT_INDEX}}.xyz);\n            vec2 shadowMapLookup{{LIGHT_INDEX}} = MOD_shadowCoord{{LIGHT_INDEX}}.xy / MOD_shadowCoord{{LIGHT_INDEX}}.w;\n            float shadowMapDepth{{LIGHT_INDEX}} = MOD_shadowCoord{{LIGHT_INDEX}}.z  / MOD_shadowCoord{{LIGHT_INDEX}}.w;\n            float shadowStrength{{LIGHT_INDEX}} = MOD_light{{LIGHT_INDEX}}.shadowStrength;\n            vec2 shadowMapSample{{LIGHT_INDEX}} = texture(MOD_shadowMap{{LIGHT_INDEX}}, shadowMapLookup{{LIGHT_INDEX}}).rg;\n            float lambert{{LIGHT_INDEX}} = clamp(dot(lightDirectionMOD{{LIGHT_INDEX}}, normalize(MOD_normal{{LIGHT_INDEX}})), 0., 1.);\n            float bias{{LIGHT_INDEX}} = clamp(MOD_light{{LIGHT_INDEX}}.shadowProperties.BIAS * tan(acos(lambert{{LIGHT_INDEX}})), 0., 0.1);\n\n            #ifdef MODE_DEFAULT\n                float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorDefault(shadowMapSample{{LIGHT_INDEX}}.r, shadowMapDepth{{LIGHT_INDEX}}, bias{{LIGHT_INDEX}}, shadowStrength{{LIGHT_INDEX}});\n                MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n            #endif\n\n            #ifdef MODE_PCF\n                float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorPCF(MOD_shadowMap{{LIGHT_INDEX}}, shadowMapLookup{{LIGHT_INDEX}}, MOD_light{{LIGHT_INDEX}}.shadowProperties.MAP_SIZE, shadowMapDepth{{LIGHT_INDEX}}, bias{{LIGHT_INDEX}}, shadowStrength{{LIGHT_INDEX}});\n                MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n            #endif\n\n            #ifdef MODE_POISSON\n                #ifdef WEBGL1\n                    FillPoissonArray();\n                #endif\n\n                float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorPoisson(MOD_shadowMap{{LIGHT_INDEX}}, shadowMapLookup{{LIGHT_INDEX}}, shadowMapDepth{{LIGHT_INDEX}}, bias{{LIGHT_INDEX}}, MOD_sampleSpread);\n                MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n            #endif\n\n            #ifdef MODE_VSM\n                float MOD_shadowFactor{{LIGHT_INDEX}} = MOD_ShadowFactorVSM(shadowMapSample{{LIGHT_INDEX}}, MOD_light{{LIGHT_INDEX}}.shadowProperties.BIAS, shadowMapDepth{{LIGHT_INDEX}}, shadowStrength{{LIGHT_INDEX}});\n                MOD_shadowFactor{{LIGHT_INDEX}} = clamp((MOD_shadowFactor{{LIGHT_INDEX}} + ((1. - shadowStrength{{LIGHT_INDEX}}))), 0., 1.);\n                vec3 MOD_shadowColor{{LIGHT_INDEX}} = (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n                col.rgb -= (1. - MOD_shadowFactor{{LIGHT_INDEX}}) * (vec3(1.) - MOD_shadowColor);\n            #endif\n        }\n    #endif\n","shadow_body_spot_vert":"// VERTEX BODY type: SPOT count: {{LIGHT_INDEX}}\n#ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n    MOD_modelPos{{LIGHT_INDEX}} = mMatrix*pos;\n    MOD_shadowCoord{{LIGHT_INDEX}} = MOD_lightMatrix{{LIGHT_INDEX}} * (MOD_modelPos{{LIGHT_INDEX}} + vec4(norm, 1) * MOD_normalOffset{{LIGHT_INDEX}});\n    MOD_normal{{LIGHT_INDEX}} = norm;\n#endif\n","shadow_head_directional_frag":"// FRAGMENT HEAD type: SPOT count: {{LIGHT_INDEX}}\n\n#ifdef RECEIVE_SHADOW\n    #ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n        IN vec4 MOD_modelPos{{LIGHT_INDEX}};\n        IN vec4 MOD_shadowCoord{{LIGHT_INDEX}};\n    #endif\n#endif\n","shadow_head_directional_vert":"// VERTEX HEAD type: DIRECTIONAL count: {{LIGHT_INDEX}}\n#ifdef RECEIVE_SHADOW\n    #ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n        OUT vec4 MOD_modelPos{{LIGHT_INDEX}};\n        OUT vec4 MOD_shadowCoord{{LIGHT_INDEX}};\n    #endif\n#endif\n","shadow_head_point_frag":"// FRAGMENT HEAD type: POINT count: {{LIGHT_INDEX}}\n#ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n    IN vec4 MOD_modelPos{{LIGHT_INDEX}};\n    IN vec3 MOD_normal{{LIGHT_INDEX}};\n#endif\n","shadow_head_point_vert":"// VERTEX HEAD type: POINT count: {{LIGHT_INDEX}}\n#ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n    OUT vec4 MOD_modelPos{{LIGHT_INDEX}};\n    OUT vec3 MOD_normal{{LIGHT_INDEX}};\n#endif\n","shadow_head_spot_frag":"// FRAGMENT HEAD type: SPOT count: {{LIGHT_INDEX}}\nIN vec4 MOD_modelPos{{LIGHT_INDEX}};\nIN vec3 MOD_normal{{LIGHT_INDEX}};\n\n#ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n    IN vec4 MOD_shadowCoord{{LIGHT_INDEX}};\n#endif\n","shadow_head_spot_vert":"// VERTEX HEAD type: SPOT count: {{LIGHT_INDEX}}\n#ifdef HAS_SHADOW_MAP_{{LIGHT_INDEX}}\n    OUT vec4 MOD_modelPos{{LIGHT_INDEX}};\n    OUT vec3 MOD_normal{{LIGHT_INDEX}};\n    OUT vec4 MOD_shadowCoord{{LIGHT_INDEX}};\n#endif\n",};
const cgl = op.patch.cgl;
const LIGHT_INDEX_REGEX = new RegExp("{{LIGHT_INDEX}}", "g");
const LIGHT_TYPES = { "point": 0, "directional": 1, "spot": 2 };

function clamp(val, min, max)
{
    return Math.min(Math.max(val, min), max);
}

const inTrigger = op.inTrigger("Trigger In");
const inCastShadow = op.inBool("Cast Shadow", true);
const inReceiveShadow = op.inBool("Receive Shadow", true);
const algorithms = ["Default", "PCF", "Poisson", "VSM"];
const inAlgorithm = op.inSwitch("Algorithm", algorithms, "Default");
const inSamples = op.inSwitch("Samples", [1, 2, 4, 8], 4);
const inSpread = op.inInt("Sample Distribution", 250);

const inShadowColorR = op.inFloatSlider("R", 0);
const inShadowColorG = op.inFloatSlider("G", 0);
const inShadowColorB = op.inFloatSlider("B", 0);
inShadowColorR.setUiAttribs({ "colorPick": true });
const inDiscardTransparent = op.inBool("Discard Transparent", false);
const inOpacityThreshold = op.inFloatSlider("Opacity Threshold", 0.5);
const ALPHA_MASK_SOURCE = ["Luminance", "R", "G", "B", "A"];
const inAlphaMaskSource = op.inSwitch("Alpha Mask Source", ALPHA_MASK_SOURCE, "Luminance");
const inOpacityTexture = op.inTexture("Opacity Texture");

inOpacityThreshold.setUiAttribs({ "greyout": !inDiscardTransparent.get() });
inAlphaMaskSource.setUiAttribs({ "greyout": !inDiscardTransparent.get() });
inSamples.setUiAttribs({ "greyout": true });
inSpread.setUiAttribs({ "greyout": true });
op.setPortGroup("", [inCastShadow, inReceiveShadow]);
op.setPortGroup("Shadow Settings", [inAlgorithm, inSamples, inSpread, inShadowColorR, inShadowColorG, inShadowColorB]);
op.setPortGroup("", [inDiscardTransparent]);
op.setPortGroup("Opacity Settings", [inOpacityThreshold, inAlphaMaskSource, inOpacityTexture]);

if (inReceiveShadow.get())
{
    if (inAlgorithm.get() === "PCF" || inAlgorithm.get() === "Poisson")
    {
        inSamples.setUiAttribs({ "greyout": false });
        inSpread.setUiAttribs({ "greyout": false });
    }
    else if (inAlgorithm.get() === "VSM" || inAlgorithm.get() === "Default")
    {
        inSamples.setUiAttribs({ "greyout": true });
        inSpread.setUiAttribs({ "greyout": true });
    }
}

inDiscardTransparent.onChange = () =>
{
    inOpacityThreshold.setUiAttribs({ "greyout": !inDiscardTransparent.get() });
    inAlphaMaskSource.setUiAttribs({ "greyout": !inDiscardTransparent.get() });
};

inAlphaMaskSource.onChange = () =>
{
    shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_LUMINANCE", inAlphaMaskSource.get() === "Luminance");
    shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_R", inAlphaMaskSource.get() === "R");
    shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_G", inAlphaMaskSource.get() === "G");
    shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_B", inAlphaMaskSource.get() === "B");
    shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_A", inAlphaMaskSource.get() === "A");
};

inReceiveShadow.onChange = () =>
{
    inAlgorithm.setUiAttribs({ "greyout": !inReceiveShadow.get() });
    setAlgorithmGreyouts();
};

inAlgorithm.onChange = () =>
{
    const current = inAlgorithm.get();
    algorithms.forEach((alg) => shaderModule.toggleDefine("MODE_" + alg.toUpperCase(), alg === current));

    setAlgorithmGreyouts();
};

function setAlgorithmGreyouts()
{
    if (!inReceiveShadow.get())
    {
        inSamples.setUiAttribs({ "greyout": true });
        inSpread.setUiAttribs({ "greyout": true });
        return;
    }

    if (inAlgorithm.get() === "PCF" || inAlgorithm.get() === "Poisson")
    {
        inSamples.setUiAttribs({ "greyout": false });
        inSpread.setUiAttribs({ "greyout": false });
    }
    else
    {
        inSamples.setUiAttribs({ "greyout": true });
        inSpread.setUiAttribs({ "greyout": true });
    }
}

inSamples.onChange = () =>
{
    shaderModule.define("SAMPLE_AMOUNT", "float(" + clamp(Number(inSamples.get()), 1, 16).toString() + ")");
};

const outTrigger = op.outTrigger("Trigger Out");

const createVertexHead = (n, type) =>
{
    if (type === "ambient") return "";
    if (type === "point") return attachments.shadow_head_point_vert.replace(LIGHT_INDEX_REGEX, n);
    if (type === "spot") return attachments.shadow_head_spot_vert.replace(LIGHT_INDEX_REGEX, n);
    if (type === "directional") return attachments.shadow_head_directional_vert.replace(LIGHT_INDEX_REGEX, n);
};

const createVertexBody = (n, type) =>
{
    if (type === "ambient") return "";
    if (type === "point") return attachments.shadow_body_point_vert.replace(LIGHT_INDEX_REGEX, n);
    if (type === "spot") return attachments.shadow_body_spot_vert.replace(LIGHT_INDEX_REGEX, n);
    if (type === "directional") return attachments.shadow_body_directional_vert.replace(LIGHT_INDEX_REGEX, n);
};

const createFragmentHead = (n, type) =>
{
    if (type === "ambient") return "";
    if (type === "point") return attachments.shadow_head_point_frag.replace(LIGHT_INDEX_REGEX, n);
    if (type === "spot") return attachments.shadow_head_spot_frag.replace(LIGHT_INDEX_REGEX, n);
    if (type === "directional") return attachments.shadow_head_directional_frag.replace(LIGHT_INDEX_REGEX, n);
};

const createFragmentBody = (n, type) =>
{
    if (type === "ambient") return "";
    let fragmentCode = "";
    if (type === "spot")
    {
        fragmentCode = fragmentCode.concat(attachments.shadow_body_spot_frag.replace(LIGHT_INDEX_REGEX, n));
    }
    else if (type === "directional")
    {
        fragmentCode = fragmentCode.concat(attachments.shadow_body_directional_frag.replace(LIGHT_INDEX_REGEX, n));
    }
    else if (type === "point")
    {
        fragmentCode = fragmentCode.concat(attachments.shadow_body_point_frag.replace(LIGHT_INDEX_REGEX, n));
    }

    return fragmentCode;
};

const STATE = {
    "lastLength": 0,
    "updating": false
};

function renderShadowPassWithModule()
{
    if (inDiscardTransparent.get())
    {
        if (inOpacityTexture.get())
        {
            if (!shadowShaderModule.hasUniform("MOD_texOpacity"))
            {
                shadowShaderModule.addUniformFrag("t", "MOD_texOpacity", 0);
            }

            if (!shadowShaderModule.hasDefine("MOD_HAS_TEXTURE_OPACITY")) shadowShaderModule.define("MOD_HAS_TEXTURE_OPACITY", "");
            shadowShaderModule.pushTexture("MOD_texOpacity", inOpacityTexture.get().tex);
        }
        else
        {
            if (shadowShaderModule.hasUniform("MOD_texOpacity"))
                shadowShaderModule.removeUniform("MOD_texOpacity");

            if (shadowShaderModule.hasDefine("MOD_HAS_TEXTURE_OPACITY")) shadowShaderModule.removeDefine("MOD_HAS_TEXTURE_OPACITY");
        }

        shadowShaderModule.bind();
        outTrigger.trigger();
        shadowShaderModule.unbind();
    }
    else
    {
        outTrigger.trigger();
    }
}

function createModuleShaders()
{
    STATE.updating = true;
    removeUniforms();

    let vertexHead = "";
    let fragmentHead = "";
    let vertexBody = "";
    let fragmentBody = "";

    for (let i = 0; i < cgl.frameStore.lightStack.length; i += 1)
    {
        const light = cgl.frameStore.lightStack[i];
        vertexHead = vertexHead.concat(createVertexHead(i, light.type));
        vertexBody = vertexBody.concat(createVertexBody(i, light.type));

        fragmentHead = fragmentHead.concat(createFragmentHead(i, light.type));
        fragmentBody = fragmentBody.concat(createFragmentBody(i, light.type, light.castShadow));
    }

    srcHeadVert = srcHeadVertBase.concat(vertexHead);
    srcBodyVert = srcBodyVertBase.concat(vertexBody);
    srcHeadFrag = srcHeadFragBase.concat(fragmentHead);
    srcBodyFrag = srcBodyFragBase.concat(fragmentBody);

    shaderModule.removeModule(op.objName);

    shaderModule.addModule({
        "name": "MODULE_VERTEX_POSITION",
        "title": op.objName,
        // "priority": -2,
        "srcHeadVert": srcHeadVert,
        "srcBodyVert": srcBodyVert
    });

    shaderModule.addModule({
        "name": "MODULE_COLOR",
        // "priority": -2,
        "title": op.objName,
        "srcHeadFrag": srcHeadFrag,
        "srcBodyFrag": srcBodyFrag,
    });

    createUniforms();
}

// * SHADOW PASS MODULE *
const shadowShaderModule = new CGL.ShaderModifier(cgl, "shadowPassModifier_" + op.id);
shadowShaderModule.addModule({
    "name": "MODULE_COLOR",
    // "priority": -2,
    "title": op.objName + "shadowPass",
    "srcHeadFrag": "",
    "srcBodyFrag": `
    #ifdef MOD_HAS_TEXTURE_OPACITY
        #ifdef MOD_ALPHA_MASK_LUMINANCE
            outColor.a *= dot(vec3(0.2126,0.7152,0.0722), texture(MOD_texOpacity, texCoord).rgb);
        #endif
        #ifdef MOD_ALPHA_MASK_R
            outColor.a *= texture(MOD_texOpacity, texCoord).r;
        #endif
        #ifdef MOD_ALPHA_MASK_G
            outColor.a *= texture(MOD_texOpacity, texCoord).g;
        #endif
        #ifdef MOD_ALPHA_MASK_B
            outColor.a *= texture(MOD_texOpacity, texCoord).b;
        #endif
        #ifdef MOD_ALPHA_MASK_A
            outColor.a *= texture(MOD_texOpacity, texCoord).a;
        #endif
        if (outColor.a < MOD_inOpacityThreshold) discard;
    #endif
    `
});

shadowShaderModule.addUniformFrag("f", "MOD_inOpacityThreshold", inOpacityThreshold);

shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_LUMINANCE", inAlphaMaskSource.get() === "Luminance");
shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_R", inAlphaMaskSource.get() === "R");
shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_G", inAlphaMaskSource.get() === "G");
shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_B", inAlphaMaskSource.get() === "B");
shadowShaderModule.toggleDefine("MOD_ALPHA_MASK_A", inAlphaMaskSource.get() === "A");

const srcHeadVertBase = attachments.head_vert;
const srcBodyVertBase = "";
const srcHeadFragBase = attachments.head_frag;
const srcBodyFragBase = "";

let srcHeadVert = srcHeadVertBase;
let srcBodyVert = srcBodyVertBase;
let srcHeadFrag = srcHeadFragBase;
let srcBodyFrag = srcBodyFragBase;

// * MAIN PASS MODULE *
const shaderModule = new CGL.ShaderModifier(cgl, "shadowModule_" + op.id);
shaderModule.define("SAMPLE_AMOUNT", "float(" + clamp(Number(inSamples.get()), 1, 16).toString() + ")");
shaderModule.toggleDefine("RECEIVE_SHADOW", inReceiveShadow);

algorithms.forEach((alg) => shaderModule.toggleDefine("MODE_" + alg.toUpperCase(), alg === inAlgorithm.get()));

const hasShadowMap = [];
const hasShadowCubemap = [];

function removeUniforms()
{
    for (let i = 0; i < STATE.lastLength; i += 1)
    {
        shaderModule.removeUniformStruct("MOD_light" + i);
        shaderModule.removeUniform("MOD_shadowMap" + i);
        shaderModule.removeUniform("MOD_shadowMapCube" + i);
        shaderModule.removeUniform("MOD_normalOffset" + i);
        shaderModule.removeUniform("MOD_lightMatrix" + i);
        shaderModule.removeDefine("HAS_SHADOW_MAP_" + i);
    }

    if (STATE.lastLength > 0)
    {
        shaderModule.removeUniform("MOD_sampleSpread");
        shaderModule.removeUniform("MOD_camPos");
    }
    hasShadowMap.length = 0;
    hasShadowCubemap.length = 0;
}

function createUniforms()
{
    for (let i = 0; i < cgl.frameStore.lightStack.length; i += 1)
    {
        const light = cgl.frameStore.lightStack[i];

        shaderModule.addUniformStructFrag("MOD_Light", "MOD_light" + i, [
            { "type": "3f", "name": "position", "v1": null },
            { "type": "2i", "name": "typeCastShadow", "v1": null },
            { "type": "4f", "name": "shadowProperties", "v1": [light.nearFar[0], light.nearFar[1], 512, light.shadowBias] },
            { "type": "f", "name": "shadowStrength", "v1": light.shadowStrength },
        ]);

        hasShadowMap[i] = false;
        hasShadowCubemap[i] = false;

        if (light.type !== "point")
        {
            shaderModule.addUniformVert("m4", "MOD_lightMatrix" + i, mat4.create(), null, null, null);
            shaderModule.addUniformVert("f", "MOD_normalOffset" + i, 0, null, null, null, null);
            shaderModule.addUniformFrag("t", "MOD_shadowMap" + i, 0, null, null, null);
        }
        else shaderModule.addUniformFrag("tc", "MOD_shadowMapCube" + i, 0, null, null, null);
    }

    if (cgl.frameStore.lightStack.length > 0)
    {
        shaderModule.addUniformFrag("3f", "MOD_shadowColor", inShadowColorR, inShadowColorG, inShadowColorB, null);
        shaderModule.addUniformFrag("f", "MOD_sampleSpread", inSpread, null, null, null);
        if (cgl.frameStore.lightStack.map((l) => l.type).indexOf("point") !== -1) shaderModule.addUniformFrag("3f", "MOD_camPos", [0, 0, 0], null, null, null);
    }

    STATE.lastLength = cgl.frameStore.lightStack.length;
    STATE.updating = false;
}

function setUniforms()
{
    if (STATE.updating) return;
    const receiveShadow = inReceiveShadow.get();

    for (let i = 0; i < cgl.frameStore.lightStack.length; i += 1)
    {
        const light = cgl.frameStore.lightStack[i];

        if (light.type === "ambient") continue;

        if (!light.isUsed) light.isUsed = true;

        if (light.type !== "point") shaderModule.setUniformValue("MOD_light" + i + ".position", light.position);
        else
        {
            shaderModule.setUniformValue("MOD_light" + i + ".position", light.positionForShadowMap);
        }
        shaderModule.setUniformValue("MOD_light" + i + ".typeCastShadow", [
            LIGHT_TYPES[light.type],
            Number(light.castShadow),
        ]);

        shaderModule.setUniformValue("MOD_light" + i + ".shadowStrength", light.shadowStrength);

        if (light.shadowMap)
        {
            if (!hasShadowMap[i])
            {
                hasShadowMap[i] = true;
                hasShadowCubemap[i] = false;
            }
            if (!shaderModule.hasDefine("HAS_SHADOW_MAP_" + i))
            {
                shaderModule.define("HAS_SHADOW_MAP_" + i, true);
            }

            if (light.type !== "point")
            {
                shaderModule.setUniformValue("MOD_lightMatrix" + i, light.lightMatrix);
                shaderModule.setUniformValue("MOD_normalOffset" + i, light.normalOffset);
            }

            shaderModule.setUniformValue("MOD_light" + i + ".shadowProperties", [
                light.nearFar[0],
                light.nearFar[1],
                light.shadowMap.width,
                light.shadowBias
            ]);

            if (light.type === "point") shaderModule.setUniformValue("MOD_camPos", [_tempCamPosMatrix[12], _tempCamPosMatrix[13], _tempCamPosMatrix[14]]);

            if (hasShadowMap[i])
            {
                if (light.shadowMap.tex) shaderModule.pushTexture("MOD_shadowMap" + i, light.shadowMap.tex);
            }
            continue;
        }

        if (light.shadowCubeMap)
        {
            if (!hasShadowCubemap[i])
            {
                hasShadowCubemap[i] = true;
                hasShadowMap[i] = false;
            }

            if (!shaderModule.hasDefine("HAS_SHADOW_MAP_" + i)) shaderModule.define("HAS_SHADOW_MAP_" + i, "");

            shaderModule.setUniformValue("MOD_light" + i + ".shadowProperties", [
                light.nearFar[0],
                light.nearFar[1],
                light.shadowCubeMap.size,
                light.shadowBias
            ]);

            if (hasShadowCubemap[i])
            {
                if (light.shadowCubeMap.cubemap) shaderModule.pushTexture("MOD_shadowMapCube" + i, light.shadowCubeMap.cubemap, cgl.gl.TEXTURE_CUBE_MAP);
            }
            continue;
        }

        else
        {
            if (hasShadowMap[i])
            {
                if (shaderModule.hasDefine("HAS_SHADOW_MAP_" + i))
                {
                    shaderModule.removeDefine("HAS_SHADOW_MAP_" + i);
                }
                hasShadowMap[i] = false;
            }
            else if (hasShadowCubemap[i])
            {
                if (shaderModule.hasDefine("HAS_SHADOW_MAP_" + i)) shaderModule.removeDefine("HAS_SHADOW_MAP_" + i);
                hasShadowCubemap[i] = false;
            }
            continue;
        }
    }
}

function updateShader()
{
    if (cgl.frameStore.lightStack.length !== STATE.lastLength)
        createModuleShaders();

    setUniforms();
}

inTrigger.onLinkChanged = function ()
{
    if (!inTrigger.isLinked()) STATE.lastLength = 0;
    hasShadowMap.length = 0;
    hasShadowCubemap.length = 0;
};
outTrigger.onLinkChanged = function ()
{
    if (!outTrigger.isLinked()) STATE.lastLength = 0;
    hasShadowMap.length = 0;
    hasShadowCubemap.length = 0;
};

const _tempCamPosMatrix = mat4.create();

inTrigger.onTriggered = () =>
{
    if (STATE.updating)
    {
        outTrigger.trigger();
        return;
    }

    if (cgl.frameStore.shadowPass)
    {
        if (!inCastShadow.get()) return;
        renderShadowPassWithModule();
        return;
    }

    if (!inReceiveShadow.get())
    {
        outTrigger.trigger();
        return;
    }

    checkUiErrors();

    mat4.invert(_tempCamPosMatrix, cgl.vMatrix);

    if (cgl.frameStore.lightStack)
    {
        if (cgl.frameStore.lightStack.length)
        {
            updateShader();

            shaderModule.bind();
            outTrigger.trigger();
            shaderModule.unbind();
        }
        else
        {
            outTrigger.trigger();
            STATE.lastLength = 0;
            hasShadowMap.length = 0;
            hasShadowCubemap.length = 0;
        }
    }
    else
    {
        outTrigger.trigger();
    }
};

function checkUiErrors()
{
    if (cgl.frameStore.lightStack)
    {
        if (cgl.frameStore.lightStack.length === 0)
        {
            op.setUiError("nolights", "There are no lights in the patch. Please add lights before this op and activate their \"Cast Shadow\" property to be able to use shadows.", 1);
        }
        else
        {
            op.setUiError("nolights", null);

            let oneLightCastsShadow = false;
            let allLightsBlurAboveZero = true;

            for (let i = 0; i < cgl.frameStore.lightStack.length; i += 1)
            {
                oneLightCastsShadow = oneLightCastsShadow || cgl.frameStore.lightStack[i].castShadow;

                if (cgl.frameStore.lightStack[i].castShadow && cgl.frameStore.lightStack[i].type !== "point")
                    allLightsBlurAboveZero = allLightsBlurAboveZero && (cgl.frameStore.lightStack[i].blurAmount > 0);
            }

            if (oneLightCastsShadow)
            {
                op.setUiError("nolights2", null);
                if (inReceiveShadow.get())
                {
                    op.setUiError("inReceiveShadowActive", null);
                }
                else
                {
                    op.setUiError("inReceiveShadowActive", "Your lights cast shadows but the \"Receive Shadow\" option in this op is not active. Please enable it to use shadows.", 1);
                }
            }
            else
            {
                op.setUiError("nolights2", "There are lights in the patch but none that cast shadows. Please activate the \"Cast Shadow\" property of one of your lights in the patch to make shadows visible.", 1);
                op.setUiError("inReceiveShadowActive", null);
            }

            if (!allLightsBlurAboveZero)
            {
                if (inAlgorithm.get() === "VSM")
                {
                    op.setUiError("vsmBlurZero", "You chose the VSM algorithm but one of your lights still has a blur amount of 0. For VSM to work correctly, consider raising the blur amount in your lights.", 1);
                }
                else
                {
                    op.setUiError("vsmBlurZero", null);
                }
            }
            else
            {
                op.setUiError("vsmBlurZero", null);
            }
        }
    }
    else
    {
        op.setUiError("nolights", "There are no lights in the patch. Please add lights before this op and activate their \"Cast Shadow\" property to be able to use shadows.", 1);
    }
}


};

Ops.Gl.ShaderEffects.Shadow_v2.prototype = new CABLES.Op();
CABLES.OPS["f5214bd2-575d-4c0c-a7a9-4eff76915ac1"]={f:Ops.Gl.ShaderEffects.Shadow_v2,objName:"Ops.Gl.ShaderEffects.Shadow_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.SplineDeform_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.SplineDeform_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"splinedeform_vert":"\n\n\npos.xyz=MOD_splineDeform(pos,0);\n\nnorm=normalize(norm*MOD_splineDeform(pos,1));\n\n","splinedeform_head_vert":"\nUNI vec3 MOD_points[SPLINE_POINTS];\n\nvec3 ip(float v)\n{\n    int index0=int(abs(mod(v,max(0.0,float(SPLINE_POINTS)))));\n    int index1=int(abs(mod(v+1.0,max(0.0,float(SPLINE_POINTS)))));\n    float fr=fract(abs(mod(v,max(0.0,float(SPLINE_POINTS)))));\n    return mix( MOD_points[index0] ,MOD_points[index1] ,fr);\n}\n\nvec3 MOD_splineDeform(vec4 pos, int isNormal)\n{\n    float off=MOD_offset+( (pos.x)*MOD_size);\n\n    vec3 bezierPointPrevious=ip(off-1.0);\n    vec3 bezierPoint=ip(off);\n    vec3 bezierPointNext=ip(off+1.0);\n\n    vec3 _Up=vec3(0.0,1.0,0.0);\n    vec3 _Forward=vec3(1.0,0.0,0.0);\n    vec3 _Right=vec3(0.0,0.0,1.0);\n\n\tfloat vertexForward = pos.x * _Forward.x + pos.y * _Forward.y + pos.z * _Forward.z;\n\tfloat vertexRight = pos.x * _Right.x + pos.y * _Right.y + pos.z * _Right.z;\n\tfloat vertexUp = pos.x * _Up.x + pos.y * _Up.y + pos.z * _Up.z;\n\n\tfloat angle = atan(vertexUp,vertexRight);\n\tfloat radius = length(vec2(vertexRight, vertexUp));\n\n\tvec3 forward = normalize(bezierPointNext - bezierPoint);\n\tvec3 backward = normalize(bezierPointPrevious - bezierPoint);\n\tvec3 up = normalize(cross(forward, backward));\n\tvec3 right = normalize(cross(forward, up));\n\n    if(isNormal==0)\n    {\n        pos.xyz = bezierPoint + right * cos(angle) * radius + up * sin(angle) * radius;\n    }\n    else\n    {\n        pos.xyz = pos.xyz-( (bezierPoint) + right * cos(angle) * radius + up * sin(angle) * radius);\n    }\n\n    return pos.xyz;\n}",};
const
    render = op.inTrigger("Render"),
    next = op.outTrigger("Next"),
    inSize = op.inValue("Size", 1),
    inOffset = op.inValue("offset"),
    inPoints = op.inArray("Points");

const cgl = op.patch.cgl;
const srcHeadVert = attachments.splinedeform_head_vert || "";
const srcBodyVert = attachments.splinedeform_vert || "";

let needsUpdate = true;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    srcHeadVert,
    srcBodyVert
});

mod.addUniform("f", "MOD_size", inSize);
mod.addUniform("f", "MOD_offset", inOffset);
mod.addUniform("3f[]", "MOD_points", new Float32Array([0, 0, 0, 0, 0, 0]));
mod.define("SPLINE_POINTS", 1);

inPoints.onChange = () =>
{
    needsUpdate = true;
};

render.onTriggered = function ()
{
    mod.bind();
    let pointArray = inPoints.get();

    if (needsUpdate)
    {
        if (inPoints.get())
        {
            if (pointArray && pointArray.length > 0)
            {
                mod.define("SPLINE_POINTS", Math.floor(pointArray.length / 3));
                needsUpdate = false;
            }
        }
    }

    if (pointArray && pointArray.length > 0)
        mod.setUniformValue("MOD_points", pointArray);

    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.SplineDeform_v2.prototype = new CABLES.Op();
CABLES.OPS["d0cac165-2146-4a3c-863c-5042149c0e95"]={f:Ops.Gl.ShaderEffects.SplineDeform_v2,objName:"Ops.Gl.ShaderEffects.SplineDeform_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.TextureProjection_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.TextureProjection_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"maptexture_frag":"IN vec2 MOD_tc;\n\n#ifdef MOD_MAP_TRIPLANAR\n    IN vec2 MOD_tc1;\n    IN vec2 MOD_tc2;\n    IN vec3 MOD_blendingTri;\n#endif\n\n\n{{CGL.BLENDMODES3}}","maptexture_vert":"vec3 MOD_pos;\n\n#ifndef MOD_WORLDSPACE\n   MOD_pos=(vec4(vPosition,1.0)*1.0/MOD_scale).xyz;\n#endif\n#ifdef MOD_WORLDSPACE\n   MOD_pos=(mMatrix*pos).xyz*1.0/MOD_scale;\n#endif\n\nMOD_pos=(vec4(MOD_pos,1.0)*MOD_rotationX(MOD_rotX*MOD_DEG2RAD)).xyz;\nMOD_pos=(vec4(MOD_pos,1.0)*MOD_rotationY(MOD_rotY*MOD_DEG2RAD)).xyz;\nMOD_pos=(vec4(MOD_pos,1.0)*MOD_rotationZ(MOD_rotZ*MOD_DEG2RAD)).xyz;\n\n#ifdef MOD_MAP_XY\n    MOD_tc=MOD_pos.xy;\n#endif\n#ifdef MOD_MAP_XZ\n    MOD_tc=MOD_pos.xz;\n#endif\n#ifdef MOD_MAP_YZ\n    MOD_tc=MOD_pos.yz;\n#endif\n\nMOD_tc.xy+=vec2(0.5,0.5);\nMOD_tc.xy+=MOD_offset;\n\n\n#ifdef MOD_TARGET_POINTSIZE\n\n    gl_PointSize+=texture(MOD_tex,MOD_tc).x*MOD_amount;\n\n#endif\n\n\n#ifdef MOD_MAP_TRIPLANAR\n    mapTriplanar((mMatrix*vec4(attrVertNormal,1.0)).xyz,MOD_pos);\n#endif\n\n","maptexture_body_frag":"#ifndef MOD_TARGET_POINTSIZE\n\n\n    vec4 MOD_color;\n\n    #ifdef MOD_MAP_TRIPLANAR\n        vec4 xaxis = texture( MOD_tex, MOD_tc);\n        vec4 yaxis = texture( MOD_tex, MOD_tc1);\n        vec4 zaxis = texture( MOD_tex, MOD_tc2);\n        MOD_color = xaxis *MOD_blendingTri.x + yaxis *MOD_blendingTri.y + zaxis *MOD_blendingTri.z;\n        MOD_color.a=1.0;\n    #endif\n\n\n    vec2 MOD_ntc=MOD_tc;\n\n    #ifdef MOD_MAP_SCREEN\n        MOD_ntc=(vec2(gl_FragCoord.x,gl_FragCoord.y)/vec2(MOD_viewPortW,MOD_viewPortH));\n\n        MOD_ntc-=vec2(0.5,0.5);\n        MOD_ntc*=1.0/MOD_scale;\n        MOD_ntc+=vec2(0.5,0.5);\n        MOD_ntc-=MOD_offset;\n    #endif\n\n    #ifdef MOD_MAP_TEXCOORD\n        MOD_ntc=texCoord;\n    #endif\n\n    #ifdef MOD_MAP_TEXCOORD1\n        MOD_ntc=texCoord1;\n    #endif\n\n    #ifdef MOD_MAP_TEXCOORD2\n        MOD_ntc=texCoord2;\n    #endif\n\n\n    #ifdef MOD_DISCARD\n    if(MOD_ntc.x>0.0 && MOD_ntc.x<1.0 && MOD_ntc.y>0.0 && MOD_ntc.y<1.0)\n    {\n    #endif\n\n        #ifndef MOD_MAP_TRIPLANAR\n            MOD_color=texture(MOD_tex,MOD_ntc);\n        #endif\n\n        #ifdef MOD_USE_IMGALPHA\n            col.a=MOD_color.a;\n        #endif\n\n        #ifdef MOD_TARGET_COLOR\n        col=cgl_blendPixel(col,MOD_color,MOD_amount*col.a);\n        #endif\n        #ifdef MOD_TARGET_ALPHA\n        col.a=1.0-MOD_color.r*MOD_amount;\n        #endif\n\n    #ifdef MOD_DISCARD\n    }\n\n    #endif\n#endif\n","maptexture_body_vert":"OUT vec2 MOD_tc;\n\nconst float MOD_DEG2RAD = 0.017453292519943;\n\n#ifdef MOD_MAP_TRIPLANAR\n\n    OUT vec2 MOD_tc1;\n    OUT vec2 MOD_tc2;\n    OUT vec3 MOD_blendingTri;\n\n    void mapTriplanar(vec3 wNorm,vec3 pos)\n    {\n        vec3 blending = abs( wNorm );\n        blending = normalize(max(blending, 0.1));\n        float b = (blending.x + blending.y + blending.z);\n        blending /= vec3(b);\n        MOD_blendingTri=blending;\n\n        MOD_tc = pos.yz;\n        MOD_tc1 = pos.xz;\n        MOD_tc2 = pos.xy;\n    }\n\n#endif\n\nmat4 MOD_rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 MOD_rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 MOD_rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n",};
const
    render = op.inTrigger("render"),
    next = op.outTrigger("trigger"),
    inTex = op.inTexture("Texture"),

    inScale = op.inValue("Scale", 10),

    inTarget = op.inSwitch("Target", ["Color", "Pointsize", "Alpha"], "Color"),

    inBlend = CGL.TextureEffect.AddBlendSelect(op, "blendMode"),
    inAmount = op.inValueSlider("Amount", 0.3),

    inUseTexAlpha = op.inBool("Use Texture Alpha", false),

    inPosX = op.inFloat("Pos X", 0),
    inPosY = op.inFloat("Pos Y", 0),

    inRotX = op.inFloat("Rot X", 0),
    inRotY = op.inFloat("Rot Y", 0),
    inRotZ = op.inFloat("Rot Z", 0),

    inMethod = op.inValueSelect("Mapping", ["Triplanar", "XY", "XZ", "YZ", "Screen", "TexCoords 1", "TexCoords 2", "TexCoords 3"], "XY"),
    inDiscard = op.inValueBool("Discard"),
    inWorldSpace = op.inValueBool("WorldSpace");

const cgl = op.patch.cgl;

inUseTexAlpha.onChange =
inTarget.onChange =
inBlend.onChange = inDiscard.onChange = inWorldSpace.onChange = inMethod.onChange = updateDefines;

op.setPortGroup("Rotation", [inRotX, inRotY, inRotZ]);
op.setPortGroup("Position", [inPosX, inPosY]);

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.maptexture_body_vert,
    "srcBodyVert": attachments.maptexture_vert,
    "attributes": [
        { "type": "vec2", "name": "attrTexCoord1", "nameFrag": "texCoord1" },
        { "type": "vec2", "name": "attrTexCoord2", "nameFrag": "texCoord2" }]
});

let head_frag = attachments.maptexture_frag;
head_frag = head_frag.replace("{{BLENDCODE}}", CGL.TextureEffect.getBlendCode(3));

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": head_frag,
    "srcBodyFrag": attachments.maptexture_body_frag
});

mod.addUniformBoth("f", "MOD_rotX", inRotX);
mod.addUniformBoth("f", "MOD_rotY", inRotY);
mod.addUniformBoth("f", "MOD_rotZ", inRotZ);

mod.addUniformBoth("t", "MOD_tex");
mod.addUniformBoth("f", "MOD_scale", inScale);
mod.addUniformBoth("f", "MOD_amount", inAmount);
mod.addUniformBoth("2f", "MOD_offset", inPosX, inPosY);

const uniWidth = mod.addUniformFrag("f", "MOD_viewPortW");
const uniHeight = mod.addUniformFrag("f", "MOD_viewPortH");

CGL.TextureEffect.setupBlending(op, mod, inBlend, inAmount);

updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_USE_IMGALPHA", inUseTexAlpha.get());
    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get());
    mod.toggleDefine("MOD_MAP_XY", inMethod.get() == "XY");
    mod.toggleDefine("MOD_MAP_XZ", inMethod.get() == "XZ");
    mod.toggleDefine("MOD_MAP_YZ", inMethod.get() == "YZ");
    mod.toggleDefine("MOD_MAP_TEXCOORD", inMethod.get() == "TexCoords 1");
    mod.toggleDefine("MOD_MAP_TEXCOORD1", inMethod.get() == "TexCoords 2");
    mod.toggleDefine("MOD_MAP_TEXCOORD2", inMethod.get() == "TexCoords 3");
    mod.toggleDefine("MOD_MAP_SCREEN", inMethod.get() == "Screen");
    mod.toggleDefine("MOD_MAP_TRIPLANAR", inMethod.get() == "Triplanar");
    mod.toggleDefine("MOD_DISCARD", inDiscard.get());

    mod.toggleDefine("MOD_BLEND_NORMAL", inBlend.get() == "Normal");
    mod.toggleDefine("MOD_BLEND_ADD", inBlend.get() == "Add");
    mod.toggleDefine("MOD_BLEND_MUL", inBlend.get() == "Mul");
    mod.toggleDefine("MOD_BLEND_MUL", inBlend.get() == "Mul");

    mod.toggleDefine("MOD_TARGET_ALPHA", inTarget.get() == "Alpha");
    mod.toggleDefine("MOD_TARGET_COLOR", inTarget.get() == "Color");
    mod.toggleDefine("MOD_TARGET_POINTSIZE", inTarget.get() == "Pointsize");
}

render.onTriggered = function ()
{
    const vp = cgl.getViewPort();

    mod.setUniformValue("MOD_viewPortW", vp[2]);
    mod.setUniformValue("MOD_viewPortH", vp[3]);

    mod.bind();
    let tex = inTex.get();
    if (!tex) tex = CGL.Texture.getEmptyTexture(cgl).tex;
    else tex = tex.tex;

    mod.pushTexture("MOD_tex", tex);

    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.TextureProjection_v2.prototype = new CABLES.Op();
CABLES.OPS["9be647c2-7afd-40ed-b669-9826ea6a50ca"]={f:Ops.Gl.ShaderEffects.TextureProjection_v2,objName:"Ops.Gl.ShaderEffects.TextureProjection_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.TransformTextureCoordinates
// 
// **************************************************************

Ops.Gl.ShaderEffects.TransformTextureCoordinates = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"trans_vert":"\n#ifdef MOD_FLIPX\n    texCoord.x=1.0-texCoord.x;\n#endif\n#ifdef MOD_FLIPY\n    texCoord.y=1.0-texCoord.y;\n#endif\n\ntexCoord*=MOD_scale;\ntexCoord+=MOD_trans;",};
const
    render = op.inTrigger("render"),
    next = op.outTrigger("Trigger"),

    transX = op.inValue("Translate X", 0),
    transY = op.inValue("Translate Y", 0),

    scaleX = op.inValue("Repeat X", 1),
    scaleY = op.inValue("Repeat Y", 1),

    inFlipX=op.inBool("Flip X",false),
    inFlipY=op.inBool("Flip Y",false)
    ;

const cgl = op.patch.cgl;
const mod = new CGL.ShaderModifier(cgl, op.name);

mod.addModule({
    "priority": -2,
    "name": "MODULE_VERTEX_POSITION",
    "srcBodyVert": attachments.trans_vert || ""
});

mod.addUniformVert("2f", "MOD_trans", transX, transY);
mod.addUniformVert("2f", "MOD_scale", scaleX, scaleY);


inFlipX.onChange=
    inFlipY.onChange=updateDefines;

updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_FLIPX",inFlipX.get());
    mod.toggleDefine("MOD_FLIPY",inFlipY.get());
}

render.onTriggered = function ()
{
    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.TransformTextureCoordinates.prototype = new CABLES.Op();
CABLES.OPS["54eeb750-1491-4fdf-bfd5-290e1b29bafd"]={f:Ops.Gl.ShaderEffects.TransformTextureCoordinates,objName:"Ops.Gl.ShaderEffects.TransformTextureCoordinates"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.TransformVertex
// 
// **************************************************************

Ops.Gl.ShaderEffects.TransformVertex = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"trans_vert":"\n\n\npos.xyz*=vec3(MOD_scale);\npos.xyz+=vec3(MOD_translate);\n\nmat4 MOD_rmat=\n        MOD_rotationX(MOD_rot.x*0.0174533)*\n        MOD_rotationY(MOD_rot.y*0.0174533)*\n        MOD_rotationZ(MOD_rot.z*0.0174533);\n\npos*=MOD_rmat;\n\n#ifdef MOD_TRANS_NORMS\n    norm=(vec4(norm,1.0)*MOD_rmat).xyz;\n    bitangent=(vec4(bitangent,1.0)*MOD_rmat).xyz;\n    tangent=(vec4(tangent,1.0)*MOD_rmat).xyz;\n#endif","trans_head_vert":"\nmat4 MOD_rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 MOD_rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 MOD_rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("Trigger"),
    transX = op.inValue("Translate X", 0),
    transY = op.inValue("Translate Y", 0),
    transZ = op.inValue("Translate Z", 0),

    scaleX = op.inValue("Scale X", 1),
    scaleY = op.inValue("Scale Y", 1),
    scaleZ = op.inValue("Scale Z", 1),

    rotX = op.inValue("Rotation X", 0),
    rotY = op.inValue("Rotation Y", 0),
    rotZ = op.inValue("Rotation Z", 0),
    transNorm = op.inBool("Transform normals", false);

const cgl = op.patch.cgl;
const mod = new CGL.ShaderModifier(cgl, op.name);

mod.addModule({
    "priority": -2,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.trans_head_vert || "",
    "srcBodyVert": attachments.trans_vert || ""
});

mod.addUniformVert("3f", "MOD_translate", transX, transY, transZ);
mod.addUniformVert("3f", "MOD_scale", scaleX, scaleY, scaleZ);
mod.addUniformVert("3f", "MOD_rot", rotX, rotY, rotZ);

transNorm.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_TRANS_NORMS", transNorm.get());
}

render.onTriggered = function ()
{
    mod.bind();
    trigger.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.TransformVertex.prototype = new CABLES.Op();
CABLES.OPS["68ca4a91-c3ce-4e81-bb84-3ba5f50dfaa1"]={f:Ops.Gl.ShaderEffects.TransformVertex,objName:"Ops.Gl.ShaderEffects.TransformVertex"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.Twist_v3
// 
// **************************************************************

Ops.Gl.ShaderEffects.Twist_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"twist_vert":"\nfloat MOD_angle_rad = MOD_amount * 3.14159 / 180.0;\n\nfloat MOD_axis=pos.y;\n\n#ifdef MOD_AXIS_Z\n    MOD_axis=pos.z;\n#endif\n\n#ifdef MOD_AXIS_X\n    MOD_axis=pos.x;\n#endif\n\nfloat MOD_ang = (MOD_height*0.5 + MOD_axis)/MOD_height * MOD_angle_rad;\n\npos = MOD_twist(pos, MOD_ang);\n\n\nnorm = normalize(MOD_twist( vec4(norm, 1.0), MOD_ang ).xyz);\n","twist_head_vert":"vec4 MOD_twist(vec4 pos, float t)\n{\n\tfloat st = sin(t);\n\tfloat ct = cos(t);\n\tvec4 new_pos;\n\n\tnew_pos.x = pos.x;\n\tnew_pos.y = pos.y;\n\tnew_pos.z = pos.z;\n\tnew_pos.w = pos.w;\n\n    #ifdef MOD_AXIS_Z\n    \tnew_pos.x = pos.y*ct - pos.x*st;\n    \tnew_pos.y = pos.y*st + pos.x*ct;\n    #endif\n\n    #ifdef MOD_AXIS_Y\n    \tnew_pos.x = pos.x*ct - pos.z*st;\n    \tnew_pos.z = pos.x*st + pos.z*ct;\n    #endif\n\n    #ifdef MOD_AXIS_X\n    \tnew_pos.y = pos.y*ct - pos.z*st;\n    \tnew_pos.z = pos.y*st + pos.z*ct;\n    #endif\n\n\treturn( new_pos );\n}\n",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("Trigger"),
    amount = op.inFloat("Degree", 180),
    height = op.inFloat("Height", 2),
    axis = op.inValueSelect("Axis", ["X", "Y", "Z"], "Y");

const cgl = op.patch.cgl;

axis.onChange = updateAxis;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": attachments.twist_head_vert,
    "srcBodyVert": attachments.twist_vert
});

updateAxis();

mod.addUniformVert("f", "MOD_amount", amount);
mod.addUniformVert("f", "MOD_height", height);

function updateAxis()
{
    mod.toggleDefine("MOD_AXIS_X", axis.get() == "X");
    mod.toggleDefine("MOD_AXIS_Y", axis.get() == "Y");
    mod.toggleDefine("MOD_AXIS_Z", axis.get() == "Z");
}

render.onTriggered = function ()
{
    if (cgl.shouldDrawHelpers(op))
    {
        CABLES.GL_MARKER.drawCube(op, 1, height.get() / 2, 1);
    }

    mod.bind();
    trigger.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.Twist_v3.prototype = new CABLES.Op();
CABLES.OPS["4635abe3-a6b1-413f-9cd1-fbf64f8c4942"]={f:Ops.Gl.ShaderEffects.Twist_v3,objName:"Ops.Gl.ShaderEffects.Twist_v3"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.UseVertexColor
// 
// **************************************************************

Ops.Gl.ShaderEffects.UseVertexColor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorarea_frag":"baseColor.rgb=vertColor.rgb;","colorarea_head_frag":"IN vec4 vertColor;\n",};
const
    render = op.inTrigger("Render"),
    next = op.outTrigger("Next");

const cgl = op.patch.cgl;

const srcHeadVert = ""
    .endl() + "IN vec4 attrVertColor;"
    .endl() + "OUT vec4 vertColor;"
    .endl();

const srcBodyVert = ""
    .endl() + "   vertColor=attrVertColor;"
    .endl();


render.onTriggered = doRender;

const vertModTitle = "vert_" + op.name;
const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": vertModTitle,
    "name": "MODULE_VERTEX_POSITION",
    srcHeadVert,
    srcBodyVert
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_BASE_COLOR",
    "srcHeadFrag": attachments.colorarea_head_frag,
    "srcBodyFrag": attachments.colorarea_frag
});


function doRender()
{
    mod.bind();
    next.trigger();

    mod.unbind();
}


};

Ops.Gl.ShaderEffects.UseVertexColor.prototype = new CABLES.Op();
CABLES.OPS["8c3cc332-3bab-4cb7-ad0a-368814eb8282"]={f:Ops.Gl.ShaderEffects.UseVertexColor,objName:"Ops.Gl.ShaderEffects.UseVertexColor"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.VertexColorAsAlpha
// 
// **************************************************************

Ops.Gl.ShaderEffects.VertexColorAsAlpha = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorarea_frag":"\nfloat MOD_vca=1.0;\n\n#ifdef MOD_INPUT_LUMI\n    float MOD_lumi = dot(vec3(0.2126,0.7152,0.0722), col.rgb);\n\n    MOD_vca=MOD_lumi;\n#endif\n#ifdef MOD_INPUT_R\n    MOD_vca=vertColor.r;\n#endif\n#ifdef MOD_INPUT_G\n    MOD_vca=vertColor.g;\n#endif\n#ifdef MOD_INPUT_B\n    MOD_vca=vertColor.b;\n#endif\n\n#ifdef MOD_INVERT\n    col.a=1.0-MOD_vca;\n#endif\n#ifndef MOD_INVERT\n    col.a=MOD_vca;\n#endif","colorarea_head_frag":"IN vec4 vertColor;\n",};
const
    render = op.inTrigger("Render"),
    inInput=op.inSwitch("Input",['Luminance','R','G','B'],'default'),
    inInvert=op.inBool("Invert",false),
    next = op.outTrigger("Next");


const cgl = op.patch.cgl;

const srcHeadVert = ""
    .endl() + "IN vec3 attrVertColor;"
    .endl() + "OUT vec4 vertColor;"

    .endl();

const srcBodyVert = ""
    .endl() + "vertColor.rgb=attrVertColor;"
    .endl();

inInput.onChange =
    inInvert.onChange = updateDefines;

render.onTriggered = doRender;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "priority": 2,
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    srcHeadVert,
    srcBodyVert
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": attachments.colorarea_head_frag,
    "srcBodyFrag": attachments.colorarea_frag
});

updateDefines();


function updateDefines()
{
    mod.toggleDefine("MOD_INPUT_R", inInput.get()==="R");
    mod.toggleDefine("MOD_INPUT_G", inInput.get()==="G");
    mod.toggleDefine("MOD_INPUT_B", inInput.get()==="B");
    mod.toggleDefine("MOD_INPUT_LUMI", inInput.get()==="Luminance");
    mod.toggleDefine("MOD_INVERT", inInvert.get());
}



function doRender()
{
    mod.bind();
    next.trigger();

    mod.unbind();
}


};

Ops.Gl.ShaderEffects.VertexColorAsAlpha.prototype = new CABLES.Op();
CABLES.OPS["3a3a4c1f-3824-4fa2-b287-1368bde0f0a0"]={f:Ops.Gl.ShaderEffects.VertexColorAsAlpha,objName:"Ops.Gl.ShaderEffects.VertexColorAsAlpha"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.VertexDisplacementMap_v4
// 
// **************************************************************

Ops.Gl.ShaderEffects.VertexDisplacementMap_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"vertdisplace_body_vert":"\nvec2 MOD_tc=texCoord;\n\n#ifdef MOD_COORD_MESHXY\n    MOD_tc=pos.xy;\n#endif\n#ifdef MOD_COORD_MESHXZ\n    MOD_tc=pos.xz;\n#endif\n\n\n#ifdef MOD_FLIP_Y\n    MOD_tc.y=1.0-MOD_tc.y;\n#endif\n#ifdef MOD_FLIP_X\n    MOD_tc.x=1.0-MOD_tc.x;\n#endif\n#ifdef MOD_FLIP_XY\n    MOD_tc=1.0-MOD_tc;\n#endif\n\nMOD_tc*=MOD_scale;\n\nvec4 MOD_sample=texture( MOD_texture, vec2(MOD_tc.x+MOD_offsetX,MOD_tc.y+MOD_offsetY) );\nvec3 MOD_disp;\n\n#ifdef MOD_INPUT_R\n    MOD_disp=vec3(MOD_sample.r);\n#endif\n#ifdef MOD_INPUT_G\n    MOD_disp=vec3(MOD_sample.g);\n#endif\n#ifdef MOD_INPUT_B\n    MOD_disp=vec3(MOD_sample.b);\n#endif\n#ifdef MOD_INPUT_A\n    MOD_disp=vec3(MOD_sample.a);\n#endif\n#ifdef MOD_INPUT_RGB\n    MOD_disp=MOD_sample.rgb;\n#endif\n#ifdef MOD_INPUT_LUMI\n    MOD_disp=vec3(dot(vec3(0.2126,0.7152,0.0722), MOD_sample.rgb));\n#endif\n\n\n\n#ifdef MOD_HEIGHTMAP_INVERT\n   MOD_disp=1.0-MOD_disp;\n#endif\n// #ifdef MOD_HEIGHTMAP_NORMALIZE\n//   MOD_disp-=0.5;\n//   MOD_disp*=2.0;\n// #endif\n\n\n#ifdef MOD_HEIGHTMAP_NORMALIZE\n    MOD_disp=(MOD_disp-0.5)*2.0;\n    // MOD_disp=(MOD_disp-0.5)*-1.0+0.5;\n#endif\n\n\nfloat MOD_zero=0.0;\n\n#ifdef MOD_MODE_DIV\n    MOD_zero=1.0;\n#endif\n#ifdef MOD_MODE_MUL\n    MOD_zero=1.0;\n#endif\n\n\n\nvec3 MOD_mask=vec3(1.0);\n\n#ifdef MOD_AXIS_X\n    MOD_mask=vec3(1.,0.,0.);\n    MOD_disp*=MOD_mask*MOD_extrude;\n#endif\n#ifdef MOD_AXIS_Y\n    MOD_mask=vec3(0.,1.,0.);\n    MOD_disp*=MOD_mask*MOD_extrude;\n#endif\n#ifdef MOD_AXIS_Z\n    MOD_mask=vec3(0.,0.,1.);\n    MOD_disp*=MOD_mask*MOD_extrude;\n#endif\n#ifdef MOD_AXIS_XY\n    MOD_mask=vec3(1.,1.,0.);\n    MOD_disp*=MOD_mask*MOD_extrude;\n#endif\n#ifdef MOD_AXIS_XYZ\n    MOD_mask=vec3(1.,1.,1.);\n    MOD_disp*=MOD_mask*MOD_extrude;\n#endif\n\n\n// MOD_disp=smoothstep(-1.,1.,MOD_disp*MOD_disp*MOD_disp);\n// MOD_disp=MOD_disp*MOD_disp*MOD_disp;\n\n// #ifdef MOD_FLIP_Y\n//     MOD_mask.y=1.0-MOD_mask.y;\n// #endif\n// #ifdef MOD_FLIP_X\n//     MOD_mask.x=1.0-MOD_mask.x;\n// #endif\n// #ifdef MOD_FLIP_XY\n//     MOD_mask.xy=1.0-MOD_mask.xy;\n// #endif\n\n\n\n#ifdef MOD_MODE_DIV\n    pos.xyz/=MOD_disp*MOD_mask;\n#endif\n\n#ifdef MOD_MODE_MUL\n    pos.xyz*=MOD_disp*MOD_mask;\n#endif\n\n#ifdef MOD_MODE_ADD\n    pos.xyz+=MOD_disp*MOD_mask;\n#endif\n\n#ifdef MOD_MODE_NORMAL\n\n    vec3 MOD_t=norm;\n    #ifdef MOD_SMOOTHSTEP\n        MOD_t=smoothstep(-1.,1.,MOD_t);\n    #endif\n\n    pos.xyz+=MOD_t*MOD_disp*MOD_mask;\n\n#endif\n\n#ifdef MOD_MODE_TANGENT\n    MOD_disp*=-1.0;\n\n    vec3 MOD_t=attrTangent;\n    #ifdef MOD_SMOOTHSTEP\n        MOD_t=smoothstep(-1.,1.,MOD_t);\n    #endif\n\n    pos.xyz+=MOD_t*MOD_disp*MOD_mask;\n\n#endif\n\n#ifdef MOD_MODE_BITANGENT\n    MOD_disp*=-1.0;\n    vec3 MOD_t=attrBiTangent;\n\n    #ifdef MOD_SMOOTHSTEP\n        MOD_t=smoothstep(-1.,1.,MOD_t);\n    #endif\n\n    pos.xyz+=MOD_t*MOD_disp*MOD_mask;\n\n#endif\n\n#ifdef MOD_MODE_VERTCOL\n    vec3 MOD_t=attrVertColor.rgb*vec3(2.0)-vec3(1.0);\n\n    #ifdef MOD_SMOOTHSTEP\n        MOD_t=smoothstep(-1.,1.,MOD_t);\n    #endif\n\n    pos.xyz+=MOD_t*MOD_disp*MOD_mask;\n\n#endif\n\n\n// pos.y*=-1.0;\n    // pos.xy+=vec2(MOD_texVal*MOD_extrude)*normalize(pos.xy);\n\n\nMOD_displHeightMapColor=MOD_disp;\n\n\n#ifdef CALC_NORMALS\n    norm+=MOD_calcNormal(MOD_texture,MOD_tc);\n#endif","vertdisplace_head_vert":"OUT vec3 MOD_displHeightMapColor;\n\n#ifdef MOD_MODE_VERTCOL\n#ifndef VERTEX_COLORS\nIN vec4 attrVertColor;\n#endif\n#endif\n\n// mat4 rotationX( in float angle ) {\n// \treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n// \t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n// \t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n// \t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n// }\n\n// mat4 rotationY( in float angle ) {\n// \treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n// \t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n// \t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n// \t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n// }\n\n// mat4 rotationZ( in float angle ) {\n// \treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n// \t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n// \t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n// \t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n// }\n\n\nvec3 MOD_calcNormal(sampler2D tex,vec2 uv)\n{\n    float strength=13.0;\n    float texelSize=1.0/512.0;\n\n    float tl = abs(texture(tex, uv + texelSize * vec2(-1.0, -1.0)).x);   // top left\n    float  l = abs(texture(tex, uv + texelSize * vec2(-1.0,  0.0)).x);   // left\n    float bl = abs(texture(tex, uv + texelSize * vec2(-1.0,  1.0)).x);   // bottom left\n    float  t = abs(texture(tex, uv + texelSize * vec2( 0.0, -1.0)).x);   // top\n    float  b = abs(texture(tex, uv + texelSize * vec2( 0.0,  1.0)).x);   // bottom\n    float tr = abs(texture(tex, uv + texelSize * vec2( 1.0, -1.0)).x);   // top right\n    float  r = abs(texture(tex, uv + texelSize * vec2( 1.0,  0.0)).x);   // right\n    float br = abs(texture(tex, uv + texelSize * vec2( 1.0,  1.0)).x);   // bottom right\n\n    //     // Compute dx using Sobel:\n    //     //           -1 0 1\n    //     //           -2 0 2\n    //     //           -1 0 1\n    float dX = tr + 2.0*r + br -tl - 2.0*l - bl;\n\n    //     // Compute dy using Sobel:\n    //     //           -1 -2 -1\n    //     //            0  0  0\n    //     //            1  2  1\n    float dY = bl + 2.0*b + br -tl - 2.0*t - tr;\n\n    //     // Build the normalized normal\n\n    vec3 N = normalize(vec3(dX,dY, 1.0 / strength));\n\n    //     //convert (-1.0 , 1.0) to (0.0 , 1.0), if needed\n    N= N * 0.5 + 0.5;\n\n   return N;\n}\n",};
const
    render = op.inTrigger("Render"),

    // meth = op.inValueSelect("Mode", ["normal", "normal xy", "mul xyz", "mul xy", "sub x", "add x", "add xy", "add y", "add z", "mul y", "mul z", "sub z", "normal2", "normal RGB", "m14"], "normal"),
    extrude = op.inValue("Extrude", 0.5),
    meth = op.inSwitch("Mode", ["Norm", "Tang", "BiTang", "VertCol", "*", "+", "/"], "Norm"),
    axis = op.inSwitch("Axis", ["XYZ", "XY", "X", "Y", "Z"], "XYZ"),
    src = op.inSwitch("Coordinates", ["Tex Coords", "Mesh XY", "Mesh XZ"], "Tex Coords"),

    texture = op.inTexture("Texture", null, "texture"),
    channel = op.inSwitch("Channel", ["Luminance", "R", "G", "B", "A", "RGB"], "Luminance"),
    flip = op.inSwitch("Flip", ["None", "X", "Y", "XY"], "None"),
    range = op.inSwitch("Range", ["0-1", "1-0", "Normalized"], "0-1"),
    offsetX = op.inValueFloat("Offset X"),
    offsetY = op.inValueFloat("Offset Y"),
    scale = op.inValueFloat("Scale", 1),

    calcNormals = op.inValueBool("Calc Normals", false),
    removeZero = op.inValueBool("Discard Zero Values"),
    colorize = op.inValueBool("colorize", false),
    colorizeMin = op.inValueSlider("Colorize Min", 0),
    colorizeMax = op.inValueSlider("Colorize Max", 1),
    next = op.outTrigger("trigger");

const cgl = op.patch.cgl;

op.setPortGroup("Input", [texture, flip, channel, range, offsetX, offsetY, scale]);
op.setPortGroup("Colorize", [colorize, colorizeMin, colorizeMax]);

op.toWorkPortsNeedToBeLinked(texture, next, render);

render.onTriggered = dorender;

channel.onChange =
colorize.onChange =
axis.onChange =
    range.onChange =
    removeZero.onChange =
    flip.onChange =
    calcNormals.onChange =
    src.onChange =
    meth.onChange = updateDefines;

const srcHeadVert = attachments.vertdisplace_head_vert;
const srcBodyVert = attachments.vertdisplace_body_vert;

const srcHeadFrag = ""
    .endl() + "IN vec3 MOD_displHeightMapColor;"
    .endl() + "vec3 MOD_map(vec3 value, float inMin, float inMax, float outMin, float outMax) { return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);}"

    .endl();

const srcBodyFrag = ""
    .endl() + "#ifdef MOD_HEIGHTMAP_COLORIZE"
    .endl() + "   col.rgb*=MOD_map( MOD_displHeightMapColor, 0.0,1.0 , MOD_colorizeMin,MOD_colorizeMax);"
    .endl() + "#endif"
    .endl() + "#ifdef MOD_DISPLACE_REMOVE_ZERO"
    .endl() + "   if(MOD_displHeightMapColor.r==0.0)discard;"
    .endl() + "#endif"
    .endl();

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": srcHeadVert,
    "srcBodyVert": srcBodyVert
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": srcHeadFrag,
    "srcBodyFrag": srcBodyFrag
});

mod.addUniformVert("t", "MOD_texture", 0);
mod.addUniformVert("f", "MOD_extrude", extrude);
mod.addUniformVert("f", "MOD_offsetX", offsetX);
mod.addUniformVert("f", "MOD_offsetY", offsetY);
mod.addUniformVert("f", "MOD_scale", scale);

mod.addUniformFrag("f", "MOD_colorizeMin", colorizeMin);
mod.addUniformFrag("f", "MOD_colorizeMax", colorizeMax);

updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_HEIGHTMAP_COLORIZE", colorize.get());

    mod.toggleDefine("MOD_HEIGHTMAP_INVERT", range.get() == "1-0");
    mod.toggleDefine("MOD_HEIGHTMAP_NORMALIZE", range.get() == "Normalized");

    mod.toggleDefine("MOD_DISPLACE_REMOVE_ZERO", removeZero.get());

    mod.toggleDefine("MOD_INPUT_R", channel.get() == "R");
    mod.toggleDefine("MOD_INPUT_G", channel.get() == "G");
    mod.toggleDefine("MOD_INPUT_B", channel.get() == "B");
    mod.toggleDefine("MOD_INPUT_A", channel.get() == "A");
    mod.toggleDefine("MOD_INPUT_RGB", channel.get() == "RGB");
    mod.toggleDefine("MOD_INPUT_LUMI", channel.get() == "Luminance");

    mod.toggleDefine("MOD_FLIP_X", flip.get() == "X");
    mod.toggleDefine("MOD_FLIP_Y", flip.get() == "Y");
    mod.toggleDefine("MOD_FLIP_XY", flip.get() == "XY");

    mod.toggleDefine("MOD_AXIS_X", axis.get() == "X");
    mod.toggleDefine("MOD_AXIS_Y", axis.get() == "Y");
    mod.toggleDefine("MOD_AXIS_Z", axis.get() == "Z");
    mod.toggleDefine("MOD_AXIS_XYZ", axis.get() == "XYZ");
    mod.toggleDefine("MOD_AXIS_XY", axis.get() == "XY");

    mod.toggleDefine("MOD_MODE_BITANGENT", meth.get() == "BiTang");
    mod.toggleDefine("MOD_MODE_TANGENT", meth.get() == "Tang");
    mod.toggleDefine("MOD_MODE_NORMAL", meth.get() == "Norm");
    mod.toggleDefine("MOD_MODE_VERTCOL", meth.get() == "VertCol");
    mod.toggleDefine("MOD_MODE_MUL", meth.get() == "*");
    mod.toggleDefine("MOD_MODE_ADD", meth.get() == "+");
    mod.toggleDefine("MOD_MODE_DIV", meth.get() == "/");
    mod.toggleDefine("MOD_SMOOTHSTEP", 0);

    mod.toggleDefine("MOD_COORD_TC", src.get() == "Tex Coords");
    mod.toggleDefine("MOD_COORD_MESHXY", src.get() == "Mesh XY");
    mod.toggleDefine("MOD_COORD_MESHXZ", src.get() == "Mesh XZ");

    mod.toggleDefine("CALC_NORMALS", calcNormals.get());
}

function dorender()
{
    mod.bind();

    if (texture.get() && !texture.get().deleted) mod.pushTexture("MOD_texture", texture.get());
    else mod.pushTexture("MOD_texture", CGL.Texture.getEmptyTexture(cgl));

    next.trigger();

    mod.unbind();
}


};

Ops.Gl.ShaderEffects.VertexDisplacementMap_v4.prototype = new CABLES.Op();
CABLES.OPS["ed36e5ad-457b-4ac6-a929-11b66951cb6c"]={f:Ops.Gl.ShaderEffects.VertexDisplacementMap_v4,objName:"Ops.Gl.ShaderEffects.VertexDisplacementMap_v4"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.VertexNumberLimit_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.VertexNumberLimit_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    limitMin = op.inValueInt("Min", 0),
    limitMax = op.inValueInt("Max", 1000),
    inv=op.inBool("Invert",false);

const trigger = op.outTrigger("Next");
const cgl = op.patch.cgl;

const srcHeadVert = ""
    .endl() + "OUT float MOD_discard;"
    .endl();

const srcBodyVert = ""
    .endl() + "MOD_discard=1.0; "

    .endl() + "#ifndef MOD_INVERT"
    .endl() + "  if(attrVertIndex >= MOD_vertLimit.x && attrVertIndex <= MOD_vertLimit.y) MOD_discard=0.0; "
    .endl() + "#endif"

    .endl() + "#ifdef MOD_INVERT"
    .endl() + "  if(attrVertIndex < MOD_vertLimit.x || attrVertIndex > MOD_vertLimit.y) MOD_discard=0.0; "
    .endl() + "#endif"
    .endl();

const srcHeadFrag = ""
    .endl() + "IN float MOD_discard;"
    .endl();

const srcBodyFrag = ""
    .endl() + "if(MOD_discard>0.0) discard;"
    .endl();


const mod = new CGL.ShaderModifier(cgl, op.name);

mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    srcHeadVert,
    srcBodyVert
});

mod.addModule({
    "title": op.name,
    "name": "MODULE_COLOR",
    "srcHeadFrag": srcHeadFrag,
    "srcBodyFrag": srcBodyFrag
});

mod.addUniform("2f", "MOD_vertLimit", limitMin,limitMax);
inv.onChange=updateDefines;


function updateDefines()
{
    mod.toggleDefine("MOD_INVERT",inv.get());
}

render.onTriggered = function ()
{
    mod.bind();
    trigger.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.VertexNumberLimit_v2.prototype = new CABLES.Op();
CABLES.OPS["3c1043bd-e65d-42ea-a154-456f235b197c"]={f:Ops.Gl.ShaderEffects.VertexNumberLimit_v2,objName:"Ops.Gl.ShaderEffects.VertexNumberLimit_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.VertexPositionFromTexture_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.VertexPositionFromTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"vertposbody_vert":"vec4 col=texture(MOD_tex,texCoord);\n\nvec3 MOD_pos=col.xyz;\n\n#ifdef MOD_ADD\npos.xyz+=MOD_pos.xyz;\n#endif\n\n#ifdef MOD_ABS\npos.xyz=MOD_pos.xyz;\n#endif\n\n",};
const
    render = op.inTrigger("render"),
    inTex = op.inTexture("Texture"),
    inMode = op.inSwitch("Mode", ["Absolute", "Add"], "Absolute"),
    trigger = op.outTrigger("Trigger");

const cgl = op.patch.cgl;

const mod = new CGL.ShaderModifier(cgl, op.name);
mod.addModule({
    "priority": 2,
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": "",
    "srcBodyVert": attachments.vertposbody_vert
});

mod.addUniformVert("t", "MOD_tex");
inMode.onChange = updateDefines;
render.onTriggered = doRender;
updateDefines();

function updateDefines()
{
    mod.toggleDefine("MOD_ADD", inMode.get() == "Add");
    mod.toggleDefine("MOD_ABS", inMode.get() == "Absolute");
}

function doRender()
{
    mod.bind();
    if (inTex.get())mod.pushTexture("MOD_tex", inTex.get().tex);

    trigger.trigger();
    mod.unbind();
}


};

Ops.Gl.ShaderEffects.VertexPositionFromTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["30eea555-afda-456e-9c50-9a40b370fa1f"]={f:Ops.Gl.ShaderEffects.VertexPositionFromTexture_v2,objName:"Ops.Gl.ShaderEffects.VertexPositionFromTexture_v2"};




// **************************************************************
// 
// Ops.Gl.ShaderEffects.VertexWobble_v2
// 
// **************************************************************

Ops.Gl.ShaderEffects.VertexWobble_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"sinewobble_vert":"\n#ifndef MOD_WORLDSPACE\n   vec4 MOD_vertPos=vec4(vPosition,1.0);\n#endif\n#ifdef MOD_WORLDSPACE\n   vec4 MOD_vertPos=mMatrix*pos;\n#endif\n\n#ifdef MOD_AREA_SPHERE\n    float MOD_de=distance(\n        MOD_posSize.xyz,\n        vec3(MOD_vertPos.x,MOD_vertPos.y,MOD_vertPos.z)\n        );\n#endif\n\n#ifdef MOD_AREA_BOX\n    float MOD_de=0.0;\n    if(abs(MOD_vertPos.y-MOD_posSize.y)>MOD_posSize.w ||\n        abs(MOD_vertPos.x-MOD_posSize.x)>MOD_posSize.w ||\n        abs(MOD_vertPos.z-MOD_posSize.z)>MOD_posSize.w ) MOD_de=1.0;\n#endif\n\n#ifdef MOD_AREA_AXIS_X\n    float MOD_de=abs(MOD_posSize.x-MOD_vertPos.x);\n#endif\n#ifdef MOD_AREA_AXIS_Y\n    float MOD_de=abs(MOD_posSize.y-MOD_vertPos.y);\n#endif\n#ifdef MOD_AREA_AXIS_Z\n    float MOD_de=abs(MOD_posSize.z-MOD_vertPos.z);\n#endif\n\n#ifdef MOD_AREA_AXIS_X_INFINITE\n    float MOD_de=MOD_posSize.x-MOD_vertPos.x;\n#endif\n#ifdef MOD_AREA_AXIS_Y_INFINITE\n    float MOD_de=MOD_posSize.y-MOD_vertPos.y;\n#endif\n#ifdef MOD_AREA_AXIS_Z_INFINITE\n    float MOD_de=MOD_posSize.z-MOD_vertPos.z;\n#endif\n\n#ifndef MOD_AREA_BOX\n    MOD_de=1.0-smoothstep(MOD_falloff,MOD_posSize.w,MOD_de);\n#endif\n\n#ifdef MOD_AREA_INVERT\n    MOD_de=1.0-MOD_de;\n#endif\n\nfloat MOD_v=0.0;\n\n#ifdef MOD_SRC_XZ\n   MOD_v=(MOD_vertPos.x+MOD_vertPos.z);\n#endif\n#ifdef MOD_SRC_XY\n   MOD_v=(MOD_vertPos.x+MOD_vertPos.y);\n#endif\n#ifdef MOD_SRC_X\n   MOD_v=MOD_vertPos.x;\n#endif\n#ifdef MOD_SRC_Y\n   MOD_v=MOD_vertPos.y;\n#endif\n#ifdef MOD_SRC_Z\n   MOD_v=MOD_vertPos.z;\n#endif\n\n\nfloat MOD_amnt=MOD_amount*MOD_de;\n\nMOD_v=sin( (MOD_time)+( MOD_v*MOD_scale  ) ) ;\n#ifdef MOD_POSITIVE\n    MOD_v=(MOD_v+1.0)/2.0;\n#endif\nMOD_v*=MOD_amnt;\n\n\n\n\n#ifdef MOD_TO_AXIS_X\n   pos.x+=MOD_v;\n//   norm.x+=MOD_v;\n#endif\n\n#ifdef MOD_TO_AXIS_Y\n   pos.y+=MOD_v;\n//   norm.y+=MOD_v;\n#endif\n\n#ifdef MOD_TO_AXIS_Z\n   pos.z+=MOD_v;\n//   norm.z+=MOD_v;\n#endif\n\n// norm=normalize(norm);\n\n\n\n\n\n",};
let self = this;
const cgl = op.patch.cgl;

const render = op.inTrigger("render");
let src = op.inValueSelect("Source", [
    "X * Z + Time",
    "X * Y + Time",
    "X + Time",
    "Y + Time",
    "Z + Time"], "X * Z + Time");

const
    amount = op.inValueSlider("amount", 0.1),
    inTime=op.inFloat("Time",0),
    mul = op.inValueFloat("Scale", 3),
    toAxisX = op.inValueBool("axisX", true),
    toAxisY = op.inValueBool("axisY", true),
    toAxisZ = op.inValueBool("axisZ", true),
    positive = op.inSwitch("Range",['-1 to 1','0 to 1'],'-1 to 1'),

    inArea = op.inValueSelect("Area", ["Sphere", "Box", "Axis X", "Axis Y", "Axis Z", "Axis X Infinite", "Axis Y Infinite", "Axis Z Infinite"], "Sphere"),
    inSize = op.inValue("Size", 1),
    inFalloff = op.inValueSlider("Falloff", 0),

    x = op.inValue("x"),
    y = op.inValue("y"),
    z = op.inValue("z"),
    inWorldSpace = op.inValueBool("WorldSpace", true),
    inInvert = op.inValueBool("Invert"),

    next = this.outTrigger("trigger");

op.setPortGroup("Area",[inArea,inSize,x,y,z,inFalloff,inWorldSpace,inInvert]);

positive.onChange=
inArea.onChange=
    inWorldSpace.onChange=
    inSize.onChange=
    src.onChange =
    toAxisZ.onChange =
    toAxisX.onChange =
    toAxisY.onChange = setDefines;

const srcHeadVert = "";
// let startTime = CABLES.now() / 1000.0;
const mod = new CGL.ShaderModifier(cgl, op.name);

mod.addModule({
    "title": op.name,
    "name": "MODULE_VERTEX_POSITION",
    "srcHeadVert": srcHeadVert,
    "srcBodyVert": attachments.sinewobble_vert
});

mod.addUniform("4f", "MOD_posSize", x, y, z,inSize);
mod.addUniformVert("f", "MOD_time", inTime);
mod.addUniformVert("f", "MOD_amount", amount);
mod.addUniformVert("f", "MOD_scale", mul);
mod.addUniformVert("f", "MOD_falloff", inFalloff);

setDefines();

function setDefines()
{
    mod.toggleDefine("MOD_AREA_INVERT", inInvert.get());
    mod.toggleDefine("MOD_POSITIVE", positive.get()=="0 to 1");

    mod.toggleDefine("MOD_WORLDSPACE", inWorldSpace.get() );
    mod.toggleDefine("MOD_AREA_AXIS_X", inArea.get() == "Axis X");
    mod.toggleDefine("MOD_AREA_AXIS_Y", inArea.get() == "Axis Y");
    mod.toggleDefine("MOD_AREA_AXIS_Z", inArea.get() == "Axis Z");
    mod.toggleDefine("MOD_AREA_AXIS_X_INFINITE", inArea.get() == "Axis X Infinite");
    mod.toggleDefine("MOD_AREA_AXIS_Y_INFINITE", inArea.get() == "Axis Y Infinite");
    mod.toggleDefine("MOD_AREA_AXIS_Z_INFINITE", inArea.get() == "Axis Z Infinite");
    mod.toggleDefine("MOD_AREA_SPHERE", inArea.get() == "Sphere");
    mod.toggleDefine("MOD_AREA_BOX", inArea.get() == "Box");

    mod.toggleDefine("MOD_TO_AXIS_X", toAxisX.get());
    mod.toggleDefine("MOD_TO_AXIS_Y", toAxisY.get());
    mod.toggleDefine("MOD_TO_AXIS_Z", toAxisZ.get());
    mod.toggleDefine("MOD_SRC_XZ", !src.get() || src.get() == "X * Z + Time" || src.get() === "");
    mod.toggleDefine("MOD_SRC_XY", src.get() == "X * Y + Time");
    mod.toggleDefine("MOD_SRC_X", src.get() == "X + Time");
    mod.toggleDefine("MOD_SRC_Y", src.get() == "Y + Time");
    mod.toggleDefine("MOD_SRC_Z", src.get() == "Z + Time");
}

render.onTriggered = function ()
{
    mod.bind();
    next.trigger();
    mod.unbind();
};


};

Ops.Gl.ShaderEffects.VertexWobble_v2.prototype = new CABLES.Op();
CABLES.OPS["76983d1c-be6d-453d-b34f-472efe8221e7"]={f:Ops.Gl.ShaderEffects.VertexWobble_v2,objName:"Ops.Gl.ShaderEffects.VertexWobble_v2"};




// **************************************************************
// 
// Ops.Gl.ShowNormals_v2
// 
// **************************************************************

Ops.Gl.ShowNormals_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorize_normals_frag":"UNI vec4 inColor;\n\nvoid main() {\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col = inColor;\n\n    {{MODULE_COLOR}}\n\n    outColor = col;\n}",};
const
    render = op.inTrigger("render"),
    inDoRender = op.inBool("Draw", true),
    geometry = op.inObject("geometry", null, "geometry"),
    dropdown = op.inSwitch("Vectors", ["Normals", "Tangents", "Bitangents"], "Normals"),
    mul = op.inValueFloat("Length", 0.1),
    inColorize = op.inBool("Colorize", true),
    inR = op.inFloat("R", 0),
    inG = op.inFloat("G", 0.8),
    inB = op.inFloat("B", 0),
    inA = op.inFloatSlider("A", 1),
    trigger = op.outTrigger("trigger"),
    outGeom = op.outObject("Line Geom", null, "geometry");

inR.setUiAttribs({ "colorPick": true, "greyout": true });
inG.setUiAttribs({ "greyout": true });
inB.setUiAttribs({ "greyout": true });
inA.setUiAttribs({ "greyout": true });

geometry.ignoreValueSerialize = true;

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "colorizeNormals");
shader.setSource(shader.getDefaultVertexShader(), attachments.colorize_normals_frag);
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.glPrimitive = cgl.gl.LINES;

const inColorUniform = new CGL.Uniform(shader, "4f", "inColor", inR, inG, inB, inA);

geometry.onChange = mul.onChange = dropdown.onChange = buildMesh;
inColorize.onChange = handleColorizeChange;
handleColorizeChange();

let mesh = null;
const position = vec3.create();

buildMesh();

function handleColorizeChange()
{
    inR.setUiAttribs({ "greyout": !inColorize.get() });
    inG.setUiAttribs({ "greyout": !inColorize.get() });
    inB.setUiAttribs({ "greyout": !inColorize.get() });
    inA.setUiAttribs({ "greyout": !inColorize.get() });

    if (inColorize.get())
    {
        shader.setSource(shader.getDefaultVertexShader(), attachments.colorize_normals_frag);
    }
    else
    {
        shader.setSource(shader.getDefaultVertexShader(), shader.getDefaultFragmentShader());
    }
}

function buildMesh()
{
    const geom = new CGL.Geometry("shownormals");

    const points = [];
    const tc = [];
    const geometryInput = geometry.get();

    if (geometryInput && geometryInput.vertices)
    {
        op.setUiError("noVertices", null);
        for (let i = 0; i < geometryInput.vertices.length; i += 3)
        {
            points.push(geometryInput.vertices[i + 0]);
            points.push(geometryInput.vertices[i + 1]);
            points.push(geometryInput.vertices[i + 2]);

            tc.push(0, 1);
            tc.push(0, 1);
            if (dropdown.get() === "Normals")
            {
                if (!geometryInput.vertexNormals || !geometryInput.vertexNormals.length)
                {
                    op.setUiError("noNormals", "Input geometry has no normals!", 1);
                }
                else
                {
                    op.setUiError("noNormals", null);
                    points.push(geometryInput.vertices[i + 0] + geometryInput.vertexNormals[i + 0] * mul.get());
                    points.push(geometryInput.vertices[i + 1] + geometryInput.vertexNormals[i + 1] * mul.get());
                    points.push(geometryInput.vertices[i + 2] + geometryInput.vertexNormals[i + 2] * mul.get());
                }
            }

            if (dropdown.get() === "Tangents")
            {
                if (!geometryInput.tangents || !geometryInput.tangents.length)
                {
                    op.setUiError("noTangents", "Input geometry has no tangents!", 1);
                }
                else
                {
                    op.setUiError("noTangents", null);
                    points.push(geometryInput.vertices[i + 0] + geometryInput.tangents[i + 0] * mul.get());
                    points.push(geometryInput.vertices[i + 1] + geometryInput.tangents[i + 1] * mul.get());
                    points.push(geometryInput.vertices[i + 2] + geometryInput.tangents[i + 2] * mul.get());
                }
            }
            if (dropdown.get() === "Bitangents")
            {
                if (!geometryInput.biTangents || !geometryInput.biTangents.length)
                {
                    op.setUiError("noBitangents", "Input geometry has no bitangents!", 1);
                }
                else
                {
                    op.setUiError("noBitangents", null);
                    points.push(geometryInput.vertices[i + 0] + geometryInput.biTangents[i + 0] * mul.get());
                    points.push(geometryInput.vertices[i + 1] + geometryInput.biTangents[i + 1] * mul.get());
                    points.push(geometryInput.vertices[i + 2] + geometryInput.biTangents[i + 2] * mul.get());
                }
            }
        }

        geom.vertices = points;
        geom.texCoords = tc;
        geom.glPrimitive = cgl.gl.LINES;

        if (mesh) mesh.dispose();
        mesh = new CGL.Mesh(cgl, geom);

        outGeom.set(null);
        outGeom.set(geom);
    }
    else
    {
        outGeom.set(null);
        if (mesh) mesh.dispose();
        mesh = null;
        op.setUiError("noVertices", "There is no input geometry or input geometry has no vertices!", 0);
    }
}

render.onTriggered = function ()
{
    if (geometry.get() && inDoRender.get())
    {
        if (!shader) return;
        if (mesh) mesh.render(shader);
    }

    trigger.trigger();
};


};

Ops.Gl.ShowNormals_v2.prototype = new CABLES.Op();
CABLES.OPS["3d68b4d4-2945-48bf-8fc9-30567946deda"]={f:Ops.Gl.ShowNormals_v2,objName:"Ops.Gl.ShowNormals_v2"};




// **************************************************************
// 
// Ops.Gl.SurfaceScatter_v2
// 
// **************************************************************

Ops.Gl.SurfaceScatter_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Render"),
    inDraw = op.inValueBool("draw", true),
    inNum = op.inValueInt("Num", 100),
    inGeomSurface = op.inObject("Geom Surface"),
    // inGeom = op.inObject("Geometry"),
    inDistribution = op.inValueSelect("Distribution", ["Vertex", "Triangle Center", "Triangle Side", "Random Triangle Point"], "Vertex"),
    inVariety = op.inValueSelect("Selection", ["Random", "Sequential"], "Random"),
    seed = op.inValueFloat("Random Seed"),
    inSizeMin = op.inValueSlider("Size min", 1.0),
    inSizeMax = op.inValueSlider("Size max", 1.0),
    inDoLimit = op.inValueBool("Limit", false),
    inLimit = op.inValueInt("Limit Num", 0),
    inRotateRandom = op.inValueBool("Random Rotate", true),
    outNext = op.outTrigger("Next"),
    outArrPositions = op.outArray("Positions", 3),
    outArrScale = op.outArray("Scale", 3),
    outArrRotations = op.outArray("Quaternions", 4);
const cgl = op.patch.cgl;
const mod = null;
let recalc = true;

let matrixArray = new Float32Array(1);
const m = mat4.create();
const qAxis = vec3.create();

op.setPortGroup("Size", [inSizeMin, inSizeMax]);
op.setPortGroup("Distribution", [inDistribution, inVariety, seed]);

inDistribution.onChange =
    seed.onChange =
    inNum.onChange =
    inRotateRandom.onChange =
    inSizeMin.onChange =
    inSizeMax.onChange =
    inVariety.onChange =
    inGeomSurface.onChange = reset;
render.onTriggered = doRender;

const arrPositions = [];
const arrRotations = [];
const arrScale = [];

function uniqueIndices(oldCount, newCount, randomize)
{
    function fisherYatesShuffle(array)
    {
        Math.randomSeed = seed.get();
        let i = 0;
        let j = 0;
        let temp = null;

        for (i = array.length - 1; i > 0; i -= 1)
        {
            j = Math.floor(Math.seededRandom() * (i + 1));
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }

    const arr = [];
    arr.length = newCount;

    if (newCount > oldCount)
    {
        arr.length = newCount;
        for (let i = 0; i < newCount; i++) arr[i] = i % (oldCount);
    }
    else
    {
        arr.length = oldCount;
        for (let i = 0; i < oldCount; i++) arr[i] = i;
    }

    if (randomize)fisherYatesShuffle(arr);
    return arr;
}

function getEuler(out, quat)
{
    const x = quat[0],
        y = quat[1],
        z = quat[2],
        w = quat[3],
        x2 = x * x,
        y2 = y * y,
        z2 = z * z,
        w2 = w * w;
    const unit = x2 + y2 + z2 + w2;
    const test = x * w - y * z;
    if (test > 0.499995 * unit)
    { // TODO: Use glmatrix.EPSILON
    // singularity at the north pole
        out[0] = Math.PI / 2;
        out[1] = 2 * Math.atan2(y, x);
        out[2] = 0;
    }
    else if (test < -0.499995 * unit)
    { // TODO: Use glmatrix.EPSILON
    // singularity at the south pole
        out[0] = -Math.PI / 2;
        out[1] = 2 * Math.atan2(y, x);
        out[2] = 0;
    }
    else
    {
        out[0] = Math.asin(2 * (x * z - w * y));
        out[1] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (z2 + w2));
        out[2] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (y2 + z2));
    }
    // TODO: Return them as degrees and not as radians
    return out;
}

function setup()
{
    recalc = false;

    op.toWorkPortsNeedToBeLinkedReset();

    // if (inDraw.get())
    // {
    //     op.toWorkPortsNeedToBeLinked(inGeom);
    // }
    const geom = inGeomSurface.get();
    const num = Math.abs(Math.floor(inNum.get()));
    const m = mat4.create();
    const q = quat.create();
    const vm2 = vec3.create();
    const qMat = mat4.create();
    const norm = vec3.create();

    if (!geom) return;

    Math.randomSeed = seed.get();

    const DISTMODE_VERTEX = 0;
    const DISTMODE_TRIANGLE_CENTER = 1;
    const DISTMODE_TRIANGLE_SIDE = 2;
    const DISTMODE_TRIANGLE_RANDOM = 3;

    let distMode = 0;
    if (inDistribution.get() == "Triangle Center")distMode = DISTMODE_TRIANGLE_CENTER;
    else if (inDistribution.get() == "Triangle Side")distMode = DISTMODE_TRIANGLE_SIDE;
    else if (inDistribution.get() == "Random Triangle Point")distMode = DISTMODE_TRIANGLE_RANDOM;

    if (matrixArray.length != num * 16) matrixArray = new Float32Array(num * 16);

    let faces = geom.verticesIndices;
    if (!geom.isIndexed())
    {
        faces = [];
        for (let i = 0; i < geom.vertices.length / 3; i++) faces[i] = i;
    }

    const indices = uniqueIndices(faces.length / 3, num, inVariety.get() == "Random");

    arrScale.length = arrPositions.length = num * 3;
    arrRotations.length = num * 4;

    for (let i = 0; i < num; i++)
    {
        const index = indices[i];
        const index3 = index * 3;

        let px = 0;
        let py = 0;
        let pz = 0;

        mat4.identity(m);

        let nx = geom.vertexNormals[faces[index3] * 3 + 0];
        let ny = geom.vertexNormals[faces[index3] * 3 + 1];
        let nz = geom.vertexNormals[faces[index3] * 3 + 2];

        if (distMode == DISTMODE_VERTEX)
        {
            px = geom.vertices[faces[index3] * 3 + 0];
            py = geom.vertices[faces[index3] * 3 + 1];
            pz = geom.vertices[faces[index3] * 3 + 2];
        }
        else if (distMode == DISTMODE_TRIANGLE_CENTER)
        {
            px = (geom.vertices[faces[index3] * 3 + 0] + geom.vertices[faces[index3 + 1] * 3 + 0] + geom.vertices[faces[index3 + 2] * 3 + 0]) / 3;
            py = (geom.vertices[faces[index3] * 3 + 1] + geom.vertices[faces[index3 + 1] * 3 + 1] + geom.vertices[faces[index3 + 2] * 3 + 1]) / 3;
            pz = (geom.vertices[faces[index3] * 3 + 2] + geom.vertices[faces[index3 + 1] * 3 + 2] + geom.vertices[faces[index3 + 2] * 3 + 2]) / 3;

            nx = (geom.vertexNormals[faces[index3] * 3 + 0] + geom.vertexNormals[faces[index3 + 1] * 3 + 0] + geom.vertexNormals[faces[index3 + 2] * 3 + 0]) / 3;
            ny = (geom.vertexNormals[faces[index3] * 3 + 1] + geom.vertexNormals[faces[index3 + 1] * 3 + 1] + geom.vertexNormals[faces[index3 + 2] * 3 + 1]) / 3;
            nz = (geom.vertexNormals[faces[index3] * 3 + 2] + geom.vertexNormals[faces[index3 + 1] * 3 + 2] + geom.vertexNormals[faces[index3 + 2] * 3 + 2]) / 3;
        }
        else if (distMode == DISTMODE_TRIANGLE_SIDE)
        {
            const which = Math.round(Math.seededRandom() * 3.0);
            const whichA = which;
            let whichB = which + 1;
            if (whichB > 2)whichB = 0;

            px = (geom.vertices[faces[index3 + whichA] * 3 + 0] + geom.vertices[faces[index3 + whichB] * 3 + 0]) / 2;
            py = (geom.vertices[faces[index3 + whichA] * 3 + 1] + geom.vertices[faces[index3 + whichB] * 3 + 1]) / 2;
            pz = (geom.vertices[faces[index3 + whichA] * 3 + 2] + geom.vertices[faces[index3 + whichB] * 3 + 2]) / 2;
        }
        else if (distMode == DISTMODE_TRIANGLE_RANDOM)
        {
            let r = Math.seededRandom();
            const p1x = CABLES.map(r, 0, 1, geom.vertices[(faces[index3 + 0]) * 3 + 0], geom.vertices[(faces[index3 + 1]) * 3 + 0]);
            const p1y = CABLES.map(r, 0, 1, geom.vertices[(faces[index3 + 0]) * 3 + 1], geom.vertices[(faces[index3 + 1]) * 3 + 1]);
            const p1z = CABLES.map(r, 0, 1, geom.vertices[(faces[index3 + 0]) * 3 + 2], geom.vertices[(faces[index3 + 1]) * 3 + 2]);

            const n1x = CABLES.map(r, 0, 1, geom.vertexNormals[(faces[index3 + 0]) * 3 + 0], geom.vertexNormals[(faces[index3 + 1]) * 3 + 0]);
            const n1y = CABLES.map(r, 0, 1, geom.vertexNormals[(faces[index3 + 0]) * 3 + 1], geom.vertexNormals[(faces[index3 + 1]) * 3 + 1]);
            const n1z = CABLES.map(r, 0, 1, geom.vertexNormals[(faces[index3 + 0]) * 3 + 2], geom.vertexNormals[(faces[index3 + 1]) * 3 + 2]);

            r = Math.seededRandom();
            const p2x = CABLES.map(r, 0, 1, geom.vertices[(faces[index3 + 1]) * 3 + 0], geom.vertices[(faces[index3 + 2]) * 3 + 0]);
            const p2y = CABLES.map(r, 0, 1, geom.vertices[(faces[index3 + 1]) * 3 + 1], geom.vertices[(faces[index3 + 2]) * 3 + 1]);
            const p2z = CABLES.map(r, 0, 1, geom.vertices[(faces[index3 + 1]) * 3 + 2], geom.vertices[(faces[index3 + 2]) * 3 + 2]);

            const n2x = CABLES.map(r, 0, 1, geom.vertexNormals[(faces[index3 + 1]) * 3 + 0], geom.vertexNormals[(faces[index3 + 2]) * 3 + 0]);
            const n2y = CABLES.map(r, 0, 1, geom.vertexNormals[(faces[index3 + 1]) * 3 + 1], geom.vertexNormals[(faces[index3 + 2]) * 3 + 1]);
            const n2z = CABLES.map(r, 0, 1, geom.vertexNormals[(faces[index3 + 1]) * 3 + 2], geom.vertexNormals[(faces[index3 + 2]) * 3 + 2]);

            r = Math.seededRandom();
            const p3x = CABLES.map(r, 0, 1, geom.vertices[(faces[index3 + 2]) * 3 + 0], geom.vertices[(faces[index3 + 0]) * 3 + 0]);
            const p3y = CABLES.map(r, 0, 1, geom.vertices[(faces[index3 + 2]) * 3 + 1], geom.vertices[(faces[index3 + 0]) * 3 + 1]);
            const p3z = CABLES.map(r, 0, 1, geom.vertices[(faces[index3 + 2]) * 3 + 2], geom.vertices[(faces[index3 + 0]) * 3 + 2]);

            const n3x = CABLES.map(r, 0, 1, geom.vertexNormals[(faces[index3 + 2]) * 3 + 0], geom.vertexNormals[(faces[index3 + 0]) * 3 + 0]);
            const n3y = CABLES.map(r, 0, 1, geom.vertexNormals[(faces[index3 + 2]) * 3 + 1], geom.vertexNormals[(faces[index3 + 0]) * 3 + 1]);
            const n3z = CABLES.map(r, 0, 1, geom.vertexNormals[(faces[index3 + 2]) * 3 + 2], geom.vertexNormals[(faces[index3 + 0]) * 3 + 2]);

            px = (p1x + p2x + p3x) / 3;
            py = (p1y + p2y + p3y) / 3;
            pz = (p1z + p2z + p3z) / 3;

            nx = (n1x + n2x + n3x) / 3;
            ny = (n1y + n2y + n3y) / 3;
            nz = (n1z + n2z + n3z) / 3;
        }

        arrPositions[i * 3 + 0] = px;
        arrPositions[i * 3 + 1] = py;
        arrPositions[i * 3 + 2] = pz;
        mat4.translate(m, m, [px, py, pz]);

        // rotate to normal direction
        vec3.set(norm, nx, ny, nz);
        vec3.set(vm2, 1, 0, 0);
        quat.rotationTo(q, vm2, norm);

        // mat4.fromQuat(qMat, q);
        // mat4.mul(m,m,qMat);

        // random rotate around up axis
        if (inRotateRandom.get())
        {
            const mr = mat4.create();
            // let qbase=quat.create();
            quat.rotateX(q, q, Math.seededRandom() * 360 * CGL.DEG2RAD);
            // mat4.fromQuat(mr,qbase);
            // mat4.mul(m,m,mr);
        }

        // rotate -90 degree
        const mr2 = mat4.create();
        // let qbase2=quat.create();
        quat.rotateZ(q, q, -90 * CGL.DEG2RAD);
        mat4.fromQuat(mr2, q);
        mat4.mul(m, m, mr2);

        // scale
        if (inSizeMin.get() != 1.0 || inSizeMax != 1.0)
        {
            const sc = inSizeMin.get() + (Math.seededRandom() * (inSizeMax.get() - inSizeMin.get()));
            mat4.scale(m, m, [sc, sc, sc]);

            arrScale[i * 3 + 0] =
            arrScale[i * 3 + 1] =
            arrScale[i * 3 + 2] = sc;
        }

        // //quaternion to euler, KINDA works, but not really :/
        // let finalq=q;//
        // let finalq=quat.create();
        // mat4.getRotation(finalq,m);

        // function clamp(v)
        // {
        //     return Math.min(1,Math.max(-1,v) ) ;
        // }

        // let yaw = Math.atan2(2.0*(finalq[1]*finalq[2] + finalq[3]*finalq[0]), finalq[3]*finalq[3] - finalq[0]*finalq[0] - finalq[1]*finalq[1] + finalq[2]*finalq[2]);
        // let pitch = Math.asin( clamp( -2.0*(finalq[0]*finalq[2] - finalq[3]*finalq[1])));
        // let roll = Math.atan2(2.0*(finalq[0]*finalq[1] + finalq[3]*finalq[2]), finalq[3]*finalq[3] + finalq[0]*finalq[0] - finalq[1]*finalq[1] - finalq[2]*finalq[2]);

        // arrRotations[i*3+0]=360-(pitch*CGL.RAD2DEG);
        // arrRotations[i*3+1]=360-(yaw*CGL.RAD2DEG);
        // arrRotations[i*3+2]=(roll*CGL.RAD2DEG);

        const rotDeg = vec3.create();
        // quat.getAxisAngle(rotDeg,finalq);
        getEuler(rotDeg, q);

        arrRotations[i * 4 + 0] = q[0];
        arrRotations[i * 4 + 1] = q[1];
        arrRotations[i * 4 + 2] = q[2];
        arrRotations[i * 4 + 3] = q[3];

        // save
        for (let a = 0; a < 16; a++)
        {
            matrixArray[i * 16 + a] = m[a];
        }
    }

    outArrScale.set(null);
    outArrScale.set(arrScale);

    outArrRotations.set(null);
    outArrRotations.set(arrRotations);

    outArrPositions.set(null);
    outArrPositions.set(arrPositions);
}

function reset()
{
    recalc = true;
}

function doRender()
{
    if (recalc)setup();
    recalc = false;

    outNext.trigger();
}


};

Ops.Gl.SurfaceScatter_v2.prototype = new CABLES.Op();
CABLES.OPS["18eb1e62-80fe-41ce-a57b-15653d00925b"]={f:Ops.Gl.SurfaceScatter_v2,objName:"Ops.Gl.SurfaceScatter_v2"};




// **************************************************************
// 
// Ops.Gl.TesselateGeometry
// 
// **************************************************************

Ops.Gl.TesselateGeometry = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inGeom = op.inObject("Geometry");
const inTimes = op.inValueInt("Iterations", 1);
const outGeom = op.outObject("Result");
const outVertices = op.outNumber("Num Vertices");

inGeom.onChange = update;
inTimes.onChange = update;

function tesselateTC(tc, x1, y1, x2, y2, x3, y3)
{
    tc.push(x1);
    tc.push(y1);

    tc.push((x1 + x2) / 2);
    tc.push((y1 + y2) / 2);

    tc.push((x1 + x3) / 2);
    tc.push((y1 + y3) / 2);

    // --

    tc.push((x1 + x2) / 2);
    tc.push((y1 + y2) / 2);

    tc.push(x2);
    tc.push(y2);

    tc.push((x2 + x3) / 2);
    tc.push((y2 + y3) / 2);

    // --

    tc.push((x2 + x3) / 2);
    tc.push((y2 + y3) / 2);

    tc.push(x3);
    tc.push(y3);

    tc.push((x1 + x3) / 2);
    tc.push((y1 + y3) / 2);

    // --

    tc.push((x1 + x2) / 2);
    tc.push((y1 + y2) / 2);

    tc.push((x2 + x3) / 2);
    tc.push((y2 + y3) / 2);

    tc.push((x1 + x3) / 2);
    tc.push((y1 + y3) / 2);
}

function tesselate(vertices, x1, y1, z1, x2, y2, z2, x3, y3, z3)
{
    vertices.push(x1);
    vertices.push(y1);
    vertices.push(z1);

    vertices.push((x1 + x2) / 2);
    vertices.push((y1 + y2) / 2);
    vertices.push((z1 + z2) / 2);

    vertices.push((x1 + x3) / 2);
    vertices.push((y1 + y3) / 2);
    vertices.push((z1 + z3) / 2);

    // --

    vertices.push((x1 + x2) / 2);
    vertices.push((y1 + y2) / 2);
    vertices.push((z1 + z2) / 2);

    vertices.push(x2);
    vertices.push(y2);
    vertices.push(z2);

    vertices.push((x2 + x3) / 2);
    vertices.push((y2 + y3) / 2);
    vertices.push((z2 + z3) / 2);

    // --

    vertices.push((x2 + x3) / 2);
    vertices.push((y2 + y3) / 2);
    vertices.push((z2 + z3) / 2);

    vertices.push(x3);
    vertices.push(y3);
    vertices.push(z3);

    vertices.push((x1 + x3) / 2);
    vertices.push((y1 + y3) / 2);
    vertices.push((z1 + z3) / 2);

    // --

    vertices.push((x1 + x2) / 2);
    vertices.push((y1 + y2) / 2);
    vertices.push((z1 + z2) / 2);

    vertices.push((x2 + x3) / 2);
    vertices.push((y2 + y3) / 2);
    vertices.push((z2 + z3) / 2);

    vertices.push((x1 + x3) / 2);
    vertices.push((y1 + y3) / 2);
    vertices.push((z1 + z3) / 2);
}

function tesselateGeom(oldGeom)
{
    const geom = new CGL.Geometry(op.name);
    const vertices = [];
    const norms = [];
    const biTangents = [];
    const tangents = [];
    const tc = [];

    let i, j, k;

    if (oldGeom.verticesIndices.length > 0)
    {
        for (i = 0; i < oldGeom.verticesIndices.length; i += 3)
        {
            for (j = 0; j < 4; j++)
                for (k = 0; k < 3; k++)
                {
                    norms.push(
                        oldGeom.vertexNormals[oldGeom.verticesIndices[i + k] * 3 + 0],
                        oldGeom.vertexNormals[oldGeom.verticesIndices[i + k] * 3 + 1],
                        oldGeom.vertexNormals[oldGeom.verticesIndices[i + k] * 3 + 2]
                    );

                    if (oldGeom.tangents)
                        tangents.push(
                            oldGeom.tangents[oldGeom.verticesIndices[i + k] * 3 + 0],
                            oldGeom.tangents[oldGeom.verticesIndices[i + k] * 3 + 1],
                            oldGeom.tangents[oldGeom.verticesIndices[i + k] * 3 + 2]
                        );

                    if (oldGeom.biTangents)
                        biTangents.push(
                            oldGeom.biTangents[oldGeom.verticesIndices[i + k] * 3 + 0],
                            oldGeom.biTangents[oldGeom.verticesIndices[i + k] * 3 + 1],
                            oldGeom.biTangents[oldGeom.verticesIndices[i + k] * 3 + 2]
                        );
                }

            tesselate(vertices,
                oldGeom.vertices[oldGeom.verticesIndices[i + 0] * 3 + 0],
                oldGeom.vertices[oldGeom.verticesIndices[i + 0] * 3 + 1],
                oldGeom.vertices[oldGeom.verticesIndices[i + 0] * 3 + 2],

                oldGeom.vertices[oldGeom.verticesIndices[i + 1] * 3 + 0],
                oldGeom.vertices[oldGeom.verticesIndices[i + 1] * 3 + 1],
                oldGeom.vertices[oldGeom.verticesIndices[i + 1] * 3 + 2],

                oldGeom.vertices[oldGeom.verticesIndices[i + 2] * 3 + 0],
                oldGeom.vertices[oldGeom.verticesIndices[i + 2] * 3 + 1],
                oldGeom.vertices[oldGeom.verticesIndices[i + 2] * 3 + 2]
            );

            tesselateTC(tc,
                oldGeom.texCoords[oldGeom.verticesIndices[i + 0] * 2 + 0],
                oldGeom.texCoords[oldGeom.verticesIndices[i + 0] * 2 + 1],

                oldGeom.texCoords[oldGeom.verticesIndices[i + 1] * 2 + 0],
                oldGeom.texCoords[oldGeom.verticesIndices[i + 1] * 2 + 1],

                oldGeom.texCoords[oldGeom.verticesIndices[i + 2] * 2 + 0],
                oldGeom.texCoords[oldGeom.verticesIndices[i + 2] * 2 + 1]
            );
        }
    }
    else
    {
        if (oldGeom.vertices.length > 0)
        {
            for (i = 0; i < oldGeom.vertices.length; i += 9)
            {
                for (j = 0; j < 4; j++)
                {
                    for (k = 0; k < 9; k++)
                        norms.push(oldGeom.vertexNormals[i + k]);

                    if (oldGeom.tangents)
                        for (k = 0; k < 9; k++)
                            tangents.push(oldGeom.tangents[i + k]);

                    if (oldGeom.biTangents)
                        for (k = 0; k < 9; k++)
                            biTangents.push(oldGeom.biTangents[i + k]);
                }

                tesselate(vertices,
                    oldGeom.vertices[i + 0],
                    oldGeom.vertices[i + 1],
                    oldGeom.vertices[i + 2],

                    oldGeom.vertices[i + 3],
                    oldGeom.vertices[i + 4],
                    oldGeom.vertices[i + 5],

                    oldGeom.vertices[i + 6],
                    oldGeom.vertices[i + 7],
                    oldGeom.vertices[i + 8]
                );

                tesselateTC(tc,
                    oldGeom.texCoords[i / 9 * 6 + 0],
                    oldGeom.texCoords[i / 9 * 6 + 1],

                    oldGeom.texCoords[i / 9 * 6 + 2],
                    oldGeom.texCoords[i / 9 * 6 + 3],

                    oldGeom.texCoords[i / 9 * 6 + 4],
                    oldGeom.texCoords[i / 9 * 6 + 5]

                );
            }
        }
    }

    geom.vertexNormals = norms;
    geom.setVertices(vertices);
    geom.setTexCoords(tc);
    geom.tangents = tangents;
    geom.biTangents = biTangents;
    return geom;
}

function update()
{
    let geom = inGeom.get();
    if (!geom) return;
    const startTime = CABLES.now();

    for (let i = 0; i < inTimes.get(); i++)
    {
        geom = tesselateGeom(geom);
    }

    outVertices.set(geom.vertices.length / 3);

    outGeom.set(null);
    outGeom.set(geom);
}


};

Ops.Gl.TesselateGeometry.prototype = new CABLES.Op();
CABLES.OPS["eb3f0bd8-211c-4336-a3ad-fa31c50d705d"]={f:Ops.Gl.TesselateGeometry,objName:"Ops.Gl.TesselateGeometry"};




// **************************************************************
// 
// Ops.Gl.TextMeshMSDF_v2
// 
// **************************************************************

Ops.Gl.TextMeshMSDF_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"textmeshsdf_frag":"\nUNI sampler2D tex0;\nUNI sampler2D tex1;\nUNI sampler2D tex2;\nUNI sampler2D tex3;\nIN vec2 texCoord;\nUNI vec4 color;\nUNI vec2 texSize;\n\n#ifdef BORDER\n    UNI float borderWidth;\n    UNI float borderSmooth;\n    UNI vec3 colorBorder;\n#endif\n\n#ifdef TEXTURE_COLOR\nUNI sampler2D texMulColor;\n#endif\n#ifdef TEXTURE_MASK\nUNI sampler2D texMulMask;\n#endif\n\nIN float texIndex;\n\n#ifdef SHADOW\n    UNI float shadowWidth;\n#endif\n\n\nfloat median(float r, float g, float b)\n{\n    return max(min(r, g), min(max(r, g), b));\n}\n\nvoid main()\n{\n    vec4 bgColor=vec4(0.0,0.0,0.0,0.0);\n    vec4 fgColor=color;\n    float opacity=1.0;\n\n    #ifndef SDF\n        if(int(texIndex)==0) outColor = texture(tex0, texCoord);\n        if(int(texIndex)==1) outColor = texture(tex1, texCoord);\n        if(int(texIndex)==2) outColor = texture(tex2, texCoord);\n        if(int(texIndex)==3) outColor = texture(tex3, texCoord);\n\n        return;\n    #endif\n\n\n    #ifdef TEXTURE_COLOR\n        fgColor.rgb *= texture(texMulColor, vec2(0.0,0.0)).rgb; //todo texcoords from char positioning\n    #endif\n    #ifdef TEXTURE_MASK\n        opacity *= texture(texMulMask, vec2(0.0,0.0)).r; //todo texcoords from char positioning\n    #endif\n\n\n    #ifdef SHADOW\n        vec2 msdfUnit1 = texSize;\n        vec2 tcv=vec2(texCoord.x-0.002,texCoord.y-0.002);\n        vec3 smpl1;\n        if(int(texIndex)==0) smpl1 = texture(tex0, tcv).rgb;\n        if(int(texIndex)==1) smpl1 = texture(tex1, tcv).rgb;\n        if(int(texIndex)==2) smpl1 = texture(tex2, tcv).rgb;\n        if(int(texIndex)==3) smpl1 = texture(tex3, tcv).rgb;\n\n        float sigDist1 = median(smpl1.r, smpl1.g, smpl1.b) - 0.001;\n        float opacity1 = smoothstep(0.0,0.9,sigDist1*sigDist1);\n        outColor = mix(bgColor, vec4(0.0,0.0,0.0,1.0), opacity1);\n    #endif\n\n    vec2 msdfUnit = 8.0/texSize;\n    vec3 smpl;\n\n    if(int(texIndex)==0) smpl = texture(tex0, texCoord).rgb;\n    if(int(texIndex)==1) smpl = texture(tex1, texCoord).rgb;\n    if(int(texIndex)==2) smpl = texture(tex2, texCoord).rgb;\n    if(int(texIndex)==3) smpl = texture(tex3, texCoord).rgb;\n\n\n    float sigDist = median(smpl.r, smpl.g, smpl.b) - 0.5;\n    sigDist *= dot(msdfUnit, 0.5/fwidth(texCoord));\n    opacity *= clamp(sigDist + 0.5, 0.0, 1.0);\n\n    #ifdef BORDER\n        float sigDist2 = median(smpl.r, smpl.g, smpl.b) - 0.01;\n        float bw=borderWidth*0.6+0.24;\n        float opacity2 = smoothstep(bw-borderSmooth,bw+borderSmooth,sigDist2*sigDist2);\n        fgColor=mix(fgColor,vec4(colorBorder,1.0),1.0-opacity2);\n    #endif\n\n    if(color.a==0.0)discard;\n    outColor = mix(outColor, fgColor, opacity*color.a);\n\n}\n\n","textmeshsdf_vert":"UNI sampler2D tex1;\nUNI sampler2D tex2;\nUNI sampler2D tex3;\nUNI sampler2D tex4;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN mat4 instMat;\nIN vec2 attrTexOffsets;\nIN vec2 attrSize;\nIN vec2 attrTcSize;\nIN float attrPage;\n\nOUT vec2 texCoord;\nOUT float texIndex;\n\nconst float mulSize=0.01;\n\nvoid main()\n{\n   texCoord=(attrTexOffsets+attrTexCoord*attrTcSize);\n   texCoord.y=1.0-texCoord.y;\n\n   mat4 instMVMat=instMat;\n   vec4 vert=vec4( vPosition, 1. );\n   vert.x*=attrSize.x*mulSize;\n   vert.y*=attrSize.y*mulSize;\n\n   texIndex=attrPage+0.4; // strange ios rounding errors?!\n\n   mat4 mvMatrix=viewMatrix * modelMatrix * instMVMat;\n\n   gl_Position = projMatrix * mvMatrix * vert;\n}\n",};
// https://soimy.github.io/msdf-bmfont-xml/

// antialiasing:
// https://github.com/Chlumsky/msdfgen/issues/22

const
    render = op.inTrigger("Render"),
    str = op.inString("Text", "cables"),
    inFont = op.inDropDown("Font", [], "", true),
    scale = op.inFloat("Scale", 0.25),

    letterSpace = op.inFloat("Letter Spacing", 0),
    lineHeight = op.inFloat("Line Height", 1),

    align = op.inSwitch("Align", ["Left", "Center", "Right"], "Center"),
    valign = op.inSwitch("Vertical Align", ["Zero", "Top", "Middle", "Bottom"], "Middle"),

    r = op.inValueSlider("r", 1),
    g = op.inValueSlider("g", 1),
    b = op.inValueSlider("b", 1),
    a = op.inValueSlider("a", 1),
    doSDF = op.inBool("SDF", true),

    inBorder = op.inBool("Border", false),
    inBorderWidth = op.inFloatSlider("Border Width", 0.5),
    inBorderSmooth = op.inFloatSlider("Smoothness", 0.25),
    br = op.inValueSlider("Border r", 1),
    bg = op.inValueSlider("Border g", 1),
    bb = op.inValueSlider("Border b", 1),

    inShadow = op.inBool("Shadow", false),

    inTexColor = op.inTexture("Texture Color"),
    inTexMask = op.inTexture("Texture Mask"),

    inPosArr = op.inArray("Positions"),
    inScaleArr = op.inArray("Scalings"),
    inRotArr = op.inArray("Rotations"),

    next = op.outTrigger("Next"),
    outArr = op.outArray("Positions Original", null, 3),
    outLines = op.outNumber("Num Lines"),

    outWidth = op.outNumber("Width"),
    outHeight = op.outNumber("Height"),
    outStartY = op.outNumber("Start Y"),
    outNumChars = op.outNumber("Num Chars");

op.setPortGroup("Size", [letterSpace, lineHeight, scale]);
op.setPortGroup("Character Transformations", [inScaleArr, inRotArr, inPosArr]);
op.setPortGroup("Alignment", [align, valign]);
op.setPortGroup("Color", [r, g, b, a, doSDF]);
op.setPortGroup("Border", [br, bg, bb, inBorderSmooth, inBorderWidth, inBorder]);

r.setUiAttribs({ "colorPick": true });
br.setUiAttribs({ "colorPick": true });

const cgl = op.patch.cgl;
const fontDataVarPrefix = "font_data_";
const substrLength = fontDataVarPrefix.length;
const alignVec = vec3.create();
const vScale = vec3.create();
const shader = new CGL.Shader(cgl, "TextMeshSDF");

let fontTexs = null;
let fontData = null;
let fontChars = null;
let needUpdate = true;
let geom = null;
let mesh = null;
let disabled = false;
let valignMode = 1;
let heightAll = 0, widthAll = 0;
let avgHeight = 0;
let minY, maxY, minX, maxX;
let needsUpdateTransmats = true;
let transMats = null;
let offY = 0;

if (cgl.glVersion == 1)
{
    cgl.gl.getExtension("OES_standard_derivatives");
    shader.enableExtension("GL_OES_standard_derivatives");
}

shader.setSource(attachments.textmeshsdf_vert, attachments.textmeshsdf_frag);

const
    uniTex = new CGL.Uniform(shader, "t", "tex0", 0),
    uniTex1 = new CGL.Uniform(shader, "t", "tex1", 1),
    uniTex2 = new CGL.Uniform(shader, "t", "tex2", 2),
    uniTex3 = new CGL.Uniform(shader, "t", "tex3", 3),
    uniTexMul = new CGL.Uniform(shader, "t", "texMulColor", 4),
    uniTexMulMask = new CGL.Uniform(shader, "t", "texMulMask", 5),
    uniColor = new CGL.Uniform(shader, "4f", "color", r, g, b, a),
    uniColorBorder = new CGL.Uniform(shader, "3f", "colorBorder", br, bg, bb),

    uniTexSize = new CGL.Uniform(shader, "2f", "texSize", 0, 0),
    uniborderSmooth = new CGL.Uniform(shader, "f", "borderSmooth", inBorderSmooth),
    uniborderWidth = new CGL.Uniform(shader, "f", "borderWidth", inBorderWidth);

scale.onChange = updateScale;

inRotArr.onChange =
    inPosArr.onChange =
    inScaleArr.onChange = function () { needsUpdateTransmats = true; };

inTexColor.onChange =
inTexMask.onChange =
inShadow.onChange =
inBorder.onChange =
doSDF.onChange =
    updateDefines;

updateDefines();
updateScale();

align.onChange =
    str.onChange =
    letterSpace.onChange =
    lineHeight.onChange =
    function ()
    {
        needUpdate = true;
    };

valign.onChange = updateAlign;

op.patch.addEventListener("variablesChanged", updateFontList);
op.patch.addEventListener("FontLoadedMSDF", updateFontList);

inFont.onChange = updateFontData;

updateFontList();

function updateDefines()
{
    shader.toggleDefine("SDF", doSDF.get());
    shader.toggleDefine("SHADOW", inShadow.get());
    shader.toggleDefine("BORDER", inBorder.get());
    shader.toggleDefine("TEXTURE_COLOR", inTexColor.isLinked());
    shader.toggleDefine("TEXTURE_MASK", inTexMask.isLinked());

    br.setUiAttribs({ "greyout": !inBorder.get() });
    bg.setUiAttribs({ "greyout": !inBorder.get() });
    bb.setUiAttribs({ "greyout": !inBorder.get() });
    inBorderSmooth.setUiAttribs({ "greyout": !inBorder.get() });
    inBorderWidth.setUiAttribs({ "greyout": !inBorder.get() });
}

function updateFontData()
{
    updateFontList();
    const varname = fontDataVarPrefix + inFont.get();

    fontData = null;
    fontTexs = null;
    fontChars = {};

    const dataVar = op.patch.getVar(varname);

    if (!dataVar || !dataVar.getValue())
    {
        fontData = null;

        op.warn("no varname", varname);
        return;
    }

    fontData = dataVar.getValue().data;

    if (!fontData)
    {
        return;
    }

    const basename = dataVar.getValue().basename;

    const textVar = op.patch.getVar("font_tex_" + basename);
    if (!textVar)
    {
        fontTexs = null;
        fontData = null;
        return;
    }

    fontTexs = textVar.getValue();

    for (let i = 0; i < fontData.chars.length; i++) fontChars[fontData.chars[i].char] = fontData.chars[i];
    needUpdate = true;
}

function updateFontList()
{
    const vars = op.patch.getVars();
    const names = ["..."];

    for (const i in vars)
        if (vars[i].type == "fontData")
            names.push(i.substr(substrLength));

    inFont.uiAttribs.values = names;
}

function updateScale()
{
    const s = scale.get();
    vec3.set(vScale, s, s, s);

    vec3.set(alignVec, 0, offY * s, 0);

    outWidth.set(widthAll * s);
    outHeight.set(heightAll * s);

    outStartY.set((maxY + offY) * s);
}

function updateAlign()
{
    if (minX == undefined) return;
    if (valign.get() == "Top") valignMode = 0;
    else if (valign.get() == "Middle") valignMode = 1;
    else if (valign.get() == "Bottom") valignMode = 2;
    else if (valign.get() == "Zero") valignMode = 3;

    offY = 0;
    widthAll = (Math.abs(minX - maxX));
    heightAll = (Math.abs(minY - maxY));

    if (valignMode === 1) offY = heightAll / 2;
    else if (valignMode === 2) offY = heightAll;

    if (valignMode != 0)offY -= avgHeight;

    updateScale();
}

function buildTransMats()
{
    needsUpdateTransmats = false;

    // if(!( inPosArr.get() || inScaleArr.get() || inRotArr.get()))
    // {
    //     transMats=null;
    //     return;
    // }

    const transformations = [];
    const translates = inPosArr.get() || outArr.get();
    const scales = inScaleArr.get();
    const rots = inRotArr.get();

    for (let i = 0; i < mesh.numInstances; i++)
    {
        const m = mat4.create();
        mat4.translate(m, m, [translates[i * 3 + 0], translates[i * 3 + 1], translates[i * 3 + 2]]);

        if (scales) mat4.scale(m, m, [scales[i * 3 + 0], scales[i * 3 + 1], scales[i * 3 + 2]]);

        if (rots)
        {
            mat4.rotateX(m, m, rots[i * 3 + 0] * CGL.DEG2RAD);
            mat4.rotateY(m, m, rots[i * 3 + 1] * CGL.DEG2RAD);
            mat4.rotateZ(m, m, rots[i * 3 + 2] * CGL.DEG2RAD);
        }

        transformations.push(Array.prototype.slice.call(m));
    }

    transMats = [].concat.apply([], transformations);
}

render.onTriggered = function ()
{
    if (!fontData)
    {
        op.setUiError("nodata", "No font data!");
        op.setUiError("msdfhint", "Use the FontMSDF op to create font and texture.", 0);
        updateFontData();
        next.trigger();
        return;
    }
    if (!fontTexs)
    {
        op.setUiError("nodata", "No font texture");
        op.setUiError("msdfhint", "Use the FontMSDF op to create font and texture.", 0);
        updateFontData();
        next.trigger();
        return;
    }

    op.setUiError("nodata", null);
    op.setUiError("msdfhint", null);

    if (needUpdate)
    {
        generateMesh();
        needUpdate = false;
    }

    if (mesh && mesh.numInstances > 0)
    {
        // cgl.pushBlendMode(CGL.BLEND_NORMAL, true);
        cgl.pushShader(shader);

        if (fontTexs[0]) uniTexSize.setValue([fontTexs[0].width, fontTexs[0].height]);

        if (fontTexs[0]) cgl.setTexture(0, fontTexs[0].tex);
        else cgl.setTexture(0, CGL.Texture.getEmptyTexture(cgl).tex);

        if (fontTexs[1])cgl.setTexture(1, fontTexs[1].tex);
        else cgl.setTexture(1, CGL.Texture.getEmptyTexture(cgl).tex);

        if (fontTexs[2])cgl.setTexture(2, fontTexs[2].tex);
        else cgl.setTexture(2, CGL.Texture.getEmptyTexture(cgl).tex);

        if (fontTexs[3])cgl.setTexture(3, fontTexs[3].tex);
        else cgl.setTexture(3, CGL.Texture.getEmptyTexture(cgl).tex);

        if (inTexColor.get()) cgl.setTexture(4, inTexColor.get().tex);
        if (inTexMask.get()) cgl.setTexture(5, inTexMask.get().tex);

        cgl.pushModelMatrix();
        mat4.translate(cgl.mMatrix, cgl.mMatrix, alignVec);

        if (needsUpdateTransmats) buildTransMats();
        if (transMats) mesh.setAttribute("instMat", new Float32Array(transMats), 16, { "instanced": true });
        if (cgl.getShader())cgl.getShader().define("INSTANCING");

        if (!disabled)
        {
            mat4.scale(cgl.mMatrix, cgl.mMatrix, vScale);

            mesh.render(cgl.getShader());
        }

        cgl.popModelMatrix();

        cgl.setTexture(0, null);
        cgl.popShader();
        // cgl.popBlendMode();
    }

    next.trigger();
};

function getChar(chStr)
{
    return fontChars[String(chStr)] || fontChars["?"] || fontChars._ || fontChars.X;
}

function generateMesh()
{
    outArr.set(null);

    if (!fontData || !fontChars)
    {
        outNumChars.set(0);
        return;
    }

    const theString = String(str.get() + "");

    if (!geom)
    {
        geom = new CGL.Geometry("textmesh");

        geom.vertices = [
            0.5, 0.5, 0.0,
            -0.5, 0.5, 0.0,
            0.5, -0.5, 0.0,
            -0.5, -0.5, 0.0
        ];

        geom.normals = [
            0.0, 0.0, 0.0,
            0.0, 0.0, 0.0,
            0.0, 0.0, 0.0,
            0.0, 0.0, 0.0
        ];

        geom.texCoords = new Float32Array([
            1.0, 0.0,
            0.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
        ]);

        geom.verticesIndices = [
            0, 1, 2,
            3, 1, 2
        ];
    }

    if (mesh)mesh.dispose();
    mesh = new CGL.Mesh(cgl, geom);

    const strings = (theString).split("\n");
    const transformations = [];
    const tcOffsets = [];
    const sizes = [];
    const texPos = [];
    const tcSizes = [];
    const pages = [];
    let charCounter = 0;
    const arrPositions = [];

    const mulSize = 0.01;

    outLines.set(strings.length);
    minY = 99999;
    maxY = -99999;
    minX = 99999;
    maxX = -99999;

    avgHeight = 0;

    for (let i = 0; i < fontData.chars.length; i++)
    {
        if (fontData.chars[i].height) avgHeight += fontData.chars[i].height;
    }
    avgHeight /= fontData.chars.length;
    avgHeight *= mulSize;

    for (let s = 0; s < strings.length; s++)
    {
        const txt = strings[s];
        const numChars = txt.length;
        let lineWidth = 0;

        for (let i = 0; i < numChars; i++)
        {
            const chStr = txt.substring(i, i + 1);
            const char = getChar(chStr);
            if (char) lineWidth += char.xadvance * mulSize + letterSpace.get();
        }

        let pos = 0;
        if (align.get() == "Right") pos -= lineWidth;
        else if (align.get() == "Center") pos -= lineWidth / 2;

        for (let i = 0; i < numChars; i++)
        {
            const m = mat4.create();

            const chStr = txt.substring(i, i + 1);
            const char = getChar(chStr);

            if (!char) continue;

            pages.push(char.page || 0);
            sizes.push(char.width, char.height);

            tcOffsets.push(char.x / fontData.common.scaleW, (char.y / fontData.common.scaleH));

            const charWidth = char.width / fontData.common.scaleW;
            const charHeight = char.height / fontData.common.scaleH;
            const charOffsetY = (char.yoffset / fontData.common.scaleH);
            const charOffsetX = char.xoffset / fontData.common.scaleW;

            if (chStr == " ") tcSizes.push(0, 0);
            else tcSizes.push(charWidth, charHeight);

            mat4.identity(m);

            let adv = (char.xadvance / 2) * mulSize;
            pos += adv;

            const x = pos + (char.xoffset / 2) * mulSize;
            const y = (s * -lineHeight.get()) + (avgHeight) - (mulSize * (char.yoffset + char.height / 2));

            minX = Math.min(x - charWidth, minX);
            maxX = Math.max(x + charWidth, maxX);
            minY = Math.min(y - charHeight - avgHeight / 2, minY);
            maxY = Math.max(y + charHeight + avgHeight / 2, maxY);

            mat4.translate(m, m, [x, y, 0]);
            arrPositions.push(x, y, 0);

            adv = (char.xadvance / 2) * mulSize + letterSpace.get();

            pos += adv;

            minX = Math.min(pos - charWidth, minX);
            maxX = Math.max(pos + charWidth, maxX);

            transformations.push(Array.prototype.slice.call(m));

            charCounter++;
        }
    }

    transMats = [].concat.apply([], transformations);

    disabled = false;
    if (transMats.length == 0) disabled = true;

    mesh.numInstances = transMats.length / 16;
    outNumChars.set(mesh.numInstances);

    if (mesh.numInstances == 0)
    {
        disabled = true;
        return;
    }

    mesh.setAttribute("instMat", new Float32Array(transMats), 16, { "instanced": true });
    mesh.setAttribute("attrTexOffsets", new Float32Array(tcOffsets), 2, { "instanced": true });
    mesh.setAttribute("attrTcSize", new Float32Array(tcSizes), 2, { "instanced": true });
    mesh.setAttribute("attrSize", new Float32Array(sizes), 2, { "instanced": true });
    mesh.setAttribute("attrPage", new Float32Array(pages), 1, { "instanced": true });

    // updateAlign();
    updateAlign();
    needsUpdateTransmats = true;
    outArr.set(arrPositions);
}


};

Ops.Gl.TextMeshMSDF_v2.prototype = new CABLES.Op();
CABLES.OPS["b5c99363-a749-4040-884b-66f91294bcad"]={f:Ops.Gl.TextMeshMSDF_v2,objName:"Ops.Gl.TextMeshMSDF_v2"};




// **************************************************************
// 
// Ops.Gl.Texture2ColorArray
// 
// **************************************************************

Ops.Gl.Texture2ColorArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    cgl = op.patch.cgl,
    pUpdate = op.inTrigger("update"),
    tex = op.inObject("texture"),
    inNormalize = op.inSwitch("Normalize", ["0-255", "0-1", "-1-1"], "0-255"),
    outTrigger = op.outTrigger("trigger"),
    outColors = op.outArray("Colors"),
    outIsFloatingPoint = op.outBoolNum("Floating Point");

let
    fb = null,
    pixelData = null,
    texChanged = false;
tex.onChange = function () { texChanged = true; };

op.toWorkPortsNeedToBeLinked(tex, outColors);

let isFloatingPoint = false;
let channelType = op.patch.cgl.gl.UNSIGNED_BYTE;

let convertedPixelData = null;

let lastFloatingPoint = false;
let lastWidth = 0;
let lastHeight = 0;

pUpdate.onTriggered = function ()
{
    const realTexture = tex.get(), gl = cgl.gl;

    if (!realTexture) return;
    if (!fb) fb = gl.createFramebuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

    let channels = gl.RGBA;
    // channels = gl.R;

    let numChannels = 4;
    // numChannels = 1;

    if (texChanged)
    {
        gl.framebufferTexture2D(
            gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D, realTexture.tex, 0
        );

        isFloatingPoint = realTexture.textureType == CGL.Texture.TYPE_FLOAT;

        if (isFloatingPoint) channelType = gl.FLOAT;
        else channelType = gl.UNSIGNED_BYTE;

        outIsFloatingPoint.set(isFloatingPoint);

        if (
            lastFloatingPoint != isFloatingPoint ||
            lastWidth != realTexture.width ||
            lastHeight != realTexture.height)
        {
            const size = realTexture.width * realTexture.height * numChannels;
            if (isFloatingPoint) pixelData = new Float32Array(size);
            else pixelData = new Uint8Array(size);

            lastFloatingPoint = isFloatingPoint;
            lastWidth = realTexture.width;
            lastHeight = realTexture.height;
        }

        texChanged = false;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

    gl.readPixels(
        0, 0,
        realTexture.width,
        realTexture.height,
        channels,
        channelType,
        pixelData
    );

    // if (!convertedPixelData || convertedPixelData.length != pixelData.length) convertedPixelData = new Float32Array(pixelData.length);
    // for (let i = 0; i < pixelData.length; i++)
    // {
    //     convertedPixelData[i] = pixelData[i];
    // }
    if (inNormalize.get() == "0-1")
    {
        if (!convertedPixelData || convertedPixelData.length != pixelData.length) convertedPixelData = new Float32Array(pixelData.length);
        for (let i = 0; i < pixelData.length; i++)
        {
            convertedPixelData[i] = pixelData[i] / 255;
        }
    }
    if (inNormalize.get() == "-1-1")
    {
        if (!convertedPixelData || convertedPixelData.length != pixelData.length) convertedPixelData = new Float32Array(pixelData.length);

        for (let i = 0; i < pixelData.length; i++)
        {
            convertedPixelData[i] = ((pixelData[i] - 128) * 2.0) / 255;
        }
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    outColors.set(null);
    outColors.set(convertedPixelData || pixelData);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    outTrigger.trigger();
};


};

Ops.Gl.Texture2ColorArray.prototype = new CABLES.Op();
CABLES.OPS["51dbc04e-f970-44ca-9cb0-39596ac4d212"]={f:Ops.Gl.Texture2ColorArray,objName:"Ops.Gl.Texture2ColorArray"};




// **************************************************************
// 
// Ops.Gl.TextureArray
// 
// **************************************************************

Ops.Gl.TextureArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    outArr = op.outArray("Array"),
    outCount = op.outNumber("Count");

outArr.ignoreValueSerialize = true;

const num = 15;
let texturePorts = [];
let arr = [];

function rebuild()
{
    let i = 0;
    let count = 0;
    for (i = 0; i < texturePorts.length; i++) if (texturePorts[i].isLinked()) count++;

    arr.length = count;

    count = 0;
    for (i = 0; i < texturePorts.length; i++)
    {
        if (texturePorts[i].isLinked())
        {
            arr[count] = texturePorts[i].get();
            count++;
        }
    }

    outArr.set(null);
    outArr.set(arr);
    outCount.set(count);
}

for (let i = 0; i < num; i++)
{
    let p = op.inTexture("Texture " + i);
    p.onLinkChanged = rebuild;
    p.onChange = rebuild;
    texturePorts.push(p);
}


};

Ops.Gl.TextureArray.prototype = new CABLES.Op();
CABLES.OPS["fac012e2-43c8-4e21-85ac-189fe85d5723"]={f:Ops.Gl.TextureArray,objName:"Ops.Gl.TextureArray"};




// **************************************************************
// 
// Ops.Gl.TextureArrayLoaderFromArray
// 
// **************************************************************

Ops.Gl.TextureArrayLoaderFromArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    filenames = op.inArray("urls"),
    tfilter = op.inValueSelect("filter", ["nearest", "linear", "mipmap"]),
    wrap = op.inValueSelect("wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"),
    flip = op.addInPort(new CABLES.Port(op, "flip", CABLES.OP_PORT_TYPE_VALUE, { "display": "bool" })),
    unpackAlpha = op.addInPort(new CABLES.Port(op, "unpackPreMultipliedAlpha", CABLES.OP_PORT_TYPE_VALUE, { "display": "bool" })),
    inCaching = op.inBool("Caching", false),
    inPatchAsset = op.inBool("Asset in patch", false),
    arrOut = op.outArray("TextureArray"),
    width = op.outNumber("width"),
    height = op.outNumber("height"),
    loading = op.outBoolNum("loading"),
    ratio = op.outNumber("Aspect Ratio");

flip.set(false);
unpackAlpha.set(false);

const cgl = op.patch.cgl;
let cgl_filter = 0;
let cgl_wrap = 0;
let loadingId = null;
const arr = [];
arrOut.set(arr);

inPatchAsset.onChange =
flip.onChange = function () { reload(); };
filenames.onChange = reload;

tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;
unpackAlpha.onChange = function () { reload(); };

let timedLoader = 0;

const setTempTexture = function ()
{
    const t = CGL.Texture.getTempTexture(cgl);
    // textureOut.set(t);
};

function reload(nocache)
{
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function ()
    {
        realReload(nocache);
    }, 30);
}

function loadImage(_i, _url, nocache, cb)
{
    let url = _url;
    const i = _i;
    if (!url) return;
    // url=url.replace("XXX",i);

    if (inPatchAsset.get())
    {
        let patchId = null;
        if (op.storage && op.storage.blueprint && op.storage.blueprint.patchId)
        {
            patchId = op.storage.blueprint.patchId;
        }
        url = op.patch.getAssetPath(patchId) + url;
    }

    url = op.patch.getFilePath(url);
    if (!inCaching.get())
        if (nocache)url += "?rnd=" + CABLES.generateUUID();

    // if((filename.get() && filename.get().length>1))
    {
        loading.set(true);

        let tex = CGL.Texture.load(cgl, url,
            function (err)
            {
                if (err)
                {
                    setTempTexture();
                    const errMsg = "could not load texture \"" + url + "\"";
                    op.uiAttr({ "error": errMsg });
                    op.warn("[TextureArrayLoader] " + errMsg);
                    if (cb)cb();
                    return;
                }
                else op.uiAttr({ "error": null });
                // textureOut.set(tex);
                width.set(tex.width);
                height.set(tex.height);
                ratio.set(tex.width / tex.height);

                arr[i] = tex;

                arrOut.set(null);
                arrOut.set(arr);
                if (cb)cb();
            }, {
                "wrap": cgl_wrap,
                "flip": flip.get(),
                "unpackAlpha": unpackAlpha.get(),
                "filter": cgl_filter
            });

        loading.set(false);
    }
}

function realReload(nocache)
{
    const files = filenames.get();

    if (!files || files.length == 0) return;

    if (loadingId)cgl.patch.loading.finished(loadingId);
    loadingId = cgl.patch.loading.start("texturearray", CABLES.uuid());

    for (let i = 0; i < files.length; i++)
    {
        arr[i] = CGL.Texture.getEmptyTexture(cgl);
        let cb = null;
        if (i == files.length - 1)cb = function ()
        {
            cgl.patch.loading.finished(loadingId);
        };

        if (!files[i]) { if (cb) cb(); }
        else loadImage(i, files[i], nocache, cb);
    }
}

function onFilterChange()
{
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;

    reload();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reload();
}

op.onFileChanged = function (fn)
{

};

tfilter.set("linear");
wrap.set("repeat");


};

Ops.Gl.TextureArrayLoaderFromArray.prototype = new CABLES.Op();
CABLES.OPS["febd6cdf-e049-4aed-be34-d7e370b90e03"]={f:Ops.Gl.TextureArrayLoaderFromArray,objName:"Ops.Gl.TextureArrayLoaderFromArray"};




// **************************************************************
// 
// Ops.Gl.TextureArrayLoader_v2
// 
// **************************************************************

Ops.Gl.TextureArrayLoader_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const USE_LEFT_PAD_DEFAULT = false;

const filename = op.inString("Url");
const leftPadFilename = op.inBool("Left Pad", USE_LEFT_PAD_DEFAULT);
const numberLengthPort = op.inInt("Num Digits", 3);
numberLengthPort.setUiAttribs({ "hidePort": !USE_LEFT_PAD_DEFAULT, "greyout": !USE_LEFT_PAD_DEFAULT });

const indexStart = op.inInt("Index Start");
const indexEnd = op.inInt("Index End");

const tfilter = op.inValueSelect("filter", ["nearest", "linear", "mipmap"]);
const wrap = op.inValueSelect("wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge");
const flip = op.inBool("Flip", false);
const unpackAlpha = op.inBool("unpackPreMultipliedAlpha", false);

const arrOut = op.outArray("TextureArray");

const width = op.outNumber("Width");
const height = op.outNumber("Height");
const loading = op.outBool("Loading");
const ratio = op.outNumber("Aspect Ratio");

indexEnd.set(10);
flip.set(false);
unpackAlpha.set(false);

const cgl = op.patch.cgl;
let cgl_filter = 0;
let cgl_wrap = 0;

const arr = [];
arrOut.set(arr);

flip.onChange = function () { reload(); };
filename.onChange = reload;

tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;
unpackAlpha.onChange = function () { reload(); };

leftPadFilename.onChange = setNumberLengthPortVisibility;

let timedLoader = 0;

function setNumberLengthPortVisibility()
{
    const doLeftPad = leftPadFilename.get();
    numberLengthPort.setUiAttribs({ "hidePort": !doLeftPad, "greyout": !doLeftPad });
}

const setTempTexture = function ()
{
    const t = CGL.Texture.getTempTexture(cgl);
    // textureOut.set(t);
};

function reload(nocache)
{
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function ()
    {
        realReload(nocache);
    }, 30);
}

const REPLACE_CHARACTER = "X";

function pad(value, length)
{
    return (value.toString().length < length) ? pad("0" + value, length) : value;
}

function loadImage(i, nocache)
{
    let url = filename.get();
    if (!url) return;
    const firstXIndex = url.indexOf(REPLACE_CHARACTER);
    const lastXIndex = url.lastIndexOf(REPLACE_CHARACTER);
    if (firstXIndex === -1) { return; }
    const replaceString = url.substring(firstXIndex, lastXIndex + 1);
    let numberString = i;
    if (leftPadFilename.get())
    {
        numberString = pad(i, numberLengthPort.get());
    }
    url = url.replace(replaceString, numberString);
    url = op.patch.getFilePath(url);

    if (nocache)url += "?rnd=" + CABLES.generateUUID();

    if ((filename.get() && filename.get().length > 1))
    {
        loading.set(1);

        var tex = CGL.Texture.load(cgl, url,
            function (err)
            {
                if (err)
                {
                    setTempTexture();
                    op.uiAttr({ "error": "could not load texture \"" + filename.get() + "\"" });
                    return;
                }
                else op.uiAttr({ "error": null });
                // textureOut.set(tex);
                width.set(tex.width);
                height.set(tex.height);
                ratio.set(tex.width / tex.height);

                arr[i - parseInt(indexStart.get())] = tex;
                if (!tex.isPowerOfTwo()) op.uiAttr(
                    {
                        "hint": "texture dimensions not power of two! - texture filtering will not work.",
                        "warning": null
                    });
                else op.uiAttr(
                    {
                        "hint": null,
                        "warning": null
                    });

                // textureOut.set(null);
                // textureOut.set(tex);

                // tex.printInfo();
                arrOut.set(null);
                arrOut.set(arr);
            }, {
                "wrap": cgl_wrap,
                "flip": flip.get(),
                "unpackAlpha": unpackAlpha.get(),
                "filter": cgl_filter
            });

        // textureOut.set(null);
        // textureOut.set(tex);

        // if(!textureOut.get() && nocache)
        // {
        // }
        loading.set(0);
    }
    else
    {
        setTempTexture();
    }
}

function realReload(nocache)
{
    for (var i = 0; i < arr.length; i++)
    {
        if (arr[i])
        {
            arr[i].delete();
        }
    }
    arr.length = 0;
    for (var i = Math.floor(indexStart.get()); i <= Math.floor(indexEnd.get()); i++)
    {
        loadImage(i, nocache);
    }
}

function onFilterChange()
{
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;

    reload();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reload();
}

op.onFileChanged = function (fn)
{
    // if(filename.get() && filename.get().indexOf(fn)>-1)
    // {
    //     textureOut.set(null);
    //     textureOut.set(CGL.Texture.getTempTexture(cgl));

    //     realReload(true);
    // }
};

tfilter.set("linear");
wrap.set("repeat");


};

Ops.Gl.TextureArrayLoader_v2.prototype = new CABLES.Op();
CABLES.OPS["4bbb57ce-3c7b-49c1-84fd-2b6a27ff3afa"]={f:Ops.Gl.TextureArrayLoader_v2,objName:"Ops.Gl.TextureArrayLoader_v2"};




// **************************************************************
// 
// Ops.Gl.TextureColorPick
// 
// **************************************************************

Ops.Gl.TextureColorPick = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    cgl = op.patch.cgl,
    pUpdate = op.inTrigger("update"),
    // inNormalize = op.inSwitch("Coordinate", ["Pixel", "Normalized"], "Pixel"),
    inX = op.inInt("X", 0),
    inY = op.inInt("Y", 0),
    tex = op.inObject("texture"),
    outTrigger = op.outTrigger("trigger"),
    outR = op.outNumber("Red"),
    outG = op.outNumber("Green"),
    outB = op.outNumber("Blue"),
    outA = op.outNumber("Alpha");

let
    fb = null,
    pixelData = null,
    texChanged = false;

tex.onChange = function () { texChanged = true; };

let isFloatingPoint = false;
let channelType = op.patch.cgl.gl.UNSIGNED_BYTE;

pUpdate.onTriggered = function ()
{
    const realTexture = tex.get(), gl = cgl.gl;

    if (!realTexture) return;
    if (!fb) fb = gl.createFramebuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

    if (texChanged)
    {
        gl.framebufferTexture2D(
            gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D, realTexture.tex, 0
        );

        isFloatingPoint = realTexture.textureType == CGL.Texture.TYPE_FLOAT;

        if (isFloatingPoint) channelType = gl.FLOAT;
        else channelType = gl.UNSIGNED_BYTE;

        const size = 4 * 4;
        if (isFloatingPoint) pixelData = new Float32Array(size);
        else pixelData = new Uint8Array(size);

        texChanged = false;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

    gl.readPixels(
        inX.get(), inY.get(),
        1, 1,
        gl.RGBA,
        channelType,
        pixelData
    );

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    if (isFloatingPoint)
    {
        outR.set(pixelData[0]);
        outG.set(pixelData[1]);
        outB.set(pixelData[2]);
        outA.set(pixelData[3]);
    }
    else
    {
        outR.set(pixelData[0] / 255);
        outG.set(pixelData[1] / 255);
        outB.set(pixelData[2] / 255);
        outA.set(pixelData[3] / 255);
    }

    outTrigger.trigger();
};


};

Ops.Gl.TextureColorPick.prototype = new CABLES.Op();
CABLES.OPS["060e740a-2432-4685-a081-5df6ab7418e4"]={f:Ops.Gl.TextureColorPick,objName:"Ops.Gl.TextureColorPick"};




// **************************************************************
// 
// Ops.Gl.TextureEffect.RgbeToFloat32Texture
// 
// **************************************************************

Ops.Gl.TextureEffect.RgbeToFloat32Texture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbe2fp_frag":"UNI sampler2D  tex;\nIN vec2 texCoord;\n\n\nvec3 decodeRGBE8(vec4 rgbe)\n{\n    vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0-128.0);\n    return vDecoded;\n}\n\nvoid main()\n{\n    highp vec4 col=vec4(\n        decodeRGBE8(\n            texture(tex,texCoord)\n        ), 1.0);\n\n\n    outColor= col;\n}",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.rgbe2fp_frag);

// const highEdgeUniform = new CGL.Uniform(shader, "f", "highEdge", inHighEdge);

// CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

// const
//     exec = op.inTrigger("Execute"),
//     inTex = op.inTexture("RGBE Texture"),
//     next = op.outTrigger("Next"),
//     outFpTex = op.outTexture("HDR Texture"),
//     tfilter = op.inSwitch("Filter", ["nearest", "linear"], "linear"),
//     twrap = op.inValueSelect("Wrap", ["clamp to edge", "repeat", "mirrored repeat"], "repeat");

// let tc = null;

// twrap.onChange =
//     tfilter.onChange = init;
// init();

// function init()
// {
//     let wrap = CGL.Texture.WRAP_REPEAT;
//     if (twrap.get() == "mirrored repeat") wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
//     if (twrap.get() == "clamp to edge") wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

//     let filter = CGL.Texture.FILTER_NEAREST;
//     if (tfilter.get() == "linear") filter = CGL.Texture.FILTER_LINEAR;

//     if (tc)tc.dispose();
//     tc = new CGL.CopyTexture(op.patch.cgl, "rgbe2hdr",
//         {
//             "shader": attachments.rgbe2fp_frag,
//             "isFloatingPointTexture": true,
//             "filter": filter,
//             "wrap": wrap
//         });
// }

// outFpTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));

// exec.onTriggered = () =>
// {
//     if (!inTex.get()) return;

//     outFpTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
//     outFpTex.set(tc.copy(inTex.get()));

//     next.trigger();
// };


};

Ops.Gl.TextureEffect.RgbeToFloat32Texture.prototype = new CABLES.Op();
CABLES.OPS["35cc1b97-3deb-4cbb-91b5-1658697d4460"]={f:Ops.Gl.TextureEffect.RgbeToFloat32Texture,objName:"Ops.Gl.TextureEffect.RgbeToFloat32Texture"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Alpha
// 
// **************************************************************

Ops.Gl.TextureEffects.Alpha = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"clearAlpha_frag":"\n// void main()\n// {\n//     outColor.a=0.0;\n// }\n\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\n\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n\n    outColor=base;\n\n    #ifdef METH_NORM\n        outColor.a=amount;\n    #endif\n    #ifdef METH_ADD\n        outColor.a+=amount;\n    #endif\n    #ifdef METH_SUB\n        outColor.a-=amount;\n    #endif\n    #ifdef METH_MUL\n        outColor.a*=amount;\n    #endif\n\n    #ifdef DO_CLAMP\n    outColor.a=clamp(0.0,1.0,outColor.a);\n    #endif\n\n}\n",};
const
    render = op.inTrigger("Render"),
    amount = op.inValueSlider("Amount", 1),
    meth = op.inSwitch("Method", ["Set", "Add", "Sub", "Mul"], "Set"),
    clamp = op.inBool("Clamp", true),
    trigger = op.outTrigger("Next");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "Alpha");
const TEX_SLOT = 0;

shader.setSource(shader.getDefaultVertexShader(), attachments.clearAlpha_frag || "");

const uniformAmount = new CGL.Uniform(shader, "f", "amount", amount);
const textureUniform = new CGL.Uniform(shader, "t", "tex", TEX_SLOT);

clamp.onChange =
    meth.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("METH_NORM", meth.get() == "Set");
    shader.toggleDefine("METH_ADD", meth.get() == "Add");
    shader.toggleDefine("METH_SUB", meth.get() == "Sub");
    shader.toggleDefine("METH_MUL", meth.get() == "Mul");
    shader.toggleDefine("DO_CLAMP", clamp.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(TEX_SLOT, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Alpha.prototype = new CABLES.Op();
CABLES.OPS["131687e0-77f5-4fd7-be57-864aa6559418"]={f:Ops.Gl.TextureEffects.Alpha,objName:"Ops.Gl.TextureEffects.Alpha"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.AlphaMask_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.AlphaMask_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"alphamask_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D image;\nUNI float amount;\n\nvoid main()\n{\n    vec4 col=vec4(0.0,0.0,0.0,1.0);\n    col=texture(tex,texCoord);\n\n#ifdef USE_TEXTURE\n    float newAlpha=0.0;\n\n    #ifdef FROM_RED\n       newAlpha=texture(image,texCoord).r;\n    #endif\n\n    #ifdef FROM_GREEN\n       newAlpha=texture(image,texCoord).g;\n    #endif\n\n    #ifdef FROM_BLUE\n       newAlpha=texture(image,texCoord).b;\n    #endif\n\n    #ifdef FROM_ALPHA\n       newAlpha=texture(image,texCoord).a;\n    #endif\n\n    #ifdef FROM_LUMINANCE\n       float gray = dot(vec3(0.2126,0.7152,0.0722), texture(image,texCoord).rgb );\n       newAlpha=gray;\n    #endif\n\n\n    newAlpha*=amount;\n\n    #ifdef INVERT\n        newAlpha=1.0-newAlpha;\n    #endif\n\n    #ifdef METH_OVERRIDE\n        col.a=newAlpha;\n    #endif\n    #ifdef METH_ADD\n        col.a+=newAlpha;\n    #endif\n    #ifdef METH_MUL\n        col.a*=newAlpha;\n    #endif\n\n#endif\n#ifndef USE_TEXTURE\n    col.a*=amount;\n    // col.g=1.0;\n#endif\n\n    outColor= col;\n}",};
const
    render = op.inTrigger("render"),
    inAmount = op.inFloatSlider("Amount", 1),
    inMethod = op.inSwitch("Method", ["Override", "Mul", "Add"], "Override"),
    inInvert = op.inBool("Invert", false),
    image = op.inTexture("image"),
    next = op.outTrigger("trigger");

const cgl = this.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
shader.setSource(shader.getDefaultVertexShader(), attachments.alphamask_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const textureDisplaceUniform = new CGL.Uniform(shader, "t", "image", 1);
const amountUniform = new CGL.Uniform(shader, "f", "amount", inAmount);

// const method = this.addInPort(new CABLES.Port(this, "method", CABLES.OP_PORT_TYPE_VALUE, { "display": "dropdown", "values": ["luminance", "image alpha", "red", "green", "blue"] }));
const method = op.inDropDown("method", ["luminance", "image alpha", "red", "green", "blue"], "luminance");

image.onChange =
inMethod.onChange =
inInvert.onChange =
method.onChange = function ()
{
    shader.toggleDefine("FROM_LUMINANCE", method.get() == "luminance");
    shader.toggleDefine("FROM_ALPHA", method.get() == "image alpha");
    shader.toggleDefine("FROM_RED", method.get() == "red");
    shader.toggleDefine("FROM_GREEN", method.get() == "green");
    shader.toggleDefine("FROM_BLUR", method.get() == "blue");
    shader.toggleDefine("USE_TEXTURE", image.get());

    shader.toggleDefine("INVERT", inInvert.get());
    shader.toggleDefine("METH_MUL", inMethod.get() == "Mul");
    shader.toggleDefine("METH_ADD", inMethod.get() == "Add");
    shader.toggleDefine("METH_OVERRIDE", inMethod.get() == "Override");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;
    // if (!image.get()) return next.trigger();

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (image.get() && image.get().tex) cgl.setTexture(1, image.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    next.trigger();
};


};

Ops.Gl.TextureEffects.AlphaMask_v2.prototype = new CABLES.Op();
CABLES.OPS["a971aaa4-565f-47cf-8a4f-61a3a4378183"]={f:Ops.Gl.TextureEffects.AlphaMask_v2,objName:"Ops.Gl.TextureEffects.AlphaMask_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.BarrelDistortion_v3
// 
// **************************************************************

Ops.Gl.TextureEffects.BarrelDistortion_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"barreldistort_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float intensity;\n\n{{CGL.BLENDMODES3}}\n\n// adapted from https://www.shadertoy.com/view/MlSXR3\n\nvec2 brownConradyDistortion(vec2 uv)\n{\n// positive values of K1 give barrel distortion, negative give pincushion\n    float barrelDistortion1 = intensity*10.; // K1 in text books\n    float barrelDistortion2 = 0.; // K2 in text books\n    float r2 = uv.x*uv.x + uv.y*uv.y;\n    uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n\n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n    return uv;\n}\n\nvoid main()\n{\n    vec2 tc=brownConradyDistortion(texCoord-0.5)+0.5;\n    vec4 col=texture(tex,texCoord);\n    vec4 base=texture(tex,tc);\n\n    col.a=0.0;\n    outColor=cgl_blendPixel(col,base,amount);\n}",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1.0),
    intensity = op.inValue("Intensity", 10.0),
    trigger = op.outTrigger("Trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.barreldistort_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniintensity = new CGL.Uniform(shader, "f", "intensity", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;
    let texture = cgl.currentTextureEffect.getCurrentSourceTexture();

    uniintensity.setValue(intensity.get() * (1 / texture.width));

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, texture.tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.BarrelDistortion_v3.prototype = new CABLES.Op();
CABLES.OPS["d5efa9e4-d552-42f8-a345-d49e5e861602"]={f:Ops.Gl.TextureEffects.BarrelDistortion_v3,objName:"Ops.Gl.TextureEffects.BarrelDistortion_v3"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Blur
// 
// **************************************************************

Ops.Gl.TextureEffects.Blur = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"blur_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float dirX;\nUNI float dirY;\nUNI float amount;\n\n#ifdef HAS_MASK\n    UNI sampler2D imageMask;\n#endif\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main()\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float am=amount;\n    #ifdef HAS_MASK\n        am=amount*texture(imageMask,texCoord).r;\n        if(am<=0.02)\n        {\n            outColor=texture(tex, texCoord);\n            return;\n        }\n    #endif\n\n    vec2 delta=vec2(dirX*am*0.01,dirY*am*0.01);\n\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    #ifdef MOBILE\n        offset = 0.1;\n    #endif\n\n    #if defined(FASTBLUR) && !defined(MOBILE)\n        const float range=5.0;\n    #else\n        const float range=20.0;\n    #endif\n\n    for (float t = -range; t <= range; t+=1.0)\n    {\n        float percent = (t + offset - 0.5) / range;\n        float weight = 1.0 - abs(percent);\n        vec4 smpl = texture(tex, texCoord + delta * percent);\n\n        smpl.rgb *= smpl.a;\n\n        color += smpl * weight;\n        total += weight;\n    }\n\n    outColor= color / total;\n\n    outColor.rgb /= outColor.a + 0.00001;\n\n\n\n}\n",};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");
const amount = op.inValueFloat("amount");
const direction = op.inSwitch("direction", ["both", "vertical", "horizontal"], "both");
const fast = op.inValueBool("Fast", true);
const cgl = op.patch.cgl;

amount.set(10);

let shader = new CGL.Shader(cgl, "blur");

shader.define("FASTBLUR");

fast.onChange = function ()
{
    if (fast.get()) shader.define("FASTBLUR");
    else shader.removeDefine("FASTBLUR");
};

shader.setSource(shader.getDefaultVertexShader(), attachments.blur_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

let uniDirX = new CGL.Uniform(shader, "f", "dirX", 0);
let uniDirY = new CGL.Uniform(shader, "f", "dirY", 0);

let uniWidth = new CGL.Uniform(shader, "f", "width", 0);
let uniHeight = new CGL.Uniform(shader, "f", "height", 0);

let uniAmount = new CGL.Uniform(shader, "f", "amount", amount.get());
amount.onChange = function () { uniAmount.setValue(amount.get()); };

let textureAlpha = new CGL.Uniform(shader, "t", "imageMask", 1);

let showingError = false;

function fullScreenBlurWarning()
{
    if (cgl.currentTextureEffect.getCurrentSourceTexture().width == cgl.canvasWidth &&
        cgl.currentTextureEffect.getCurrentSourceTexture().height == cgl.canvasHeight)
    {
        op.setUiError("warning", "Full screen blurs are slow! Try reducing the resolution to 1/2 or a 1/4", 0);
    }
    else
    {
        op.setUiError("warning", null);
    }
}

let dir = 0;
direction.onChange = function ()
{
    if (direction.get() == "both")dir = 0;
    if (direction.get() == "horizontal")dir = 1;
    if (direction.get() == "vertical")dir = 2;
};

let mask = op.inTexture("mask");

mask.onChange = function ()
{
    if (mask.get() && mask.get().tex) shader.define("HAS_MASK");
    else shader.removeDefine("HAS_MASK");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);

    uniWidth.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniHeight.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().height);

    fullScreenBlurWarning();

    // first pass
    if (dir === 0 || dir == 2)
    {
        cgl.currentTextureEffect.bind();
        cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

        if (mask.get() && mask.get().tex)
        {
            cgl.setTexture(1, mask.get().tex);
            // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, mask.get().tex );
        }

        uniDirX.setValue(0.0);
        uniDirY.setValue(1.0);

        cgl.currentTextureEffect.finish();
    }

    // second pass
    if (dir === 0 || dir == 1)
    {
        cgl.currentTextureEffect.bind();
        cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

        if (mask.get() && mask.get().tex)
        {
            cgl.setTexture(1, mask.get().tex);
            // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, mask.get().tex );
        }

        uniDirX.setValue(1.0);
        uniDirY.setValue(0.0);

        cgl.currentTextureEffect.finish();
    }

    cgl.popShader();
    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Blur.prototype = new CABLES.Op();
CABLES.OPS["54f26f53-f637-44c1-9bfb-a2f2b722e998"]={f:Ops.Gl.TextureEffects.Blur,objName:"Ops.Gl.TextureEffects.Blur"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Border_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Border_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"border_frag":"IN vec2 texCoord;\nUNI float width;\nUNI sampler2D tex;\nUNI float amount;\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float aspect;\nUNI vec4 mulSides;\nUNI bool smoothed;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 col= texture(tex,texCoord);\n\n    if(!smoothed)\n    {\n        float border=0.0;\n        if(border==0.0 && texCoord.y < width/aspect/3.0) border=mulSides.x;\n        if(border==0.0 && texCoord.y > 1.0-width/aspect/3.0) border=mulSides.z;\n        if(border==0.0 && texCoord.x > 1.0-width/3.0) border=mulSides.a;\n        if(border==0.0 && texCoord.x < width/3.0 ) border=mulSides.y;\n\n        col = vec4(r,g,b, border);\n    }\n    else\n    {\n       float f=smoothstep(0.0,width,texCoord.x)-smoothstep(1.0-width,1.0,texCoord.x);\n       f*=smoothstep(0.0,width/aspect,texCoord.y);\n       f*=smoothstep(1.0,1.0-width/aspect,texCoord.y);\n       col= mix(col,vec4(r,g,b, 1.0),1.0-f);\n    }\n\n    vec4 base=texture(tex,texCoord);\n    outColor=cgl_blendPixel(base,col,amount*col.a);\n}",};
const
    render = op.inTrigger("render"),
    width = op.inValue("width", 0.1),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),

    amount = op.inValueSlider("Amount", 1),
    trigger = op.outTrigger("trigger"),
    smooth = op.inValueBool("Smooth", false),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    sideA = op.inFloat("Side A", 1),
    sideB = op.inFloat("Side B", 1),
    sideC = op.inFloat("Side C", 1),
    sideD = op.inFloat("Side D", 1);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "border");

shader.setSource(shader.getDefaultVertexShader(), attachments.border_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    aspectUniform = new CGL.Uniform(shader, "f", "aspect", 0),
    uniSmooth = new CGL.Uniform(shader, "b", "smoothed", smooth),
    uniWidth = new CGL.Uniform(shader, "f", "width", width.get()),
    unir = new CGL.Uniform(shader, "f", "r", r),
    unig = new CGL.Uniform(shader, "f", "g", g),
    unib = new CGL.Uniform(shader, "f", "b", b);

width.onChange = function ()
{
    uniWidth.setValue(width.get() / 2);
};

r.setUiAttribs({ "colorPick": true });
shader.addUniformFrag("4f", "mulSides", sideA, sideB, sideC, sideD);

op.setPortGroup("Sides", [sideA, sideB, sideC, sideD]);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    let texture = cgl.currentTextureEffect.getCurrentSourceTexture();
    aspectUniform.set(texture.height / texture.width);

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, texture.tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Border_v2.prototype = new CABLES.Op();
CABLES.OPS["ee773dc0-d00c-4d6a-86b7-8fd32f9d72e1"]={f:Ops.Gl.TextureEffects.Border_v2,objName:"Ops.Gl.TextureEffects.Border_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.BrightnessContrast
// 
// **************************************************************

Ops.Gl.TextureEffects.BrightnessContrast = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"brightness_contrast_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float amountbright;\n\nvoid main()\n{\n    vec4 col=vec4(1.0,0.0,0.0,1.0);\n    col=texture(tex,texCoord);\n\n    // apply contrast\n    col.rgb = ((col.rgb - 0.5) * max(amount*2.0, 0.0))+0.5;\n\n    // apply brightness\n    col.rgb *= amountbright*2.0;\n\n    outColor = col;\n}",};
const
    render = op.inTrigger("render"),
    amount = op.inValueSlider("contrast", 0.5),
    amountBright = op.inValueSlider("brightness", 0.5),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;

const shader = new CGL.Shader(cgl, "brightnesscontrast");
shader.setSource(shader.getDefaultVertexShader(), attachments.brightness_contrast_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
const amountBrightUniform = new CGL.Uniform(shader, "f", "amountbright", amountBright);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    if (!cgl.currentTextureEffect.getCurrentSourceTexture()) return;
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.BrightnessContrast.prototype = new CABLES.Op();
CABLES.OPS["54b89199-c594-4dff-bc48-82d6c7a55e8a"]={f:Ops.Gl.TextureEffects.BrightnessContrast,objName:"Ops.Gl.TextureEffects.BrightnessContrast"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.BulgePinch
// 
// **************************************************************

Ops.Gl.TextureEffects.BulgePinch = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"bulgepinch_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n\nUNI float radius;\nUNI float strength;\nUNI float centerX;\nUNI float centerY;\n\nvoid main()\n{\n   vec2 center=vec2(centerX,centerY);\n   vec2 coord=texCoord;\n   coord -= center;\n   float distance = length(coord);\n   float percent = distance / radius;\n   if (strength > 0.0) coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n   else coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n   coord += center;\n   vec4 col=texture(tex,coord);\n   outColor= col;\n}",};
const
    render=op.inTrigger('render'),
    radius=op.inValueFloat("Radius",0.5),
    strength=op.inValueFloat("Strength",1),
    centerX=op.inValueFloat("Center X",0.5),
    centerY=op.inValueFloat("Center Y",0.5),
    trigger=op.outTrigger('trigger');

const cgl=op.patch.cgl;
const shader=new CGL.Shader(cgl,'bulgepinch');
shader.setSource(shader.getDefaultVertexShader(),attachments.bulgepinch_frag);

const
    uniRadius=new CGL.Uniform(shader,'f','radius',radius),
    uniStrength=new CGL.Uniform(shader,'f','strength',strength),
    uniCenterX=new CGL.Uniform(shader,'f','centerX',centerX),
    uniCenterY=new CGL.Uniform(shader,'f','centerY',centerY),
    textureUniform=new CGL.Uniform(shader,'t','tex',0);

render.onTriggered=function()
{
    if(!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex );

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.BulgePinch.prototype = new CABLES.Op();
CABLES.OPS["25696840-bd64-463e-9301-964a81385bfb"]={f:Ops.Gl.TextureEffects.BulgePinch,objName:"Ops.Gl.TextureEffects.BulgePinch"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.CheckerBoard_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.CheckerBoard_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"checkerboard_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float numX;\nUNI float numY;\nUNI float amount;\nUNI float rotate;\nUNI float aspect;\n\n{{CGL.BLENDMODES3}}\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid main()\n{\n    vec2 uv=texCoord-0.5;\n    pR(uv.xy,rotate * (TAU));\n    // uv = vec2(texCoord.x,texCoord.y*aspect)-0.5;\n\n    #ifdef CENTER\n        uv+=vec2(0.5,0.5);\n    #endif\n\n    float asp=1.0;\n    float nY=numY;\n    #ifdef SQUARE\n        asp=aspect;\n        nY=numX/aspect;\n\n    #endif\n\n    float total = floor(uv.x*numX-numX/2.0) +floor(uv.y/asp*nY-nY/2.0);\n    float r = mod(total,2.0);\n\n    vec4 col=vec4(r,r,r,1.0);\n    vec4 base=texture(tex,texCoord);\n    outColor=cgl_blendPixel(base,col,amount);\n}",};
const render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    amount = op.inValueSlider("Amount", 1),
    inSquare = op.inBool("Square", true),
    numX = op.inValue("Num X", 10),
    numY = op.inValue("Num Y", 10),
    inRotate = op.inValueSlider("Rotate", 0.0),
    inCentered = op.inBool("Centered", true),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "checkerboard");

shader.setSource(shader.getDefaultVertexShader(), attachments.checkerboard_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniNumX = new CGL.Uniform(shader, "f", "numX", numX),
    uniNumY = new CGL.Uniform(shader, "f", "numY", numY),
    uniAspect = new CGL.Uniform(shader, "f", "aspect", 1),
    rotateUniform = new CGL.Uniform(shader, "f", "rotate", inRotate);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

inSquare.onChange =
inCentered.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    shader.toggleDefine("CENTER", inCentered.get());
    shader.toggleDefine("SQUARE", inSquare.get());

    numY.setUiAttribs({ "greyout": inSquare.get() });
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    uniAspect.set(cgl.currentTextureEffect.aspectRatio);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.CheckerBoard_v2.prototype = new CABLES.Op();
CABLES.OPS["7edfae81-f092-413f-a2a0-b109fdffa61d"]={f:Ops.Gl.TextureEffects.CheckerBoard_v2,objName:"Ops.Gl.TextureEffects.CheckerBoard_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ChromaticAberration_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.ChromaticAberration_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"chromatic_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float pixel;\nUNI float onePixel;\nUNI float amount;\nUNI float lensDistort;\n\n#ifdef MASK\nUNI sampler2D texMask;\n#endif\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n   vec4 base=texture(tex,texCoord);\n   vec4 col=texture(tex,texCoord);\n\n   vec2 tc=texCoord;;\n   float pix = pixel;\n   if(lensDistort>0.0)\n   {\n       float dist = distance(texCoord, vec2(0.5,0.5));\n       tc-=0.5;\n       tc *=smoothstep(-0.9,1.0*lensDistort,1.0-dist);\n       tc+=0.5;\n   }\n\n    #ifdef MASK\n        vec4 m=texture(texMask,texCoord);\n        pix*=m.r*m.a;\n    #endif\n\n    #ifdef SMOOTH\n    #ifdef WEBGL2\n        float numSamples=round(pix/onePixel/4.0+1.0);\n        col.r=0.0;\n        col.b=0.0;\n\n        for(float off=0.0;off<numSamples;off++)\n        {\n            float diff=(pix/numSamples)*off;\n            col.r+=texture(tex,vec2(tc.x+diff,tc.y)).r/numSamples;\n            col.b+=texture(tex,vec2(tc.x-diff,tc.y)).b/numSamples;\n        }\n    #endif\n    #endif\n\n    #ifndef SMOOTH\n        col.r=texture(tex,vec2(tc.x+pix,tc.y)).r;\n        col.b=texture(tex,vec2(tc.x-pix,tc.y)).b;\n    #endif\n\n   outColor= cgl_blendPixel(base,col,amount);\n\n}\n",};
const
    render=op.inTrigger('render'),
    blendMode=CGL.TextureEffect.AddBlendSelect(op,"Blend Mode","normal"),
    amount=op.inValueSlider("Amount",1),
    pixel=op.inValue("Pixel",5),
    lensDistort=op.inValueSlider("Lens Distort",0),
    doSmooth=op.inValueBool("Smooth",false),
    textureMask=op.inTexture("Mask"),
    trigger=op.outTrigger('trigger');

const cgl=op.patch.cgl;
const shader=new CGL.Shader(cgl,"chromatic");

CGL.TextureEffect.setupBlending(op,shader,blendMode,amount);

shader.setSource(shader.getDefaultVertexShader(),attachments.chromatic_frag);
const textureUniform=new CGL.Uniform(shader,'t','tex',0),
    uniPixel=new CGL.Uniform(shader,'f','pixel',0),
    uniOnePixel=new CGL.Uniform(shader,'f','onePixel',0),
    unitexMask=new CGL.Uniform(shader,'t','texMask',1),
    uniAmount=new CGL.Uniform(shader,'f','amount',amount),
    unilensDistort=new CGL.Uniform(shader,'f','lensDistort',lensDistort);

doSmooth.onChange=function()
{
    if(doSmooth.get())shader.define("SMOOTH");
    else shader.removeDefine("SMOOTH");
};

textureMask.onChange=function()
{
    if(textureMask.get())shader.define("MASK");
    else shader.removeDefine("MASK");
};

render.onTriggered=function()
{
    if(!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    var texture=cgl.currentTextureEffect.getCurrentSourceTexture();

    uniPixel.setValue(pixel.get()*(1/texture.width));
    uniOnePixel.setValue(1/texture.width);

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, texture.tex );

    if(textureMask.get()) cgl.setTexture(1, textureMask.get().tex );

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.ChromaticAberration_v2.prototype = new CABLES.Op();
CABLES.OPS["07701f81-1a98-44c0-b1ef-592db3cbb5d3"]={f:Ops.Gl.TextureEffects.ChromaticAberration_v2,objName:"Ops.Gl.TextureEffects.ChromaticAberration_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.CircleTexture_v4
// 
// **************************************************************

Ops.Gl.TextureEffects.CircleTexture_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"circle_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n\nUNI float amount;\nUNI float size;\nUNI float inner;\nUNI float fadeOut;\n\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\nUNI float aspect;\nUNI vec2 stretch;\n\n\nUNI float x;\nUNI float y;\n\n{{CGL.BLENDMODES3}}\n\nfloat dist(float x,float y,float x2,float y2)\n{\n\tfloat xd = x2-x;\n\tfloat yd = y2-y;\n\treturn abs(sqrt(xd*xd*(1.0-stretch.x) + yd*yd*(1.0-stretch.y)));\n}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n\n    vec4 col=vec4(r,g,b,1.0);\n    float dist = dist(x,y/aspect,(texCoord.x-0.5)*2.0,(texCoord.y-0.5)*2.0/aspect);\n\n    float sz=size*0.5/aspect;\n    float v=0.0;\n    float fade=fadeOut;\n\n    if(fade==0.0)\n    {\n        if(dist<sz && dist>inner*sz) v=(smoothstep(0.0,1.0,(dist-(inner*sz))/(fade)));\n    }\n\n    if(fade>=0.0)\n    {\n\n        #ifdef FALLOFF_SMOOTHSTEP\n            if(dist>inner*sz && dist<sz+fade)v=1.0-(smoothstep(0.0,1.0,(dist-sz)/(fade)));\n        #endif\n        #ifndef FALLOFF_SMOOTHSTEP\n            fade+=0.0001;\n            if(dist>inner*sz && dist<sz+fade)v=1.0-((dist-sz)/(fade));\n        #endif\n    }\n\n    outColor=cgl_blendPixel(base,col,amount*v);\n\n    outColor.a-=(1.0-a)*v;\n\n    #ifdef WARN_OVERFLOW\n        float width=0.01;\n        if( texCoord.x>(1.0-width) || texCoord.y>(1.0-width) || texCoord.y<width || texCoord.x<width )\n            if(v>0.001*amount)outColor= vec4(1.0,0.0,0.0, 1.0);\n    #endif\n}\n",};
const
    render = op.inTrigger("Render"),
    amount = op.inValueSlider("Amount", 1),
    blendMode = CGL.TextureEffect.AddBlendSelect(op),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    inSize = op.inValueSlider("Size", 0.25),
    inInner = op.inValueSlider("Inner"),
    inStretchX = op.inFloat("Stretch X"),
    inStretchY = op.inFloat("Stretch Y"),
    inX = op.inValue("Pos X", 0),
    inY = op.inValue("Pos Y", 0),
    fallOff = op.inValueSelect("fallOff", ["Linear", "SmoothStep"], "Linear"),
    inFadeOut = op.inValueSlider("fade Out"),
    warnOverflow = op.inValueBool("warn overflow", false),
    r = op.inValueSlider("r", 1),
    g = op.inValueSlider("g", 1),
    b = op.inValueSlider("b", 1),
    a = op.inValueSlider("a", 1),
    trigger = op.outTrigger("Next");

r.setUiAttribs({ "colorPick": true });

op.setPortGroup("Size", [inSize, inInner, inStretchX, inStretchY]);
op.setPortGroup("Position", [inX, inY]);
op.setPortGroup("Style", [warnOverflow, fallOff, inFadeOut]);

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, "textureeffect stripes");
shader.setSource(shader.getDefaultVertexShader(), attachments.circle_frag);

updateDefines();

let
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniStretch = new CGL.Uniform(shader, "2f", "stretch", inStretchX, inStretchY),
    uniSize = new CGL.Uniform(shader, "f", "size", inSize),
    uniFadeOut = new CGL.Uniform(shader, "f", "fadeOut", inFadeOut),
    uniInner = new CGL.Uniform(shader, "f", "inner", inInner),
    aspect = new CGL.Uniform(shader, "f", "aspect", 1),
    uniformR = new CGL.Uniform(shader, "f", "r", r),
    uniformG = new CGL.Uniform(shader, "f", "g", g),
    uniformB = new CGL.Uniform(shader, "f", "b", b),
    uniformA = new CGL.Uniform(shader, "f", "a", a),
    uniformX = new CGL.Uniform(shader, "f", "x", inX),
    uniformY = new CGL.Uniform(shader, "f", "y", inY);

fallOff.onChange =
    warnOverflow.onChange = updateDefines;

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

function updateDefines()
{
    shader.toggleDefine("FALLOFF_LINEAR", fallOff.get() == "Linear");
    shader.toggleDefine("FALLOFF_SMOOTHSTEP", fallOff.get() == "SmoothStep");
    shader.toggleDefine("WARN_OVERFLOW", warnOverflow.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    aspect.set(cgl.currentTextureEffect.aspectRatio);

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.CircleTexture_v4.prototype = new CABLES.Op();
CABLES.OPS["9738c421-1ee0-42bf-be0b-f4a481385fbf"]={f:Ops.Gl.TextureEffects.CircleTexture_v4,objName:"Ops.Gl.TextureEffects.CircleTexture_v4"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ClampTexture
// 
// **************************************************************

Ops.Gl.TextureEffects.ClampTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"clampShader_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float lowEdge;\nUNI float highEdge;\n\n{{CGL.BLENDMODES}}\n\nvoid main()\n{\n    vec3 result = vec3(0.);\n    vec3 color = texture(tex,texCoord).rgb;\n\n    #ifdef CLAMP\n        result = clamp(color,vec3(lowEdge),vec3(highEdge));\n    #endif\n\n    #ifdef REMAP\n        result = mix(color*vec3(lowEdge),color*vec3(highEdge),color);\n    #endif\n\n    #ifdef REMAP_SMOOTH\n        result = smoothstep(vec3(lowEdge),vec3(highEdge),color);\n    #endif\n\n    outColor= mix(vec4(color,1.0),\n                    vec4(result,1.0),\n                        amount);\n}",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    modeSelect = op.inValueSelect("Mode", ["Clamp", "Remap", "Remap smooth"], "Clamp"),
    inLowEdge = op.inValue("Min", 0.0),
    inHighEdge = op.inValue("Max", 1.0),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.clampShader_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
const lowEdgeUniform = new CGL.Uniform(shader, "f", "lowEdge", inLowEdge);
const highEdgeUniform = new CGL.Uniform(shader, "f", "highEdge", inHighEdge);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

op.init = modeSelect.onChange = function ()
{
    shader.toggleDefine("CLAMP", modeSelect.get() === "Clamp");
    shader.toggleDefine("REMAP", modeSelect.get() === "Remap");
    shader.toggleDefine("REMAP_SMOOTH", modeSelect.get() === "Remap smooth");
};
render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.ClampTexture.prototype = new CABLES.Op();
CABLES.OPS["086ca023-af3c-4e3a-9be7-1972adcf63b5"]={f:Ops.Gl.TextureEffects.ClampTexture,objName:"Ops.Gl.TextureEffects.ClampTexture"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Clarity
// 
// **************************************************************

Ops.Gl.TextureEffects.Clarity = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"clarity_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float pX,pY;\n\nvec3 desaturate(vec4 color)\n{\n    vec3 c= vec3(dot(vec3(0.2126,0.7152,0.0722), color.rgb));\n    return c;\n}\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\n    vec3 gray=desaturate(col);\n    vec3 m=smoothstep(0.2,0.5,gray)*smoothstep(0.75,0.5,gray);\n    vec4 col2=vec4(1.0);\n\n    col2.rgb = ((col.rgb - 0.5) * max(( vec3(amount)*m+0.5)*2.0, 0.0))+0.5;\n\n    outColor= col2;\n}\n\n\n",};
const render = op.inTrigger("Render");
const trigger = op.outTrigger("Trigger");
const amount = op.inFloat("amount", 0.5);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.clarity_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Clarity.prototype = new CABLES.Op();
CABLES.OPS["37d66c32-5594-4509-bba0-0ba2cbb706d8"]={f:Ops.Gl.TextureEffects.Clarity,objName:"Ops.Gl.TextureEffects.Clarity"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ColorBalance_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.ColorBalance_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorbalance_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float r;\nUNI float g;\nUNI float b;\n\nfloat lumi(vec3 color)\n{\n    return vec3(dot(vec3(0.2126,0.7152,0.0722), color)).r;\n}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    float l=lumi(base.rgb);\n\n    #ifdef TONE_MID\n        l=smoothstep(0.33,0.66,l);\n    #endif\n\n    #ifdef TONE_LOW\n        l=1.0-l;\n    #endif\n\n    l=l*l;\n    vec3 color=base.rgb+vec3(l*r*0.1,l*g*0.1,l*b*0.1);\n    outColor= vec4(color,base.a);\n}\n",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    tone = op.inValueSelect("Tone", ["Highlights", "Midtones", "Shadows"], "Highlights"),
    r = op.inValue("r"),
    g = op.inValue("g"),
    b = op.inValue("b");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.colorbalance_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniR = new CGL.Uniform(shader, "f", "r", r),
    uniG = new CGL.Uniform(shader, "f", "g", g),
    uniB = new CGL.Uniform(shader, "f", "b", b);

tone.onChange = function ()
{
    shader.toggleDefine("TONE_HIGH", tone.get() == "Highlights");
    shader.toggleDefine("TONE_MID", tone.get() == "Midtones");
    shader.toggleDefine("TONE_LOW", tone.get() == "Shadows");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.ColorBalance_v2.prototype = new CABLES.Op();
CABLES.OPS["5af81475-2aa6-451b-a1f3-0980f641a72e"]={f:Ops.Gl.TextureEffects.ColorBalance_v2,objName:"Ops.Gl.TextureEffects.ColorBalance_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ColorChannel_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.ColorChannel_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorchannel_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n\nvoid main()\n{\n    vec4 color=texture(tex,texCoord);\n    vec4 col=vec4(0.0,0.0,0.0,color.a);\n\n   #ifdef CHANNEL_R\n        col.r=color.r;\n        #ifdef MONO\n            col.g=col.b=col.r;\n        #endif\n   #endif\n\n   #ifdef CHANNEL_G\n       col.g=color.g;\n       #ifdef MONO\n            col.r=col.b=col.g;\n       #endif\n   #endif\n\n   #ifdef CHANNEL_B\n       col.b=color.b;\n       #ifdef MONO\n            col.g=col.r=col.b;\n       #endif\n   #endif\n\n   #ifdef CHANNEL_A\n       col.r=col.g=col.b=color.a;\n   #endif\n\n   outColor = col;\n}",};
const
    render = op.inTrigger("render"),
    channelR = op.inValueBool("channelR", true),
    channelG = op.inValueBool("channelG", false),
    channelB = op.inValueBool("channelB", false),
    channelA = op.inValueBool("channelA", false),
    mono = op.inValueBool("mono", false),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.colorchannel_frag || "");
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

mono.onChange =
    channelA.onChange =
    channelR.onChange =
    channelG.onChange =
    channelB.onChange = updateChannels;
updateChannels();

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

function updateChannels()
{
    shader.toggleDefine("CHANNEL_R",channelR.get());
    shader.toggleDefine("CHANNEL_G",channelG.get());
    shader.toggleDefine("CHANNEL_B",channelB.get());
    shader.toggleDefine("CHANNEL_A",channelA.get());
    shader.toggleDefine("MONO",mono.get());
}


};

Ops.Gl.TextureEffects.ColorChannel_v2.prototype = new CABLES.Op();
CABLES.OPS["0a512974-0920-4aa8-89dc-4dda184c0d46"]={f:Ops.Gl.TextureEffects.ColorChannel_v2,objName:"Ops.Gl.TextureEffects.ColorChannel_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ColorMapRange
// 
// **************************************************************

Ops.Gl.TextureEffects.ColorMapRange = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"maprange_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n\nUNI float min1,min2,max1,max2;\n\nfloat map(float value)\n{\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\n    #ifdef CH_R\n        col.r=map(col.r);\n    #endif\n    #ifdef CH_G\n        col.g=map(col.g);\n    #endif\n    #ifdef CH_B\n        col.b=map(col.b);\n    #endif\n    #ifdef CH_A\n        col.a=map(col.a);\n    #endif\n\n    outColor = col;\n}",};
const
    render = op.inTrigger("render"),
    min1 = op.inValueSlider("Old Min", 0),
    max1 = op.inValueSlider("Old Max", 1),
    min2 = op.inValueSlider("New Min", 0),
    max2 = op.inValueSlider("New Max", 1),

    inR = op.inBool("R", true),
    inG = op.inBool("G", true),
    inB = op.inBool("B", true),
    inA = op.inBool("A", false),

    trigger = op.outTrigger("trigger");

op.setPortGroup("Input Range", [min1, max1]);
op.setPortGroup("Output Range", [min2, max2]);

const cgl = op.patch.cgl;

const shader = new CGL.Shader(cgl, "colorMaprange");
shader.setSource(shader.getDefaultVertexShader(), attachments.maprange_frag);
toggleChannels(shader);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniMin1 = new CGL.Uniform(shader, "f", "min1", min1),
    uniMin2 = new CGL.Uniform(shader, "f", "min2", min2),
    unimax1 = new CGL.Uniform(shader, "f", "max1", max1),
    unimax2 = new CGL.Uniform(shader, "f", "max2", max2);

inR.onChange =
    inG.onChange =
    inB.onChange =
    inA.onChange = () =>
    {
        toggleChannels(shader);
    };

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;
    if (!cgl.currentTextureEffect.getCurrentSourceTexture()) return;
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};

function toggleChannels(shader)
{
    shader.toggleDefine("CH_R", inR.get());
    shader.toggleDefine("CH_G", inG.get());
    shader.toggleDefine("CH_B", inB.get());
    shader.toggleDefine("CH_A", inA.get());
}


};

Ops.Gl.TextureEffects.ColorMapRange.prototype = new CABLES.Op();
CABLES.OPS["a1452720-dc08-4195-983b-7949aac33055"]={f:Ops.Gl.TextureEffects.ColorMapRange,objName:"Ops.Gl.TextureEffects.ColorMapRange"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ColorMap_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.ColorMap_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colormap_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D gradient;\nUNI float pos;\nUNI float amount;\nUNI float vmin;\nUNI float vmax;\n\n{{CGL.BLENDMODES3}}\n\n\nfloat lumi(vec3 color)\n{\n   return vec3(dot(vec3(0.2126,0.7152,0.0722), color)).r;\n}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    float a=base.a;\n\n    base=clamp(base,vmin,vmax);\n\n    #ifdef METH_LUMI\n        vec4 color=texture(gradient,vec2(lumi(base.rgb),pos));\n    #endif\n\n    #ifdef METH_CHANNELS\n        vec4 color=vec4(1.0);\n        color.r=texture(gradient,vec2(base.r,pos)).r;\n        color.g=texture(gradient,vec2(base.g,pos)).g;\n        color.b=texture(gradient,vec2(base.b,pos)).b;\n    #endif\n\n    base.a=color.a=a;\n\n\n    outColor=cgl_blendPixel(base,color,amount);\n\n}\n",};
let render = op.inTrigger("render");
let trigger = op.outTrigger("trigger");

const blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal");
const amount = op.inValueSlider("Amount", 1);

let inGradient = op.inTexture("Gradient");
let inMethod = op.inSwitch("Method", ["Luminance", "Channels"], "Luminance");

let inMin = op.inFloatSlider("Min", 0);
let inMax = op.inFloatSlider("Max", 1);

let inPos = op.inValueSlider("Position", 0.5);

op.setPortGroup("Vertical Position", [inMin, inMax, inPos]);

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name);
shader.define("METH_LUMI");

shader.setSource(shader.getDefaultVertexShader(), attachments.colormap_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let textureUniform2 = new CGL.Uniform(shader, "t", "gradient", 1);
let uniPos = new CGL.Uniform(shader, "f", "pos", inPos);
let uniMin = new CGL.Uniform(shader, "f", "vmin", inMin);
let uniMax = new CGL.Uniform(shader, "f", "vmax", inMax);
let uniAmount = new CGL.Uniform(shader, "f", "amount", amount);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

inMethod.onChange = () =>
{
    shader.toggleDefine("METH_LUMI", inMethod.get() == "Luminance");
    shader.toggleDefine("METH_CHANNELS", inMethod.get() == "Channels");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;
    if (!inGradient.get()) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.setTexture(1, inGradient.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.ColorMap_v2.prototype = new CABLES.Op();
CABLES.OPS["440c1675-122d-411f-b848-16c60b677120"]={f:Ops.Gl.TextureEffects.ColorMap_v2,objName:"Ops.Gl.TextureEffects.ColorMap_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Color_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Color_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"color_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float amount;\n\n#ifdef MASK\n    UNI sampler2D mask;\n#endif\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 col=vec4(r,g,b,1.0);\n    vec4 base=texture(tex,texCoord);\n\n    float am=amount;\n    #ifdef MASK\n        float msk=texture(mask,texCoord).r;\n        #ifdef INVERTMASK\n            msk=1.0-msk;\n        #endif\n        am*=1.0-msk;\n    #endif\n\n    outColor=cgl_blendPixel(base,col,am);\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),

    inMask = op.inTexture("Mask"),
    inMaskInvert = op.inValueBool("Mask Invert"),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    trigger = op.outTrigger("trigger");

r.setUiAttribs({ "colorPick": true });
op.setPortGroup("Color", [r, g, b]);

const TEX_SLOT = 0;
const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "textureeffect color");
const srcFrag = attachments.color_frag || "";
shader.setSource(shader.getDefaultVertexShader(), srcFrag);
CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", TEX_SLOT),
    makstextureUniform = new CGL.Uniform(shader, "t", "mask", 1),
    uniformR = new CGL.Uniform(shader, "f", "r", r),
    uniformG = new CGL.Uniform(shader, "f", "g", g),
    uniformB = new CGL.Uniform(shader, "f", "b", b),
    uniformAmount = new CGL.Uniform(shader, "f", "amount", amount);

inMask.onChange = function ()
{
    if (inMask.isLinked())shader.define("MASK");
    else shader.removeDefine("MASK");
};

inMaskInvert.onChange = function ()
{
    if (inMaskInvert.get())shader.define("INVERTMASK");
    else shader.removeDefine("INVERTMASK");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(TEX_SLOT, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inMask.get()) cgl.setTexture(1, inMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Color_v2.prototype = new CABLES.Op();
CABLES.OPS["6dada2b7-da7c-47ee-87a9-a12e87055208"]={f:Ops.Gl.TextureEffects.Color_v2,objName:"Ops.Gl.TextureEffects.Color_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Denoise
// 
// **************************************************************

Ops.Gl.TextureEffects.Denoise = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"denoise_frag":"UNI sampler2D tex;\nUNI float exponent;\nUNI float strength;\nUNI vec2 texSize;\nIN vec2 texCoord;\n\nvoid main()\n{\n    vec4 center = texture(tex, texCoord);\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n    const float pixels=4.0;\n    for (float x = -pixels; x <= pixels; x += 1.0) {\n        for (float y = -pixels; y <= pixels; y += 1.0) {\n            vec4 smpl = texture(tex, texCoord + vec2(x, y) / texSize);\n            float weight = 1.0 - abs(dot(smpl.rgb - center.rgb, vec3(0.25)));\n            weight = pow(weight, (1.0-exponent)*50.0);\n            color += smpl * weight;\n            total += weight;\n        }\n    }\n    outColor = color / total;\n}\n",};
let render = op.inTrigger("render");
let strength = op.inValueSlider("Exponent", 0.6);

let trigger = op.outTrigger("trigger");

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name);
let tsize = [128, 128];
let srcFrag = attachments.denoise_frag;

shader.setSource(shader.getDefaultVertexShader(), srcFrag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

let strengthUniform = new CGL.Uniform(shader, "f", "exponent", strength);
let texSizeUniform = new CGL.Uniform(shader, "2f", "texSize", tsize);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    tsize[0] = cgl.currentTextureEffect.getCurrentSourceTexture().width;
    tsize[1] = cgl.currentTextureEffect.getCurrentSourceTexture().height;
    texSizeUniform.setValue(tsize);

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Denoise.prototype = new CABLES.Op();
CABLES.OPS["0abfea0f-1aa9-47bf-b540-f54f89a60a6c"]={f:Ops.Gl.TextureEffects.Denoise,objName:"Ops.Gl.TextureEffects.Denoise"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.DepthTextureFocus_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.DepthTextureFocus_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"depth_focus_frag":"IN vec2 texCoord;\nUNI sampler2D image;\nUNI float nearPlane;\nUNI float farPlane;\nUNI float focus; // center\nUNI float width;\n\n\nvoid main()\n{\n    float depthFromTexture = texture(image,texCoord).r;\n\n    float z_viewSpace = (nearPlane * farPlane) / (farPlane - depthFromTexture * (farPlane - nearPlane));\n    z_viewSpace = abs(z_viewSpace - (focus));\n    z_viewSpace = smoothstep(0.0, width, z_viewSpace);\n\n    #ifndef INVERT\n        z_viewSpace = 1. - z_viewSpace;\n    #endif\n\n    outColor = vec4(vec3(z_viewSpace), 1.);\n}",};
const render = op.inTrigger("render");
const depthTexture = op.inTexture("Depth Texture");

const inFocus = op.inFloat("Focus", 0.5);
const inWidth = op.inFloat("Width", 0.2);
const inInv = op.inBool("Invert", false);
const nearPlane = op.inFloat("nearplane", 0.1);
const farPlane = op.inFloat("farplane", 100);

const trigger = op.outTrigger("trigger");

op.setPortGroup("Frustum", [farPlane, nearPlane]);
op.setPortGroup("Focus Settings", [inInv, inFocus, inWidth]);


const cgl = op.patch.cgl;

const shader = new CGL.Shader(cgl, op.name);
const srcFrag = attachments.depth_focus_frag || "";
shader.setSource(shader.getDefaultVertexShader(), srcFrag);

const textureUniform = new CGL.Uniform(shader, "t", "depthTexture", 0);
const uniFarplane = new CGL.Uniform(shader, "f", "farPlane", farPlane);
const uniNearplane = new CGL.Uniform(shader, "f", "nearPlane", nearPlane);
const uniFocus = new CGL.Uniform(shader, "f", "focus", inFocus);
const uniwidth = new CGL.Uniform(shader, "f", "width", inWidth);
const uniAspect = new CGL.Uniform(shader, "f", "aspectRatio", 0);

inInv.onChange = function ()
{
    if (inInv.get())shader.define("INVERT");
    else shader.removeDefine("INVERT");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    if (depthTexture.get() && depthTexture.get().tex)
    {
        const a =
            cgl.currentTextureEffect.getCurrentSourceTexture().height
            / cgl.currentTextureEffect.getCurrentSourceTexture().width;

        uniAspect.set(a);

        cgl.pushShader(shader);
        cgl.currentTextureEffect.bind();


        cgl.setTexture(0, depthTexture.get().tex);

        cgl.currentTextureEffect.finish();
        cgl.popShader();
    }

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.DepthTextureFocus_v2.prototype = new CABLES.Op();
CABLES.OPS["f84ac22e-664e-4ff1-b23f-539ac1f5c67e"]={f:Ops.Gl.TextureEffects.DepthTextureFocus_v2,objName:"Ops.Gl.TextureEffects.DepthTextureFocus_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.DepthTexture_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.DepthTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"depthtexture_frag":"IN vec2 texCoord;\nUNI float amount;\nUNI sampler2D texDepth;\nUNI sampler2D texBase;\nUNI float n;\nUNI float f;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 col=texture(texDepth,texCoord);\n    float z=col.r;\n    float c=(2.0*n)/(f+n-z*(f-n));\n\n    #ifdef INVERT\n       c=1.0-c;\n    #endif\n\n    col=vec4(c,c,c,1.0);\n    vec4 base=texture(texBase,texCoord);\n\n    outColor=cgl_blendPixel(base,col,amount);\n\n}",};
const
    render = op.inTrigger("render"),
    inDepthTex = op.inTexture("image"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    farPlane = op.inValue("farplane", 50.0),
    nearPlane = op.inValue("nearplane", 0.1),
    inInv = op.inValueBool("Invert", false),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Frustum", [farPlane, nearPlane]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.depthtexture_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "texDepth", 0),
    textureBaseUniform = new CGL.Uniform(shader, "t", "texBase", 1),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniFarplane = new CGL.Uniform(shader, "f", "f", farPlane),
    uniNearplane = new CGL.Uniform(shader, "f", "n", nearPlane);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

inInv.onChange = function ()
{
    if (inInv.get())shader.define("INVERT");
    else shader.removeDefine("INVERT");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    if (inDepthTex.get() && inDepthTex.get().tex)
    {
        cgl.pushShader(shader);
        cgl.currentTextureEffect.bind();

        cgl.setTexture(0, inDepthTex.get().tex);
        cgl.setTexture(1, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
        cgl.currentTextureEffect.finish();
        cgl.popShader();
    }

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.DepthTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["5958fbb8-fb78-4de2-85dc-5eb289f652cb"]={f:Ops.Gl.TextureEffects.DepthTexture_v2,objName:"Ops.Gl.TextureEffects.DepthTexture_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Desaturate
// 
// **************************************************************

Ops.Gl.TextureEffects.Desaturate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"desaturate_frag":"\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\n\n#ifdef MASK\n    UNI sampler2D mask;\n#endif\n\nvec3 desaturate(vec3 color, float amount)\n{\n   vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n   return vec3(mix(color, gray, amount));\n}\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\n    float am=amount;\n    #ifdef MASK\n        am*=1.0-texture(mask,texCoord).r;\n        #ifdef INVERTMASK\n        am=1.0-am;\n        #endif\n    #endif\n\n    col.rgb=desaturate(col.rgb,am);\n    outColor= col;\n}",};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");
const amount = op.inValueSlider("amount", 1);
const inMask = op.inTexture("Mask");
const invertMask = op.inValueBool("Invert Mask");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.desaturate_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let masktextureUniform = new CGL.Uniform(shader, "t", "mask", 1);
let amountUniform = new CGL.Uniform(shader, "f", "amount", amount);


invertMask.onChange = function ()
{
    if (invertMask.get())shader.define("INVERTMASK");
    else shader.removeDefine("INVERTMASK");
};

inMask.onChange = function ()
{
    if (inMask.get())shader.define("MASK");
    else shader.removeDefine("MASK");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (inMask.get()) cgl.setTexture(1, inMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Desaturate.prototype = new CABLES.Op();
CABLES.OPS["340efbd5-be53-4bd5-92ad-8f38d8eeecf1"]={f:Ops.Gl.TextureEffects.Desaturate,objName:"Ops.Gl.TextureEffects.Desaturate"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Dither_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Dither_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"dither_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float strength;\nUNI float amount;\nUNI float width;\nUNI float height;\nUNI float threshold;\n\nfloat lumi( vec4 col ) {\n    return (0.2126*col.r + 0.7152*col.g + 0.0722*col.b);\n}\n\n{{CGL.BLENDMODES3}}\n\nfloat adjustFrag( mat4 adjustments,float val, vec2 coord )\n{\n    vec2 coordMod = mod(vec2(coord.x*width,coord.y*height), 4.0);\n    int xMod = int(coordMod.x);\n    int yMod = int(coordMod.y);\n\n    vec4 col;\n    if (xMod == 0) col = adjustments[0];\n    else if (xMod == 1) col = adjustments[1];\n    else if (xMod == 2) col = adjustments[2];\n    else if (xMod == 3) col = adjustments[3];\n\n    float adjustment;\n    if (yMod == 0) adjustment = col.x;\n    else if (yMod == 1) adjustment = col.y;\n    else if (yMod == 2) adjustment = col.z;\n    else if (yMod == 3) adjustment = col.w;\n\n    return val + (val * adjustment);\n}\n\nvoid main()\n{\n    mat4 adjustments = ((mat4(\n        1, 13, 4, 16,\n        9, 5, 12, 8,\n        3, 15, 2, 14,\n        11, 7, 10, 6\n    ) - 8.) *  1.0 / strength);\n\n    vec4 base=texture(tex,texCoord);\n    vec4 color;\n\n    float lum = lumi(base);\n    lum = adjustFrag(adjustments,lum, texCoord.xy);\n\n    if (lum > threshold) color = vec4(1, 1, 1, base.a);\n    else color = vec4(0, 0, 0, base.a);\n\n    outColor=cgl_blendPixel(base,color,amount);\n}",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    trigger = op.outTrigger("Trigger"),
    strength = op.inValue("strength", 2),
    threshold = op.inValueSlider("threshold", 0.35);

const
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.dither_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    strengthUniform = new CGL.Uniform(shader, "f", "strength", strength),
    uniWidth = new CGL.Uniform(shader, "f", "width", 0),
    uniHeight = new CGL.Uniform(shader, "f", "height", 0),
    unithreshold = new CGL.Uniform(shader, "f", "threshold", threshold);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    uniWidth.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniHeight.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().height);

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Dither_v2.prototype = new CABLES.Op();
CABLES.OPS["686ae373-2d2d-44cc-b45f-2ccb782dea26"]={f:Ops.Gl.TextureEffects.Dither_v2,objName:"Ops.Gl.TextureEffects.Dither_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.DrawImage_v3
// 
// **************************************************************

Ops.Gl.TextureEffects.DrawImage_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"drawimage_frag":"#ifdef HAS_TEXTURES\n    IN vec2 texCoord;\n    UNI sampler2D tex;\n    UNI sampler2D image;\n#endif\n\n#ifdef TEX_TRANSFORM\n    IN mat3 transform;\n#endif\n// UNI float rotate;\n\n{{CGL.BLENDMODES}}\n\n#ifdef HAS_TEXTUREALPHA\n   UNI sampler2D imageAlpha;\n#endif\n\nUNI float amount;\n\n#ifdef ASPECT_RATIO\n    UNI float aspectTex;\n    UNI float aspectPos;\n#endif\n\nvoid main()\n{\n    vec4 blendRGBA=vec4(0.0,0.0,0.0,1.0);\n\n    #ifdef HAS_TEXTURES\n        vec2 tc=texCoord;\n\n        #ifdef TEX_FLIP_X\n            tc.x=1.0-tc.x;\n        #endif\n        #ifdef TEX_FLIP_Y\n            tc.y=1.0-tc.y;\n        #endif\n\n        #ifdef ASPECT_RATIO\n            #ifdef ASPECT_AXIS_X\n                tc.y=(1.0-aspectPos)-(((1.0-aspectPos)-tc.y)*aspectTex);\n            #endif\n            #ifdef ASPECT_AXIS_Y\n                tc.x=(1.0-aspectPos)-(((1.0-aspectPos)-tc.x)/aspectTex);\n            #endif\n        #endif\n\n        #ifdef TEX_TRANSFORM\n            vec3 coordinates=vec3(tc.x, tc.y,1.0);\n            tc=(transform * coordinates ).xy;\n        #endif\n\n        blendRGBA=texture(image,tc);\n\n        vec3 blend=blendRGBA.rgb;\n        vec4 baseRGBA=texture(tex,texCoord);\n        vec3 base=baseRGBA.rgb;\n\n\n        #ifdef PREMUL\n            blend.rgb = (blend.rgb) + (base.rgb * (1.0 - blendRGBA.a));\n        #endif\n\n        vec3 colNew=_blend(base,blend);\n\n\n\n\n        #ifdef REMOVE_ALPHA_SRC\n            blendRGBA.a=1.0;\n        #endif\n\n        #ifdef HAS_TEXTUREALPHA\n            vec4 colImgAlpha=texture(imageAlpha,tc);\n            float colImgAlphaAlpha=colImgAlpha.a;\n\n            #ifdef ALPHA_FROM_LUMINANCE\n                vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), colImgAlpha.rgb ));\n                colImgAlphaAlpha=(gray.r+gray.g+gray.b)/3.0;\n            #endif\n\n            #ifdef ALPHA_FROM_INV_UMINANCE\n                vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), colImgAlpha.rgb ));\n                colImgAlphaAlpha=1.0-(gray.r+gray.g+gray.b)/3.0;\n            #endif\n\n            #ifdef INVERT_ALPHA\n                colImgAlphaAlpha=clamp(colImgAlphaAlpha,0.0,1.0);\n                colImgAlphaAlpha=1.0-colImgAlphaAlpha;\n            #endif\n\n            blendRGBA.a=colImgAlphaAlpha*blendRGBA.a;\n        #endif\n    #endif\n\n    float am=amount;\n\n    #ifdef CLIP_REPEAT\n        if(tc.y>1.0 || tc.y<0.0 || tc.x>1.0 || tc.x<0.0)\n        {\n            // colNew.rgb=vec3(0.0);\n            am=0.0;\n        }\n    #endif\n\n    #ifdef ASPECT_RATIO\n        #ifdef ASPECT_CROP\n            if(tc.y>1.0 || tc.y<0.0 || tc.x>1.0 || tc.x<0.0)\n            {\n                colNew.rgb=base.rgb;\n                am=0.0;\n            }\n\n        #endif\n    #endif\n\n\n\n    #ifndef PREMUL\n        blendRGBA.rgb=mix(colNew,base,1.0-(am*blendRGBA.a));\n        blendRGBA.a=clamp(baseRGBA.a+(blendRGBA.a*am),0.,1.);\n    #endif\n\n    #ifdef PREMUL\n        // premultiply\n        // blendRGBA.rgb = (blendRGBA.rgb) + (baseRGBA.rgb * (1.0 - blendRGBA.a));\n        blendRGBA=vec4(\n            mix(colNew.rgb,base,1.0-(am*blendRGBA.a)),\n            blendRGBA.a*am+baseRGBA.a\n            );\n    #endif\n\n    #ifdef ALPHA_MASK\n    blendRGBA.a=baseRGBA.a;\n    #endif\n\n    outColor=blendRGBA;\n}\n\n\n\n\n\n\n\n","drawimage_vert":"IN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\n\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\n\nOUT vec2 texCoord;\n// OUT vec3 norm;\n\n#ifdef TEX_TRANSFORM\n    UNI float posX;\n    UNI float posY;\n    UNI float scaleX;\n    UNI float scaleY;\n    UNI float rotate;\n    OUT mat3 transform;\n#endif\n\nvoid main()\n{\n   texCoord=attrTexCoord;\n//   norm=attrVertNormal;\n\n   #ifdef TEX_TRANSFORM\n        vec3 coordinates=vec3(attrTexCoord.x, attrTexCoord.y,1.0);\n        float angle = radians( rotate );\n        vec2 scale= vec2(scaleX,scaleY);\n        vec2 translate= vec2(posX,posY);\n\n        transform = mat3(   scale.x * cos( angle ), scale.x * sin( angle ), 0.0,\n            - scale.y * sin( angle ), scale.y * cos( angle ), 0.0,\n            - 0.5 * scale.x * cos( angle ) + 0.5 * scale.y * sin( angle ) - 0.5 * translate.x*2.0 + 0.5,  - 0.5 * scale.x * sin( angle ) - 0.5 * scale.y * cos( angle ) - 0.5 * translate.y*2.0 + 0.5, 1.0);\n   #endif\n\n   gl_Position = projMatrix * mvMatrix * vec4(vPosition,  1.0);\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "blendMode"),
    amount = op.inValueSlider("amount", 1),

    image = op.inTexture("Image"),
    inAlphaPremul = op.inValueBool("Premultiplied", false),
    inAlphaMask = op.inValueBool("Alpha Mask", false),
    removeAlphaSrc = op.inValueBool("removeAlphaSrc", false),

    imageAlpha = op.inTexture("Mask"),
    alphaSrc = op.inValueSelect("Mask Src", ["alpha channel", "luminance", "luminance inv"], "luminance"),
    invAlphaChannel = op.inValueBool("Invert alpha channel"),

    inAspect = op.inValueBool("Aspect Ratio", false),
    inAspectAxis = op.inValueSelect("Stretch Axis", ["X", "Y"], "X"),
    inAspectPos = op.inValueSlider("Position", 0.0),
    inAspectCrop = op.inValueBool("Crop", false),

    trigger = op.outTrigger("trigger");

blendMode.set("normal");
const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "drawimage");

imageAlpha.onLinkChanged = updateAlphaPorts;

op.setPortGroup("Mask", [imageAlpha, alphaSrc, invAlphaChannel]);
op.setPortGroup("Aspect Ratio", [inAspect, inAspectPos, inAspectCrop, inAspectAxis]);

function updateAlphaPorts()
{
    if (imageAlpha.isLinked())
    {
        removeAlphaSrc.setUiAttribs({ "greyout": true });
        alphaSrc.setUiAttribs({ "greyout": false });
        invAlphaChannel.setUiAttribs({ "greyout": false });
    }
    else
    {
        removeAlphaSrc.setUiAttribs({ "greyout": false });
        alphaSrc.setUiAttribs({ "greyout": true });
        invAlphaChannel.setUiAttribs({ "greyout": true });
    }
}

op.toWorkPortsNeedToBeLinked(image);

shader.setSource(attachments.drawimage_vert, attachments.drawimage_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureImaghe = new CGL.Uniform(shader, "t", "image", 1),
    textureAlpha = new CGL.Uniform(shader, "t", "imageAlpha", 2),
    uniTexAspect = new CGL.Uniform(shader, "f", "aspectTex", 1),
    uniAspectPos = new CGL.Uniform(shader, "f", "aspectPos", inAspectPos);

inAspect.onChange =
    inAspectCrop.onChange =
    inAspectAxis.onChange = updateAspectRatio;

function updateAspectRatio()
{
    shader.removeDefine("ASPECT_AXIS_X");
    shader.removeDefine("ASPECT_AXIS_Y");
    shader.removeDefine("ASPECT_CROP");

    inAspectPos.setUiAttribs({ "greyout": !inAspect.get() });
    inAspectCrop.setUiAttribs({ "greyout": !inAspect.get() });
    inAspectAxis.setUiAttribs({ "greyout": !inAspect.get() });

    if (inAspect.get())
    {
        shader.define("ASPECT_RATIO");

        if (inAspectCrop.get()) shader.define("ASPECT_CROP");

        if (inAspectAxis.get() == "X") shader.define("ASPECT_AXIS_X");
        if (inAspectAxis.get() == "Y") shader.define("ASPECT_AXIS_Y");
    }
    else
    {
        shader.removeDefine("ASPECT_RATIO");
        if (inAspectCrop.get()) shader.define("ASPECT_CROP");

        if (inAspectAxis.get() == "X") shader.define("ASPECT_AXIS_X");
        if (inAspectAxis.get() == "Y") shader.define("ASPECT_AXIS_Y");
    }
}

alphaSrc.set("alpha channel");

//
// texture flip
//
const flipX = op.inValueBool("flip x");
const flipY = op.inValueBool("flip y");

//
// texture transform
//

let doTransform = op.inValueBool("Transform");

let scaleX = op.inValueSlider("Scale X", 1);
let scaleY = op.inValueSlider("Scale Y", 1);

let posX = op.inValue("Position X", 0);
let posY = op.inValue("Position Y", 0);

let rotate = op.inValue("Rotation", 0);

const inClipRepeat = op.inValueBool("Clip Repeat", false);

const uniScaleX = new CGL.Uniform(shader, "f", "scaleX", scaleX);
const uniScaleY = new CGL.Uniform(shader, "f", "scaleY", scaleY);
const uniPosX = new CGL.Uniform(shader, "f", "posX", posX);
const uniPosY = new CGL.Uniform(shader, "f", "posY", posY);
const uniRotate = new CGL.Uniform(shader, "f", "rotate", rotate);

doTransform.onChange = updateTransformPorts;

function updateTransformPorts()
{
    shader.toggleDefine("TEX_TRANSFORM", doTransform.get());

    scaleX.setUiAttribs({ "greyout": !doTransform.get() });
    scaleY.setUiAttribs({ "greyout": !doTransform.get() });
    posX.setUiAttribs({ "greyout": !doTransform.get() });
    posY.setUiAttribs({ "greyout": !doTransform.get() });
    rotate.setUiAttribs({ "greyout": !doTransform.get() });
}

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

render.onTriggered = doRender;

inClipRepeat.onChange =
    imageAlpha.onChange =
    inAlphaPremul.onChange =
    inAlphaMask.onChange =
    invAlphaChannel.onChange =
    flipY.onChange =
    flipX.onChange =
    removeAlphaSrc.onChange =
    alphaSrc.onChange = updateDefines;

updateTransformPorts();
updateAlphaPorts();
updateAspectRatio();
updateDefines();

function updateDefines()
{
    shader.toggleDefine("REMOVE_ALPHA_SRC", removeAlphaSrc.get());
    shader.toggleDefine("ALPHA_MASK", inAlphaMask.get());

    shader.toggleDefine("CLIP_REPEAT", inClipRepeat.get());

    shader.toggleDefine("HAS_TEXTUREALPHA", imageAlpha.get() && imageAlpha.get().tex);

    shader.toggleDefine("TEX_FLIP_X", flipX.get());
    shader.toggleDefine("TEX_FLIP_Y", flipY.get());

    shader.toggleDefine("INVERT_ALPHA", invAlphaChannel.get());

    shader.toggleDefine("ALPHA_FROM_LUMINANCE", alphaSrc.get() == "luminance");
    shader.toggleDefine("ALPHA_FROM_INV_UMINANCE", alphaSrc.get() == "luminance_inv");
    shader.toggleDefine("PREMUL", inAlphaPremul.get());
}

function doRender()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    const tex = image.get();
    if (tex && tex.tex && amount.get() > 0.0)
    {
        cgl.pushShader(shader);
        cgl.currentTextureEffect.bind();

        const imgTex = cgl.currentTextureEffect.getCurrentSourceTexture();
        cgl.setTexture(0, imgTex.tex);

        if (imgTex && tex)
        {
            if (tex.textureType != imgTex.textureType && (tex.textureType != CGL.Texture.TYPE_FLOAT || imgTex.textureType != CGL.Texture.TYPE_FLOAT))
                op.setUiError("textypediff", "Drawing 32bit texture into an 8 bit can result in data/precision loss", 1);
            else
                op.setUiError("textypediff", null);
        }

        const asp = 1 / (cgl.currentTextureEffect.getWidth() / cgl.currentTextureEffect.getHeight()) * (tex.width / tex.height);
        // uniTexAspect.setValue(1 / (tex.height / tex.width * imgTex.width / imgTex.height));

        uniTexAspect.setValue(asp);

        cgl.setTexture(1, tex.tex);
        // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, image.get().tex );

        if (imageAlpha.get() && imageAlpha.get().tex)
        {
            cgl.setTexture(2, imageAlpha.get().tex);
            // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, imageAlpha.get().tex );
        }

        // cgl.pushBlend(false);

        cgl.pushBlendMode(CGL.BLEND_NONE, true);

        cgl.currentTextureEffect.finish();
        cgl.popBlendMode();

        // cgl.popBlend();

        cgl.popShader();
    }

    trigger.trigger();
}


};

Ops.Gl.TextureEffects.DrawImage_v3.prototype = new CABLES.Op();
CABLES.OPS["8f6b2f15-fcb0-4597-90c0-e5173f2969fe"]={f:Ops.Gl.TextureEffects.DrawImage_v3,objName:"Ops.Gl.TextureEffects.DrawImage_v3"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.EdgeDetection_v4
// 
// **************************************************************

Ops.Gl.TextureEffects.EdgeDetection_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"edgedetect_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float width;\nUNI float strength;\nUNI float texWidth;\nUNI float texHeight;\nUNI float mulColor;\n\nconst vec4 lumcoeff = vec4(0.299,0.587,0.114, 0.);\n\nvec3 desaturate(vec3 color)\n{\n    return vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n}\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    // vec4 col=vec4(1.0,0.0,0.0,1.0);\n\n    // float pixelX=0.27/texWidth;\n    // float pixelY=0.27/texHeight;\n    float pixelX=(width+0.01)*4.0/texWidth;\n    float pixelY=(width+0.01)*4.0/texHeight;\n\nvec2 tc=texCoord;\n// #ifdef OFFSETPIXEL\n    tc.x+=1.0/texWidth*0.5;\n    tc.y+=1.0/texHeight*0.5;\n// #endif\n    // col=texture(tex,texCoord);\n\n    float count=1.0;\n    vec4 base=texture(tex,texCoord);\n\n\tvec4 horizEdge = vec4( 0.0 );\n\thorizEdge -= texture( tex, vec2( tc.x - pixelX, tc.y - pixelY ) ) * 1.0;\n\thorizEdge -= texture( tex, vec2( tc.x - pixelX, tc.y     ) ) * 2.0;\n\thorizEdge -= texture( tex, vec2( tc.x - pixelX, tc.y + pixelY ) ) * 1.0;\n\thorizEdge += texture( tex, vec2( tc.x + pixelX, tc.y - pixelY ) ) * 1.0;\n\thorizEdge += texture( tex, vec2( tc.x + pixelX, tc.y     ) ) * 2.0;\n\thorizEdge += texture( tex, vec2( tc.x + pixelX, tc.y + pixelY ) ) * 1.0;\n\tvec4 vertEdge = vec4( 0.0 );\n\tvertEdge -= texture( tex, vec2( tc.x - pixelX, tc.y - pixelY ) ) * 1.0;\n\tvertEdge -= texture( tex, vec2( tc.x    , tc.y - pixelY ) ) * 2.0;\n\tvertEdge -= texture( tex, vec2( tc.x + pixelX, tc.y - pixelY ) ) * 1.0;\n\tvertEdge += texture( tex, vec2( tc.x - pixelX, tc.y + pixelY ) ) * 1.0;\n\tvertEdge += texture( tex, vec2( tc.x    , tc.y + pixelY ) ) * 2.0;\n\tvertEdge += texture( tex, vec2( tc.x + pixelX, tc.y + pixelY ) ) * 1.0;\n\n\thorizEdge*=base.a;\n\tvertEdge*=base.a;\n\n\n\tvec3 edge = sqrt((horizEdge.rgb/count * horizEdge.rgb/count) + (vertEdge.rgb/count * vertEdge.rgb/count));\n\n    edge=desaturate(edge);\n    edge*=strength;\n\n    if(mulColor>0.0) edge*=texture( tex, texCoord ).rgb*mulColor*4.0;\n    edge=max(min(edge,1.0),0.0);\n\n    //blend section\n    vec4 col=vec4(edge,base.a);\n\n    outColor=cgl_blendPixel(base,col,amount*base.a);\n}\n\n",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    strength = op.inFloat("Strength", 4.0),
    width = op.inValueSlider("Width", 0.1),
    mulColor = op.inValueSlider("Mul Color", 0),
    trigger = op.outTrigger("Trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.edgedetect_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    strengthUniform = new CGL.Uniform(shader, "f", "strength", strength),
    widthUniform = new CGL.Uniform(shader, "f", "width", width),
    uniWidth = new CGL.Uniform(shader, "f", "texWidth", 128),
    uniHeight = new CGL.Uniform(shader, "f", "texHeight", 128),
    uniMulColor = new CGL.Uniform(shader, "f", "mulColor", mulColor);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    uniWidth.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniHeight.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().height);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.EdgeDetection_v4.prototype = new CABLES.Op();
CABLES.OPS["0240e26e-b86d-43b2-8c72-6795bb86dc76"]={f:Ops.Gl.TextureEffects.EdgeDetection_v4,objName:"Ops.Gl.TextureEffects.EdgeDetection_v4"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Emboss
// 
// **************************************************************

Ops.Gl.TextureEffects.Emboss = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"emboss_frag":"#ifdef HAS_TEXTURES\n  IN vec2 texCoord;\n  UNI sampler2D tex;\n  UNI float texSizeX;\n  UNI float texSizeY;\n#endif\n\nUNI float strength;\n\nvoid main()\n{\n    vec4 orig=texture(tex, texCoord);\n    vec2 texelSize=vec2(texSizeX,texSizeY);\n\n    float tl = abs(texture(tex, texCoord + texelSize * vec2(-1.0, -1.0)).x); // top left\n    float  l = abs(texture(tex, texCoord + texelSize * vec2(-1.0,  0.0)).x); // left\n    float bl = abs(texture(tex, texCoord + texelSize * vec2(-1.0,  1.0)).x); // bottom left\n    float  t = abs(texture(tex, texCoord + texelSize * vec2( 0.0, -1.0)).x); // top\n    float  b = abs(texture(tex, texCoord + texelSize * vec2( 0.0,  1.0)).x); // bottom\n    float tr = abs(texture(tex, texCoord + texelSize * vec2( 1.0, -1.0)).x); // top right\n    float  r = abs(texture(tex, texCoord + texelSize * vec2( 1.0,  0.0)).x); // right\n    float br = abs(texture(tex, texCoord + texelSize * vec2( 1.0,  1.0)).x); // bottom right\n\n    float dX = tr + 2.0*r + br -tl - 2.0*l - bl;\n    float dY = bl + 2.0*b + br -tl - 2.0*t - tr;\n\n    vec4 N=vec4(1.0);\n\n    N.rgb=orig.rgb;\n\n    #ifdef CLEAR\n        N.rgb=vec3(0.5,0.5,0.5);\n    #endif\n\n    N.rgb-=vec3(dY)*strength;\n    N.rgb+=vec3(dX)*strength;\n\n   outColor= N;\n}",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    strength = op.inValue("Strength", 4),
    clear = op.inValueBool("Clear", true),
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.emboss_frag || "");
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let uniStrength = new CGL.Uniform(shader, "f", "strength", strength);
let unitexSizeX = new CGL.Uniform(shader, "f", "texSizeX", 1024);
let unitexSizeY = new CGL.Uniform(shader, "f", "texSizeY", 1024);

clear.onChange = updateClear;
updateClear();

function updateClear()
{
    if (clear.get())shader.define("CLEAR");
    else shader.removeDefine("CLEAR");
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    unitexSizeX.set(1.0 / cgl.currentTextureEffect.getCurrentSourceTexture().width);
    unitexSizeY.set(1.0 / cgl.currentTextureEffect.getCurrentSourceTexture().height);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Emboss.prototype = new CABLES.Op();
CABLES.OPS["e973e104-392a-44f0-bbc5-c382a08c15df"]={f:Ops.Gl.TextureEffects.Emboss,objName:"Ops.Gl.TextureEffects.Emboss"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.FXAA
// 
// **************************************************************

Ops.Gl.TextureEffects.FXAA = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"fxaa_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float FXAA_SPAN_MAX;\nUNI float FXAA_REDUCE_MUL;\nUNI float FXAA_REDUCE_MIN;\nUNI float width;\nUNI float height;\n\nvec4 getColorFXAA(vec2 coord)\n{\n    vec2 invtexsize=vec2(1.0/width,1.0/height);\n\n    float step=1.0;\n\n    vec3 rgbNW = texture(tex, coord.xy + (vec2(-step, -step)*invtexsize )).xyz;\n    vec3 rgbNE = texture(tex, coord.xy + (vec2(+step, -step)*invtexsize )).xyz;\n    vec3 rgbSW = texture(tex, coord.xy + (vec2(-step, +step)*invtexsize )).xyz;\n    vec3 rgbSE = texture(tex, coord.xy + (vec2(+step, +step)*invtexsize )).xyz;\n    vec3 rgbM  = texture(tex, coord.xy).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot( rgbM, luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin))*invtexsize ;\n\n    vec3 rgbA = (1.0/2.0) * (\n                texture(tex, coord.xy + dir * (1.0/3.0 - 0.5)).xyz +\n                texture(tex, coord.xy + dir * (2.0/3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n                texture(tex, coord.xy + dir * (0.0/3.0 - 0.5)).xyz +\n                texture(tex, coord.xy + dir * (3.0/3.0 - 0.5)).xyz);\n    float lumaB = dot(rgbB, luma);\n\n    vec4 color=texture(tex,coord).rgba;\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)){\n      color.xyz=rgbA;\n    } else {\n      color.xyz=rgbB;\n    }\n    return color;\n}\n\nvoid main()\n{\n   vec4 col=vec4(1.0,0.0,0.0,1.0);\n   outColor= getColorFXAA(texCoord);\n}",};
// shader from: https://github.com/mattdesl/glsl-fxaa

let render = op.inTrigger("render");
let trigger = op.outTrigger("trigger");
let fxaa_span = op.inValueSelect("span", [0, 2, 4, 8, 16, 32, 64]);
let fxaa_reduceMin = op.inValueFloat("reduceMin");
let fxaa_reduceMul = op.inValueFloat("reduceMul");
let useVPSize = op.inValueBool("use viewport size", true);
let texWidth = op.inValueInt("width");
let texHeight = op.inValueInt("height");

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.fxaa_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;
    cgl.pushShader(shader);

    if (cgl.getViewPort()[2] != texWidth.get() || cgl.getViewPort()[3] != texHeight.get())
    {
        changeRes();
    }

    cgl.currentTextureEffect.bind();
    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);


    cgl.currentTextureEffect.finish();

    cgl.popShader();

    trigger.trigger();
};


let uniformSpan = new CGL.Uniform(shader, "f", "FXAA_SPAN_MAX", 0);
let uniformMul = new CGL.Uniform(shader, "f", "FXAA_REDUCE_MUL", 0);
let uniformMin = new CGL.Uniform(shader, "f", "FXAA_REDUCE_MIN", 0);

fxaa_span.onChange = function ()
{
    uniformSpan.setValue(parseInt(fxaa_span.get(), 10));
};

let uWidth = new CGL.Uniform(shader, "f", "width", 0);
let uHeight = new CGL.Uniform(shader, "f", "height", 0);

function changeRes()
{
    if (useVPSize.get())
    {
        let w = cgl.getViewPort()[2];
        let h = cgl.getViewPort()[3];
        uWidth.setValue(w);
        uHeight.setValue(h);
        // texWidth.set(w);
        // texHeight.set(h);
    }
    else
    {
        uWidth.setValue(texWidth.get());
        uHeight.setValue(texHeight.get());
    }
}

texWidth.onChange = changeRes;
texHeight.onChange = changeRes;
useVPSize.onChange = changeRes;
op.onResize = changeRes;

fxaa_span.set(8);
// texWidth.set(1920);
// texHeight.set(1080);

fxaa_reduceMul.onChange = function ()
{
    uniformMul.setValue(1.0 / fxaa_reduceMul.get());
};

fxaa_reduceMin.onChange = function ()
{
    uniformMin.setValue(1.0 / fxaa_reduceMin.get());
};

fxaa_reduceMul.set(8);
fxaa_reduceMin.set(128);


};

Ops.Gl.TextureEffects.FXAA.prototype = new CABLES.Op();
CABLES.OPS["3e679c17-f050-4bc8-bfe5-5b9190e7ce40"]={f:Ops.Gl.TextureEffects.FXAA,objName:"Ops.Gl.TextureEffects.FXAA"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.FastBlur_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.FastBlur_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"blur_frag":"\nUNI sampler2D tex;\n#ifdef USE_MASK\n    UNI sampler2D texMask;\n#endif\nUNI float amount;\nUNI float pass;\n\nIN vec2 texCoord;\n\nUNI float dirX;\nUNI float dirY;\nUNI float width;\nUNI float height;\n\nIN vec2 coord0;\nIN vec2 coord1;\nIN vec2 coord2;\nIN vec2 coord3;\nIN vec2 coord4;\nIN vec2 coord5;\nIN vec2 coord6;\n\n#ifdef HAS_MASK\n    UNI sampler2D imageMask;\n#endif\n\nvoid main()\n{\n    vec4 color = vec4(0.0);\n\n    #ifdef USE_MASK\n        #ifdef MASK_INVERT\n            if(texture(texMask,texCoord).r<0.5)\n            {\n                outColor= texture(tex, texCoord);\n                return;\n            }\n        #endif\n\n        #ifndef MASK_INVERT\n            if(texture(texMask,texCoord).r>0.5)\n            {\n                outColor= texture(tex, texCoord);\n                return;\n            }\n        #endif\n    #endif\n\n    color += texture(tex, coord0) * 0.06927096443792478;\n    color += texture(tex, coord1) * 0.1383328848652136;\n    color += texture(tex, coord2) * 0.21920904690397863;\n    color += texture(tex, coord3) * 0.14637421;\n    color += texture(tex, coord4) * 0.21920904690397863;\n    color += texture(tex, coord5) * 0.1383328848652136;\n    color += texture(tex, coord6) * 0.06927096443795711;\n\n    outColor= color;\n}","blur_vert":"\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\nUNI mat4 modelMatrix;\n\nUNI float pass;\nUNI float dirX;\nUNI float dirY;\nUNI float width;\nUNI float height;\n\nOUT vec2 coord0;\nOUT vec2 coord1;\nOUT vec2 coord2;\nOUT vec2 coord3;\nOUT vec2 coord4;\nOUT vec2 coord5;\nOUT vec2 coord6;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n    {{MODULE_VERTEX_POSITION}}\n\n    vec2 dir=vec2(dirX,dirY);\n    vec2 res=vec2( (1.) / width , (1.) / height )*dir;\n\n    coord3= attrTexCoord;\n\n    coord0= attrTexCoord + (-3.0368997744118595 * res);\n    coord1= attrTexCoord + (-2.089778445362373 * res);\n    coord2= attrTexCoord + (-1.2004366090034069 * res);\n    coord4= attrTexCoord + (1.2004366090034069 * res);\n    coord5= attrTexCoord + (2.089778445362373* res);\n    coord6= attrTexCoord + (3.0368997744118595 * res);\n\n    #ifdef CLAMP\n        coord0=clamp(coord0,0.0,1.0);\n        coord1=clamp(coord1,0.0,1.0);\n        coord2=clamp(coord2,0.0,1.0);\n        coord3=clamp(coord3,0.0,1.0);\n        coord4=clamp(coord4,0.0,1.0);\n        coord5=clamp(coord5,0.0,1.0);\n        coord6=clamp(coord6,0.0,1.0);\n    #endif\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
// http://dev.theomader.com/gaussian-kernel-calculator/
// http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/

const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    inPasses = op.inFloat("Passes", 3),
    clamp = op.inBool("Clamp", false),
    direction = op.inDropDown("direction", ["both", "vertical", "horizontal"], "both"),
    mask = op.inTexture("Mask"),
    maskInvert = op.inBool("Mask Invert", false);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "fastblur");

op.setPortGroup("Mask", [mask, maskInvert]);

shader.setSource(attachments.blur_vert, attachments.blur_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniDirX = new CGL.Uniform(shader, "f", "dirX", 0),
    uniDirY = new CGL.Uniform(shader, "f", "dirY", 0),
    uniWidth = new CGL.Uniform(shader, "f", "width", 0),
    uniHeight = new CGL.Uniform(shader, "f", "height", 0),
    uniPass = new CGL.Uniform(shader, "f", "pass", 0),
    uniAmount = new CGL.Uniform(shader, "f", "amount", inPasses.get()),
    textureAlpha = new CGL.Uniform(shader, "t", "texMask", 1);

inPasses.onChange = () => { uniAmount.setValue(inPasses.get()); };

let dir = 0;
direction.onChange = () =>
{
    if (direction.get() == "both") dir = 0;
    if (direction.get() == "horizontal") dir = 1;
    if (direction.get() == "vertical") dir = 2;
};

clamp.onChange = () => { shader.toggleDefine("CLAMP", clamp.get()); };

maskInvert.onChange =
    mask.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("USE_MASK", mask.isLinked());
    shader.toggleDefine("MASK_INVERT", maskInvert.get());

    maskInvert.setUiAttribs({ "greyout": !mask.isLinked() });
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    uniWidth.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniHeight.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().height);
    const numPasses = inPasses.get();

    if (mask.get())cgl.setTexture(1, mask.get().tex);

    for (let i = 0; i < numPasses; i++)
    {
        cgl.pushShader(shader);

        uniPass.setValue(i / numPasses);

        // first pass
        if (dir === 0 || dir == 2)
        {
            cgl.currentTextureEffect.bind();
            cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

            uniDirX.setValue(0.0);
            uniDirY.setValue(1.0 + (i * i));

            cgl.currentTextureEffect.finish();
        }

        // second pass
        if (dir === 0 || dir == 1)
        {
            cgl.currentTextureEffect.bind();
            cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

            uniDirX.setValue(1.0 + (i * i));
            uniDirY.setValue(0.0);

            cgl.currentTextureEffect.finish();
        }

        cgl.popShader();
    }

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.FastBlur_v2.prototype = new CABLES.Op();
CABLES.OPS["61ed277f-d096-43b2-9de8-dc87fb3a9169"]={f:Ops.Gl.TextureEffects.FastBlur_v2,objName:"Ops.Gl.TextureEffects.FastBlur_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Flip
// 
// **************************************************************

Ops.Gl.TextureEffects.Flip = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"flip_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float x;\nUNI float y;\n\nvoid main()\n{\n   vec4 col=vec4(1.0,0.0,0.0,1.0);\n   col=texture(tex,vec2(abs(x-texCoord.x),abs(y-texCoord.y)));\n   outColor= col;\n}",};
const render = op.inTrigger("render");
const x = op.inValueBool("X");
const y = op.inValueBool("Y");
const trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.flip_frag);

const uniTexture = new CGL.Uniform(shader, "t", "tex", 0);
const uniX = new CGL.Uniform(shader, "f", "x", x);
const uniY = new CGL.Uniform(shader, "f", "y", y);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Flip.prototype = new CABLES.Op();
CABLES.OPS["ce36ad01-411a-412f-affa-1959aa23f93b"]={f:Ops.Gl.TextureEffects.Flip,objName:"Ops.Gl.TextureEffects.Flip"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Float32ToRgbeTexture
// 
// **************************************************************

Ops.Gl.TextureEffects.Float32ToRgbeTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbe2fp_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\n\n\n// highp vec3 decodeRGBE8(highp vec4 rgbe)\n// {\n//     highp vec3 vDecoded = rgbe.rgb * pow(2.0, rgbe.a * 255.0-128.0);\n//     return vDecoded;\n// }\nvec4 encodeRGBE8( vec3 rgb )\n{\n    vec4 vEncoded;\n    float maxComponent = max(max(rgb.r, rgb.g), rgb.b );\n    float fExp = ceil( log2(maxComponent) );\n    vEncoded.rgb = rgb / exp2(fExp);\n    vEncoded.a = (fExp + 128.0) / 255.0;\n    return vEncoded;\n}\n\n\nvoid main()\n{\n    vec4 col=vec4( encodeRGBE8(texture(tex,texCoord).rgb));\n\n    outColor= col;\n}",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.rgbe2fp_frag);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Float32ToRgbeTexture.prototype = new CABLES.Op();
CABLES.OPS["ae3585c4-b49a-4dd5-b7be-1f53a90bb060"]={f:Ops.Gl.TextureEffects.Float32ToRgbeTexture,objName:"Ops.Gl.TextureEffects.Float32ToRgbeTexture"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Fog_v4
// 
// **************************************************************

Ops.Gl.TextureEffects.Fog_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"fog_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D texDepth;\n\n#ifdef HAS_GRADIENT_TEX\n    UNI sampler2D texGradient;\n#endif\n\n#ifdef HAS_BG_TEX\n    UNI sampler2D texBg;\n#endif\n\nUNI float nearPlane;\nUNI float farPlane;\nUNI float inAmount;\nUNI vec4 inFogColor;\nUNI float inFogDensity;\nUNI float inFogStart;\nUNI float inFogEnd;\n\n{{CGL.BLENDMODES3}}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat CalcFogDensity(float depth) {\n    float newDepth = map(depth, nearPlane, farPlane, 0., 1.);\n    float fogAmount = 1.0 - clamp((inFogEnd - depth) / (inFogEnd - inFogStart), 0.0, 1.0);\n\n    // EXPONENTIAL: fogAmount = 1. - exp(MAGIC_NUMBER * -inFogDensity * newDepth); // smoothstep(fogStart, fogEnd, newDepth));\n    // EXP2: fogAmount = 1. - exp(-pow(MAGIC_NUMBER * inFogDensity * smoothstep(fogStart, fogEnd, newDepth), 2.0));\n\n    fogAmount *= inFogDensity;\n\n    return fogAmount;\n}\n\nvoid main()\n{\n    vec4 color = texture(tex, texCoord);\n\n    float depthFromTexture = texture(texDepth,texCoord).r;\n\n    float distanceToCamera_viewSpace = (nearPlane * farPlane) / (farPlane - depthFromTexture * (farPlane - nearPlane));\n\n    float fogAmount = CalcFogDensity(distanceToCamera_viewSpace);\n\n    vec4 fogColor = inFogColor;\n\n    #ifdef HAS_GRADIENT_TEX\n        vec4 fogColTex = texture(texGradient, vec2(clamp(distanceToCamera_viewSpace / (farPlane - nearPlane), 0.0, 0.9999),0.5));\n        fogColor *= fogColTex;\n    #endif\n\n    #ifdef HAS_BG_TEX\n        vec4 fogColTexBg = texture(texBg, texCoord);\n        fogColor *= fogColTexBg;\n\n    #endif\n\n    fogColor = color * (1.0 - fogAmount) + fogColor * fogAmount;\n    // fogColor = mix(color, fogColor, fogAmount);\n\n\n    outColor = cgl_blendPixel(color, fogColor, inAmount);\n\n}\n","fog_vert":"IN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\n\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord = attrTexCoord;\n    norm = attrVertNormal;\n    vec4 pos = vec4(vPosition,  1.0);\n\n    {{MODULE_VERTEX_POSITION}}\n\n    gl_Position = projMatrix * mvMatrix * pos;\n\n}\n",};
const cgl = op.patch.cgl;

const render = op.inTrigger("render");
const blendMode = CGL.TextureEffect.AddBlendSelect(op, "blendMode");
const inAmount = op.inFloatSlider("Amount", 1);
const image = op.inTexture("Depth Texture");
const inGradientTexture = op.inTexture("Gradient Texture");
const inBgTex = op.inTexture("Background Texture");
const inFogStart = op.inFloat("Fog Start", 1);
const inFogEnd = op.inFloat("Fog End", 8);
const inFogDensity = op.inFloatSlider("Fog Density", 1);
const nearPlane = op.inFloat("nearplane", 0.1);
const farPlane = op.inFloat("farplane", 20);
const inFogR = op.inFloatSlider("Fog R", 0.6);
const inFogG = op.inFloatSlider("Fog G", 0.6);
const inFogB = op.inFloatSlider("Fog B", 0.6);
const inFogA = op.inFloatSlider("Fog A", 1);
inFogR.setUiAttribs({ "colorPick": true });

const trigger = op.outTrigger("trigger");

op.setPortGroup("Textures", [image, inGradientTexture, inBgTex]);
op.setPortGroup("Frustum", [farPlane, nearPlane]);
op.setPortGroup("Fog Options", [inFogStart, inFogEnd, inFogDensity]);
op.setPortGroup("Fog Color", [inFogR, inFogG, inFogB, inFogA]);

const shader = new CGL.Shader(cgl, "Fog");
const srcFrag = attachments.fog_frag;
const srcVert = attachments.fog_vert;
shader.setSource(srcVert, srcFrag);

const uniAmount = new CGL.Uniform(shader, "f", "inAmount", inAmount);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const depthTextureUniform = new CGL.Uniform(shader, "t", "texDepth", 1);
const uniGradientTexture = new CGL.Uniform(shader, "t", "texGradient", 2);
const uniBgTexture = new CGL.Uniform(shader, "t", "texBg", 3);

const uniFarplane = new CGL.Uniform(shader, "f", "farPlane", farPlane);
const uniNearplane = new CGL.Uniform(shader, "f", "nearPlane", nearPlane);

const uniAspect = new CGL.Uniform(shader, "f", "aspectRatio", 0);
const uniFogColor = new CGL.Uniform(shader, "4f", "inFogColor", inFogR, inFogG, inFogB, inFogA);
const uniFogDensity = new CGL.Uniform(shader, "f", "inFogDensity", inFogDensity);
const uniFogStart = new CGL.Uniform(shader, "f", "inFogStart", inFogStart);
const uniFogEnd = new CGL.Uniform(shader, "f", "inFogEnd", inFogEnd);

CGL.TextureEffect.setupBlending(op, shader, blendMode, inAmount);

let texturesChanged = false;
inGradientTexture.onChange =
inBgTex.onChange = () =>
{
    texturesChanged = true;
};

function updateDefines()
{
    shader.toggleDefine("HAS_BG_TEX", inBgTex.get() && inBgTex.get().tex);

    if (inGradientTexture.get() && inGradientTexture.get().tex) shader.define("HAS_GRADIENT_TEX");
    else shader.removeDefine("HAS_GRADIENT_TEX");
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;
    if (!image.get())
    {
        op.setUiError("noDepthTex", "This op needs a depth texture to work properly!", 0);
    }
    else
    {
        op.setUiError("noDepthTex", null);
    }

    if (texturesChanged)updateDefines();

    if (image.get() && image.get().tex)
    {
        const a =
            cgl.currentTextureEffect.getCurrentSourceTexture().height
            / cgl.currentTextureEffect.getCurrentSourceTexture().width;

        uniAspect.set(a);

        cgl.pushShader(shader);
        cgl.currentTextureEffect.bind();

        cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
        if (image.get()) cgl.setTexture(1, image.get().tex);
        if (inGradientTexture.get()) cgl.setTexture(2, inGradientTexture.get().tex);
        if (inBgTex.get()) cgl.setTexture(3, inBgTex.get().tex);
        cgl.currentTextureEffect.finish();
        cgl.popShader();
    }

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Fog_v4.prototype = new CABLES.Op();
CABLES.OPS["9d52bb1d-cf80-4f75-a80b-bdca16421d65"]={f:Ops.Gl.TextureEffects.Fog_v4,objName:"Ops.Gl.TextureEffects.Fog_v4"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.GammaCorrection_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.GammaCorrection_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"gamma_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float multiplyAmount;\nUNI float gammaAmount;\n\n{{CGL.BLENDMODES}}\n\nvoid main()\n{\n    vec4 base4=texture(tex,texCoord);\n    vec3 color = base4.rgb * multiplyAmount;\n\n    outColor= vec4(\n            mix(\n                color,\n                vec3(pow(color,vec3(1.0 / gammaAmount))\n            ),amount),\n            base4.a);\n}",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    inMultiply = op.inValue("Multiply texture", 1.0),
    inGamma = op.inValue("Gamma correction", 2.2),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.gamma_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
const multiplyUniform = new CGL.Uniform(shader, "f", "multiplyAmount", inMultiply);
const gammaUniform = new CGL.Uniform(shader, "f", "gammaAmount", inGamma);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.GammaCorrection_v2.prototype = new CABLES.Op();
CABLES.OPS["18da81c9-bcae-4446-ac58-d3ba31808013"]={f:Ops.Gl.TextureEffects.GammaCorrection_v2,objName:"Ops.Gl.TextureEffects.GammaCorrection_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Gradient_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Gradient_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"gradient_frag":"IN vec2 texCoord;\nUNI float amount;\nUNI float pos;\nUNI float width;\n\nUNI vec3 colA;\nUNI vec3 colB;\nUNI vec3 colC;\nUNI sampler2D tex;\n\n{{CGL.BLENDMODES3}}\n\n\n\n\nvec3 lin2srgb( vec3 cl )\n{\n\tcl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666,0.41666,0.41666)) - 0.055;\n\treturn vec3( (cl.r<0.0031308) ? c_lo.r : c_hi.r,\n                (cl.g<0.0031308) ? c_lo.g : c_hi.g,\n                (cl.b<0.0031308) ? c_lo.b : c_hi.b );\n}\n\nvec3 oklab_mix( vec3 colA, vec3 colB, float h )\n{\n    // https://www.shadertoy.com/view/ttcyRS\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(\n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n\n    // rgb to cone (arg of pow can't be negative)\n    vec3 lmsA = pow( kCONEtoLMS*colA, vec3(1.0/3.0) );\n    vec3 lmsB = pow( kCONEtoLMS*colB, vec3(1.0/3.0) );\n    // lerp\n    vec3 lms = mix( lmsA, lmsB, h );\n    // gain in the middle (no oaklab anymore, but looks better?)\n    #ifdef OKLABGAIN\n  lms *= 1.0+0.2*h*(1.0-h);\n  #endif\n    // cone to rgb\n    return kLMStoCONE*(lms*lms*lms);\n}\n\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    vec4 col;\n    float ax=texCoord.x;\n\n    #ifdef GRAD_Y\n        ax=texCoord.y;\n    #endif\n    #ifdef GRAD_XY\n        ax=(texCoord.x+texCoord.y)/2.0;\n    #endif\n    #ifdef GRAD_RADIAL\n        ax=distance(texCoord,vec2(0.5,0.5))*2.0;\n    #endif\n\n    ax=((ax-0.5)*width)+0.5;\nax=clamp(ax,0.0,1.0);\n\n    #ifndef GRAD_SMOOTHSTEP\n        if(ax<=pos) col = vec4(MIXER(colA, colB, ax*1.0/pos),1.0);\n        else col = vec4(MIXER(colB, colC, min(1.0,(ax-pos)*1.0/(1.0-pos))),1.0);\n    #endif\n\n    #ifdef GRAD_SMOOTHSTEP\n        if(ax<=pos) col = vec4(MIXER(colA, colB, smoothstep(0.0,1.0,ax*1.0/pos)),1.0);\n        else col = vec4(MIXER(colB, colC, smoothstep(0.0,1.0,min(1.0,(ax-pos)*1.0/(1.0-pos)))),1.0);\n    #endif\n\n    #ifdef SRGB\n        col.rgb=lin2srgb(col.rgb);\n    #endif\n\n    outColor=cgl_blendPixel(base,col,amount);\n}",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    amount = op.inValueSlider("Amount", 1),
    width = op.inValue("Width", 1),
    gType = op.inSwitch("Type", ["X", "Y", "XY", "Radial"], "X"),
    pos1 = op.inValueSlider("Pos", 0.5),
    smoothStep = op.inValueBool("Smoothstep", true),
    inSrgb = op.inValueBool("sRGB", false),
    inColSpace = op.inSwitch("color space", ["RGB", "Oklab", "OklabG"], "RGB"),

    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),

    r2 = op.inValueSlider("r2", Math.random()),
    g2 = op.inValueSlider("g2", Math.random()),
    b2 = op.inValueSlider("b2", Math.random()),

    r3 = op.inValueSlider("r3", Math.random()),
    g3 = op.inValueSlider("g3", Math.random()),
    b3 = op.inValueSlider("b3", Math.random()),

    randomize = op.inTriggerButton("Randomize"),
    next = op.outTrigger("Next");

r.setUiAttribs({ "colorPick": true });
r2.setUiAttribs({ "colorPick": true });
r3.setUiAttribs({ "colorPick": true });

op.setPortGroup("Blending", [blendMode, amount]);
op.setPortGroup("Color A", [r, g, b]);
op.setPortGroup("Color B", [r2, g2, b2]);
op.setPortGroup("Color C", [r3, g3, b3]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "gradient");

shader.setSource(shader.getDefaultVertexShader(), attachments.gradient_frag);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
const uniPos = new CGL.Uniform(shader, "f", "pos", pos1);
const uniWidth = new CGL.Uniform(shader, "f", "width", width);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let r3uniform, r2uniform, runiform;

r2.onChange = g2.onChange = b2.onChange = updateCol2;
r3.onChange = g3.onChange = b3.onChange = updateCol3;
r.onChange = g.onChange = b.onChange = updateCol;

r2.onLinkChanged = g2.onLinkChanged = b2.onLinkChanged =
r3.onLinkChanged = g3.onLinkChanged = b3.onLinkChanged =
r.onLinkChanged = g.onLinkChanged = b.onLinkChanged = updateUi;

updateCol();
updateCol2();
updateCol3();
updateDefines();

inSrgb.onChange =
inColSpace.onChange =
smoothStep.onChange =
    gType.onChange = updateDefines;

function updateUi()
{
    randomize.setUiAttribs({ "greyout": r2.isLinked() || g2.isLinked() || b2.isLinked() || r3.isLinked() || g3.isLinked() || b3.isLinked() || r.isLinked() || g.isLinked() || b.isLinked() });
}

function updateDefines()
{
    // shader.toggleDefine("OKLABGAIN", inoklabGain.get());
    shader.toggleDefine("SRGB", inSrgb.get());

    shader.define("MIXER", (inColSpace.get() + "").indexOf("Oklab") > -1 ? "oklab_mix" : "mix");
    shader.toggleDefine("OKLABGAIN", (inColSpace.get() + "").indexOf("OklabG") > -1);

    shader.toggleDefine("GRAD_SMOOTHSTEP", smoothStep.get());
    shader.toggleDefine("GRAD_X", gType.get() == "X");
    shader.toggleDefine("GRAD_XY", gType.get() == "XY");
    shader.toggleDefine("GRAD_Y", gType.get() == "Y");
    shader.toggleDefine("GRAD_RADIAL", gType.get() == "Radial");
}

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

randomize.onTriggered = function ()
{
    r.set(Math.random());
    g.set(Math.random());
    b.set(Math.random());

    r2.set(Math.random());
    g2.set(Math.random());
    b2.set(Math.random());

    r3.set(Math.random());
    g3.set(Math.random());
    b3.set(Math.random());

    op.refreshParams();
};

function updateCol()
{
    const colA = [r.get(), g.get(), b.get()];
    if (!runiform) runiform = new CGL.Uniform(shader, "3f", "colA", colA);
    else runiform.setValue(colA);
}

function updateCol2()
{
    const colB = [r2.get(), g2.get(), b2.get()];
    if (!r2uniform) r2uniform = new CGL.Uniform(shader, "3f", "colB", colB);
    else r2uniform.setValue(colB);
}

function updateCol3()
{
    const colC = [r3.get(), g3.get(), b3.get()];
    if (!r3uniform) r3uniform = new CGL.Uniform(shader, "3f", "colC", colC);
    else r3uniform.setValue(colC);
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();
    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    cgl.currentTextureEffect.finish();
    cgl.popShader();

    next.trigger();
};


};

Ops.Gl.TextureEffects.Gradient_v2.prototype = new CABLES.Op();
CABLES.OPS["c8a9408a-75e5-481f-99a7-6aa7ca88bebc"]={f:Ops.Gl.TextureEffects.Gradient_v2,objName:"Ops.Gl.TextureEffects.Gradient_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.GridTexture_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.GridTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"grid_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI bool invertColor;\nUNI float lineThicknessX;\nUNI float lineThicknessY;\nUNI float cellsX;\nUNI float cellsY;\nUNI float offsetX;\nUNI float offsetY;\nUNI float rotate;\n\nUNI float lineR;\nUNI float lineG;\nUNI float lineB;\n\n{{CGL.BLENDMODES3}}\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec2 v)\n{\n\treturn max(v.x, v.y);\n}\nfloat fBox2(vec2 p, vec2 b)\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0.0))) + vmax(min(d, vec2(0.0)));\n}\n\nvec2 pMod2(inout vec2 p, vec2 size)\n{\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\nvoid main()\n{\n    vec2 uv = texCoord;\n    uv -= 0.5;\n    pR(uv.xy,rotate * (TAU));\n    uv += 0.5;\n    uv *= vec2(cellsX,cellsY);\n    uv -= 0.5;\n    uv -= vec2(offsetX,offsetY);\n    pMod2(uv,vec2(1.));\n\n    float box = 0.0;\n\n    if(invertColor) box = 1.0 - sign(fBox2(uv,vec2(lineThicknessX,lineThicknessY)));\n        else box = sign(fBox2(uv,vec2(lineThicknessX,lineThicknessY)));\n    vec4 color = vec4(vec3(box) * vec3(lineR,lineG,lineB),1.0);\n\n    vec4 col=vec4(color);\n    vec4 base=texture(tex,texCoord);\n\n    outColor=cgl_blendPixel(base,col,amount);\n}",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),

    amount = op.inValueSlider("Amount", 1),

    lineThicknessX = op.inValueSlider("Line thickness X", 0.4),
    lineThicknessY = op.inValueSlider("Line thickness Y", 0.4),
    cellsX = op.inValueFloat("Cells X", 10),
    cellsY = op.inValueFloat("Cells Y", 10),
    inRotate = op.inValueSlider("Rotate", 0.0),
    offsetX = op.inValue("Offset X", 0.0),
    offsetY = op.inValue("Offset Y", 0.0),

    invertColor = op.inValueBool("Invert color", false),
    r = op.inValueSlider("Line red", Math.random()),
    g = op.inValueSlider("Line green", Math.random()),
    b = op.inValueSlider("Line Blue", Math.random());

r.setUiAttribs({ "colorPick": true });

op.setPortGroup("LineThickness", [lineThicknessX, lineThicknessY]);
op.setPortGroup("Cells", [cellsX, cellsY]);
op.setPortGroup("Position", [inRotate, offsetX, offsetY]);

const trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.grid_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniInvertColor = new CGL.Uniform(shader, "b", "invertColor", invertColor),
    unilineThicknessX = new CGL.Uniform(shader, "f", "lineThicknessX", lineThicknessX),
    unilineThicknessY = new CGL.Uniform(shader, "f", "lineThicknessY", lineThicknessY),
    unicellsX = new CGL.Uniform(shader, "f", "cellsX", cellsX),
    unicellsY = new CGL.Uniform(shader, "f", "cellsY", cellsY),
    rotateUniform = new CGL.Uniform(shader, "f", "rotate", inRotate),
    offsetXUniform = new CGL.Uniform(shader, "f", "offsetX", offsetX),
    offsetYUniform = new CGL.Uniform(shader, "f", "offsetY", offsetY),
    uniformLineR = new CGL.Uniform(shader, "f", "lineR", r),
    uniformLineG = new CGL.Uniform(shader, "f", "lineG", g),
    uniformLineB = new CGL.Uniform(shader, "f", "lineB", b);


CGL.TextureEffect.setupBlending(op, shader, blendMode, amount,maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.GridTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["4e3c7990-9434-4f41-ad79-dfed8395c460"]={f:Ops.Gl.TextureEffects.GridTexture_v2,objName:"Ops.Gl.TextureEffects.GridTexture_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.GrowPixels_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.GrowPixels_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"outline_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float strength;\nUNI float texWidth,texHeight;\nUNI float r,g,b;\nconst vec4 lumcoeff = vec4(0.299,0.587,0.114, 0.);\n\n{{CGL.BLENDMODES3}}\n\nvec3 desaturate(vec3 color)\n{\n    return vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n}\n\nvoid main()\n{\n    float pixelX=1.0/texWidth*0.5;\n    float pixelY=1.0/texHeight*0.5;\n\n    vec4 co = texture(tex, vec2(texCoord.x, texCoord.y - pixelY ));\n    float n=co.r*co.a;\n    co = texture(tex, vec2(texCoord.x, texCoord.y + pixelY ));\n    float s=co.r*co.a;\n\n    co = texture(tex, vec2(texCoord.x+pixelX, texCoord.y ));\n    float e=co.r*co.a;\n    co = texture(tex, vec2(texCoord.x-pixelX, texCoord.y ));\n    float w=co.r*co.a;\n\n    float c=0.0;\n    if(n+s+e+w/4.0>((1.0-strength)*0.4)) c=1.0;\n\n    vec4 base=texture(tex,texCoord);\n    vec4 col=vec4(r*c,g*c,b*c,base.a+c);\n\n    outColor=cgl_blendPixel(base,col,amount);\n}\n\n",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    strength = op.inValueSlider("strength", 1),
    iter = op.inInt("iterations", 1),
    r = op.inValueSlider("r", 1),
    g = op.inValueSlider("g", 1),
    b = op.inValueSlider("b", 1),
    trigger = op.outTrigger("Trigger");

op.setPortGroup("Look", strength);
r.setUiAttribs({ "colorPick": true });
const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.outline_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    strengthUniform = new CGL.Uniform(shader, "f", "strength", strength),
    uniWidth = new CGL.Uniform(shader, "f", "texWidth", 128),
    uniHeight = new CGL.Uniform(shader, "f", "texHeight", 128),
    unir = new CGL.Uniform(shader, "f", "r", r),
    unig = new CGL.Uniform(shader, "f", "g", g),
    unib = new CGL.Uniform(shader, "f", "b", b);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;


    for (let i = 0; i < Math.floor(iter.get()); i++)
        if (strength.get() > 0.0)
        {
            cgl.pushShader(shader);
            cgl.currentTextureEffect.bind();

            cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

            uniWidth.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width);
            uniHeight.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().height);

            cgl.currentTextureEffect.finish();
            cgl.popShader();
        }

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.GrowPixels_v2.prototype = new CABLES.Op();
CABLES.OPS["f81a7074-7a97-4d1e-bcb8-98f5874a64fc"]={f:Ops.Gl.TextureEffects.GrowPixels_v2,objName:"Ops.Gl.TextureEffects.GrowPixels_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Hue
// 
// **************************************************************

Ops.Gl.TextureEffects.Hue = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"hue_frag":"UNI float hue;\n\n#ifdef HAS_TEXTURES\n  IN vec2 texCoord;\n  UNI sampler2D tex;\n#endif\n\n#ifdef TEX_MASK\n    UNI sampler2D texMask;\n#endif\n#ifdef TEX_OFFSET\n    UNI sampler2D texOffset;\n#endif\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main()\n{\n   vec4 col=vec4(1.0,0.0,0.0,1.0);\n    #ifdef HAS_TEXTURES\n        col=texture(tex,texCoord);\n        float h=hue;\n\n        #ifdef TEX_OFFSET\n            h += texture(texOffset,texCoord).r;\n        #endif\n\n\n        vec3 hsv = rgb2hsv(col.rgb);\n        hsv.x=hsv.x+h;\n\n        #ifndef TEX_MASK\n            col.rgb = hsv2rgb(hsv);\n        #endif\n\n        #ifdef TEX_MASK\n            col.rgb = mix(col.rgb,hsv2rgb(hsv),texture(texMask,texCoord).r);\n        #endif\n\n   #endif\n   outColor= col;\n}",};
const
    render = op.inTrigger("render"),
    hue = op.inValueSlider("hue", 1),
    texMask = op.inTexture("Mask"),
    texOffset = op.inTexture("Offset"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.hue_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

const textureMaskUniform = new CGL.Uniform(shader, "t", "texMask", 1);
const textureOffsetUniform = new CGL.Uniform(shader, "t", "texOffset", 2);

const uniformHue = new CGL.Uniform(shader, "f", "hue", 1.0);

hue.onChange = function () { uniformHue.setValue(hue.get()); };

texMask.onChange =
texOffset.onChange = () =>
{
    shader.toggleDefine("TEX_MASK", texMask.get());
    shader.toggleDefine("TEX_OFFSET", texOffset.get());
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (texMask.get()) cgl.setTexture(1, texMask.get().tex);
    if (texOffset.get()) cgl.setTexture(2, texOffset.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Hue.prototype = new CABLES.Op();
CABLES.OPS["94ef0da0-c920-415c-81b0-fecbd437991d"]={f:Ops.Gl.TextureEffects.Hue,objName:"Ops.Gl.TextureEffects.Hue"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ImageComposeAspectRatio
// 
// **************************************************************

Ops.Gl.TextureEffects.ImageComposeAspectRatio = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpdate=op.inTrigger("Update"),
    inAspect=op.inFloat("Aspect",1),
    next=op.outTrigger("Next");

const cgl=op.patch.cgl;
let prev=1;

inUpdate.onTriggered=()=>
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    if(cgl.currentTextureEffect)
    {
        prev=cgl.currentTextureEffect.aspectRatio;
        cgl.currentTextureEffect.aspectRatio=inAspect.get();

        next.trigger();

        cgl.currentTextureEffect.aspectRatio=prev;
    }

};


};

Ops.Gl.TextureEffects.ImageComposeAspectRatio.prototype = new CABLES.Op();
CABLES.OPS["b346b8cf-b63d-4e1d-b95f-19edf04ae07d"]={f:Ops.Gl.TextureEffects.ImageComposeAspectRatio,objName:"Ops.Gl.TextureEffects.ImageComposeAspectRatio"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ImageComposeSnapshot
// 
// **************************************************************

Ops.Gl.TextureEffects.ImageComposeSnapshot = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("Update"),
    trigger = op.outTrigger("trigger"),
    outTex = op.outTexture("Texture");

const cgl = op.patch.cgl;
let tc = new CGL.CopyTexture(cgl, "textureThief", {});
let fp = false;

render.onTriggered = () =>
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    const effect = cgl.currentTextureEffect;
    effect.endEffect();

    const shouldFp = cgl.currentTextureEffect.getCurrentSourceTexture().isFloatingPoint();

    if (fp != shouldFp)
    {
        tc = new CGL.CopyTexture(cgl, "textureThief",
            {
                "isFloatingPointTexture": shouldFp,
            });
        fp = shouldFp;
    }

    const vp = cgl.getViewPort();
    outTex.set(CGL.Texture.getEmptyTexture(cgl));

    const tx = cgl.currentTextureEffect.getCurrentSourceTexture();
    outTex.set(tc.copy(tx));

    effect.continueEffect(tx);

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.ImageComposeSnapshot.prototype = new CABLES.Op();
CABLES.OPS["e15c0803-02bb-4783-9d75-e75abd70d910"]={f:Ops.Gl.TextureEffects.ImageComposeSnapshot,objName:"Ops.Gl.TextureEffects.ImageComposeSnapshot"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ImageCompose_v3
// 
// **************************************************************

Ops.Gl.TextureEffects.ImageCompose_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"imgcomp_frag":"IN vec2 texCoord;\nUNI vec4 bgColor;\nUNI sampler2D tex;\n\nvoid main()\n{\n\n    #ifndef USE_TEX\n        outColor=bgColor;\n    #endif\n    #ifdef USE_TEX\n        outColor=texture(tex,texCoord);\n    #endif\n\n\n\n}\n",};
const
    cgl = op.patch.cgl,
    render = op.inTrigger("Render"),
    inTex = op.inTexture("Base Texture"),
    inSize = op.inSwitch("Size", ["Auto", "Manual"], "Auto"),
    width = op.inValueInt("Width", 640),
    height = op.inValueInt("Height", 480),
    inFilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"], "linear"),
    inWrap = op.inValueSelect("Wrap", ["clamp to edge", "repeat", "mirrored repeat"], "repeat"),
    inPixel = op.inDropDown("Pixel Format", CGL.Texture.PIXELFORMATS, CGL.Texture.PFORMATSTR_RGBA8UB),

    r = op.inValueSlider("R", 0),
    g = op.inValueSlider("G", 0),
    b = op.inValueSlider("B", 0),
    a = op.inValueSlider("A", 0),

    trigger = op.outTrigger("Next"),
    texOut = op.outTexture("texture_out", CGL.Texture.getEmptyTexture(cgl)),
    outRatio = op.outNumber("Aspect Ratio"),
    outWidth = op.outNumber("Texture Width"),
    outHeight = op.outNumber("Texture Height");

op.setPortGroup("Texture Size", [inSize, width, height]);
op.setPortGroup("Texture Parameters", [inWrap, inFilter, inPixel]);

r.setUiAttribs({ "colorPick": true });
op.setPortGroup("Color", [r, g, b, a]);

const prevViewPort = [0, 0, 0, 0];
let effect = null;
let tex = null;
let reInitEffect = true;
let isFloatTex = false;
let copyShader = null;
let copyShaderTexUni = null;
let copyShaderRGBAUni = null;

inWrap.onChange =
    inFilter.onChange =
    inPixel.onChange = reInitLater;

inTex.onLinkChanged =
inSize.onChange = updateUi;

render.onTriggered =
    op.preRender = doRender;

updateUi();

function initEffect()
{
    if (effect)effect.delete();
    if (tex)tex.delete();

    effect = new CGL.TextureEffect(cgl, { "isFloatingPointTexture": getFloatingPoint() });

    tex = new CGL.Texture(cgl,
        {
            "name": "image_compose_v2_" + op.id,
            "isFloatingPointTexture": getFloatingPoint(),
            "filter": getFilter(),
            "wrap": getWrap(),
            "width": getWidth(),
            "height": getHeight()
        });

    effect.setSourceTexture(tex);

    outWidth.set(getWidth());
    outHeight.set(getHeight());
    outRatio.set(getWidth() / getHeight());

    texOut.set(CGL.Texture.getEmptyTexture(cgl));

    reInitEffect = false;
    updateUi();
}

function getFilter()
{
    if (inFilter.get() == "nearest") return CGL.Texture.FILTER_NEAREST;
    else if (inFilter.get() == "linear") return CGL.Texture.FILTER_LINEAR;
    else if (inFilter.get() == "mipmap") return CGL.Texture.FILTER_MIPMAP;
}

function getWrap()
{
    if (inWrap.get() == "repeat") return CGL.Texture.WRAP_REPEAT;
    else if (inWrap.get() == "mirrored repeat") return CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (inWrap.get() == "clamp to edge") return CGL.Texture.WRAP_CLAMP_TO_EDGE;
}

function getFloatingPoint()
{
    isFloatTex = inPixel.get() == CGL.Texture.PFORMATSTR_RGBA32F;
    return isFloatTex;
}

function getWidth()
{
    if (inTex.get() && inSize.get() == "Auto") return inTex.get().width;
    if (inSize.get() == "Auto") return cgl.getViewPort()[2];
    return Math.ceil(width.get());
}

function getHeight()
{
    if (inTex.get() && inSize.get() == "Auto") return inTex.get().height;
    else if (inSize.get() == "Auto") return cgl.getViewPort()[3];
    else return Math.ceil(height.get());
}

function reInitLater()
{
    reInitEffect = true;
}

function updateResolution()
{
    if ((
        getWidth() != tex.width ||
        getHeight() != tex.height ||
        tex.isFloatingPoint() != getFloatingPoint() ||
        tex.filter != getFilter() ||
        tex.wrap != getWrap()
    ) && (getWidth() !== 0 && getHeight() !== 0))
    {
        initEffect();
        effect.setSourceTexture(tex);
        texOut.set(CGL.Texture.getEmptyTexture(cgl));
        texOut.set(tex);
        updateResolutionInfo();
    }
}

function updateResolutionInfo()
{
    let info = null;

    if (inSize.get() == "Manual")
    {
        info = null;
    }
    else if (inSize.get() == "Auto")
    {
        if (inTex.get()) info = "Input Texture";
        else info = "Canvas Size";

        info += ": " + getWidth() + " x " + getHeight();
    }

    let changed = false;
    changed = inSize.uiAttribs.info != info;
    inSize.setUiAttribs({ "info": info });
    if (changed)op.refreshParams();
}

function updateDefines()
{
    if (copyShader)copyShader.toggleDefine("USE_TEX", inTex.isLinked());
}

function updateUi()
{
    r.setUiAttribs({ "greyout": inTex.isLinked() });
    b.setUiAttribs({ "greyout": inTex.isLinked() });
    g.setUiAttribs({ "greyout": inTex.isLinked() });
    a.setUiAttribs({ "greyout": inTex.isLinked() });

    width.setUiAttribs({ "greyout": inSize.get() == "Auto" });
    height.setUiAttribs({ "greyout": inSize.get() == "Auto" });

    width.setUiAttribs({ "hideParam": inSize.get() != "Manual" });
    height.setUiAttribs({ "hideParam": inSize.get() != "Manual" });

    if (tex)
        if (getFloatingPoint() && getFilter() == CGL.Texture.FILTER_MIPMAP) op.setUiError("fpmipmap", "Don't use mipmap and 32bit at the same time, many systems do not support this.");
        else op.setUiError("fpmipmap", null);

    updateResolutionInfo();
    updateDefines();
}

op.preRender = () =>
{
    doRender();
};

function copyTexture()
{
    if (!copyShader)
    {
        copyShader = new CGL.Shader(cgl, "copytextureshader");
        copyShader.setSource(copyShader.getDefaultVertexShader(), attachments.imgcomp_frag);
        copyShaderTexUni = new CGL.Uniform(copyShader, "t", "tex", 0);
        copyShaderRGBAUni = new CGL.Uniform(copyShader, "4f", "bgColor", r, g, b, a);
        updateDefines();
    }

    cgl.pushShader(copyShader);
    cgl.currentTextureEffect.bind();

    if (inTex.get()) cgl.setTexture(0, inTex.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();
}

function doRender()
{
    if (!effect || reInitEffect) initEffect();

    const vp = cgl.getViewPort();
    prevViewPort[0] = vp[0];
    prevViewPort[1] = vp[1];
    prevViewPort[2] = vp[2];
    prevViewPort[3] = vp[3];

    cgl.pushBlend(false);

    updateResolution();

    const oldEffect = cgl.currentTextureEffect;
    cgl.currentTextureEffect = effect;
    cgl.currentTextureEffect.imgCompVer = 3;
    cgl.currentTextureEffect.width = width.get();
    cgl.currentTextureEffect.height = height.get();
    effect.setSourceTexture(tex);

    effect.startEffect(inTex.get() || CGL.Texture.getEmptyTexture(cgl, isFloatTex), true);
    copyTexture();

    trigger.trigger();

    texOut.set(CGL.Texture.getEmptyTexture(cgl));

    texOut.set(effect.getCurrentSourceTexture());

    effect.endEffect();

    cgl.setViewPort(prevViewPort[0], prevViewPort[1], prevViewPort[2], prevViewPort[3]);

    cgl.popBlend(false);
    cgl.currentTextureEffect = oldEffect;
}


};

Ops.Gl.TextureEffects.ImageCompose_v3.prototype = new CABLES.Op();
CABLES.OPS["e890a050-11b7-456e-b09b-d08cd9c1ee41"]={f:Ops.Gl.TextureEffects.ImageCompose_v3,objName:"Ops.Gl.TextureEffects.ImageCompose_v3"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Interlace
// 
// **************************************************************

Ops.Gl.TextureEffects.Interlace = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"interlace_frag":"\n#ifdef HAS_TEXTURES\n  IN vec2 texCoord;\n  UNI sampler2D tex;\n#endif\nUNI float amount;\nUNI float lum;\nUNI float add;\nUNI float lineSize;\nUNI float scroll;\nUNI float displace;\n\n\nvoid main()\n{\n   vec4 col=vec4(1.0,0.0,0.0,1.0);\n\n   col=texture(tex,texCoord);\n    // .endl()+'   col=clamp(col,0.0,1.0);'\n\n    float dir;\n    #ifdef DIRECTION\n        dir = gl_FragCoord.x;\n    #endif\n\n    #ifndef DIRECTION\n        dir = gl_FragCoord.y;\n    #endif\n\n   if( mod(dir+scroll,lineSize)>=lineSize*0.5)\n   {\n       col=texture(tex,vec2(texCoord.x+displace*0.05,texCoord.y));\n       float gray = vec3(dot(vec3(0.2126,0.7152,0.0722), col.rgb)).r;\n       col.rgb=col.rgb*(1.0-amount) + (col.rgb*gray*gray*lum)*amount;\n   }\n   else col+=add;\n\n\n   outColor= col;\n}",};
let render = op.inTrigger("render");
let amount = op.inValueSlider("amount", 0.5);
let lum = op.inValueSlider("Lumi Scale", 0.9);
let direction = op.inBool("X or Y", false);
let lineSize = op.inValue("Line Size", 4);
let displace = op.inValueSlider("Displacement", 0);

let add = op.inValue("Add", 0.02);
let inScroll = op.inValue("scroll", 0);

let trigger = op.outTrigger("trigger");

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.interlace_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let uniAmount = new CGL.Uniform(shader, "f", "amount", amount);

let uniLum = new CGL.Uniform(shader, "f", "lum", lum);
let uniLineSize = new CGL.Uniform(shader, "f", "lineSize", lineSize);
let uniAdd = new CGL.Uniform(shader, "f", "add", add);
let uniDisplace = new CGL.Uniform(shader, "f", "displace", displace);
let uniScroll = new CGL.Uniform(shader, "f", "scroll", inScroll);

direction.onChange = function ()
{
    shader.toggleDefine("DIRECTION", direction.get());
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Interlace.prototype = new CABLES.Op();
CABLES.OPS["3cd69d5b-6c05-4522-9551-52458f99421a"]={f:Ops.Gl.TextureEffects.Interlace,objName:"Ops.Gl.TextureEffects.Interlace"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Invert_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Invert_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"invert_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D texMask;\nUNI float amount;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\n    #ifdef USE_MASK\n        #ifdef MASK_INVERT\n            if(texture(texMask,texCoord).r>0.5)\n            {\n                outColor= col;\n                return;\n            }\n        #endif\n\n        #ifndef MASK_INVERT\n            if(texture(texMask,texCoord).r<0.5)\n            {\n                outColor= col;\n                return;\n            }\n        #endif\n    #endif\n\n\n    vec3 m=vec3( INVR , INVG , INVB );\n    vec4 invert = vec4(clamp(m-col.rgb,0.0,1.0),col.a);\n\n    outColor=cgl_blendPixel(col,invert,amount);\n\n    // outColor.rgb=m;\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskInvert = op.inBool("Mask Invert", false),
    mask = op.inTexture("Mask"),
    invertR = op.inBool("Invert R", true),
    invertG = op.inBool("Invert G", true),
    invertB = op.inBool("Invert B", true),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.invert_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    textureMaskUniform = new CGL.Uniform(shader, "t", "texMask", 1);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

maskInvert.onChange =
    invertR.onChange =
    invertG.onChange =
    invertB.onChange =
    mask.onLinkChanged = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("USE_MASK", mask.isLinked());
    shader.toggleDefine("MASK_INVERT", maskInvert.get());

    shader.define("INVR", invertR.get() ? "1.0" : "0.0");
    shader.define("INVG", invertG.get() ? "1.0" : "0.0");
    shader.define("INVB", invertB.get() ? "1.0" : "0.0");
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (mask.get())cgl.setTexture(1, mask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Invert_v2.prototype = new CABLES.Op();
CABLES.OPS["56e8c95b-da89-423b-9d31-23351c263bb6"]={f:Ops.Gl.TextureEffects.Invert_v2,objName:"Ops.Gl.TextureEffects.Invert_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Kaleidoscope_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Kaleidoscope_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"kaleidoscope_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n\nUNI float sides;\nUNI float angle;\nUNI float amount;\n\nUNI float slidex;\nUNI float slidey;\nUNI float centerX;\nUNI float centerY;\nUNI float aspect;\n\nconst float tau = 6.28318530718;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec2 center=vec2(centerX,centerY/aspect);\n\n\tvec2 loc = texCoord;\n\tloc.y/=aspect;\n\n\tfloat r = distance(center, loc);\n\tfloat a = atan ((loc.y-center.y),(loc.x-center.x));\n\n\t// kaleidoscope\n\ta = mod(a, tau/sides);\n\ta = abs(a - tau/sides/2.);\n\n\tloc.x = r * cos(a + tau * angle);\n\tloc.y = r * sin(a + tau * angle);\n\n\tloc = (center + loc) *2.1;\n\n\tloc.x = mod(loc.x + slidex, 1.0);\n\tloc.y = mod(loc.y + slidey, 1.0);\n\n\tif(loc.x < 0.0)loc.x = mod(abs(loc.x),1.0);\n\tif(loc.y < 0.0)loc.y = mod(abs(loc.y),1.0);\n\n\tif(loc.x > 1.0) loc.x = mod(abs(1.0-loc.x),1.0);\n\tif(loc.y > 1.0) loc.y = mod(abs(1.0-loc.y),1.0);\n\n\tvec4 col=texture(tex,loc);\n\tvec4 base=texture(tex,texCoord);\n\tbase.a=0.0;\n    outColor= cgl_blendPixel(base,col,amount);\n\n}\n",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    sides = op.inValue("Sides", 10),
    angle = op.inValueSlider("Angle", 0),
    slidex = op.inValueSlider("Slide X", 0),
    slidey = op.inValueSlider("Slide Y", 0),
    centerX = op.inValueSlider("Center X", 0.5),
    centerY = op.inValueSlider("Center Y", 0.5),
    inAspect=op.inBool("Aspect Ratio",true),
    trigger = op.outTrigger("Next");

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name);

const
    unisides = new CGL.Uniform(shader, "f", "sides", sides),
    uniangle = new CGL.Uniform(shader, "f", "angle", angle),
    unislidex = new CGL.Uniform(shader, "f", "slidex", slidex),
    unislidey = new CGL.Uniform(shader, "f", "slidey", slidey),
    uniCenterX = new CGL.Uniform(shader, "f", "centerX", centerX),
    uniCenterY = new CGL.Uniform(shader, "f", "centerY", centerY),
    uniAmount = new CGL.Uniform(shader, "f", "amount", amount),
    uniAspect = new CGL.Uniform(shader, "f", "aspect", 1);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

shader.setSource(shader.getDefaultVertexShader(), attachments.kaleidoscope_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if(inAspect.get()) uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);
    else uniAspect.setValue(1);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Kaleidoscope_v2.prototype = new CABLES.Op();
CABLES.OPS["3c900fc2-8508-4531-a365-43224f7751c8"]={f:Ops.Gl.TextureEffects.Kaleidoscope_v2,objName:"Ops.Gl.TextureEffects.Kaleidoscope_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.LUTMap
// 
// **************************************************************

Ops.Gl.TextureEffects.LUTMap = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"lut_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D texLut;\nUNI float amount;\n\nvoid main()\n{\n    vec4 textureColor = texture(tex, texCoord);\n    float blueColor = textureColor.b * 63.0;\n    \n    vec2 quad1;\n    quad1.y = floor(floor(blueColor) / 8.0);\n    quad1.x = floor(blueColor) - (quad1.y * 8.0);\n    \n    vec2 quad2;\n    quad2.y = floor(ceil(blueColor) / 8.0);\n    quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n    \n    highp vec2 texPos1;\n    texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n    texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n    \n    highp vec2 texPos2;\n    texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n    texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n    \n    vec4 newColor1 = texture(texLut, texPos1);\n    vec4 newColor2 = texture(texLut, texPos2);\n    \n    vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n    outColor= mix(textureColor,vec4(newColor.rgb, textureColor.w),amount);\n}\n",};
let render = op.inTrigger("render");
let trigger = op.outTrigger("trigger");
let inLut = op.inTexture("LUT Image");
let inAmount = op.inValueSlider("Amount", 1.0);

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.lut_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let textureUniform2 = new CGL.Uniform(shader, "t", "texLut", 1);
let uniPos = new CGL.Uniform(shader, "f", "amount", inAmount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;
    if (!inLut.get()) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.setTexture(1, inLut.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.LUTMap.prototype = new CABLES.Op();
CABLES.OPS["baba13d7-1cc2-4ba8-b66d-05425b0e5a75"]={f:Ops.Gl.TextureEffects.LUTMap,objName:"Ops.Gl.TextureEffects.LUTMap"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.LensDirt_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.LensDirt_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"lensDirt_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float uOffsetX;\nUNI float uOffsetY;\nUNI float uZoom;\n// UNI int uIterations;\nUNI int uRandomSeed;\nUNI float uSpotEdge;\nUNI float uGamma;\nUNI float uAspect;\nUNI float amount;\n\n{{CGL.BLENDMODES3}}\n\n// https://www.shadertoy.com/view/MdfBRX\nfloat Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)\n{\n    float d = length(p - sp);\n    float c = smoothstep(size, size*(1.-blur), d);\n    c *= mix(mi, 1., smoothstep(size*.8, size, d));\n    return c;\n}\n///  2 out, 2 in... from https://www.shadertoy.com/view/4djSRW\n//stable\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy)*2.0-1.0;\n\n}\nvec3 dirt(vec2 uv, float n,float density,float hardness)\n{\n    n *= density;\n    vec2 p = fract(uv * n);\n    vec2 st = (floor(uv * n) + 0.5) / n;\n    vec2 rnd = hash22(st);\n    float c = Bokeh(p, vec2(0.5, 0.5) + vec2(0.3) * rnd, 0.2,\n                    abs(rnd.y * 0.35) + 0.3, 0.25 + rnd.x * rnd.y * hardness);\n\n    return vec3(c) * exp(rnd.x * 4.0);\n}\n\nvoid main()\n{\n\tvec3 di = vec3(1.0);\n    float edgeHardness = 0.1;\n    edgeHardness = clamp(uSpotEdge*0.25,0.0,0.2);\n\n    vec2 uv = (texCoord-0.5);\n\n    uv.y/=uAspect;\n    uv *= uZoom;\n    uv -= vec2(uOffsetX,uOffsetY);\n\n    float q = 0.0;\n    for (int i = 1; i < ITERATIONS ; i++)\n    {\n        q = float(i);\n        vec2 h=hash22(vec2(q)+vec2(uRandomSeed));\n        di += dirt(uv-h, h.x, 1.0, edgeHardness);\n    }\n\n    di = pow(di* 0.01,vec3(uGamma));\n    vec4 col = vec4(di,1.0);\n    vec4 base = texture(tex,texCoord);\n\n    outColor = cgl_blendPixel(base,col,amount);\n}",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    offsetX = op.inFloat("Offset X", 0),
    offsetY = op.inFloat("Offset Y", 0),
    zoom = op.inFloat("Zoom", 5),
    iterations = op.inInt("Iterations", 50),
    randomSeed = op.inInt("Seed", 1),
    spotEdge = op.inFloatSlider("Spot edge", 0.5),
    gamma = op.inFloat("Gamma", 0.75),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.lensDirt_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    offsetXUniformX = new CGL.Uniform(shader, "f", "uOffsetX", offsetX),
    offsetXUniformY = new CGL.Uniform(shader, "f", "uOffsetY", offsetY),
    zoomUniform = new CGL.Uniform(shader, "f", "uZoom", zoom),
    // iterationsUniform=new CGL.Uniform(shader,'i','uIterations',iterations),
    randomSeedUniform = new CGL.Uniform(shader, "i", "uRandomSeed", randomSeed),
    spotEdgeUniform = new CGL.Uniform(shader, "f", "uSpotEdge", spotEdge),
    gammaUniform = new CGL.Uniform(shader, "f", "uGamma", gamma),
    uniformAspect = new CGL.Uniform(shader, "f", "uAspect", 1.0),

    amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

iterations.onChange = updateIterations;
updateIterations();

function updateIterations()
{
    let its = iterations.get();
    its = Math.min(300, Math.max(1, its));
    shader.define("ITERATIONS", its);
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    uniformAspect.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width / cgl.currentTextureEffect.getCurrentSourceTexture().height);
    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.LensDirt_v2.prototype = new CABLES.Op();
CABLES.OPS["a04156f6-f636-430f-810e-9cb27199ceeb"]={f:Ops.Gl.TextureEffects.LensDirt_v2,objName:"Ops.Gl.TextureEffects.LensDirt_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.LensScratches_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.LensScratches_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"lensScratches_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float uOffsetX;\nUNI float uOffsetY;\nUNI float uWavyness;\nUNI float uScale;\nUNI int uLayers;\nUNI float uAntiAliasIterations;\nUNI float uFrequency;\nUNI float uFrequencyStep;\nUNI float uResWidth;\nUNI float uResHeight;\nUNI float uAspect;\nUNI float amount;\n\n{{CGL.BLENDMODES3}}\n//Shader kindly used with the permission of Tropical trevor\n//shadertoy user Daedelus\n//https://www.shadertoy.com/view/4syXRD\n\nvoid pR(inout vec2 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    p *= mat2(ca, sa, -sa, ca);\n}\n\nfloat scratch(vec2 uv, vec2 seed)\n{\n    seed.x = floor(sin(seed.x * 51024.0) * 3104.0);\n    seed.y = floor(sin(seed.y * 1324.0) * 554.0);\n\n    uv = uv * 2.0 - 1.0;\n    pR(uv, seed.x + seed.y);\n    uv += sin(seed.x - seed.y);\n    uv = clamp(uv * 0.5 + 0.5, 0.0, 1.0);\n\n    float s1 = sin(seed.x + uv.y * 3.1415) * uWavyness;\n    float s2 = sin(seed.y + uv.y * 3.1415) * uWavyness;\n\n    float x = sign(0.01 - abs(uv.x - 0.5 + s2 + s1));\n    return clamp(((1.0 - pow(uv.y, 2.0)) * uv.y) * 2.5 * x, 0.0, 1.0);\n}\n\nfloat layer(vec2 uv, vec2 frequency, vec2 offset, float angle)\n{\n    pR(uv, angle);\n    uv = uv * frequency + offset;\n    return scratch(fract(uv), floor(uv));\n}\n\nfloat scratches(vec2 uv)\n{\n    uv *= uScale;\n    uv -= vec2(uOffsetX,uOffsetY);\n    vec2 frequency = vec2(uFrequency);\n    float scratches = 0.0;\n    int iterations = clamp(uLayers,1,20);\n    for(int i = 0; i < iterations; ++i)\n    {\n        float fi = float(i);\n    \tscratches += layer(uv, frequency, vec2(fi, fi), fi * 3145.0);\n        frequency += uFrequencyStep;\n    }\n    return scratches;\n}\nvoid main()\n{\n    vec2 uv = texCoord.xy-0.5;\n    uv.y/=uAspect;\n\n    // using AA by Shane:\n    // https://www.shadertoy.com/view/4d3SWf\n    // Antialias level. Set to 1 for a standard, aliased scene\n    float AA = clamp(uAntiAliasIterations,1.,4.);\n    int AA2 = int(AA*AA);\n    float color = 0.0;\n    vec2 pix = 2.0/vec2(uResWidth,uResHeight)/AA; // or iResolution.xy\n    for (int i=0; i<AA2; i++){\n\n        float k = float(i);\n        vec2 uvOffs = uv + vec2(floor(k/AA), mod(k, AA)) * pix;\n        color += scratches(uvOffs);\n    }\n    color /= (AA*AA);\n    vec4 col = vec4(vec3(color),1.0);\n    vec4 base = texture(tex,texCoord);\n\n    outColor = cgl_blendPixel(base,col,amount);;\n}\n\n//",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    offsetX = op.inFloat("Offset X", 0),
    offsetY = op.inFloat("Offset Y", 0),
    wavyness = op.inFloatSlider("Wavyness", 0.5),
    scale = op.inFloat("scale", 10),
    layers = op.inInt("Layers", 4),
    antiAliasIterations = op.inFloat("AA iterations", 4.0),
    frequency = op.inFloat("Frequency", 0.5),
    frequencyStep = op.inFloat("Frequency step size", 0.5),

    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.lensScratches_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    offsetXUniformX = new CGL.Uniform(shader, "f", "uOffsetX", offsetX),
    offsetXUniformY = new CGL.Uniform(shader, "f", "uOffsetY", offsetY),
    wavynessUniform = new CGL.Uniform(shader, "f", "uWavyness", wavyness),
    scaleUniform = new CGL.Uniform(shader, "f", "uScale", scale),
    layersUniform = new CGL.Uniform(shader, "i", "uLayers", layers),
    antiAliasIterationsUniform = new CGL.Uniform(shader, "f", "uAntiAliasIterations", antiAliasIterations),
    frequencyUniform = new CGL.Uniform(shader, "f", "uFrequency", frequency),
    frequencyStepUniform = new CGL.Uniform(shader, "f", "uFrequencyStep", frequencyStep),
    uniformTextureWidth = new CGL.Uniform(shader, "f", "uResWidth", 1.0),
    uniformTextureHeight = new CGL.Uniform(shader, "f", "uResHeight", 1.0),
    uniformAspect = new CGL.Uniform(shader, "f", "uAspect", 1.0),

    amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    uniformAspect.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width
                            / cgl.currentTextureEffect.getCurrentSourceTexture().height);

    uniformTextureWidth.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniformTextureHeight.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().height);
    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.LensScratches_v2.prototype = new CABLES.Op();
CABLES.OPS["12661ef7-8d41-4c10-8ada-0b00be6498c0"]={f:Ops.Gl.TextureEffects.LensScratches_v2,objName:"Ops.Gl.TextureEffects.LensScratches_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Levels_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Levels_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"levels_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float inMin;\nUNI float inMax;\nUNI float midPoint;\nUNI float outMax;\nUNI float outMin;\n\nvoid main()\n{\n    vec4 baseRGBA=texture(tex,texCoord);\n    vec3 base=baseRGBA.rgb;\n    vec3 inputRange = min(max(base - vec3(inMin), vec3(0.0)) / (vec3(inMax) - vec3(inMin)), vec3(outMax));\n\n    inputRange = pow(inputRange, vec3(1.0 / (1.5 - midPoint)));\n\n    outColor= vec4(mix(vec3(outMin), vec3(1.0), inputRange) ,baseRGBA.a);\n}",};
const
    render = op.inTrigger("Render"),

    inMin = op.inValueSlider("In Min", 0),
    inMid = op.inValueSlider("Midpoint", 0.5),
    inMax = op.inValueSlider("In Max", 1),

    outMin = op.inValueSlider("Out Min", 0),
    outMax = op.inValueSlider("Out Max", 1),

    trigger=op.outTrigger("Next");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

const
    uniInMin = new CGL.Uniform(shader, "f", "inMin", inMin),
    uniInMid = new CGL.Uniform(shader, "f", "midPoint", inMid),
    uniInMax = new CGL.Uniform(shader, "f", "inMax", inMax),
    uniOutMin = new CGL.Uniform(shader, "f", "outMin", outMin),
    uniOutMax = new CGL.Uniform(shader, "f", "outMax", outMax),
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

shader.setSource(shader.getDefaultVertexShader(), attachments.levels_frag);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Levels_v2.prototype = new CABLES.Op();
CABLES.OPS["cf49063c-a010-4e2b-add6-f8dea50392b5"]={f:Ops.Gl.TextureEffects.Levels_v2,objName:"Ops.Gl.TextureEffects.Levels_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.LumaKey_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.LumaKey_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"lumakeyV2_frag":"IN vec2 texCoord;\nUNI float threshholdLow;\nUNI float threshholdHigh;\nUNI sampler2D text;\n\nvoid main()\n{\n   vec4 col = texture(text, texCoord );\n\n   float gray = dot(vec3(0.2126,0.7152,0.0722), col.rgb );\n\n   #ifndef INVERT\n       if(gray < threshholdLow || gray > threshholdHigh) col.r=col.g=col.b=col.a=0.0;\n       #ifdef BLACKWHITE\n           else col.r=col.g=col.b=col.a=1.0;\n       #endif\n   #endif\n\n   #ifdef INVERT\n       if(gray > threshholdLow && gray < threshholdHigh) col.r=col.g=col.b=col.a=0.0;\n       #ifdef BLACKWHITE\n           else col.r=col.g=col.b=col.a=1.0;\n       #endif\n   #endif\n\n   outColor= col;\n}",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    inInvert = op.inValueBool("Invert"),
    inBlackWhite = op.inValueBool("Black White"),
    thresholdLow = op.inValueSlider("Threshold low ", 0.5),
    thresholdHigh = op.inValueSlider("Threshold high", 1.0);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "lumakey");

shader.setSource(shader.getDefaultVertexShader(), attachments.lumakeyV2_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const uniThresholdLow = new CGL.Uniform(shader, "f", "threshholdLow", thresholdLow);
const uniThresholdHigh = new CGL.Uniform(shader, "f", "threshholdHigh", thresholdHigh);

inBlackWhite.onChange = function ()
{
    if (inBlackWhite.get()) shader.define("BLACKWHITE");
    else shader.removeDefine("BLACKWHITE");
};

inInvert.onChange = function ()
{
    if (inInvert.get()) shader.define("INVERT");
    else shader.removeDefine("INVERT");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);

    cgl.currentTextureEffect.bind();
    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();

    cgl.popShader();
    trigger.trigger();
};


};

Ops.Gl.TextureEffects.LumaKey_v2.prototype = new CABLES.Op();
CABLES.OPS["1699f3fc-355b-4497-a23c-1620a04a9cd4"]={f:Ops.Gl.TextureEffects.LumaKey_v2,objName:"Ops.Gl.TextureEffects.LumaKey_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Math.RgbMath
// 
// **************************************************************

Ops.Gl.TextureEffects.Math.RgbMath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbmul_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n#ifdef MOD_MASK\n    UNI sampler2D texMask;\n#endif\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\n\n\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n    vec4 v=vec4(r,g,b,a);\n\n    #ifdef MOD_MASK\n        v*=texture(texMask,texCoord);\n    #endif\n\n    #ifdef MOD_OP_SUB_CX\n        #ifdef MOD_CHAN_R\n            col.r=col.r-v.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g=col.g-v.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b=col.b-v.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a=col.a-v.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_SUB_XC\n        #ifdef MOD_CHAN_R\n            col.r=v.r-col.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g=v.g-col.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b=v.b-col.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a=v.a-col.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_ADD\n        #ifdef MOD_CHAN_R\n            col.r+=v.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g+=v.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b+=v.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a+=v.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_MUL\n        #ifdef MOD_CHAN_R\n            col.r*=v.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g*=v.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b*=v.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a*=v.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_DIV_XC\n        #ifdef MOD_CHAN_R\n            col.r=v.r/col.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g=v.g/col.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b=v.b/col.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a=v.a/col.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_DIV_CX\n        #ifdef MOD_CHAN_R\n            col.r=col.r/v.r;\n        #endif\n        #ifdef MOD_CHAN_G\n            col.g=col.g/v.g;\n        #endif\n        #ifdef MOD_CHAN_B\n            col.b=col.b/v.b;\n        #endif\n        #ifdef MOD_CHAN_A\n            col.a=col.a/v.a;\n        #endif\n    #endif\n\n    #ifdef MOD_OP_MODULO\n        col=mod(col,v);\n    #endif\n\n// csdcsd\n   outColor= col;\n}\n",};
const
    render = op.inTrigger("Render"),
    inOp = op.inSwitch("Operation", ["c-x", "x-c", "c+x", "c*x", "x/c", "c/x", "c%x"], "c*x"),
    chanR = op.inBool("R Active", true),
    chanG = op.inBool("G Active", true),
    chanB = op.inBool("B Active", true),
    chanA = op.inBool("A Active", false),
    r = op.inValue("r", 1),
    g = op.inValue("g", 1),
    b = op.inValue("b", 1),
    a = op.inValue("a", 1),
    inTexMask = op.inTexture("Mask"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.rgbmul_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureMaskUniform = new CGL.Uniform(shader, "t", "texMask", 1),
    uniformR = new CGL.Uniform(shader, "f", "r", r),
    uniformG = new CGL.Uniform(shader, "f", "g", g),
    uniformB = new CGL.Uniform(shader, "f", "b", b),
    uniformA = new CGL.Uniform(shader, "f", "a", a);

chanR.onChange =
    inTexMask.onChange =
    chanG.onChange =
    chanB.onChange =
    chanA.onChange =
    inOp.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    shader.toggleDefine("MOD_MASK", inTexMask.get());

    shader.toggleDefine("MOD_OP_SUB_CX", inOp.get() === "c-x");
    shader.toggleDefine("MOD_OP_SUB_XC", inOp.get() === "x-c");

    shader.toggleDefine("MOD_OP_ADD", inOp.get() === "c+x");
    shader.toggleDefine("MOD_OP_MUL", inOp.get() === "c*x");

    shader.toggleDefine("MOD_OP_DIV_XC", inOp.get() === "x/c");
    shader.toggleDefine("MOD_OP_DIV_CX", inOp.get() === "c/x");

    shader.toggleDefine("MOD_OP_MODULO", inOp.get() === "c%x");

    shader.toggleDefine("MOD_CHAN_R", chanR.get());
    r.setUiAttribs({ "greyout": !chanR.get() });

    shader.toggleDefine("MOD_CHAN_G", chanG.get());
    g.setUiAttribs({ "greyout": !chanG.get() });

    shader.toggleDefine("MOD_CHAN_B", chanB.get());
    b.setUiAttribs({ "greyout": !chanB.get() });

    shader.toggleDefine("MOD_CHAN_A", chanA.get());
    a.setUiAttribs({ "greyout": !chanA.get() });
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inTexMask.get())cgl.setTexture(1, inTexMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Math.RgbMath.prototype = new CABLES.Op();
CABLES.OPS["dc858e71-1f12-4de5-89f5-67fb41ebfa39"]={f:Ops.Gl.TextureEffects.Math.RgbMath,objName:"Ops.Gl.TextureEffects.Math.RgbMath"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Math.RgbTransform
// 
// **************************************************************

Ops.Gl.TextureEffects.Math.RgbTransform = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbmul_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n#ifdef MOD_MASK\n    UNI sampler2D texMask;\n#endif\n\nUNI vec3 translate;\nUNI vec3 scale;\nUNI vec3 rot;\n\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\n    float mul=1.0;\n\n\n    #ifdef MOD_MASK\n        mul=texture(texMask,texCoord).r;\n    #endif\n\n    #ifdef DO_ROT\n        col*=rotationMatrix(vec3(1.0,0.0,0.0), mul*rot.x/57.29577951308232);\n        col*=rotationMatrix(vec3(0.0,1.0,0.0), mul*rot.y/57.29577951308232);\n        col*=rotationMatrix(vec3(0.0,0.0,1.0), mul*rot.z/57.29577951308232);\n    #endif\n\n    #ifdef DO_SCALE\n        col.xyz*=scale*mul;\n    #endif\n\n    #ifdef DO_TRANS\n        col.xyz+=translate*mul;\n    #endif\n\n    outColor=col;\n}\n",};
const
    render = op.inTrigger("Render"),

    inDoTrans = op.inBool("Translate", true),
    posx = op.inValue("Pos X", 0),
    posy = op.inValue("Pos Y", 0),
    posz = op.inValue("Pos Z", 0),

    inDoScale = op.inBool("Scale", true),
    scalex = op.inValue("Scale X", 1),
    scaley = op.inValue("Scale Y", 1),
    scalez = op.inValue("Scale Z", 1),

    inDoRot = op.inBool("Rotate", true),
    rotx = op.inValue("Rotation X", 1),
    roty = op.inValue("Rotation Y", 1),
    rotz = op.inValue("Rotation Z", 1),

    inTexMask = op.inTexture("Mask"),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Rotation", [inDoRot, rotx, roty, rotz]);
op.setPortGroup("Position", [inDoTrans, posx, posy, posz]);
op.setPortGroup("Scale", [inDoScale, scalex, scaley, scalez]);
op.setUiAxisPorts(posx, posz, posy);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.rgbmul_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureMaskUniform = new CGL.Uniform(shader, "t", "texMask", 1),
    uniformTransl = new CGL.Uniform(shader, "3f", "translate", posx, posy, posz),
    uniformScale = new CGL.Uniform(shader, "3f", "scale", scalex, scaley, scalez),
    uniformRot = new CGL.Uniform(shader, "3f", "rot", rotx, roty, rotz);

inTexMask.onChange =
    inDoTrans.onChange =
    inDoRot.onChange =
    inDoScale.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    shader.toggleDefine("MOD_MASK", inTexMask.get());

    shader.toggleDefine("DO_TRANS", inDoTrans.get());
    shader.toggleDefine("DO_ROT", inDoRot.get());
    shader.toggleDefine("DO_SCALE", inDoScale.get());

    posx.setUiAttribs({ "greyout": !inDoTrans.get() });
    posy.setUiAttribs({ "greyout": !inDoTrans.get() });
    posz.setUiAttribs({ "greyout": !inDoTrans.get() });

    rotx.setUiAttribs({ "greyout": !inDoRot.get() });
    roty.setUiAttribs({ "greyout": !inDoRot.get() });
    rotz.setUiAttribs({ "greyout": !inDoRot.get() });

    scalex.setUiAttribs({ "greyout": !inDoScale.get() });
    scaley.setUiAttribs({ "greyout": !inDoScale.get() });
    scalez.setUiAttribs({ "greyout": !inDoScale.get() });
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inTexMask.get())cgl.setTexture(1, inTexMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Math.RgbTransform.prototype = new CABLES.Op();
CABLES.OPS["0a069281-e7a1-43a4-a74a-101026df6a29"]={f:Ops.Gl.TextureEffects.Math.RgbTransform,objName:"Ops.Gl.TextureEffects.Math.RgbTransform"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Mirror
// 
// **************************************************************

Ops.Gl.TextureEffects.Mirror = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"mirror_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float axis;\nUNI float width;\nUNI float flip;\nUNI float offset;\n\nvoid main()\n{\n   vec4 col=vec4(1.0,0.0,0.0,1.0);\n\n   float tc=texCoord.x;\n   if(axis==1.0) tc=(texCoord.y);\n\n   float x=(tc);\n   if(tc>=0.5)x=1.0-tc;\n\n   x*=width*2.0;\n   if(flip==1.0)x=1.0-x;\n   x*=1.0-offset;\n\n   if(axis==1.0) col=texture(tex,vec2(texCoord.x,x) );\n       else col=texture(tex,vec2(x,texCoord.y) );\n\n   outColor= col;\n}",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    axis = op.inSwitch("axis", ["X", "Y"], "X"),
    width = op.inValueFloat("width", 0.5),
    offset = op.inValueFloat("offset"),
    flip = op.inValueBool("flip");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.mirror_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniAxis = new CGL.Uniform(shader, "f", "axis", 0),
    uniWidth = new CGL.Uniform(shader, "f", "width", width),
    uniOffset = new CGL.Uniform(shader, "f", "offset", offset),
    uniFlip = new CGL.Uniform(shader, "f", "flip", 0);

flip.onChange = function ()
{
    if (flip.get())uniFlip.setValue(1);
    else uniFlip.setValue(0);
};

axis.onChange = function ()
{
    if (axis.get() == "X")uniAxis.setValue(0);
    else if (axis.get() == "Y")uniAxis.setValue(1);
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Mirror.prototype = new CABLES.Op();
CABLES.OPS["10d3c769-9a7f-4bd3-a849-7354d3e5f7f0"]={f:Ops.Gl.TextureEffects.Mirror,objName:"Ops.Gl.TextureEffects.Mirror"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.MultiDrawImage
// 
// **************************************************************

Ops.Gl.TextureEffects.MultiDrawImage = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"invert_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D tex1;\nUNI sampler2D tex2;\nUNI sampler2D tex3;\nUNI sampler2D tex4;\nUNI sampler2D tex5;\nUNI sampler2D tex6;\nUNI sampler2D tex7;\nUNI sampler2D tex8;\n\n\nUNI sampler2D texMask1;\nUNI sampler2D texMask2;\nUNI sampler2D texMask3;\nUNI sampler2D texMask4;\nUNI sampler2D texMask5;\nUNI sampler2D texMask6;\nUNI sampler2D texMask7;\nUNI sampler2D texMask8;\n\nUNI float amount1;\nUNI float amount2;\nUNI float amount3;\nUNI float amount4;\nUNI float amount5;\nUNI float amount6;\nUNI float amount7;\nUNI float amount8;\n\n{{BLENDCODE}}\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\n\n    #ifdef USE_TEX_1\n        vec4 col1=texture(tex1,texCoord);\n        col=cgl_blend1(col,col1,amount1);\n    #endif\n    #ifdef USE_TEX_2\n        vec4 col2=texture(tex2,texCoord);\n        col=cgl_blend2(col,col2,amount2);\n    #endif\n    #ifdef USE_TEX_3\n        vec4 col3=texture(tex3,texCoord);\n        col=cgl_blend3(col,col3,amount3);\n    #endif\n    #ifdef USE_TEX_4\n        vec4 col4=texture(tex4,texCoord);\n        col=cgl_blend4(col,col4,amount4);\n    #endif\n    #ifdef USE_TEX_5\n        vec4 col5=texture(tex5,texCoord);\n        col=cgl_blend5(col,col5,amount5);\n    #endif\n    #ifdef USE_TEX_6\n        vec4 col6=texture(tex6,texCoord);\n        col=cgl_blend6(col,col6,amount6);\n    #endif\n    #ifdef USE_TEX_7\n        vec4 col7=texture(tex7,texCoord);\n        col=cgl_blend7(col,col7,amount7);\n    #endif\n    #ifdef USE_TEX_8\n        vec4 col8=texture(tex8,texCoord);\n        col=cgl_blend8(col,col8,amount8);\n    #endif\n\n    outColor=col;\n\n}\n",};
const blendmodes = ["normal", "lighten", "darken", "multiply", "multiply invert", "average", "add", "substract", "difference", "negation", "exclusion", "overlay", "screen", "color dodge", "color burn", "softlight", "hardlight"];
const
    render = op.inTrigger("render"),
    maskInvert = op.inBool("Mask Invert", false),
    trigger = op.outTrigger("trigger");
const
    NUM = 8,
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name),
    amounts = [],
    blends = [],
    alphas = [],
    texMasks = [],
    maskModes = [],
    texs = [];

let needsUpdate = true;

for (let i = 0; i < NUM; i++)
{
    const tex = op.inTexture("Texture " + (i + 1));
    const blend = op.inDropDown("Blendmode " + (i + 1), blendmodes, "normal");
    const texMask = op.inTexture("Mask " + (i + 1));
    const maskMode = op.inSwitch("Mask Source " + (i + 1), ["R", "R inv", "A", "A inv"], "R");
    const alpha = op.inSwitch("Opacity " + (i + 1), ["Normal", "Prev A", "Prev R"], "Normal");
    const amount = op.inValueSlider("Amount " + (i + 1), 1);

    blend.onChange =
    alpha.onChange =
    maskMode.onChange =
    texMask.onLinkChanged =
    tex.onLinkChanged = () => { needsUpdate = true; };

    texs.push(tex);
    texMasks.push(texMask);
    alphas.push(alpha);
    blends.push(blend);
    amounts.push(amount);
    maskModes.push(maskMode);

    op.setPortGroup("Image " + (i + 1), [tex, blend, amount, alpha, texMask, maskMode]);

    new CGL.Uniform(shader, "t", "tex" + (i + 1), i * 2 + 1);
    new CGL.Uniform(shader, "t", "texMask" + (i + 1), i * 2 + 2);
    new CGL.Uniform(shader, "f", "amount" + (i + 1), amount);
}

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

function setBlendCode()
{
    let defines = "";
    let blendcode = "";
    for (let i = 0; i < NUM; i++)
    {
        let active = texs[i].isLinked();
        amounts[i].setUiAttribs({ "greyout": !active });
        blends[i].setUiAttribs({ "greyout": !active });
        alphas[i].setUiAttribs({ "greyout": !active });

        if (active)
        {
            defines += "#define USE_TEX_" + (i + 1) + "".endl();
            blendcode += getBlendCode(i + 1,
                blends[i].get(),
                alphas[i].get(),
                texMasks[i].get(),
                maskModes[i].get());
        }
    }

    let src = defines.endl() + attachments.invert_frag;
    src = src.replace("{{BLENDCODE}}", blendcode);

    shader.setSource(shader.getDefaultVertexShader(), src);

    needsUpdate = false;
}

function getBlendCode(idx, name, alpha, hasMask, maskMode)
{
    let src = ""
        + "vec3 _blend" + idx + "(vec3 base,vec3 blend)".endl()
        + "{".endl()
        + "   vec3 colNew=blend;".endl();

    if (name == "multiply") src += "       colNew=base*blend;".endl();
    else if (name == "multiply invert") src += "       colNew=base* vec3(1.0)-blend;".endl();
    else if (name == "average") src += "       colNew=((base + blend) / 2.0);".endl();
    else if (name == "add") src += "       colNew=min(base + blend, vec3(1.0));".endl();
    else if (name == "substract") src += "       colNew=max(base + blend - vec3(1.0), vec3(0.0));".endl();
    else if (name == "difference") src += "       colNew=abs(base - blend);".endl();
    else if (name == "negation") src += "       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));".endl();
    else if (name == "exclusion") src += "       colNew=(base + blend - 2.0 * base * blend);".endl();
    else if (name == "lighten") src += "       colNew=max(blend, base);".endl();
    else if (name == "darken") src += "       colNew=min(blend, base);".endl();
    else if (name == "overlay")
    {
        src += ""
        + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))".endl()
        + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl();
    }
    else if (name == "screen")
    {
        src += ""
        + "      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))".endl()
        + "      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));".endl();
    }
    else if (name == "softlight")
    {
        src += ""
        + "      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))".endl()
        + "      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));".endl();
    }
    else if (name == "hardlight")
    {
        src += ""
        + "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))".endl()
        + "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl();
    }
    else if (name == "color dodge")
    {
        src += ""
        + "      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))".endl()
        + "      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));".endl();
    }
    else if (name == "color burn")
    {
        src += ""
        + "      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))".endl()
        + "      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));".endl();
    }

    src += ""
        + "   return colNew;".endl()
        + "}".endl()

        + "vec4 cgl_blend" + idx + "(vec4 oldColor,vec4 newColor,float amount)".endl()
        + "{".endl()
        // +"vec4 col=vec4(0.0,0.0,0.0,1.0);"

    // +"if(newColor.a==0.0)return vec4(0.0);".endl()
        + "float a=(amount*newColor.a);".endl();

    if (alpha === "Prev A") src += "a*=oldColor.a;";
    if (alpha === "Prev R") src += "a*=oldColor.r;";

    src = src

        + "vec4 col = vec4( _blend" + idx + "(oldColor.rgb, newColor.rgb), 1.0);".endl()
        + "col = vec4( mix( col.rgb,oldColor.rgb, col.a * 1.0-amount), 1.0);".endl();

    if (hasMask)
        if (maskMode === "R")src = src + "newColor.a *= texture(texMask" + idx + ",texCoord).r;".endl();
        else if (maskMode === "R inv")src = src + "newColor.a *= 1.0-texture(texMask" + idx + ",texCoord).r;".endl();
        else if (maskMode === "A")src = src + "newColor.a *= texture(texMask" + idx + ",texCoord).a;".endl();
        else if (maskMode === "A inv")src = src + "newColor.a *= 1.0-texture(texMask" + idx + ",texCoord).a;".endl();

    src = src + "col = vec4( mix( oldColor,col, newColor.a));".endl()

    // + "vec3 blendedCol=_blend"+idx+"(newColor.rgb,newColor.rgb);".endl()
    // + "col.rgb=mix(oldColor.rgb,newColor.rgb,a);".endl()

    // + "col.a=clamp(oldColor.a+a,0.0,1.0);".endl()

            + "return col;".endl()
        + "}".endl().endl();
    return src;
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    if (needsUpdate)setBlendCode();

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    let count = 1;
    for (let i = 0; i < texs.length; i++)
    {
        if (texs[i].get())
        {
            cgl.setTexture(i * 2 + 1, texs[i].get().tex);
            count++;
        }
        if (texMasks[i].get())
        {
            cgl.setTexture(i * 2 + 2, texMasks[i].get().tex);
            count++;
        }
    }
    if (count > cgl.maxTextureUnits) op.setUiError("manytex", "Too many textures bound");
    else op.setUiError("manytex", null);

    cgl.pushBlendMode(CGL.BLEND_NONE, true);
    cgl.currentTextureEffect.finish();
    cgl.popBlendMode();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.MultiDrawImage.prototype = new CABLES.Op();
CABLES.OPS["4df51ead-c46c-471d-ac5e-1872219a3174"]={f:Ops.Gl.TextureEffects.MultiDrawImage,objName:"Ops.Gl.TextureEffects.MultiDrawImage"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.CellularNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.CellularNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"cellularnoise3d_frag":"UNI float z;\nUNI float x;\nUNI float y;\nUNI float scale;\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float harmonics;\nUNI float aspect;\n\n#ifdef HAS_TEX_OFFSETMAP\n    UNI sampler2D texOffsetZ;\n    UNI float offMul;\n#endif\n\n#ifdef HAS_TEX_MASK\n    UNI sampler2D texMask;\n#endif\n\n{{CGL.BLENDMODES3}}\n\nvoid FAST32_hash_3D( \tvec3 gridcell,\n                        out vec4 lowz_hash_0,\n                        out vec4 lowz_hash_1,\n                        out vec4 lowz_hash_2,\n                        out vec4 highz_hash_0,\n                        out vec4 highz_hash_1,\n                        out vec4 highz_hash_2\t)\t\t//\tgenerates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\n\n\n\n\nvec4 Cellular_weight_samples( vec4 samples )\n{\n    samples = samples * 2.0 - 1.0;\n    //return (1.0 - samples * samples) * sign(samples);\t// square\n    return (samples * samples * samples) - sign(samples);\t// cubic (even more variance)\n}\n\n\n//\n//\tCellular Noise 3D\n//\tBased off Stefan Gustavson's work at http://www.itn.liu.se/~stegu/GLSL-cellular\n//\thttp://briansharpe.files.wordpress.com/2011/12/cellularsample.jpg\n//\n//\tSpeed up by using 2x2x2 search window instead of 3x3x3\n//\tproduces range of 0.0->1.0\n//\nfloat Cellular3D(vec3 P)\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_x0, hash_y0, hash_z0, hash_x1, hash_y1, hash_z1;\n    FAST32_hash_3D( Pi, hash_x0, hash_y0, hash_z0, hash_x1, hash_y1, hash_z1 );\n    //SGPP_hash_3D( Pi, hash_x0, hash_y0, hash_z0, hash_x1, hash_y1, hash_z1 );\n\n    //\tgenerate the 8 random points\n#if 1\n    //\trestrict the random point offset to eliminate artifacts\n    //\twe'll improve the variance of the noise by pushing the points to the extremes of the jitter window\n    const float JITTER_WINDOW = 0.166666666;\t// 0.166666666 will guarentee no artifacts. It is the intersection on x of graphs f(x)=( (0.5 + (0.5-x))^2 + 2*((0.5-x)^2) ) and f(x)=( 2 * (( 0.5 + x )^2) + x * x )\n    hash_x0 = Cellular_weight_samples( hash_x0 ) * JITTER_WINDOW + vec4(0.0, 1.0, 0.0, 1.0);\n    hash_y0 = Cellular_weight_samples( hash_y0 ) * JITTER_WINDOW + vec4(0.0, 0.0, 1.0, 1.0);\n    hash_x1 = Cellular_weight_samples( hash_x1 ) * JITTER_WINDOW + vec4(0.0, 1.0, 0.0, 1.0);\n    hash_y1 = Cellular_weight_samples( hash_y1 ) * JITTER_WINDOW + vec4(0.0, 0.0, 1.0, 1.0);\n    hash_z0 = Cellular_weight_samples( hash_z0 ) * JITTER_WINDOW + vec4(0.0, 0.0, 0.0, 0.0);\n    hash_z1 = Cellular_weight_samples( hash_z1 ) * JITTER_WINDOW + vec4(1.0, 1.0, 1.0, 1.0);\n#else\n    //\tnon-weighted jitter window.  jitter window of 0.4 will give results similar to Stefans original implementation\n    //\tnicer looking, faster, but has minor artifacts.  ( discontinuities in signal )\n    const float JITTER_WINDOW = 0.4;\n    hash_x0 = hash_x0 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, 1.0-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_y0 = hash_y0 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_x1 = hash_x1 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, 1.0-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_y1 = hash_y1 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_z0 = hash_z0 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, -JITTER_WINDOW, -JITTER_WINDOW);\n    hash_z1 = hash_z1 * JITTER_WINDOW * 2.0 + vec4(1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n#endif\n\n    //\treturn the closest squared distance\n    vec4 dx1 = Pf.xxxx - hash_x0;\n    vec4 dy1 = Pf.yyyy - hash_y0;\n    vec4 dz1 = Pf.zzzz - hash_z0;\n    vec4 dx2 = Pf.xxxx - hash_x1;\n    vec4 dy2 = Pf.yyyy - hash_y1;\n    vec4 dz2 = Pf.zzzz - hash_z1;\n    vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;\n    vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;\n    d1 = min(d1, d2);\n    d1.xy = min(d1.xy, d1.wz);\n    return min(d1.x, d1.y) * ( 9.0 / 12.0 );\t//\tscale return value from 0.0->1.333333 to 0.0->1.0  \t(2/3)^2 * 3  == (12/9) == 1.333333\n}\n\n\nvoid main()\n{\n\n\n    vec2 p=vec2(texCoord.x-0.5,texCoord.y-0.5);\n\n    #ifdef DO_TILEABLE\n        p=abs(texCoord-0.5);\n    #endif\n\n    p.x*=aspect;\n\n    p=p*scale;\n\n    p=vec2(p.x+0.5-x,p.y+0.5-y);\n\n    vec3 offset;\n    #ifdef HAS_TEX_OFFSETMAP\n        vec4 offMap=texture(texOffsetZ,texCoord);\n\n        #ifdef OFFSET_X_R\n            offset.x=offMap.r;\n        #endif\n        #ifdef OFFSET_X_G\n            offset.x=offMap.g;\n        #endif\n        #ifdef OFFSET_X_B\n            offset.x=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Y_R\n            offset.y=offMap.r;\n        #endif\n        #ifdef OFFSET_Y_G\n            offset.y=offMap.g;\n        #endif\n        #ifdef OFFSET_Y_B\n            offset.y=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Z_R\n            offset.z=offMap.r;\n        #endif\n        #ifdef OFFSET_Z_G\n            offset.z=offMap.g;\n        #endif\n        #ifdef OFFSET_Z_B\n            offset.z=offMap.b;\n        #endif\n\n        offset*=offMul;\n\n    #endif\n\n    float v=Cellular3D(vec3(p.x,p.y,z)+offset);\n\n\n    if (harmonics >= 2.0) v += Cellular3D(vec3(p.x,p.y,z)*2.3+offset) * 0.5;\n    if (harmonics >= 3.0) v += Cellular3D(vec3(p.x,p.y,z)*4.2+offset) * 0.25;\n    if (harmonics >= 4.0) v += Cellular3D(vec3(p.x,p.y,z)*8.1+offset) * 0.125;\n    if (harmonics >= 5.0) v += Cellular3D(vec3(p.x,p.y,z)*16.7+offset) * 0.0625;\n\n\n    vec4 col=vec4(v,v,v,1.0);\n\n    vec4 base=texture(tex,texCoord);\n\n\n    float str=1.0;\n    #ifdef HAS_TEX_MASK\n        str=texture(texMask,texCoord).r;\n    #endif\n\n    outColor=cgl_blendPixel(base,col,amount*str);\n\n}\n",};
const
    render = op.inTrigger("render"),
    inTexMask = op.inTexture("Mask"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),

    amount = op.inValueSlider("Amount", 1),
    x = op.inValue("X", 0),
    y = op.inValue("Y", 0),
    z = op.inValue("Z", 0),
    scale = op.inValue("Scale", 5),

    inHarmonics = op.inSwitch("Harmonics", ["1", "2", "3", "4", "5"], "1"),
    tile = op.inValueBool("Tileable", false),

    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.cellularnoise3d_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniOffset = new CGL.Uniform(shader, "t", "texOffsetZ", 1),
    uniMask = new CGL.Uniform(shader, "t", "texMask", 2),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniZ = new CGL.Uniform(shader, "f", "z", z),
    uniX = new CGL.Uniform(shader, "f", "x", x),
    uniY = new CGL.Uniform(shader, "f", "y", y),
    uniScale = new CGL.Uniform(shader, "f", "scale", scale);

tile.onChange = updateTileable;
function updateTileable()
{
    if (tile.get())shader.define("DO_TILEABLE");
    else shader.removeDefine("DO_TILEABLE");
}

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount,maskAlpha);

// offsetMap

const
    inTexOffsetTex = op.inTexture("Offset"),
    inOffsetMul = op.inFloat("Offset Multiply", 1),

    offsetX = op.inSwitch("Offset X", ["None", "R", "G", "B"], "None"),
    offsetY = op.inSwitch("Offset Y", ["None", "R", "G", "B"], "None"),
    offsetZ = op.inSwitch("Offset Z", ["None", "R", "G", "B"], "R");

const uniOffMul = new CGL.Uniform(shader, "f", "offMul", inOffsetMul);

op.setPortGroup("Offset Map", [inTexOffsetTex, offsetZ, offsetY, offsetX, inOffsetMul]);

const uniAspect = new CGL.Uniform(shader, "f", "aspect", 1);
const uniHarmonics = new CGL.Uniform(shader, "f", "harmonics", 0);
inHarmonics.onChange = () =>
{
    uniHarmonics.setValue(parseFloat(inHarmonics.get()));
};

offsetX.onChange =
offsetY.onChange =
offsetZ.onChange =
inTexMask.onChange =
inTexOffsetTex.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("HAS_TEX_OFFSETMAP", inTexOffsetTex.get());
    shader.toggleDefine("HAS_TEX_MASK", inTexMask.get());

    shader.toggleDefine("OFFSET_X_R", offsetX.get() == "R");
    shader.toggleDefine("OFFSET_X_G", offsetX.get() == "G");
    shader.toggleDefine("OFFSET_X_B", offsetX.get() == "B");

    shader.toggleDefine("OFFSET_Y_R", offsetY.get() == "R");
    shader.toggleDefine("OFFSET_Y_G", offsetY.get() == "G");
    shader.toggleDefine("OFFSET_Y_B", offsetY.get() == "B");

    shader.toggleDefine("OFFSET_Z_R", offsetZ.get() == "R");
    shader.toggleDefine("OFFSET_Z_G", offsetZ.get() == "G");
    shader.toggleDefine("OFFSET_Z_B", offsetZ.get() == "B");

    offsetX.setUiAttribs({ "greyout": !inTexOffsetTex.isLinked() });
    offsetY.setUiAttribs({ "greyout": !inTexOffsetTex.isLinked() });
    offsetZ.setUiAttribs({ "greyout": !inTexOffsetTex.isLinked() });
}

// end offsetmap

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inTexOffsetTex.get()) cgl.setTexture(1, inTexOffsetTex.get().tex);
    if (inTexMask.get()) cgl.setTexture(2, inTexMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.CellularNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["e0ce24fe-4ddb-4df4-a087-623cf4c711a7"]={f:Ops.Gl.TextureEffects.Noise.CellularNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.CellularNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.FBMNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.FBMNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"fbmnoise_frag":"UNI sampler2D tex;\nUNI float anim;\n\nUNI float scale;\nUNI float repeat;\n\nUNI float scrollX;\nUNI float scrollY;\n\nUNI float amount;\n\nUNI bool layer1;\nUNI bool layer2;\nUNI bool layer3;\nUNI bool layer4;\nUNI vec3 color;\nUNI float aspect;\n\nIN vec2 texCoord;\n\n\n{{CGL.BLENDMODES3}}\n\n// csdcsdcds\n// adapted from warp shader by inigo quilez/iq\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See here for a tutorial on how to make this: http://www.iquilezles.org/www/articles/warp/warp.htm\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvoid main()\n{\n    vec2 tc=texCoord;\n\t#ifdef DO_TILEABLE\n\t    tc=abs(texCoord-0.5);\n\t#endif\n\n    vec2 p=(tc-0.5)*scale;\n\n    p.y/=aspect;\n    vec2 q = vec2( fbm4( p + vec2(0.3+scrollX,0.20+scrollY) ),\n                   fbm4( p + vec2(3.1+scrollX,1.3+scrollY) ) );\n\n    vec2 q2 = vec2( fbm4( p + vec2(2.0+scrollX,1.0+scrollY) ),\n                   fbm4( p + vec2(3.1+scrollX,1.3+scrollY) ) );\n\n    vec2 q3 = vec2( fbm4( p + vec2(9.0+scrollX,4.0+scrollY) ),\n                   fbm4( p + vec2(3.1+scrollX,4.3+scrollY) ) );\n\n    float v= fbm4( ( p + 4.0*q +anim*0.1)*repeat);\n    float v2= fbm4( (p + 4.0*q2 +anim*0.1)*repeat );\n\n    float v3= fbm6( (p + 4.0*q3 +anim*0.1)*repeat );\n    float v4= fbm6( (p + 4.0*q2 +anim*0.1)*repeat );\n\n    vec4 base=texture(tex,texCoord);\n\n    vec4 finalColor;\n    float colVal=0.0;\n    float numLayers=0.0;\n\n    if(layer1)\n    {\n        colVal+=v;\n        numLayers++;\n    }\n\n    if(layer2)\n    {\n        colVal+=v2;\n        numLayers++;\n    }\n\n    if(layer3)\n    {\n        colVal+=v3;\n        numLayers++;\n    }\n\n    if(layer4)\n    {\n        colVal+=v4;\n        numLayers++;\n    }\n\n    finalColor=vec4( color*vec3(colVal/numLayers),1.0);\n\n    outColor = cgl_blendPixel(base,finalColor,amount);\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    r = op.inValueSlider("r", 1.0),
    g = op.inValueSlider("g", 1.0),
    b = op.inValueSlider("b", 1.0),
    trigger = op.outTrigger("trigger");

r.setUiAttribs({ "colorPick": true });

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "fbmnoise");

shader.setSource(shader.getDefaultVertexShader(), attachments.fbmnoise_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniScale = new CGL.Uniform(shader, "f", "scale", op.inValue("scale", 2)),
    uniAnim = new CGL.Uniform(shader, "f", "anim", op.inValue("anim", 0)),
    uniScrollX = new CGL.Uniform(shader, "f", "scrollX", op.inValue("scrollX", 9)),
    uniScrollY = new CGL.Uniform(shader, "f", "scrollY", op.inValue("scrollY", 0)),
    uniRepeat = new CGL.Uniform(shader, "f", "repeat", op.inValue("repeat", 1)),
    uniAspect = new CGL.Uniform(shader, "f", "aspect", op.inValue("aspect", 1)),
    uniLayer1 = new CGL.Uniform(shader, "b", "layer1", op.inValueBool("Layer 1", true)),
    uniLayer2 = new CGL.Uniform(shader, "b", "layer2", op.inValueBool("Layer 2", true)),
    uniLayer3 = new CGL.Uniform(shader, "b", "layer3", op.inValueBool("Layer 3", true)),
    uniLayer4 = new CGL.Uniform(shader, "b", "layer4", op.inValueBool("Layer 4", true)),
    uniColor = new CGL.Uniform(shader, "3f", "color", r, g, b),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

const tile = op.inValueBool("Tileable", false);
tile.onChange = updateTileable;

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

function updateTileable()
{
    shader.toggleDefine("DO_TILEABLE", tile.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    uniAspect.set(cgl.currentTextureEffect.getCurrentSourceTexture().width / cgl.currentTextureEffect.getCurrentSourceTexture().height);

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.FBMNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["9422eeab-b6c5-47d1-8737-d5c43dc137a3"]={f:Ops.Gl.TextureEffects.Noise.FBMNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.FBMNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.GlitchNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.GlitchNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"glitchnoise_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n\n{{CGL.BLENDMODES3}}\n\nUNI float amount;\nUNI float time;\nUNI float frequency;\nUNI float strength;\nUNI float blockSizeA;\nUNI float blockSizeB;\nUNI float blockSizeC;\nUNI float blockSizeD;\nUNI float scrollX;\nUNI float scrollY;\n\nfloat rng2(vec2 seed)\n{\n    return fract(sin(dot(seed * floor(time * (frequency * 10.0)), vec2(127.1,311.7))) * 43758.5453123);//43758.5453123\n}\n\nfloat rng(float seed)\n{\n    return rng2(vec2(seed, 1.0));\n}\n\nvoid main( )\n{\n    //add scroll for x and y\n    vec2 scrollXY = vec2(scrollX,scrollY);\n    vec2 blockS = floor((texCoord + scrollXY ) * vec2(blockSizeA,blockSizeB));\n    vec2 blockL = floor((texCoord )  * vec2(blockSizeC,blockSizeD));\n\n    float r = rng2(texCoord);\n    vec3 noise = (vec3(r, 1. - r, r / 2. + 0.5) * 1.0 - 2.0) * 0.08;\n\n    float lineNoise = pow(rng2(blockS), 8.0) * pow(rng2(blockL), 3.0) - pow(rng(7.2341), 17.0) * 2.;\n\n    vec4 col1 = texture(tex, texCoord);\n    vec4 col2 = texture(tex, texCoord + vec2(lineNoise * (0.05 * strength)  * rng(5.0), 1));\n    vec4 col3 = texture(tex, texCoord - vec2(lineNoise * (0.05 * strength) * rng(31.0), 1));\n\n    float glitch = (lineNoise * strength * rng(5.0)) + (lineNoise * strength * rng(31.));\n    float glitch2 = lineNoise * strength * rng(31.);\n\n    //blend section\n    vec4 col=vec4(vec3(glitch),1.0);\n    //original texture\n    vec4 base=texture(tex,texCoord);\n\n    outColor=cgl_blendPixel(base,col,amount);\n\n}",};
const
    render = op.inTrigger("render"),
    amount = op.inValueSlider("Amount", 1),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),

    time = op.inValue("Seed", 0),
    inFrequency = op.inValue("frequency", 1),
    inStrength = op.inValue("strength", 8.0),
    inBlockSizeA = op.inValue("Block size small x", 24.0),
    inBlockSizeB = op.inValue("Block size small y", 9.0),
    inBlockSizeC = op.inValue("Block size large x", 8.0),
    inBlockSizeD = op.inValue("Block size large y", 4.0),
    inScrollX = op.inValue("Scroll X", 0.0),
    inScrollY = op.inValue("Scroll Y", 0.0),
    trigger = op.outTrigger("trigger");

const TEX_SLOT = 0;
const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
shader.setSource(shader.getDefaultVertexShader(), attachments.glitchnoise_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", TEX_SLOT),
    uniformAmount = new CGL.Uniform(shader, "f", "amount", amount),
    timeUniform = new CGL.Uniform(shader, "f", "time", time),
    frequencyUniform = new CGL.Uniform(shader, "f", "frequency", inFrequency),
    strengthUniform = new CGL.Uniform(shader, "f", "strength", inStrength),
    sizeAUniform = new CGL.Uniform(shader, "f", "blockSizeA", inBlockSizeA),
    sizeBUniform = new CGL.Uniform(shader, "f", "blockSizeB", inBlockSizeB),
    sizeCUniform = new CGL.Uniform(shader, "f", "blockSizeC", inBlockSizeC),
    sizeDUniform = new CGL.Uniform(shader, "f", "blockSizeD", inBlockSizeD),
    scrollXUniform = new CGL.Uniform(shader, "f", "scrollX", inScrollX),
    scrollYUniform = new CGL.Uniform(shader, "f", "scrollY", inScrollY);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(TEX_SLOT, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.GlitchNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["87de572e-644a-4613-b0f3-68b9ec74f489"]={f:Ops.Gl.TextureEffects.Noise.GlitchNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.GlitchNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.HexagonNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.HexagonNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"hexnoise_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float scale;\nUNI float addX;\nUNI float addY;\nUNI float addZ;\nUNI float seed2;\nUNI float minIn;\nUNI float maxIn;\n\nUNI float aspect;\n{{CGL.BLENDMODES3}}\n\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n//cell code from https://www.shadertoy.com/view/lldfWH\nvec4 hex(vec2 uv, out vec2 id)\n{\n    // #ifdef ASPECT\n        uv.x*=aspect;\n    // #endif\n\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0) { f = 1.0 - f; triid = -1.0; }\n\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);\n\n    uv = abs(co);\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\nfloat random(vec2 co)\n{\n    float r=fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * (5.711+(mod(addZ+5711.210,57.0))));\n\n    #ifdef LOOP\n        r=abs(r-0.5)*2.0;\n    #endif\n\n    return r;\n}\n\n\nvoid main()\n{\n    vec2 uv = texCoord;\n    uv -= 0.5;\n    uv -= vec2(addX,addY);\n    uv*=scale;\n\n    #ifdef FLIP\n        pR(uv.xy,0.25*TAU);\n    #endif\n\n    float r,g,b;\n    vec4 rnd = vec4(0.0);\n\n    // get hexagon cell id\n    vec2 id0;\n    vec4 h = hex(uv*4.0, id0);\n\n    #ifndef RGB\n        r=g=b= random(id0.xy*id0.xy+seed2);\n    #endif\n\n    #ifdef RGB\n        r = random(((id0.xy*id0.xy)*0.234)+seed2);\n        g = random(((id0.xy*id0.xy)*0.234)+seed2+0.9812);\n        b = random(((id0.xy*id0.xy)*0.234)+seed2+57.101);\n    #endif\n\n    rnd = clamp( vec4( r,g,b,1.0 ),vec4(minIn), vec4(maxIn) );\n    vec4 base=texture(tex,texCoord);\n\n    outColor=cgl_blendPixel(base,rnd,amount);\n}\n\n//",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    inLoop = op.inValueBool("Loop", false),
    inRGB = op.inValueBool("RGB", false),
    minValue = op.inValue("Minimum value", 0),
    maxValue = op.inValue("Maximum value", 1),
    scale = op.inValue("Scale", 3),
    orientation = op.inBool("Orientation", false),
    addX = op.inValue("X", 0),
    addY = op.inValue("Y", 0),
    addZ = op.inValue("Z", 0),
    seed2 = op.inValue("Seed", 0),
    trigger = op.outTrigger("Next");

op.setPortGroup("Look", [inRGB, inLoop, minValue, maxValue]);
op.setPortGroup("Position", [addX, addY, addZ]);
op.setPortGroup("Position", [addX, addY, addZ]);
op.setPortGroup("", [scale, orientation]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
shader.setSource(shader.getDefaultVertexShader(), attachments.hexnoise_frag);

const
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    timeUniform = new CGL.Uniform(shader, "f", "time", 1.0),
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uni_scale = new CGL.Uniform(shader, "f", "scale", scale),
    uni_addX = new CGL.Uniform(shader, "f", "addX", addX),
    uni_addY = new CGL.Uniform(shader, "f", "addY", addY),
    uni_addZ = new CGL.Uniform(shader, "f", "addZ", addZ),
    uni_seed = new CGL.Uniform(shader, "f", "seed2", seed2),
    uni_minValue = new CGL.Uniform(shader, "f", "minIn", minValue),
    uni_maxValue = new CGL.Uniform(shader, "f", "maxIn", maxValue),
    uni_asp = new CGL.Uniform(shader, "f", "aspect", 1);

inLoop.onChange =
inRGB.onChange =
orientation.onChange = updateDefines;

function updateDefines()
{
    shader.toggleDefine("FLIP", orientation.get());
    shader.toggleDefine("RGB", inRGB.get());
    shader.toggleDefine("LOOP", inLoop.get());
}

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    uni_asp.setValue(cgl.currentTextureEffect.aspectRatio);

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.HexagonNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["1c4def10-3574-4ef7-8abc-de28d2293095"]={f:Ops.Gl.TextureEffects.Noise.HexagonNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.HexagonNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.LayerNoise_v3
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.LayerNoise_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"layernoise_frag":"// @author Jan <LJ> Scheurer - Xe-Development UG\n// @copyright undefined development UG\n\n{{MODULES_HEAD}}\n\nUNI int mode;\nUNI vec4 attribs;\nUNI vec3 scroll;\nUNI bool rgba;\nUNI float amount;\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI float aspect;\n\n{{CGL.BLENDMODES3}}\n\n#define LINEAR 0\n#define EXPONENTIAL 1\n#define LOGARITHMIC 2\n\nfloat rand (vec3 p) {\n    return fract(sin(dot(p,vec3(12.4085,48.512313,32.6143)))*42754.71415);\n}\n\nconst vec2 O = vec2(0,1);\n\nfloat noise (vec3 p) {\n    vec3 b=floor(p),f=fract(p);\n    return mix(\n        mix(mix(rand(b+O.xxx),rand(b+O.yxx),f.x),mix(rand(b+O.xyx),rand(b+O.yyx),f.x),f.y),\n        mix(mix(rand(b+O.xxy),rand(b+O.yxy),f.x),mix(rand(b+O.xyy),rand(b+O.yyy),f.x),f.y),\n        f.z\n    );\n}\n\nfloat gn(vec3 p){\n    float n = 0., fi;\n    int numLayers = int(attribs.g);\n    for (int i = 1; i < 100; i++) {\n        if (i > numLayers) break;\n        if (mode == LINEAR)\n            fi = float(i),p+=attribs.r;\n        else if (mode == EXPONENTIAL)\n            fi = float(pow(float(i),attribs.a));\n        else if (mode == LOGARITHMIC)\n            fi = log(float(i+1)),p+=attribs.r;\n        n += noise(p*fi) / fi;\n    }\n    return n*attribs.b;\n}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    vec2 tc=texCoord;\n    tc.y/=aspect;\n\n\t#ifdef DO_TILEABLE\n\t    tc=abs(texCoord-0.5);\n\t#endif\n    vec3 p = vec3(tc * 2. - 1.,0) + scroll;\n    vec4 col;\n    if (rgba)\n    {\n        for(int i = 0; i < 4; i++)\n        {\n            col[i] = gn(p*attribs.r);\n            p += attribs.r;\n        }\n    } else col = vec4(vec3(gn(p*attribs.r)),1);\n\n    outColor=cgl_blendPixel(base,col,amount);\n}",};
const cgl = op.patch.cgl;

// inputs
const
    inTrigger = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inFloatSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    inLayerMode = op.inValueSelect("mode", [
        "exponential",
        "logarithmic",
        "linear"
    ], "exponential"),
    inRGBA = op.inValueBool("RGBA"),
    inScale = op.inValue("scale", 7),
    inNumLayers = op.inValueInt("layers", 3),
    inFactor = op.inFloat("factor", 1),
    inExponent = op.inFloat("exponent", 2),
    inScrollX = op.inFloat("scrollX"),
    inScrollY = op.inFloat("scrollY"),
    inScrollZ = op.inFloat("scrollZ"),
    tile = op.inValueBool("Tileable", false),
    outTrigger = op.outTrigger("trigger");

// locals
const TEX_SLOT = 0;
const shader = new CGL.Shader(cgl, "layernoise");
const attribs = [inScale.get(), inNumLayers.get(), inFactor.get(), 0];
shader.setSource(shader.getDefaultVertexShader(), attachments.layernoise_frag);
const attributes = new CGL.Uniform(shader, "4f", "attribs", attribs);

const uniMode = new CGL.Uniform(shader, "i", "mode", 2);
shader._addUniform(uniMode);
const uniRGBA = new CGL.Uniform(shader, "b", "rgba", false);
const scrollArr = [inScrollX.get(), inScrollY.get(), inScrollZ.get()];
const uniScroll = new CGL.Uniform(shader, "3f", "scroll", scrollArr);
const uniformAmount = new CGL.Uniform(shader, "f", "amount", amount);
const uniAspect = new CGL.Uniform(shader, "f", "aspect", 1);
const textureUniform = new CGL.Uniform(shader, "t", "tex", TEX_SLOT);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

let needsUpdate = false;
// events

tile.onChange = updateTileable;

inTrigger.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    if (needsUpdate)
    {
        attribs[0] = inScale.get();
        attribs[1] = inNumLayers.get();

        const layerMode = inLayerMode.get();
        if (layerMode == "linear")
            uniMode.set(0);
        else if (layerMode == "exponential")
            uniMode.set(1);
        else
            uniMode.set(2);

        attribs[2] = inFactor.get();
        attribs[3] = inExponent.get();
        attributes.set(attribs);

        uniRGBA.set(inRGBA.get());
        scroll[0] = inScrollX.get();
        scroll[1] = inScrollY.get();
        scroll[2] = inScrollZ.get();
        uniScroll.set(scroll);

        needsUpdate = false;
    }

    uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.setTexture(TEX_SLOT, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();
    cgl.currentTextureEffect.finish();
    cgl.popShader();
    outTrigger.trigger();
};

function updateTileable()
{
    shader.toggleDefine("DO_TILEABLE", tile.get());
}

inScale.onChange =
    inNumLayers.onChange =
    inLayerMode.onChange =
    inExponent.onChange =
    inFactor.onChange =
    inRGBA.onChange =
    inScrollX.onChange =
    inScrollY.onChange =
    inScrollZ.onChange = update;
function update()
{
    needsUpdate = true;
}
update();


};

Ops.Gl.TextureEffects.Noise.LayerNoise_v3.prototype = new CABLES.Op();
CABLES.OPS["b918b3f1-53ee-4d32-92b7-73a1d00e0d69"]={f:Ops.Gl.TextureEffects.Noise.LayerNoise_v3,objName:"Ops.Gl.TextureEffects.Noise.LayerNoise_v3"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.Noise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.Noise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"noise_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float time;\n\n#ifdef HAS_MULMASK\n    UNI sampler2D texMul;\n#endif\n\n{{CGL.BLENDMODES3}}\n{{MODULES_HEAD}}\n\n{{CGL.RANDOM_TEX}}\n\nvoid main()\n{\n    vec4 rnd;\n\n    #ifdef RGB\n        rnd=vec4(cgl_random3(texCoord.xy+vec2(time)),1.0);\n    #else\n        float r=cgl_random(texCoord.xy+vec2(time));\n        rnd=vec4( r,r,r,1.0 );\n    #endif\n\n    vec4 base=texture(tex,texCoord);\n    vec4 col=rnd;//( _blend(base.rgb,rnd.rgb) ,1.0);\n\n    #ifdef NORMALIZE\n        col.rgb=(col.rgb-0.5)*2.0;\n    #endif\n\n    #ifdef HAS_MULMASK\n        col.rgb*=texture(texMul,texCoord).rgb;\n    #endif\n\n    outColor=cgl_blendPixel(base,col,amount);\n    // outColor=vec4( mix( col.rgb, base.rgb ,1.0-base.a*amount),1.0);\n}",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    amount = op.inValueSlider("Amount", 1),
    animated = op.inValueBool("Animated", true),
    inRGB = op.inValueBool("RGB", false),
    normalize = op.inValueBool("Normalize", false),
    inTexMul = op.inTexture("Multiply"),
    trigger = op.outTrigger("Next");

const
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    timeUniform = new CGL.Uniform(shader, "f", "time", 1.0),
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    mulUniform = new CGL.Uniform(shader, "t", "texMul", 1);

shader.setSource(shader.getDefaultVertexShader(), attachments.noise_frag);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount,maskAlpha);

op.toWorkPortsNeedToBeLinked(render);

inTexMul.onChange =
normalize.onChange =
inRGB.onChange = function ()
{
    shader.toggleDefine("HAS_MULMASK", inTexMul.get());
    shader.toggleDefine("RGB", inRGB.get());
    shader.toggleDefine("NORMALIZE", normalize.get());
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    if (animated.get()) timeUniform.setValue(op.patch.freeTimer.get() / 1000 % 100);
    else timeUniform.setValue(0);

    cgl.pushShader(shader);

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inTexMul.get())cgl.setTexture(1, inTexMul.get().tex);

    cgl.currentTextureEffect.bind();

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.Noise_v2.prototype = new CABLES.Op();
CABLES.OPS["b1d9aacc-dc52-43a6-a00f-414f08768800"]={f:Ops.Gl.TextureEffects.Noise.Noise_v2,objName:"Ops.Gl.TextureEffects.Noise.Noise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.PerlinNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.PerlinNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"perlinnoise3d_frag":"UNI float z;\nUNI float x;\nUNI float y;\nUNI float scale;\nUNI float rangeMul;\nUNI float harmonics;\nUNI float aspect;\n\nIN vec2 texCoord;\nUNI sampler2D tex;\n\n#ifdef HAS_TEX_OFFSETMAP\n    UNI sampler2D texOffsetZ;\n    UNI float offMul;\n#endif\n\n#ifdef HAS_TEX_MASK\n    UNI sampler2D texMask;\n#endif\n\nUNI float amount;\n\n{{CGL.BLENDMODES3}}\n\n\nfloat Interpolation_C2( float x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }   //  6x^5-15x^4+10x^3\t( Quintic Curve.  As used by Perlin in Improved Noise.  http://mrl.nyu.edu/~perlin/paper445.pdf )\nvec2 Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 Interpolation_C2( vec3 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2( vec4 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2_InterpAndDeriv( vec2 x ) { return x.xyxy * x.xyxy * ( x.xyxy * ( x.xyxy * ( x.xyxy * vec2( 6.0, 0.0 ).xxyy + vec2( -15.0, 30.0 ).xxyy ) + vec2( 10.0, -60.0 ).xxyy ) + vec2( 0.0, 30.0 ).xxyy ); }\nvec3 Interpolation_C2_Deriv( vec3 x ) { return x * x * (x * (x * 30.0 - 60.0) + 30.0); }\n\n\nvoid FAST32_hash_3D( vec3 gridcell, out vec4 lowz_hash, out vec4 highz_hash )\t//\tgenerates a random number for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const float SOMELARGEFLOAT = 635.298681;\n    const float ZINC = 48.500388;\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    highz_hash.xy = vec2( 1.0 / ( SOMELARGEFLOAT + vec2( gridcell.z, gridcell_inc1.z ) * ZINC ) );\n    lowz_hash = fract( P * highz_hash.xxxx );\n    highz_hash = fract( P * highz_hash.yyyy );\n}\n\n\n\n\nvoid FAST32_hash_3D( \tvec3 gridcell,\n                        out vec4 lowz_hash_0,\n                        out vec4 lowz_hash_1,\n                        out vec4 lowz_hash_2,\n                        out vec4 highz_hash_0,\n                        out vec4 highz_hash_1,\n                        out vec4 highz_hash_2\t)\t\t//\tgenerates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\nfloat Falloff_Xsq_C1( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq; }\t// ( 1.0 - x*x )^2   ( Used by Humus for lighting falloff in Just Cause 2.  GPUPro 1 )\nfloat Falloff_Xsq_C2( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\t// ( 1.0 - x*x )^3.   NOTE: 2nd derivative is 0.0 at x=1.0, but non-zero at x=0.0\nvec4 Falloff_Xsq_C2( vec4 xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\n\n\n//\n//\tPerlin Noise 3D  ( gradient noise )\n//\tReturn value range of -1.0->1.0\n//\thttp://briansharpe.files.wordpress.com/2011/11/perlinsample.jpg\n//\nfloat Perlin3D( vec3 P )\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n#if 1\n    //\n    //\tclassic noise.\n    //\trequires 3 random values per point.  with an efficent hash function will run faster than improved noise\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n    //SGPP_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n\n    //\tcalculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n#if 1\n    //\tClassic Perlin Interpolation\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    final *= 1.1547005383792515290182975610039;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/sqrt(0.75)\n    return final;\n#else\n    //\tClassic Perlin Surflet\n    //\thttp://briansharpe.wordpress.com/2012/03/09/modifications-to-classic-perlin-noise/\n    Pf *= Pf;\n    Pf_min1 *= Pf_min1;\n    vec4 vecs_len_sq = vec4( Pf.x, Pf_min1.x, Pf.x, Pf_min1.x ) + vec4( Pf.yy, Pf_min1.yy );\n    float final = dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf.zzzz ) ), grad_results_0 ) + dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf_min1.zzzz ) ), grad_results_1 );\n    final *= 2.3703703703703703703703703703704;\t\t//\t(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/cube(0.75)\n    return final;\n#endif\n\n#else\n    //\n    //\timproved noise.\n    //\trequires 1 random value per point.  Will run faster than classic noise if a slow hashing function is used\n    //\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_lowz, hash_highz;\n    FAST32_hash_3D( Pi, hash_lowz, hash_highz );\n    //BBS_hash_3D( Pi, hash_lowz, hash_highz );\n    //SGPP_hash_3D( Pi, hash_lowz, hash_highz );\n\n    //\n    //\t\"improved\" noise using 8 corner gradients.  Faster than the 12 mid-edge point method.\n    //\tKen mentions using diagonals like this can cause \"clumping\", but we'll live with that.\n    //\t[1,1,1]  [-1,1,1]  [1,-1,1]  [-1,-1,1]\n    //\t[1,1,-1] [-1,1,-1] [1,-1,-1] [-1,-1,-1]\n    //\n    hash_lowz -= 0.5;\n    vec4 grad_results_0_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_lowz );\n    hash_lowz = abs( hash_lowz ) - 0.25;\n    vec4 grad_results_0_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_lowz );\n    vec4 grad_results_0_2 = Pf.zzzz * sign( abs( hash_lowz ) - 0.125 );\n    vec4 grad_results_0 = grad_results_0_0 + grad_results_0_1 + grad_results_0_2;\n\n    hash_highz -= 0.5;\n    vec4 grad_results_1_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_highz );\n    hash_highz = abs( hash_highz ) - 0.25;\n    vec4 grad_results_1_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_highz );\n    vec4 grad_results_1_2 = Pf_min1.zzzz * sign( abs( hash_highz ) - 0.125 );\n    vec4 grad_results_1 = grad_results_1_0 + grad_results_1_1 + grad_results_1_2;\n\n    //\tblend the gradients and return\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy ) * (2.0 / 3.0);\t//\t(optionally) mult by (2.0/3.0) to scale to a strict -1.0->1.0 range\n#endif\n}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    vec2 p=vec2(texCoord.x-0.5,texCoord.y-0.5);\n\n    p=p*scale;\n    p=vec2(p.x+0.5-x,p.y+0.5-y);\n\n\n\n    vec3 offset;\n    #ifdef HAS_TEX_OFFSETMAP\n        vec4 offMap=texture(texOffsetZ,texCoord);\n\n        #ifdef OFFSET_X_R\n            offset.x=offMap.r;\n        #endif\n        #ifdef OFFSET_X_G\n            offset.x=offMap.g;\n        #endif\n        #ifdef OFFSET_X_B\n            offset.x=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Y_R\n            offset.y=offMap.r;\n        #endif\n        #ifdef OFFSET_Y_G\n            offset.y=offMap.g;\n        #endif\n        #ifdef OFFSET_Y_B\n            offset.y=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Z_R\n            offset.z=offMap.r;\n        #endif\n        #ifdef OFFSET_Z_G\n            offset.z=offMap.g;\n        #endif\n        #ifdef OFFSET_Z_B\n            offset.z=offMap.b;\n        #endif\n        offset*=offMul;\n    #endif\n\n    float aa=texture(tex,texCoord).r;\n\n    float v = 0.0;\n    p.x*=aspect;\n\n    v+=Perlin3D(vec3(p.x,p.y,z)+offset);\n\n    #ifdef HARMONICS\n        if (harmonics >= 2.0) v += Perlin3D(vec3(p.x,p.y,z)*2.2+offset) * 0.5;\n        if (harmonics >= 3.0) v += Perlin3D(vec3(p.x,p.y,z)*4.3+offset) * 0.25;\n        if (harmonics >= 4.0) v += Perlin3D(vec3(p.x,p.y,z)*8.4+offset) * 0.125;\n        if (harmonics >= 5.0) v += Perlin3D(vec3(p.x,p.y,z)*16.5+offset) * 0.0625;\n    #endif\n\n\n    v*=rangeMul;\n    v=v*0.5+0.5;\n    float v2=v;\n    float v3=v;\n\n    #ifdef RGB\n        v2=Perlin3D(vec3(p.x+2.0,p.y+2.0,z))*0.5+0.5;\n\n        #ifdef HARMONICS\n            if (harmonics >= 2.0) v2 += Perlin3D(vec3(p.x,p.y,z)*2.2+offset) * 0.5;\n            if (harmonics >= 3.0) v2 += Perlin3D(vec3(p.x,p.y,z)*4.3+offset) * 0.25;\n            if (harmonics >= 4.0) v2 += Perlin3D(vec3(p.x,p.y,z)*8.4+offset) * 0.125;\n            if (harmonics >= 5.0) v2 += Perlin3D(vec3(p.x,p.y,z)*16.5+offset) * 0.0625;\n        #endif\n\n        v3=Perlin3D(vec3(p.x+3.0,p.y+3.0,z))*0.5+0.5;\n\n        #ifdef HARMONICS\n            if (harmonics >= 2.0) v3 += Perlin3D(vec3(p.x,p.y,z)*2.2+offset) * 0.5;\n            if (harmonics >= 3.0) v3 += Perlin3D(vec3(p.x,p.y,z)*4.3+offset) * 0.25;\n            if (harmonics >= 4.0) v3 += Perlin3D(vec3(p.x,p.y,z)*8.4+offset) * 0.125;\n            if (harmonics >= 5.0) v3 += Perlin3D(vec3(p.x,p.y,z)*16.5+offset) * 0.0625;\n        #endif\n\n    #endif\n\n    vec4 col=vec4(v,v2,v3,1.0);\n\n    float str=1.0;\n    #ifdef HAS_TEX_MASK\n        str=texture(texMask,texCoord).r;\n    #endif\n\n    col=cgl_blendPixel(base,col,amount*str);\n\n\n    #ifdef NO_CHANNEL_R\n        col.r=base.r;\n    #endif\n    #ifdef NO_CHANNEL_G\n        col.g=base.g;\n    #endif\n    #ifdef NO_CHANNEL_B\n        col.b=base.b;\n    #endif\n\n\n\n    outColor=col;\n}\n",};
const
    render = op.inTrigger("render"),
    inTexMask = op.inTexture("Mask"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    amount = op.inValueSlider("Amount", 1),
    inMode = op.inSwitch("Color", ["Mono", "RGB", "R", "G", "B"], "Mono"),
    scale = op.inValue("Scale", 8),
    rangeMul = op.inValue("Multiply", 1),
    inHarmonics = op.inSwitch("Harmonics", ["1", "2", "3", "4", "5"], "1"),
    x = op.inValue("X", 0),
    y = op.inValue("Y", 0),
    z = op.inValue("Z", 0),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "perlinnoise");

op.setPortGroup("Position", [x, y, z]);

shader.setSource(shader.getDefaultVertexShader(), attachments.perlinnoise3d_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureUniformOffZ = new CGL.Uniform(shader, "t", "texOffsetZ", 1),
    textureUniformMask = new CGL.Uniform(shader, "t", "texMask", 2),

    uniZ = new CGL.Uniform(shader, "f", "z", z),
    uniX = new CGL.Uniform(shader, "f", "x", x),
    uniY = new CGL.Uniform(shader, "f", "y", y),
    uniScale = new CGL.Uniform(shader, "f", "scale", scale),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    rangeMulUniform = new CGL.Uniform(shader, "f", "rangeMul", rangeMul);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

// offsetMap

const
    inTexOffsetZ = op.inTexture("Offset"),
    inOffsetMul = op.inFloat("Offset Multiply", 1),
    offsetX = op.inSwitch("Offset X", ["None", "R", "G", "B"], "None"),
    offsetY = op.inSwitch("Offset Y", ["None", "R", "G", "B"], "None"),
    offsetZ = op.inSwitch("Offset Z", ["None", "R", "G", "B"], "R");

op.setPortGroup("Offset Map", [inTexOffsetZ, offsetZ, offsetY, offsetX, inOffsetMul]);

const uniOffMul = new CGL.Uniform(shader, "f", "offMul", inOffsetMul);

const uniAspect = new CGL.Uniform(shader, "f", "aspect", 1);
const uniHarmonics = new CGL.Uniform(shader, "f", "harmonics", 0);

inHarmonics.onChange = () =>
{
    uniHarmonics.setValue(parseFloat(inHarmonics.get()));
    shader.toggleDefine("HARMONICS", inHarmonics.get() > 1);
};

offsetX.onChange =
offsetY.onChange =
offsetZ.onChange =
inTexMask.onChange =
inMode.onChange =
inTexOffsetZ.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("NO_CHANNEL_R", inMode.get() == "G" || inMode.get() == "B");
    shader.toggleDefine("NO_CHANNEL_G", inMode.get() == "R" || inMode.get() == "B");
    shader.toggleDefine("NO_CHANNEL_B", inMode.get() == "R" || inMode.get() == "G");

    shader.toggleDefine("HAS_TEX_OFFSETMAP", inTexOffsetZ.get());
    shader.toggleDefine("HAS_TEX_MASK", inTexMask.get());

    shader.toggleDefine("OFFSET_X_R", offsetX.get() == "R");
    shader.toggleDefine("OFFSET_X_G", offsetX.get() == "G");
    shader.toggleDefine("OFFSET_X_B", offsetX.get() == "B");

    shader.toggleDefine("OFFSET_Y_R", offsetY.get() == "R");
    shader.toggleDefine("OFFSET_Y_G", offsetY.get() == "G");
    shader.toggleDefine("OFFSET_Y_B", offsetY.get() == "B");

    shader.toggleDefine("OFFSET_Z_R", offsetZ.get() == "R");
    shader.toggleDefine("OFFSET_Z_G", offsetZ.get() == "G");
    shader.toggleDefine("OFFSET_Z_B", offsetZ.get() == "B");

    offsetX.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    offsetY.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    offsetZ.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    inOffsetMul.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });

    shader.toggleDefine("RGB", inMode.get() == "RGB");
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inTexOffsetZ.get()) cgl.setTexture(1, inTexOffsetZ.get().tex);
    if (inTexMask.get()) cgl.setTexture(2, inTexMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.PerlinNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["b4b238d3-db68-4206-8dc7-4b52433fc932"]={f:Ops.Gl.TextureEffects.Noise.PerlinNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.PerlinNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.PixelNoise_v3
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.PixelNoise_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"pixelnoise2_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float numX;\nUNI float numY;\nUNI float addX;\nUNI float addY;\nUNI float addZ;\nUNI float seed2;\nUNI float minIn;\nUNI float maxIn;\n\nfloat random(vec2 co)\n{\n    float r=fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * (5.711+(mod(addZ+5711.210,57111.0))));\n\n    #ifdef LOOP\n        r=abs(r-0.5)*2.0;\n    #endif\n\n    return r;\n}\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec2 seed=vec2(0.0);\n\n    #ifndef CENTER\n        seed=vec2(floor( texCoord.x*numX+addX),floor( texCoord.y*numY+addY));\n    #endif\n    #ifdef CENTER\n        seed=vec2(floor( (texCoord.x-0.5)*numX+addX),floor( (texCoord.y-0.5)*numY+addY));\n    #endif\n\n    float r,g,b;\n\n    #ifndef RGB\n        r=g=b=random( seed + 0.5711 + seed2 );\n    #endif\n\n    #ifdef RGB\n        r=random( seed+0.5711 + seed2);\n        g=random( seed+0.5712 + seed2);\n        b=random( seed+0.5713 + seed2);\n    #endif\n\n    vec4 rnd = clamp( vec4( r,g,b,1.0 ),vec4(minIn), vec4(maxIn) );\n\n    vec4 base=texture(tex,texCoord);\n\n    outColor=cgl_blendPixel(base,rnd,amount);\n\n}",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    amount = op.inValueSlider("Amount", 1),
    inLoop = op.inValueBool("Loop", false),
    inRGB = op.inValueBool("RGB", false),
    minValue = op.inValue("Minimum value", 0),
    maxValue = op.inValue("Maximum value", 1),
    numX = op.inValue("Num X", 10),
    numY = op.inValue("Num Y", 10),
    addX = op.inValue("X", 0),
    addY = op.inValue("Y", 0),
    addZ = op.inValue("Z", 0),
    seed2 = op.inValue("Seed", 0),
    inCentered = op.inBool("Centered", false),
    trigger = op.outTrigger("Next");

op.setPortGroup("Look", [inRGB, inLoop, minValue, maxValue]);
op.setPortGroup("Position", [addX, addY, addZ]);
op.setPortGroup("Scaling", [numX, numY]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
shader.setSource(shader.getDefaultVertexShader(), attachments.pixelnoise2_frag);

const
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    timeUniform = new CGL.Uniform(shader, "f", "time", 1.0),
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uni_numX = new CGL.Uniform(shader, "f", "numX", numX),
    uni_numY = new CGL.Uniform(shader, "f", "numY", numY),
    uni_addX = new CGL.Uniform(shader, "f", "addX", addX),
    uni_addY = new CGL.Uniform(shader, "f", "addY", addY),
    uni_addZ = new CGL.Uniform(shader, "f", "addZ", addZ),
    uni_seed = new CGL.Uniform(shader, "f", "seed2", seed2),
    uni_minValue = new CGL.Uniform(shader, "f", "minIn", minValue),
    uni_maxValue = new CGL.Uniform(shader, "f", "maxIn", maxValue);

inLoop.onChange = function ()
{
    if (inLoop.get())shader.define("LOOP");
    else shader.removeDefine("LOOP");
};

inRGB.onChange = function ()
{
    if (inRGB.get())shader.define("RGB");
    else shader.removeDefine("RGB");
};

inCentered.onChange = function ()
{
    shader.toggleDefine("CENTER", inCentered.get());
};

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.PixelNoise_v3.prototype = new CABLES.Op();
CABLES.OPS["01ad08b6-dea4-4765-984c-3885c9c6520f"]={f:Ops.Gl.TextureEffects.Noise.PixelNoise_v3,objName:"Ops.Gl.TextureEffects.Noise.PixelNoise_v3"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.PolkaDotNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.PolkaDotNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"polkadotnoise_frag":"#ifdef HAS_TEXTURES\n  IN vec2 texCoord;\n  UNI sampler2D tex;\n#endif\n\nUNI float amount;\nUNI float radius_low;\nUNI float radius_high;\nUNI float X,Y,Z;\nUNI float scale;\nUNI float threshhold;\nUNI float aspect;\n\n{{CGL.BLENDMODES3}}\n\nfloat random(vec2 co)\n{\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * (437511.5453));\n}\n\n\n//\n//\tFalloff defined in XSquared\n//\t( smoothly decrease from 1.0 to 0.0 as xsq increases from 0.0 to 1.0 )\n//\thttp://briansharpe.wordpress.com/2011/11/14/two-useful-interpolation-functions-for-noise-development/\n//\nfloat Falloff_Xsq_C1( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq; }\t// ( 1.0 - x*x )^2   ( Used by Humus for lighting falloff in Just Cause 2.  GPUPro 1 )\nfloat Falloff_Xsq_C2( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\t// ( 1.0 - x*x )^3.   NOTE: 2nd derivative is 0.0 at x=1.0, but non-zero at x=0.0\nvec4 Falloff_Xsq_C2( vec4 xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\n\n\nvec4 FAST32_hash_3D_Cell( vec3 gridcell )\t//\tgenerates 4 different random numbers for the single given cell point\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec4 SOMELARGEFLOATS = vec4( 635.298681, 682.357502, 668.926525, 588.255119 );\n    const vec4 ZINC = vec4( 48.500388, 65.294118, 63.934599, 63.279683 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell - floor(gridcell * ( 1.0 / DOMAIN )) * DOMAIN;\n    gridcell.xy += OFFSET.xy;\n    gridcell.xy *= gridcell.xy;\n    return fract( ( gridcell.x * gridcell.y ) * ( 1.0 / ( SOMELARGEFLOATS + gridcell.zzzz * ZINC ) ) );\n}\n\n\n//\tPolkaDot Noise 3D\n//\thttp://briansharpe.files.wordpress.com/2011/12/polkadotsample.jpg\n//\thttp://briansharpe.files.wordpress.com/2012/01/polkaboxsample.jpg\n//\tTODO, these images have random intensity and random radius.  This noise now has intensity as proportion to radius.  Images need updated.  TODO\n//\n//\tGenerates a noise of smooth falloff polka dots.\n//\tAllow for control on radius.  Intensity is proportional to radius\n//\tReturn value range of 0.0->1.0\n//\nfloat PolkaDot3D( \tvec3 P,\n                    float radius_low,\t\t//\tradius range is 0.0->1.0\n                    float radius_high\t)\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    vec4 hash = FAST32_hash_3D_Cell( Pi );\n\n    hash.w=step(hash.w,threshhold);\n\n    //\tuser variables\n    float RADIUS = max( 0.0, radius_low + hash.w * ( radius_high - radius_low ) );\n    float VALUE = RADIUS / max( radius_high, radius_low );\t//\tnew keep value in proportion to radius.  Behaves better when used for bumpmapping, distortion and displacement\n\n    //\tcalc the noise and return\n    RADIUS = 2.0/RADIUS;\n    Pf *= RADIUS;\n    Pf -= ( RADIUS - 1.0 );\n    Pf += hash.xyz * ( RADIUS - 2.0 );\n    #ifdef BOX\n        Pf *= Pf;\t\t//\tthis gives us a cool box looking effect\n    #endif\n    return Falloff_Xsq_C2( min( dot( Pf, Pf ), 1.0 ) ) * VALUE;\n}\n\n\n\nvoid main()\n{\n    vec3 pos=vec3(texCoord.x,texCoord.y,0);\n\n    pos.xy-=0.5;\n    pos.y/=aspect;\n    pos.xy*=scale;\n    pos.xy-=vec2(X,Y);\n\n    vec3 Pi = floor(pos);\n    vec4 hash = FAST32_hash_3D_Cell( Pi );\n    pos.z=Z+random(hash.zz);\n\n    vec4 rnd=vec4(PolkaDot3D(pos,radius_low,radius_high));\n    rnd.a=1.0;\n\n    vec4 base=texture(tex,texCoord);\n\n    outColor=cgl_blendPixel(base,rnd,amount);\n\n}",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    inBox = op.inValueBool("Square Look", false),
    threshhold = op.inValueSlider("Threshold", 0.25),
    radius_low = op.inValueSlider("Radius Low", 0),
    radius_high = op.inValueSlider("Radius High", 1),
    scale = op.inValue("Scale", 14),
    X = op.inValue("X", 0),
    Y = op.inValue("Y", 0),
    Z = op.inValue("Z", 0),
    trigger = op.outTrigger("Next");

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name);

let amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
let timeUniform = new CGL.Uniform(shader, "f", "time", 1.0);

shader.setSource(CGL.Shader.getDefaultVertexShader(), attachments.polkadotnoise_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
radius_low.uniform = new CGL.Uniform(shader, "f", "radius_low", radius_low);
radius_high.uniform = new CGL.Uniform(shader, "f", "radius_high", radius_high);
X.uniform = new CGL.Uniform(shader, "f", "X", X);
Y.uniform = new CGL.Uniform(shader, "f", "Y", Y);
Z.uniform = new CGL.Uniform(shader, "f", "Z", Z);
scale.uniform = new CGL.Uniform(shader, "f", "scale", scale);
const uniaspect = new CGL.Uniform(shader, "f", "aspect", 1);
const uniThreshhold = new CGL.Uniform(shader, "f", "threshhold", threshhold);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

inBox.onChange = function ()
{
    if (inBox.get())shader.define("BOX");
    else shader.removeDefine("BOX");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    uniaspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.PolkaDotNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["2f128bcc-0846-4565-89ad-eda22e41ca4f"]={f:Ops.Gl.TextureEffects.Noise.PolkaDotNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.PolkaDotNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.SimplexNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.SimplexNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"simplexnoise_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float smoothness;\nUNI float scale;\nUNI float seed;\nUNI float x;\nUNI float y;\nUNI float time;\nUNI float aspect;\nUNI float harmonics;\n\n#ifdef HAS_TEX_OFFSETMAP\n    UNI sampler2D texOffsetZ;\n    UNI float offMul;\n#endif\n\n\n#ifdef HAS_TEX_MASK\n    UNI sampler2D texMask;\n#endif\n\n\n\n{{CGL.BLENDMODES3}}\n\nvoid FAST32_hash_3D(    vec3 gridcell,\n                        vec3 v1_mask,       //  user definable v1 and v2.  ( 0s and 1s )\n                        vec3 v2_mask,\n                        out vec4 hash_0,\n                        out vec4 hash_1,\n                        out vec4 hash_2 )       //  generates 3 random numbers for each of the 4 3D cell corners.  cell  corners:  v0=0,0,0  v3=1,1,1  the other two are user definable\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //  TODO:   these constants need tweaked to find the best possible noise.\n    //          probably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //  truncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //  compute x*x*y*y for the 4 corners\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    vec4 V1xy_V2xy = mix( P.xyxy, P.zwzw, vec4( v1_mask.xy, v2_mask.xy ) );     //  appl y mask for v1 and v2\n    P = vec4( P.x, V1xy_V2xy.xz, P.z ) * vec4( P.y, V1xy_V2xy.yw, P.w );\n\n    //  get the lowz and highz mods\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n\n    //  appl mask for v1 and v2 mod values\n    v1_mask = ( v1_mask.z < 0.5 ) ? lowz_mods : highz_mods;\n    v2_mask = ( v2_mask.z < 0.5 ) ? lowz_mods : highz_mods;\n\n    //  compute the final hash\n    hash_0 = fract( P * vec4( lowz_mods.x, v1_mask.x, v2_mask.x, highz_mods.x ) );\n    hash_1 = fract( P * vec4( lowz_mods.y, v1_mask.y, v2_mask.y, highz_mods.y ) );\n    hash_2 = fract( P * vec4( lowz_mods.z, v1_mask.z, v2_mask.z, highz_mods.z ) );\n}\n\n\n//\n//  Given an arbitrary 3D point this calculates the 4 vectors from the corners of the simplex pyramid to the point\n//  It also returns the integer grid index information for the corners\n//\nvoid Simplex3D_GetCornerVectors(    vec3 P,                 //  input point\n                                    out vec3 Pi,            //  integer grid index for the origin\n                                    out vec3 Pi_1,          //  offsets for the 2nd and 3rd corners.  ( the 4th = Pi + 1.0 )\n                                    out vec3 Pi_2,\n                                    out vec4 v1234_x,       //  vectors from the 4 corners to the intput point\n                                    out vec4 v1234_y,\n                                    out vec4 v1234_z )\n{\n    //\n    //  Simplex math from Stefan Gustavsons and Ian McEwans work at...\n    //  http://github.com/ashima/webgl-noise\n    //\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_PYRAMID_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )  height of simplex pyramid.\n\n    P *= SIMPLEX_PYRAMID_HEIGHT;        // scale space so we can have an approx feature size of 1.0  ( optional )\n\n    //  Find the vectors to the corners of our simplex pyramid\n    Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    Pi_1 = min( g.xyz, l.zxy );\n    Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n}\n\n//\n//  Calculate the weights for the 3D simplex surflet\n//\nvec4 Simplex3D_GetSurfletWeights(   vec4 v1234_x,\n                                    vec4 v1234_y,\n                                    vec4 v1234_z )\n{\n    //  perlins original implementation uses the surlet falloff formula of (0.6-x*x)^4.\n    //  This is buggy as it can cause discontinuities along simplex faces.  (0.5-x*x)^3 solves this and gives an almost identical curve\n\n    //  evaluate surflet. f(x)=(0.5-x*x)^3\n    vec4 surflet_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    surflet_weights = max(0.5 - surflet_weights, 0.0);      //  0.5 here represents the closest distance (squared) of any simplex pyramid corner to any of its planes.  ie, SIMPLEX_PYRAMID_HEIGHT^2\n    return surflet_weights*surflet_weights*surflet_weights;\n}\n\n\n\n//\n//  SimplexPerlin3D  ( simplex gradient noise )\n//  Perlin noise over a simplex (tetrahedron) grid\n//  Return value range of -1.0->1.0\n//  http://briansharpe.files.wordpress.com/2012/01/simplexperlinsample.jpg\n//\n//  Implementation originally based off Stefan Gustavsons and Ian McEwans work at...\n//  http://github.com/ashima/webgl-noise\n//\nfloat SimplexPerlin3D(vec3 P)\n{\n    //  calculate the simplex vector and index math\n    vec3 Pi;\n    vec3 Pi_1;\n    vec3 Pi_2;\n    vec4 v1234_x;\n    vec4 v1234_y;\n    vec4 v1234_z;\n    Simplex3D_GetCornerVectors( P, Pi, Pi_1, Pi_2, v1234_x, v1234_y, v1234_z );\n\n    //  generate the random vectors\n    //  ( various hashing methods listed in order of speed )\n    vec4 hash_0;\n    vec4 hash_1;\n    vec4 hash_2;\n    FAST32_hash_3D( Pi, Pi_1, Pi_2, hash_0, hash_1, hash_2 );\n    //SGPP_hash_3D( Pi, Pi_1, Pi_2, hash_0, hash_1, hash_2 );\n    hash_0 -= 0.49999;\n    hash_1 -= 0.49999;\n    hash_2 -= 0.49999;\n\n    //  evaluate gradients\n    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\n\n    //  Normalization factor to scale the final result to a strict 1.0->-1.0 range\n    //  x = sqrt( 0.75 ) * 0.5\n    //  NF = 1.0 / ( x * ( ( 0.5 * x*x ) ^ 3 ) * 2.0 )\n    //  http://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n     float FINAL_NORMALIZATION = 37.837227241611314102871574478976*smoothness;\n\n    //  sum with the surflet and return\n    return dot( Simplex3D_GetSurfletWeights( v1234_x, v1234_y, v1234_z ), grad_results ) * FINAL_NORMALIZATION;\n}\n\nvoid main()\n{\n    vec2 p=vec2(texCoord.x-0.5,texCoord.y-0.5);\n\n    p.x*=aspect;\n    p=p*scale;\n\n    p=vec2(p.x+0.5-x,p.y+0.5-y);\n\n    vec3 offset;\n    #ifdef HAS_TEX_OFFSETMAP\n        vec4 offMap=texture(texOffsetZ,texCoord);\n\n        #ifdef OFFSET_X_R\n            offset.x=offMap.r;\n        #endif\n        #ifdef OFFSET_X_G\n            offset.x=offMap.g;\n        #endif\n        #ifdef OFFSET_X_B\n            offset.x=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Y_R\n            offset.y=offMap.r;\n        #endif\n        #ifdef OFFSET_Y_G\n            offset.y=offMap.g;\n        #endif\n        #ifdef OFFSET_Y_B\n            offset.y=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Z_R\n            offset.z=offMap.r;\n        #endif\n        #ifdef OFFSET_Z_G\n            offset.z=offMap.g;\n        #endif\n        #ifdef OFFSET_Z_B\n            offset.z=offMap.b;\n        #endif\n\n        offset*=offMul;\n    #endif\n\n    float v=SimplexPerlin3D(vec3(p.x,p.y,time)+offset)*0.5+0.5;\n\n\n    if (harmonics >= 2.0) v += SimplexPerlin3D(vec3(p.x,p.y,time)*2.3+offset) * 0.5;\n    if (harmonics >= 3.0) v += SimplexPerlin3D(vec3(p.x,p.y,time)*4.2+offset) * 0.25;\n    if (harmonics >= 4.0) v += SimplexPerlin3D(vec3(p.x,p.y,time)*8.1+offset) * 0.125;\n    if (harmonics >= 5.0) v += SimplexPerlin3D(vec3(p.x,p.y,time)*16.7+offset) * 0.0625;\n\n\n\n    //blend section\n    vec4 col=vec4(v,v,v,1.0);\n\n    vec4 base=texture(tex,texCoord);\n\n    // outColor=cgl_blend(base,col,amount);\n\n\n    float str=1.0;\n    #ifdef HAS_TEX_MASK\n        str=texture(texMask,texCoord).r;\n    #endif\n\n    outColor=cgl_blendPixel(base,col,amount*str);\n\n}",};
const
    render = op.inTrigger("render"),
    inTexMask = op.inTexture("Mask"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    smoothness = op.inValue("smoothness", 1.0),
    inHarmonics = op.inSwitch("Harmonics", ["1", "2", "3", "4", "5"], "1"),
    scale = op.inValue("scale", 7),
    trigger = op.outTrigger("trigger"),
    x = op.inValue("x"),
    y = op.inValue("y"),
    time = op.inValue("time", 0);

const
    inTexOffsetZ = op.inTexture("Offset"),
    inOffsetMul = op.inFloat("Offset Multiply", 1),
    offsetX = op.inSwitch("Offset X", ["None", "R", "G", "B"], "None"),
    offsetY = op.inSwitch("Offset Y", ["None", "R", "G", "B"], "None"),
    offsetZ = op.inSwitch("Offset Z", ["None", "R", "G", "B"], "R");

op.setPortGroup("Offset Map", [inTexOffsetZ, offsetZ, offsetY, offsetX, inOffsetMul]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.simplexnoise_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureUniformOffZ = new CGL.Uniform(shader, "t", "texOffsetZ", 1),
    uniTexMask = new CGL.Uniform(shader, "t", "texMask", 2),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniSmoothness = new CGL.Uniform(shader, "f", "smoothness", smoothness),
    uniScale = new CGL.Uniform(shader, "f", "scale", scale),
    uniX = new CGL.Uniform(shader, "f", "x", x),
    uniY = new CGL.Uniform(shader, "f", "y", y),
    uniAspect = new CGL.Uniform(shader, "f", "aspect", 1),
    uniTime = new CGL.Uniform(shader, "f", "time", time),
    uniOffMul = new CGL.Uniform(shader, "f", "offMul", inOffsetMul),
    uniHarmonics = new CGL.Uniform(shader, "f", "harmonics", 0);

inHarmonics.onChange = () =>
{
    uniHarmonics.setValue(parseFloat(inHarmonics.get()));
};

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount,maskAlpha);

offsetX.onChange =
offsetY.onChange =
offsetZ.onChange =
inTexMask.onChange =
inTexOffsetZ.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("HAS_TEX_OFFSETMAP", inTexOffsetZ.get());
    shader.toggleDefine("HAS_TEX_MASK", inTexMask.get());

    shader.toggleDefine("OFFSET_X_R", offsetX.get() == "R");
    shader.toggleDefine("OFFSET_X_G", offsetX.get() == "G");
    shader.toggleDefine("OFFSET_X_B", offsetX.get() == "B");

    shader.toggleDefine("OFFSET_Y_R", offsetY.get() == "R");
    shader.toggleDefine("OFFSET_Y_G", offsetY.get() == "G");
    shader.toggleDefine("OFFSET_Y_B", offsetY.get() == "B");

    shader.toggleDefine("OFFSET_Z_R", offsetZ.get() == "R");
    shader.toggleDefine("OFFSET_Z_G", offsetZ.get() == "G");
    shader.toggleDefine("OFFSET_Z_B", offsetZ.get() == "B");

    offsetX.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    offsetY.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    offsetZ.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    inOffsetMul.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inTexOffsetZ.get()) cgl.setTexture(1, inTexOffsetZ.get().tex);
    if (inTexMask.get()) cgl.setTexture(2, inTexMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.SimplexNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["0f4a8d04-89b0-437a-9da8-b4098772d250"]={f:Ops.Gl.TextureEffects.Noise.SimplexNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.SimplexNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.TriangleNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.TriangleNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"trianglenoise_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float scale;\nUNI float angle;\nUNI float ratio;\nUNI float add;\nUNI float amount;\n\n{{CGL.BLENDMODES3}}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(13.98987,28.533))) * 4758.6453+add*0.1);\n}\n\nfloat GetLocation(vec2 s, float d)\n{\n    vec2 f = s*d;\n    f = f + vec2(0,0.5)*floor(f).x;\n    s = fract(f);\n    f = floor(f);\n\n    d = s.y - 0.5;\n    float l = abs(d) + 0.5 * s.x;\n    float ff = f.x+f.y;\n    f = mix(f, f+sign(d)*vec2(0,0.5), step(0.5, l));\n    l = mix(ff, ff+sign(d)*0.5, step(0.5, l));\n\n    float r=mod(rand(f)*2.0,2.0);\n    if(r>1.0)r=2.0-r;\n\n    return r;\n}\n\nvoid main()\n{\n    vec2 coord=texCoord;\n    coord-=0.5;\n    coord.y/=ratio;\n    coord*=scale;\n    coord+=0.5;\n\n    float sin_factor = sin(angle*0.01745329251);\n    float cos_factor = cos(angle*0.01745329251);\n    coord = vec2((coord.x - 0.5), coord.y - ratio/2.0) * mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n\n    float a=GetLocation(coord,1.0);\n\n    vec4 base=texture(tex,texCoord);\n    vec4 col=vec4(a,a,a,1.0);\n\n    outColor=cgl_blendPixel(base,col,amount);\n}",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    scale = op.inValue("scale", 10),
    angle = op.inValue("angle", 0),
    add = op.inValue("Add", 0),
    trigger = op.outTrigger("Next");

const
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.trianglenoise_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    addUniform = new CGL.Uniform(shader, "f", "add", add),
    scaleUniform = new CGL.Uniform(shader, "f", "scale", scale),
    angleUniform = new CGL.Uniform(shader, "f", "angle", angle),
    ratioUniform = new CGL.Uniform(shader, "f", "ratio", 1);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    ratioUniform.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.TriangleNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["9e634336-cb44-40ca-b06b-90063e4324a2"]={f:Ops.Gl.TextureEffects.Noise.TriangleNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.TriangleNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.ValueNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.ValueNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"valuenoise3d_frag":"UNI float z;\nUNI float x;\nUNI float y;\nUNI float scale;\nUNI float amount;\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI float aspect;\n\n{{CGL.BLENDMODES3}}\n\n//\n//\tValue Noise 3D\n//\tReturn value range of 0.0->1.0\n//\thttp://briansharpe.files.wordpress.com/2011/11/valuesample1.jpg\n//\n\nfloat Interpolation_C2( float x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }   //  6x^5-15x^4+10x^3\t( Quintic Curve.  As used by Perlin in Improved Noise.  http://mrl.nyu.edu/~perlin/paper445.pdf )\nvec2 Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 Interpolation_C2( vec3 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2( vec4 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2_InterpAndDeriv( vec2 x ) { return x.xyxy * x.xyxy * ( x.xyxy * ( x.xyxy * ( x.xyxy * vec2( 6.0, 0.0 ).xxyy + vec2( -15.0, 30.0 ).xxyy ) + vec2( 10.0, -60.0 ).xxyy ) + vec2( 0.0, 30.0 ).xxyy ); }\nvec3 Interpolation_C2_Deriv( vec3 x ) { return x * x * (x * (x * 30.0 - 60.0) + 30.0); }\n\nvoid FAST32_hash_3D( vec3 gridcell, out vec4 lowz_hash, out vec4 highz_hash )\t//\tgenerates a random number for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const float SOMELARGEFLOAT = 635.298681;\n    const float ZINC = 48.500388;\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    highz_hash.xy = vec2( 1.0 / ( SOMELARGEFLOAT + vec2( gridcell.z, gridcell_inc1.z ) * ZINC ) );\n    lowz_hash = fract( P * highz_hash.xxxx );\n    highz_hash = fract( P * highz_hash.yyyy );\n}\n\n\nfloat Value3D( vec3 P )\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_lowz, hash_highz;\n    FAST32_hash_3D( Pi, hash_lowz, hash_highz );\n    //FAST32_2_hash_3D( Pi, hash_lowz, hash_highz );\n    //BBS_hash_3D( Pi, hash_lowz, hash_highz );\n    //SGPP_hash_3D( Pi, hash_lowz, hash_highz );\n\n    //\tblend the results and return\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nvoid main()\n{\n    vec2 tc=texCoord;\n    tc.y/=aspect;\n    vec4 base=texture(tex,tc);\n\n    vec2 p=vec2(tc.x-0.5,tc.y-0.5);\n    p=p*scale;\n\n    p=vec2(p.x+0.5-x,p.y+0.5-y);\n\n    float v=Value3D(vec3(p.x,p.y,z));\n    vec4 col=vec4(v,v,v,1.0);\n\n    outColor=cgl_blendPixel(base,col,amount);\n\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    scale = op.inValue("Scale", 25),
    x = op.inValue("X", 0),
    y = op.inValue("Y", 0),
    z = op.inValue("Z", 0),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Position", [x, y, z]);
op.setPortGroup("Look", [scale]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(CGL.Shader.getDefaultVertexShader(), attachments.valuenoise3d_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniZ = new CGL.Uniform(shader, "f", "z", z),
    uniX = new CGL.Uniform(shader, "f", "x", x),
    uniY = new CGL.Uniform(shader, "f", "y", y),
    uniScale = new CGL.Uniform(shader, "f", "scale", scale),
    uniAspect = new CGL.Uniform(shader, "f", "aspect", 1),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.ValueNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["d2748c53-9ac1-4cd7-8176-66d3eb5d1bb6"]={f:Ops.Gl.TextureEffects.Noise.ValueNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.ValueNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.Voronoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.Voronoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"voronoise_frag":"// adapted from https://thebookofshaders.com/12/\n\nIN vec2 texCoord;\n\nUNI bool drawIsoLines;\nUNI bool drawDistance;\nUNI int fill;\nUNI float seed;\n\nUNI float time;\nUNI float movement;\nUNI float amount;\nUNI float centerSize;\nUNI sampler2D tex;\nUNI float aspect;\n\n{{CGL.BLENDMODES3}}\n{{CGL.RANDOM_OLD}}\n\nfloat rand(float n){return fract(sin(n) * 43.5453123);}\nvec2 random2( vec2 p )\n{\n    return vec2(rand(p.x),rand(p.x+p.y));\n}\n\nvoid main() {\n\n    vec3 color = vec3(.0);\n    float m_dist = 1.;  // minimun distance\n    vec2 m_point;        // minimum position\n    float indexColor=0.0;\n\n    vec2 coord=texCoord;\n\n    coord.y/=aspect;\n\n    // const float NUM=21.0;\n\n    // Iterate through the points positions\n    for (float i = 0.0; i < NUM; i++)\n    {\n        vec2 pos= random2(vec2(i+seed,i+seed));\n\n        pos.x+=sin(time+i)*movement;\n        pos.y+=cos(time+i)*movement;\n\n        if(i==0.0)\n        {\n            // pos=vec2(mouseX,mouseY);\n        }\n\n        float dist = distance(coord, pos);\n        if( dist < m_dist )\n        {\n            // Keep the closer distance\n            m_dist = dist;\n\n            // Kepp the position of the closer point\n            m_point = pos;\n            indexColor=(i)/NUM;\n        }\n    }\n\n    // tint acording the closest point position\n    if(fill==1) color.rgb = vec3( indexColor );\n    if(fill==2) color.rgb = vec3( m_point.x );\n    if(fill==3) color.rgb = vec3( 0.5 );\n\n    // Add distance field to closest point center\n    if(drawDistance) color += m_dist*2.;\n\n    // Show isolines\n    if(drawIsoLines) color -= abs(sin(120.0*m_dist))*0.07;\n\n    // Draw point center\n    if(centerSize>0.0)\n    color += 1.-step(centerSize/30.0, m_dist);\n\n    vec4 base=texture(tex,coord);\n\n    outColor= cgl_blendPixel(base,vec4(color,1.0),amount);\n}",};
const
    render = op.inTrigger("Render"),
    trigger = op.outTrigger("Trigger"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    time = op.inValue("Time", 0),
    movement = op.inValueSlider("Movement", 0),
    num = op.inValue("Num", 20),
    seed = op.inValue("seed", 0),
    fill = op.inValueSelect("Fill", ["None", "Random", "Gradient", "Gray"], "Random"),
    drawIsoLines = op.inValueBool("Draw Isolines", false),
    drawDistance = op.inValueBool("Draw Distance", false),
    centerSize = op.inValueSlider("Draw Center", 0);

const cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.voronoise_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniPx = new CGL.Uniform(shader, "f", "pX", 1 / 1024),
    uniPy = new CGL.Uniform(shader, "f", "pY", 1 / 1024),
    uniFill = new CGL.Uniform(shader, "i", "fill", 1),
    uniSeed = new CGL.Uniform(shader, "f", "seed", seed),
    uniTime = new CGL.Uniform(shader, "f", "time", time),
    uniMovement = new CGL.Uniform(shader, "f", "movement", movement),
    uniAspect = new CGL.Uniform(shader, "f", "aspect", 1),
    uniIsoLines = new CGL.Uniform(shader, "b", "drawIsoLines", drawIsoLines),
    uniDrawDistance = new CGL.Uniform(shader, "b", "drawDistance", drawDistance),
    uniCenterSize = new CGL.Uniform(shader, "f", "centerSize", centerSize);

shader.define("NUM", 20.001);

num.onChange = function ()
{
    shader.define("NUM", num.get() + 0.001);
};

fill.onChange = function ()
{
    if (fill.get() == "Random") uniFill.setValue(1);
    else if (fill.get() == "Gradient") uniFill.setValue(2);
    else if (fill.get() == "Gray") uniFill.setValue(3);
    else uniFill.setValue(0);
};

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    uniPx.setValue(1 / cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniPy.setValue(1 / cgl.currentTextureEffect.getCurrentSourceTexture().height);

    uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.Voronoise_v2.prototype = new CABLES.Op();
CABLES.OPS["0e68dbf4-dc3e-448d-b1e1-256dde99802a"]={f:Ops.Gl.TextureEffects.Noise.Voronoise_v2,objName:"Ops.Gl.TextureEffects.Noise.Voronoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Noise.WorleyNoise_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Noise.WorleyNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"worleynoise_frag":"// Author: Stefan Gustavson\n// Title: Worley noise 2x2x2\n\nIN vec2 texCoord;\n\nUNI float amount;\nUNI float x;\nUNI float y;\nUNI float z;\nUNI float scale;\nUNI sampler2D tex;\nUNI float rangeA;\nUNI float rangeB;\nUNI float aspect;\nUNI float harmonics;\n\n#ifdef HAS_MASK\n    UNI sampler2D texMask;\n#endif\n\n#ifdef HAS_TEX_OFFSETMAP\n    UNI sampler2D texOffsetZ;\n    UNI float offMul;\n#endif\n\n{{CGL.BLENDMODES3}}\n{{CGL.LUMINANCE}}\n\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\n// at the expense of some pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a good F2, use the slower 3x3x3 version.\nvec2 cellular2x2x2(vec3 P) {\n\t#define K 0.142857142857 // 1/7\n\t#define Ko 0.428571428571 // 1/2-K/2\n\t#define K2 0.020408163265306 // 1/(7*7)\n\t#define Kz 0.166666666667 // 1/6\n\t#define Kzo 0.416666666667 // 1/2-1/6*2\n\t#define jitter 0.8 // smaller jitter gives less errors in F2\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);\n\tvec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 p1 = permute(p + Pi.z); // z+0\n\tvec4 p2 = permute(p + Pi.z + vec4(1.0)); // z+1\n\tvec4 ox1 = fract(p1*K) - Ko;\n\tvec4 oy1 = mod(floor(p1*K), 7.0)*K - Ko;\n\tvec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract(p2*K) - Ko;\n\tvec4 oy2 = mod(floor(p2*K), 7.0)*K - Ko;\n\tvec4 oz2 = floor(p2*K2)*Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter*ox1;\n\tvec4 dy1 = Pfy + jitter*oy1;\n\tvec4 dz1 = Pf.z + jitter*oz1;\n\tvec4 dx2 = Pfx + jitter*ox2;\n\tvec4 dy2 = Pfy + jitter*oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter*oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\td1 = min(d1, d2);\n\td1.xy = min(d1.xy, d1.wz);\n\td1.x = min(d1.x, d1.y);\n\treturn sqrt(d1.xx);\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec4 d = min(d1,d2); // F1 is now in d\n\td2 = max(d1,d2); // Make sure we keep all candidates for F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw\n\td.y = min(d.y, d.z); // nor in d.z\n\td.y = min(d.y, d.w); // nor in d.w\n\td.y = min(d.y, d2.x); // F2 is now in d.y\n\treturn sqrt(d.xy); // F1 and F2\n#endif\n}\n\nvoid main(void) {\n\tvec2 st = texCoord;//gl_FragCoord.xy/u_resolution.xy;\n\n\t#ifdef DO_TILEABLE\n\t    st=abs(texCoord-0.5);\n\t#endif\n\n    vec3 offset;\n    #ifdef HAS_TEX_OFFSETMAP\n        vec4 offMap=texture(texOffsetZ,texCoord);\n\n        #ifdef OFFSET_X_R\n            offset.x=offMap.r;\n        #endif\n        #ifdef OFFSET_X_G\n            offset.x=offMap.g;\n        #endif\n        #ifdef OFFSET_X_B\n            offset.x=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Y_R\n            offset.y=offMap.r;\n        #endif\n        #ifdef OFFSET_Y_G\n            offset.y=offMap.g;\n        #endif\n        #ifdef OFFSET_Y_B\n            offset.y=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Z_R\n            offset.z=offMap.r;\n        #endif\n        #ifdef OFFSET_Z_G\n            offset.z=offMap.g;\n        #endif\n        #ifdef OFFSET_Z_B\n            offset.z=offMap.b;\n        #endif\n        offset*=offMul;\n    #endif\n\n    st.x-=0.5;\n    st.y-=0.5;\n\tst *= scale;\n    st.x+=0.5;\n    st.y+=0.5;\n\n    st.y/=aspect;\n\n\tst.x+=x;\n\tst.y+=y;\n\n\tvec2 F = cellular2x2x2(vec3(st,z)+offset);\n\n    if (harmonics >= 2.0) F.x += cellular2x2x2(vec3(st,z)*2.2+offset).x * 0.5;\n    if (harmonics >= 3.0) F.x += cellular2x2x2(vec3(st,z)*4.3+offset).x * 0.25;\n    if (harmonics >= 4.0) F.x += cellular2x2x2(vec3(st,z)*8.4+offset).x * 0.125;\n    if (harmonics >= 5.0) F.x += cellular2x2x2(vec3(st,z)*16.5+offset).x * 0.0625;\n\n\tfloat n = smoothstep(rangeA,rangeB, F.x);\n\n    #ifdef DO_INVERT\n        n=1.0-n;\n    #endif\n\n    vec4 col=vec4(n,n,n,1.0);\n    vec4 base=texture(tex,texCoord);\n\n    float am=amount;\n    #ifdef HAS_MASK\n        #ifdef MASK_SRC_R\n            float mul=texture(texMask,texCoord).r;\n        #endif\n        #ifdef MASK_SRC_G\n            float mul=texture(texMask,texCoord).g;\n        #endif\n        #ifdef MASK_SRC_B\n            float mul=texture(texMask,texCoord).b;\n        #endif\n        #ifdef MASK_SRC_A\n            float mul=texture(texMask,texCoord).a;\n        #endif\n        #ifdef MASK_SRC_LUM\n            float mul=cgl_luminance(texture(texMask,texCoord).rgb);\n        #endif\n        #ifdef MASK_INV\n            mul=1.0-mul;\n        #endif\n        am*=mul;\n    #endif\n\n    outColor=cgl_blendPixel(base,col,am);\n\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    amount = op.inValueSlider("Amount", 1),
    x = op.inValue("X", 0),
    y = op.inValue("Y", 0),
    z = op.inValue("Z", 0),
    scale = op.inValue("Scale", 6),
    inHarmonics = op.inSwitch("Harmonics", ["1", "2", "3", "4", "5"], "1"),
    inv = op.inValueBool("Invert", true),
    rangeA = op.inValueSlider("RangeA", 0.4),
    rangeB = op.inValueSlider("RangeB", 0.5),
    tile = op.inValueBool("Tileable", false),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.worleynoise_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureUniformOffZ = new CGL.Uniform(shader, "t", "texOffsetZ", 1),
    textureUniformMask = new CGL.Uniform(shader, "t", "texMask", 2),
    uniZ = new CGL.Uniform(shader, "f", "z", z),
    uniX = new CGL.Uniform(shader, "f", "x", x),
    uniY = new CGL.Uniform(shader, "f", "y", y),
    uniScale = new CGL.Uniform(shader, "f", "scale", scale),
    uniAspect = new CGL.Uniform(shader, "f", "aspect", 1),
    uniharmonics = new CGL.Uniform(shader, "f", "harmonics", inHarmonics),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    rangeAUniform = new CGL.Uniform(shader, "f", "rangeA", rangeA),
    rangeBUniform = new CGL.Uniform(shader, "f", "rangeB", rangeB);

// amount Map

const
    inMaskTex = op.inTexture("Amount Map"),
    inMaskSource = op.inSwitch("Source Strength Map", ["R", "G", "B", "A", "Lum"], "R"),
    inMaskInv = op.inBool("Invert Strength Map", false);

inMaskSource.setUiAttribs({ "title": "Source Amount Map" });
inMaskInv.setUiAttribs({ "title": "Invert Amount Map" });

op.setPortGroup("Amount Map", [inMaskTex, inMaskSource, inMaskInv]);

// offsetMap

const
    inTexOffsetZ = op.inTexture("Offset"),
    inOffsetMul = op.inFloat("Offset Multiply", 1),
    offsetX = op.inSwitch("Offset X", ["None", "R", "G", "B"], "None"),
    offsetY = op.inSwitch("Offset Y", ["None", "R", "G", "B"], "None"),
    offsetZ = op.inSwitch("Offset Z", ["None", "R", "G", "B"], "R");

op.setPortGroup("Offset Map", [inTexOffsetZ, offsetZ, offsetY, offsetX, inOffsetMul]);

const uniOffMul = new CGL.Uniform(shader, "f", "offMul", inOffsetMul);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

inMaskTex.onChange =
    inMaskSource.onChange =
    inMaskInv.onChange =
    inv.onChange =
    offsetX.onChange =
    offsetY.onChange =
    offsetZ.onChange =
    inMaskTex.onLinkChanged =
    inTexOffsetZ.onLinkChanged =
    tile.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    shader.toggleDefine("DO_INVERT", inv.get());
    shader.toggleDefine("DO_TILEABLE", tile.get());

    shader.toggleDefine("HAS_TEX_OFFSETMAP", inTexOffsetZ.isLinked());
    shader.toggleDefine("HAS_TEX_MASK", inMaskTex.isLinked());

    shader.toggleDefine("OFFSET_X_R", offsetX.get() == "R");
    shader.toggleDefine("OFFSET_X_G", offsetX.get() == "G");
    shader.toggleDefine("OFFSET_X_B", offsetX.get() == "B");

    shader.toggleDefine("OFFSET_Y_R", offsetY.get() == "R");
    shader.toggleDefine("OFFSET_Y_G", offsetY.get() == "G");
    shader.toggleDefine("OFFSET_Y_B", offsetY.get() == "B");

    shader.toggleDefine("OFFSET_Z_R", offsetZ.get() == "R");
    shader.toggleDefine("OFFSET_Z_G", offsetZ.get() == "G");
    shader.toggleDefine("OFFSET_Z_B", offsetZ.get() == "B");

    offsetX.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    offsetY.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    offsetZ.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    inOffsetMul.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });

    shader.toggleDefine("HAS_MASK", inMaskTex.isLinked());
    shader.toggleDefine("MASK_SRC_R", inMaskSource.get() == "R");
    shader.toggleDefine("MASK_SRC_G", inMaskSource.get() == "G");
    shader.toggleDefine("MASK_SRC_B", inMaskSource.get() == "B");
    shader.toggleDefine("MASK_SRC_A", inMaskSource.get() == "A");
    shader.toggleDefine("MASK_SRC_LUM", inMaskSource.get() == "Lum");
    shader.toggleDefine("MASK_INV", inMaskInv.get());
    inMaskSource.setUiAttribs({ "greyout": !inMaskTex.isLinked() });
    inMaskInv.setUiAttribs({ "greyout": !inMaskTex.isLinked() });
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inTexOffsetZ.get()) cgl.setTexture(1, inTexOffsetZ.get().tex);
    if (inMaskTex.get()) cgl.setTexture(2, inMaskTex.get().tex);

    uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Noise.WorleyNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["fc6fbe7c-4bf8-4fdc-bd37-95b9f50a5bf2"]={f:Ops.Gl.TextureEffects.Noise.WorleyNoise_v2,objName:"Ops.Gl.TextureEffects.Noise.WorleyNoise_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.PatternLookup
// 
// **************************************************************

Ops.Gl.TextureEffects.PatternLookup = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"patternlookup_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D patternTex;\nUNI float amount;\nUNI float patternWidth;\nUNI float patternHeight;\n\n{{CGL.BLENDMODES}}\n\nfloat desaturate(vec3 color)\n{\n    vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n    return gray.g;\n}\n\nvoid main()\n{\n    vec4 col=vec4(1.0,0.0,0.0,1.0);\n    vec4 base=texture(tex,texCoord);\n\n    vec2 nc=vec2(0.5,desaturate(base.rgb));\n    nc.x=mod(texCoord.x,patternWidth*0.1);\n    nc.y=nc.y+mod(texCoord.y,patternHeight*0.1);\n\n    // maybe should have a ping pong modulo option...\n\n    nc.x=clamp(nc.x,0.0,1.0);\n    nc.y=clamp(nc.y,0.0,1.0);\n\n    vec4 newCol=texture(patternTex,nc);\n\n    outColor=cgl_blend(base,newCol,amount);\n}",};
const render = op.inTrigger("render");
const multiplierTex = op.inTexture("Multiplier");
const blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal");
const amount = op.inValueSlider("Amount", 1);
const trigger = op.outTrigger("trigger");

const patternWidth = op.inValueSlider("Width", 0.1);
const patternHeight = op.inValueSlider("Height", 0.1);


const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

op.toWorkPortsNeedToBeLinked(multiplierTex);


shader.setSource(shader.getDefaultVertexShader(), attachments.patternlookup_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const textureMultiplierUniform = new CGL.Uniform(shader, "t", "patternTex", 1);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
const ptrnWidthUniform = new CGL.Uniform(shader, "f", "patternWidth", patternWidth);
const patternHeightUniform = new CGL.Uniform(shader, "f", "patternHeight", patternHeight);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    let multex = multiplierTex.get();
    if (multex)
    {
        cgl.pushShader(shader);
        cgl.currentTextureEffect.bind();

        cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

        if (multex) cgl.setTexture(1, multex.tex);

        cgl.currentTextureEffect.finish();
        cgl.popShader();
    }


    trigger.trigger();
};


};

Ops.Gl.TextureEffects.PatternLookup.prototype = new CABLES.Op();
CABLES.OPS["f05f45fe-f3d2-4d99-b1b7-dfae7005382a"]={f:Ops.Gl.TextureEffects.PatternLookup,objName:"Ops.Gl.TextureEffects.PatternLookup"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.PixelColor
// 
// **************************************************************

Ops.Gl.TextureEffects.PixelColor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"pixelate_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D srcTex;\nUNI float amount;\n\nUNI vec2 pixelPos;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n\n    vec4 base=texture(tex,texCoord);\n    vec4 col=texture(srcTex,pixelPos);\n\n    outColor=cgl_blendPixel(base,col,amount);\n    outColor=col;\n}",};
const render = op.inTrigger("render"),
    srcTex = op.inTexture("Source Texture"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    posX = op.inFloatSlider("Pos X", 0),
    posY = op.inFloatSlider("Pos Y", 0),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.pixelate_frag);

const textureMultiplierUniform = new CGL.Uniform(shader, "t", "srcTex", 1);
const unipos = new CGL.Uniform(shader, "2f", "pixelPos", posX, posY);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

// srcTex.onChange = function ()
// {
//     shader.toggleDefine("PI XELATE_TEXTURE", srcTex.isLinked());
// };

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (srcTex.get()) cgl.setTexture(1, srcTex.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.PixelColor.prototype = new CABLES.Op();
CABLES.OPS["114e250c-f569-4963-a3b3-fcdce816406f"]={f:Ops.Gl.TextureEffects.PixelColor,objName:"Ops.Gl.TextureEffects.PixelColor"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.PixelDifference
// 
// **************************************************************

Ops.Gl.TextureEffects.PixelDifference = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"slope_frag":"\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI vec2 pixel;\nUNI float strength;\nUNI float sstep;\n\nfloat lum(vec3 c)\n{\n    return dot(vec3(0.2126,0.7152,0.0722),c);\n}\n\nvoid main()\n{\n    vec4 a,b;\n    // vec4 px=texture(tex, texCoord);\n    vec4 pxl=texture(tex, texCoord + vec2(-sstep*pixel.x, 0.0));\n    vec4 pxr=texture(tex, texCoord + vec2( sstep*pixel.x, 0.0));\n    vec4 pxt=texture(tex, texCoord + vec2(0.0, -sstep*pixel.y));\n    vec4 pxb=texture(tex, texCoord + vec2(0.0,  sstep*pixel.y));\n\n    vec4 col=vec4(0.5);\n\n    #ifdef DIR_R_HORIZONTAL\n        a=pxl;\n        b=pxr;\n    #endif\n    #ifndef DIR_R_HORIZONTAL // VERTICAL\n        a=pxt;\n        b=pxb;\n    #endif\n    #ifdef FLIP_R\n        vec4 c=a;\n        a=b;\n        b=c;\n    #endif\n    #ifdef METH_R_DIFF\n        #ifdef METH_R_R\n            col.r+=(b.r-a.r)*strength;\n        #endif\n        #ifdef METH_R_G\n            col.r+=(b.g-a.g)*strength;\n        #endif\n        #ifdef METH_R_B\n            col.r+=(b.b-a.b)*strength;\n        #endif\n    #endif\n    #ifdef METH_R_AVG\n        #ifdef METH_R_R\n            col.r+=(((b.r+a.r-0.5)/2.0))*strength;\n        #endif\n        #ifdef METH_R_G\n            col.r+=(((b.g+a.g-0.5)/2.0))*strength;\n        #endif\n        #ifdef METH_R_B\n            col.r+=(((b.b+a.b-0.5)/2.0))*strength;\n        #endif\n    #endif\n    #ifdef METH_R_LUMI\n        col.r+=(lum(b.rgb)-lum(a.rgb))*strength;\n    #endif\n    #ifdef METH_R_ONE\n        col.r=1.0;\n    #endif\n    #ifdef METH_R_ZERO\n        col.r=0.0;\n    #endif\n\n\n    ////////////////////////\n\n    #ifdef DIR_G_HORIZONTAL\n        a=pxl;\n        b=pxr;\n    #endif\n    #ifndef DIR_G_HORIZONTAL // VERTICAL\n        a=pxt;\n        b=pxb;\n    #endif\n    #ifdef FLIP_G\n        vec4 c3=a;\n        a=b;\n        b=c3;\n    #endif\n    #ifdef METH_G_DIFF\n        #ifdef METH_G_R\n            col.g+=(b.r-a.r)*strength;\n        #endif\n        #ifdef METH_G_G\n            col.g+=(b.g-a.g)*strength;\n        #endif\n        #ifdef METH_G_B\n            col.g+=(b.b-a.b)*strength;\n        #endif\n    #endif\n    #ifdef METH_G_AVG\n        #ifdef METH_G_R\n            col.g+=(((b.r+a.r-0.5)/2.0))*strength;\n        #endif\n        #ifdef METH_G_G\n            col.g+=(((b.g+a.g-0.5)/2.0))*strength;\n        #endif\n        #ifdef METH_G_B\n            col.g+=(((b.b+a.b-0.5)/2.0))*strength;\n        #endif\n    #endif\n    #ifdef METH_G_LUMI\n        col.g+=(lum(b.rgb)-lum(a.rgb))*strength;\n    #endif\n    #ifdef METH_G_ONE\n        col.g=1.0;\n    #endif\n    #ifdef METH_G_ZERO\n        col.g=0.0;\n    #endif\n\n\n    ////////////////////////\n\n    #ifdef DIR_B_HORIZONTAL\n        a=pxl;\n        b=pxr;\n    #endif\n    #ifndef DIR_B_HORIZONTAL // VERTICAL\n        a=pxt;\n        b=pxb;\n    #endif\n    #ifdef FLIP_B\n        vec4 c2=a;\n        a=b;\n        b=c2;\n    #endif\n    #ifdef METH_B_DIFF\n        #ifdef METH_B_R\n            col.b+=(b.r-a.r)*strength;\n        #endif\n        #ifdef METH_B_G\n            col.b+=(b.g-a.g)*strength;\n        #endif\n        #ifdef METH_B_B\n            col.b+=(b.b-a.b)*strength;\n        #endif\n    #endif\n    #ifdef METH_B_AVG\n        #ifdef METH_B_R\n            col.b+=(((b.r+a.r-0.5)/2.0))*strength;\n        #endif\n        #ifdef METH_B_G\n            col.b+=(((b.g+a.g-0.5)/2.0))*strength;\n        #endif\n        #ifdef METH_B_B\n            col.b+=(((b.b+a.b-0.5)/2.0))*strength;\n        #endif\n    #endif\n    #ifdef METH_B_LUMI\n        col.b+=(lum(b.rgb)-lum(a.rgb))*strength;\n    #endif\n    #ifdef METH_B_ONE\n        col.b=1.0;\n    #endif\n    #ifdef METH_B_ZERO\n        col.b=0.0;\n    #endif\n\n\n\n    col.a=1.0;\n\n    outColor= col;\n\n}\n",};
const options = [
    "Vertical Difference Red", "Vertical Difference Green", "Vertical Difference Blue",
    "Vertical Average Red", "Vertical Average Green", "Vertical Average Blue",
    "Vertical Luminance",
    "Horizontal Difference Red", "Horizontal Difference Green", "Horizontal Difference Blue",
    "Horizontal Average Red", "Horizontal Average Green", "Horizontal Average Blue",
    "Horizontal Luminance",
    "Midpoint", "Zero", "One"
];

const
    render = op.inTrigger("render"),
    strength = op.inValue("Strength", 4),
    step = op.inValue("Step", 1),
    rMeth = op.inDropDown("Red", options, "Horizontal Difference Red"),
    rFlip = op.inBool("Red Flip", false),
    gMeth = op.inDropDown("Green", options, "Vertical Difference Green"),
    gFlip = op.inBool("Green Flip", false),
    bMeth = op.inDropDown("Blue", options, "Midpoint"),
    bFlip = op.inBool("Blue Flip", false),
    trigger = op.outTrigger("trigger");
op.setPortGroup("Method", [rFlip, gFlip, bFlip, rMeth, gMeth, bMeth]);

rFlip.onChange =
gFlip.onChange =
bFlip.onChange =
rMeth.onChange =
    gMeth.onChange =
    bMeth.onChange = updateDefines;

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.slope_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniStrength = new CGL.Uniform(shader, "f", "strength", strength),
    uniStep = new CGL.Uniform(shader, "f", "sstep", step),
    uniRes = new CGL.Uniform(shader, "2f", "pixel");

updateDefines();

function updateDefines()
{
    shader.toggleDefine("DIR_R_HORIZONTAL", (rMeth.get() + "").indexOf("Horizontal") != -1);
    shader.toggleDefine("DIR_G_HORIZONTAL", (gMeth.get() + "").indexOf("Horizontal") != -1);
    shader.toggleDefine("DIR_B_HORIZONTAL", (bMeth.get() + "").indexOf("Horizontal") != -1);

    shader.toggleDefine("METH_R_DIFF", (rMeth.get() + "").indexOf("Difference") != -1);
    shader.toggleDefine("METH_G_DIFF", (gMeth.get() + "").indexOf("Difference") != -1);
    shader.toggleDefine("METH_B_DIFF", (bMeth.get() + "").indexOf("Difference") != -1);

    shader.toggleDefine("METH_R_AVG", (rMeth.get() + "").indexOf("Average") != -1);
    shader.toggleDefine("METH_G_AVG", (gMeth.get() + "").indexOf("Average") != -1);
    shader.toggleDefine("METH_B_AVG", (bMeth.get() + "").indexOf("Average") != -1);

    shader.toggleDefine("METH_R_R", (rMeth.get() + "").indexOf("Red") != -1);
    shader.toggleDefine("METH_G_R", (gMeth.get() + "").indexOf("Red") != -1);
    shader.toggleDefine("METH_B_R", (bMeth.get() + "").indexOf("Red") != -1);

    shader.toggleDefine("METH_R_G", (rMeth.get() + "").indexOf("Green") != -1);
    shader.toggleDefine("METH_G_G", (gMeth.get() + "").indexOf("Green") != -1);
    shader.toggleDefine("METH_B_G", (bMeth.get() + "").indexOf("Green") != -1);

    shader.toggleDefine("METH_R_B", (rMeth.get() + "").indexOf("Blue") != -1);
    shader.toggleDefine("METH_G_B", (gMeth.get() + "").indexOf("Blue") != -1);
    shader.toggleDefine("METH_B_B", (bMeth.get() + "").indexOf("Blue") != -1);

    shader.toggleDefine("METH_R_LUMI", (rMeth.get() + "").indexOf("Luminance") != -1);
    shader.toggleDefine("METH_G_LUMI", (gMeth.get() + "").indexOf("Luminance") != -1);
    shader.toggleDefine("METH_B_LUMI", (bMeth.get() + "").indexOf("Luminance") != -1);

    shader.toggleDefine("METH_R_MID", (rMeth.get() + "").indexOf("Midpoint") != -1);
    shader.toggleDefine("METH_G_MID", (gMeth.get() + "").indexOf("Midpoint") != -1);
    shader.toggleDefine("METH_B_MID", (bMeth.get() + "").indexOf("Midpoint") != -1);

    shader.toggleDefine("METH_R_ZERO", (rMeth.get() + "").indexOf("Zero") != -1);
    shader.toggleDefine("METH_G_ZERO", (gMeth.get() + "").indexOf("Zero") != -1);
    shader.toggleDefine("METH_B_ZERO", (bMeth.get() + "").indexOf("Zero") != -1);

    shader.toggleDefine("METH_R_ONE", (rMeth.get() + "").indexOf("One") != -1);
    shader.toggleDefine("METH_G_ONE", (gMeth.get() + "").indexOf("One") != -1);
    shader.toggleDefine("METH_B_ONE", (bMeth.get() + "").indexOf("One") != -1);

    shader.toggleDefine("FLIP_R", rFlip.get());
    shader.toggleDefine("FLIP_G", gFlip.get());
    shader.toggleDefine("FLIP_B", bFlip.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    const tex = cgl.currentTextureEffect.getCurrentSourceTexture();
    uniRes.set([1 / tex.width, 1 / tex.height]);

    cgl.setTexture(0, tex.tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.PixelDifference.prototype = new CABLES.Op();
CABLES.OPS["f4e53fd9-d4c3-4d0e-839a-78543c38b8db"]={f:Ops.Gl.TextureEffects.PixelDifference,objName:"Ops.Gl.TextureEffects.PixelDifference"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.PixelDisplacement_v4
// 
// **************************************************************

Ops.Gl.TextureEffects.PixelDisplacement_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"pixeldisplace3_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D displaceTex;\nUNI float amountX;\nUNI float amountY;\nUNI float amount;\n\n{{CGL.BLENDMODES3}}\n\nvec3 getOffset(vec3 offset)\n{\n    #ifdef ZERO_BLACK\n        return offset;\n    #endif\n\n    #ifdef ZERO_GREY\n        return offset*2.0-1.0;\n    #endif\n}\n\nfloat getOffset(float offset)\n{\n    #ifdef ZERO_BLACK\n        return offset;\n    #endif\n\n    #ifdef ZERO_GREY\n        return offset*2.0-1.0;\n    #endif\n}\n\nvoid main()\n{\n    vec4 rgba=texture(displaceTex,texCoord);\n    vec3 offset=rgba.rgb*rgba.a;\n    float x,y;\n\n    #ifdef INPUT_REDGREEN\n        offset=getOffset(offset);\n        x=offset.r*amountX+texCoord.x;\n        y=offset.g*amountY+texCoord.y;\n    #endif\n    #ifdef INPUT_RED\n        offset=getOffset(offset);\n        x=offset.r*amountX+texCoord.x;\n        y=offset.r*amountY+texCoord.y;\n    #endif\n    #ifdef INPUT_GREEN\n        offset=getOffset(offset);\n        x=offset.g*amountX+texCoord.x;\n        y=offset.g*amountY+texCoord.y;\n    #endif\n    #ifdef INPUT_BLUE\n        offset=getOffset(offset);\n        x=offset.b*amountX+texCoord.x;\n        y=offset.b*amountY+texCoord.y;\n    #endif\n    #ifdef INPUT_LUMINANCE\n        float o=dot(vec3(0.2126,0.7152,0.0722), offset);\n        o=getOffset(o);\n        x=o*amountX+texCoord.x;\n        y=o*amountY+texCoord.y;\n    #endif\n    #ifdef WRAP_CLAMP\n        x=clamp(x,0.0,1.0);\n        y=clamp(y,0.0,1.0);\n    #endif\n    #ifdef WRAP_REPEAT\n        x=mod(x,1.0);\n        y=mod(y,1.0);\n    #endif\n    #ifdef WRAP_MIRROR\n        float mx=mod(x,2.0);\n        float my=mod(y,2.0);\n        x=abs((floor(mx)-fract(mx)));\n        y=abs((floor(my)-fract(my)));\n    #endif\n\n\n\n    vec4 col=texture(tex,vec2(x,y));\n    vec4 base=texture(tex,texCoord);\n\n    base.a=0.0;\n\n    outColor=cgl_blendPixel(base,col,amount);\n}\n",};
const
    render = op.inTrigger("render"),
    displaceTex = op.inTexture("displaceTex"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    amountX = op.inValueSlider("amount X", 0.2),
    amountY = op.inValueSlider("amount Y", 0.2),
    inWrap = op.inSwitch("Wrap", ["Mirror", "Clamp", "Repeat"], "Mirror"),
    inInput = op.inValueSelect("Input", ["Luminance", "RedGreen", "Red", "Green", "Blue"], "Luminance"),
    inZero = op.inSwitch("Zero Displace", ["Grey", "Black"], "Grey"),
    // displaceTex=op.inTexture("displaceTex"),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Axis Displacement Strength", [amountX, amountY]);
op.setPortGroup("Modes", [inWrap, inInput]);
op.toWorkPortsNeedToBeLinked(displaceTex);

const
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.pixeldisplace3_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureDisplaceUniform = new CGL.Uniform(shader, "t", "displaceTex", 1),
    amountXUniform = new CGL.Uniform(shader, "f", "amountX", amountX),
    amountYUniform = new CGL.Uniform(shader, "f", "amountY", amountY),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

inZero.onChange = updateZero;
inWrap.onChange = updateWrap;
inInput.onChange = updateInput;

updateWrap();
updateInput();
updateZero();

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

function updateZero()
{
    shader.removeDefine("ZERO_BLACK");
    shader.removeDefine("ZERO_GREY");
    shader.define("ZERO_" + (inZero.get() + "").toUpperCase());
}

function updateWrap()
{
    shader.removeDefine("WRAP_CLAMP");
    shader.removeDefine("WRAP_REPEAT");
    shader.removeDefine("WRAP_MIRROR");
    shader.define("WRAP_" + (inWrap.get() + "").toUpperCase());
}

function updateInput()
{
    shader.removeDefine("INPUT_LUMINANCE");
    shader.removeDefine("INPUT_REDGREEN");
    shader.removeDefine("INPUT_RED");
    shader.define("INPUT_" + (inInput.get() + "").toUpperCase());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    if(displaceTex.get())
    {
        cgl.pushShader(shader);
        cgl.currentTextureEffect.bind();

        cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
        if (displaceTex.get()) cgl.setTexture(1, displaceTex.get().tex);

        cgl.currentTextureEffect.finish();
        cgl.popShader();
    }

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.PixelDisplacement_v4.prototype = new CABLES.Op();
CABLES.OPS["c00f79f2-0505-4b4f-b0bf-10ef7875dd87"]={f:Ops.Gl.TextureEffects.PixelDisplacement_v4,objName:"Ops.Gl.TextureEffects.PixelDisplacement_v4"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Pixelate_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Pixelate_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"pixelate_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D multiplierTex;\nUNI float amount;\nUNI float amountX;\nUNI float amountY;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 col=vec4(1.0,0.0,0.0,1.0);\n\n    float x=1.0/amountX;\n    float y=1.0/amountY;\n\n    #ifdef PIXELATE_TEXTURE\n        x += texture(multiplierTex,texCoord).r*0.1;//*0.1\n        y += texture(multiplierTex,texCoord).r*0.1;//*0.1\n    #endif\n\n    vec2 coord = vec2(x*floor(texCoord.x/x), y*floor(texCoord.y/y));\n\n    col=texture(tex,coord);\n    vec4 base=texture(tex,texCoord);\n\n    outColor=cgl_blendPixel(base,col,amount);\n}",};
const render = op.inTrigger("render"),
    multiplierTex = op.inTexture("Multiplier"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    amountX = op.inValue("width", 100),
    amountY = op.inValue("height", 100),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.pixelate_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const textureMultiplierUniform = new CGL.Uniform(shader, "t", "multiplierTex", 1);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
const amountXUniform = new CGL.Uniform(shader, "f", "amountX", amountX);
const amountYUniform = new CGL.Uniform(shader, "f", "amountY", amountY);

multiplierTex.onChange = function ()
{
    shader.toggleDefine("PIXELATE_TEXTURE", multiplierTex.isLinked());
};

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (multiplierTex.get()) cgl.setTexture(1, multiplierTex.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Pixelate_v2.prototype = new CABLES.Op();
CABLES.OPS["c06ae168-ff4f-4ae6-b4d0-06c3b24203bc"]={f:Ops.Gl.TextureEffects.Pixelate_v2,objName:"Ops.Gl.TextureEffects.Pixelate_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Plasma_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Plasma_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"plasma_frag":"#define PI 3.1415926535897932384626433832795\n\nIN vec2 texCoord;\n\nUNI sampler2D tex;\nUNI vec2 size;\nUNI vec2 pos;\nUNI float mul;\nUNI float amount;\nUNI float time;\nUNI float aspect;\n\n#ifdef HAS_TEX_OFFSETMAP\n    UNI sampler2D texOffsetZ;\n    UNI float offMul;\n#endif\n\n#ifdef HAS_TEX_MASK\n    UNI sampler2D texMask;\n#endif\n\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    float v = 0.0;\n\n    vec2 s=size;\n    #ifdef FIXASPECT\n        s.y=size.x/aspect;\n    #endif\n\n    vec2 c = texCoord * s - s/2.0;\n\n    c+=pos;\n\n    vec3 offset;\n    #ifdef HAS_TEX_OFFSETMAP\n        vec4 offMap=texture(texOffsetZ,texCoord);\n\n        #ifdef OFFSET_X_R\n            offset.x=offMap.r;\n        #endif\n        #ifdef OFFSET_X_G\n            offset.x=offMap.g;\n        #endif\n        #ifdef OFFSET_X_B\n            offset.x=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Y_R\n            offset.y=offMap.r;\n        #endif\n        #ifdef OFFSET_Y_G\n            offset.y=offMap.g;\n        #endif\n        #ifdef OFFSET_Y_B\n            offset.y=offMap.b;\n        #endif\n\n        #ifdef OFFSET_Z_R\n            offset.z=offMap.r;\n        #endif\n        #ifdef OFFSET_Z_G\n            offset.z=offMap.g;\n        #endif\n        #ifdef OFFSET_Z_B\n            offset.z=offMap.b;\n        #endif\n        offset*=offMul;\n    #endif\n\n    c+=offset.xy;\n    float t=time+offset.z;\n\n    v += sin((c.x+t));\n    v += sin((c.y+t)/2.0);\n    v += sin((c.x+c.y+t)/2.0);\n    c += size/2.0 * vec2(sin(t/3.0), cos(t/2.0));\n\n    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+t);\n    v = v/2.0;\n\n    vec3 newColor = vec3(sin(PI*v*mul/4.0), sin(PI*v*mul), cos(PI*v*mul))*.5 + .5;\n    vec4 base=texture(tex,texCoord);\n\n    #ifndef GREY\n       vec4 col=vec4( _blend(base.rgb,newColor) ,1.0);\n    #endif\n    #ifdef GREY\n       vec4 col=vec4( _blend(base.rgb,vec3(newColor.g)) ,1.0);\n    #endif\n\n    float str=1.0;\n    #ifdef HAS_TEX_MASK\n        str=texture(texMask,texCoord).r;\n    #endif\n\n    outColor=cgl_blendPixel(base,col,amount*str);\n}\n\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    amount = op.inValueSlider("Amount", 1),
    w = op.inValue("Width", 20),
    h = op.inValue("Height", 20),
    inAspect = op.inBool("Aspect", true),
    mul = op.inValue("Mul", 1),
    x = op.inValue("X", 0),
    y = op.inValue("Y", 0),
    time = op.inValue("Time", 1),
    greyscale = op.inValueBool("Greyscale", true),

    inTexOffsetZ = op.inTexture("Offset"),
    inOffsetMul = op.inFloat("Offset Multiply", 1),
    offsetX = op.inSwitch("Offset X", ["None", "R", "G", "B"], "None"),
    offsetY = op.inSwitch("Offset Y", ["None", "R", "G", "B"], "None"),
    offsetZ = op.inSwitch("Offset Time", ["None", "R", "G", "B"], "R"),

    inTexMask = op.inTexture("Mask"),

    trigger = op.outTrigger("trigger");

op.setPortGroup("Offset Map", [inTexOffsetZ, offsetZ, offsetY, offsetX, inOffsetMul]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.plasma_frag);
CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

const
    uniPos = new CGL.Uniform(shader, "2f", "pos", x, y),
    uniSize = new CGL.Uniform(shader, "2f", "size", w, h),
    uniTime = new CGL.Uniform(shader, "f", "time", time),
    uniMul = new CGL.Uniform(shader, "f", "mul", mul),
    uniAspect = new CGL.Uniform(shader, "f", "aspect", 1),
    uniOffMul = new CGL.Uniform(shader, "f", "offMul", inOffsetMul),
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureUniformOffZ = new CGL.Uniform(shader, "t", "texOffsetZ", 1),
    textureUniformMask = new CGL.Uniform(shader, "t", "texMask", 2),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

offsetX.onChange =
    inAspect.onChange =
    offsetY.onChange =
    offsetZ.onChange =
    inTexMask.onChange =
    greyscale.onChange =
    inTexOffsetZ.onLinkChanged = updateDefines;

updateDefines();

function updateDefines()
{
    shader.toggleDefine("GREY", greyscale.get());

    shader.toggleDefine("HAS_TEX_OFFSETMAP", inTexOffsetZ.isLinked());
    shader.toggleDefine("HAS_TEX_MASK", inTexMask.isLinked());

    shader.toggleDefine("OFFSET_X_R", offsetX.get() == "R");
    shader.toggleDefine("OFFSET_X_G", offsetX.get() == "G");
    shader.toggleDefine("OFFSET_X_B", offsetX.get() == "B");

    shader.toggleDefine("OFFSET_Y_R", offsetY.get() == "R");
    shader.toggleDefine("OFFSET_Y_G", offsetY.get() == "G");
    shader.toggleDefine("OFFSET_Y_B", offsetY.get() == "B");

    shader.toggleDefine("OFFSET_Z_R", offsetZ.get() == "R");
    shader.toggleDefine("OFFSET_Z_G", offsetZ.get() == "G");
    shader.toggleDefine("OFFSET_Z_B", offsetZ.get() == "B");

    offsetX.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    offsetY.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    offsetZ.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });
    inOffsetMul.setUiAttribs({ "greyout": !inTexOffsetZ.isLinked() });

    h.setUiAttribs({ "greyout": inAspect.get() });
    shader.toggleDefine("FIXASPECT", inAspect.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    if (inAspect.get()) uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);
    else uniAspect.setValue(1);

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inTexOffsetZ.get()) cgl.setTexture(1, inTexOffsetZ.get().tex);
    if (inTexMask.get()) cgl.setTexture(2, inTexMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Plasma_v2.prototype = new CABLES.Op();
CABLES.OPS["89b3bf34-a9a8-4dcf-a304-9dee597fcf48"]={f:Ops.Gl.TextureEffects.Plasma_v2,objName:"Ops.Gl.TextureEffects.Plasma_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.PolarCoords
// 
// **************************************************************

Ops.Gl.TextureEffects.PolarCoords = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"polarcoords_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float inner;\nUNI float outer;\n\nvoid main()\n{\n    vec4 col=vec4(1.0,0.0,0.0,1.0);\n    vec2 x = texCoord - vec2(0.5);\n    float radius = length(x);\n    float angle = atan(x.y, x.x);\n\n    vec2 tc;\n    tc.s = ( radius - inner) / (outer - inner);\n    tc.t = angle * 0.5 / 3.141592653589793 + 0.5;\n\n    #ifdef CROP_IMAGE\n        if(tc.s<0.0 || tc.t<0.0 || tc.s>1.0 || tc.t>1.0) discard;\n    #endif\n\n    col=texture(tex,tc);\n    outColor= col;\n}\n",};
const
    render = op.inTrigger("render"),
    inner = op.inValueSlider("Radius Inner", 0),
    outer = op.inValueSlider("Radius Outer", 1),
    crop = op.inValueBool("Crop", false),
    trigger = op.outTrigger("trigger"),
    cgl = op.patch.cgl;

const shader = new CGL.Shader(cgl, op.name);
shader.setSource(shader.getDefaultVertexShader(), attachments.polarcoords_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniinner = new CGL.Uniform(shader, "f", "inner", inner),
    uniouter = new CGL.Uniform(shader, "f", "outer", outer);

crop.onChange = updateCrop;

function updateCrop()
{
    if (crop.get()) shader.define("CROP_IMAGE");
    else shader.removeDefine("CROP_IMAGE");
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.PolarCoords.prototype = new CABLES.Op();
CABLES.OPS["1555fefe-4eb4-4aed-84c0-ad54e0dae1c1"]={f:Ops.Gl.TextureEffects.PolarCoords,objName:"Ops.Gl.TextureEffects.PolarCoords"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Posterize_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Posterize_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"posterize_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\nUNI float levels;\nUNI float amount;\n\n{{CGL.BLENDMODES3}}\n\nvoid main(void)\n{\n    vec3 srcPixel = texture(tex, texCoord  ).rgb;\n    vec3 amountPerLevel = vec3(1.0/levels);\n    vec3 numOfLevels = floor(srcPixel/amountPerLevel);\n    vec3 col = numOfLevels * (vec3(1.0) / (vec3(levels) - vec3(1.0)));\n\n    vec4 base=texture(tex,texCoord);\n    outColor= cgl_blendPixel(base,vec4(col,base.a),amount);\n}\n\n",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    levels = op.inValue("levels", 2),
    trigger = op.outTrigger("Trigger");

const
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.posterize_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    levelsUniform = new CGL.Uniform(shader, "f", "levels", levels),
    uniWidth = new CGL.Uniform(shader, "f", "texWidth", 128),
    uniHeight = new CGL.Uniform(shader, "f", "texHeight", 128),
    uniAmount = new CGL.Uniform(shader, "f", "amount", amount);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    uniWidth.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniHeight.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().height);

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Posterize_v2.prototype = new CABLES.Op();
CABLES.OPS["19703953-7984-4334-af72-0991425b4850"]={f:Ops.Gl.TextureEffects.Posterize_v2,objName:"Ops.Gl.TextureEffects.Posterize_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.PseudoLensFlares
// 
// **************************************************************

Ops.Gl.TextureEffects.PseudoLensFlares = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"lensflares_frag":"UNI sampler2D tex;\n// UNI sampler2D texInput;\nUNI float haloWidth;\nUNI int numGhosts;\nUNI float dispersal;\nUNI float amountGhosts;\nUNI float amountHalo;\nUNI sampler2D texLookup;\n\nIN vec2 texCoord;\n\nvec3 lumi(vec3 c)\n{\n   return vec3(sqrt(c.r*c.r*0.241+c.g*c.g*0.691+c.b*c.b*0.068));\n}\n\nvec4 myTexture(sampler2D tex,vec2 coords)\n{\n    vec4 c=texture(tex, coords);\n    c.rgb=lumi(c.rgb);\n    return c;\n}\n\nvoid main()\n{\n    vec2 texcoord = -texCoord + vec2(1.0);\n    // vec2 texelSize = 1.0 / vec2(textureSize(texInput, 0));\n    vec2 ghostVec = (vec2(0.5) - texcoord) * (0.5*dispersal);\n    vec4 result = vec4(0.0,0.0,0.0,1.0);//texture(tex,texCoord);\n\n\n\n    // ghosts\n    for (int i = 0; i < numGhosts; ++i)\n    {\n        vec2 offset = fract(texcoord + ghostVec * float(i));\n        float weightA = length(vec2(0.5) - offset) / length(vec2(0.5));\n        weightA = pow(1. - weightA, 10.0);\n        result += myTexture(tex, offset)*weightA*amountGhosts;\n    }\n\n    // halo\n    vec2 haloVec = normalize(ghostVec) * haloWidth;\n    float weight = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5));\n\n    weight = pow(1.0 - weight, 5.0);\n    result += myTexture(tex, texcoord + haloVec) * weight * amountHalo;\n\n    #ifdef TEX_LOOPUP\n        result *= texture(texLookup, vec2(length(vec2(0.5) - texcoord) / length(vec2(0.5)),0.5));\n    #endif\n\n    outColor=result;\n}\n\n",};
// http://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html

const render = op.inTrigger("render"),
    inAmountGhosts = op.inValueSlider("Ghosts", 1.0),
    inNumGhosts = op.inValueInt("Num Ghosts", 3),
    inDispersal = op.inValueSlider("Dispersal", 0.5),
    inAmountHalo = op.inValueSlider("Halo", 1.0),
    inHaloWidth = op.inValueSlider("Halo Width", 0.5),
    textureLookup = op.inTexture("Color Lookup"),
    trigger = op.outTrigger("trigger");

const
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.lensflares_frag || "");

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureLookupUni = new CGL.Uniform(shader, "t", "texLookup", 1),
    uniHaloWidth = new CGL.Uniform(shader, "f", "haloWidth", inHaloWidth),
    uniNumGhosts = new CGL.Uniform(shader, "i", "numGhosts", inNumGhosts),
    uniDispersal = new CGL.Uniform(shader, "f", "dispersal", inDispersal),
    uniAmountGhosts = new CGL.Uniform(shader, "f", "amountGhosts", inAmountGhosts),
    uniAmounthalo = new CGL.Uniform(shader, "f", "amountHalo", inAmountHalo);

textureLookup.onChange = function ()
{
    if (textureLookup.get())shader.define("TEX_LOOPUP");
    else shader.removeDefine("TEX_LOOPUP");
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    let texture = cgl.currentTextureEffect.getCurrentSourceTexture();

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, texture.tex);
    if (textureLookup.get()) cgl.setTexture(1, textureLookup.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.PseudoLensFlares.prototype = new CABLES.Op();
CABLES.OPS["9e4a5694-ed59-4401-9f7b-123a627924c5"]={f:Ops.Gl.TextureEffects.PseudoLensFlares,objName:"Ops.Gl.TextureEffects.PseudoLensFlares"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.RGBOffset_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.RGBOffset_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"offsetrgb_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float offsetRedX,offsetRedY,offsetGreenX,offsetGreenY,offsetBlueX,offsetBlueY;\nUNI float redAmount,greenAmount,blueAmount;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec3 rgb = vec3(texture(tex,texCoord+vec2(offsetRedX,offsetRedY)).r,\n                    texture(tex,texCoord+vec2(offsetGreenX,offsetGreenY)).g,\n                    texture(tex,texCoord+vec2(offsetBlueX,offsetBlueY)).b);\n\n    vec4 base = texture(tex,texCoord);\n    vec4 col = vec4(rgb*vec3(redAmount,greenAmount,blueAmount),base.a);\n\n    outColor=cgl_blendPixel(base,col,amount);\n}\n",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    offsetRedX = op.inFloat("Red offset X", 0.05),
    offsetRedY = op.inFloat("Red offset Y", 0.1),
    redAmount = op.inFloat("Red amount", 1.0),
    offsetGreenX = op.inFloat("Green offset X", 0.0),
    offsetGreenY = op.inFloat("Green offset Y", 0.0),
    greenAmount = op.inFloat("Green amount", 1.0),
    offsetBlueX = op.inFloat("Blue offset X", 0),
    offsetBlueY = op.inFloat("Blue offset Y", 0),
    blueAmount = op.inFloat("Blue amount", 1.0),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Red", [offsetRedX, offsetRedY, redAmount]);
op.setPortGroup("Green", [offsetGreenX, offsetGreenY, greenAmount]);
op.setPortGroup("Blue", [offsetBlueX, offsetBlueY, blueAmount]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "RGB offset");

shader.setSource(shader.getDefaultVertexShader(), attachments.offsetrgb_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    offsetRedUniX = new CGL.Uniform(shader, "f", "offsetRedX", offsetRedX),
    offsetRedUniY = new CGL.Uniform(shader, "f", "offsetRedY", offsetRedY),
    redUniAmount = new CGL.Uniform(shader, "f", "redAmount", redAmount),

    offsetGreenUniX = new CGL.Uniform(shader, "f", "offsetGreenX", offsetGreenX),
    offsetGreenUniY = new CGL.Uniform(shader, "f", "offsetGreenY", offsetGreenY),
    greenUniAmount = new CGL.Uniform(shader, "f", "greenAmount", greenAmount),

    offsetBlueUniX = new CGL.Uniform(shader, "f", "offsetBlueX", offsetBlueX),
    offsetBlueUniY = new CGL.Uniform(shader, "f", "offsetBlueY", offsetBlueY),
    blueUniAmount = new CGL.Uniform(shader, "f", "blueAmount", blueAmount);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.RGBOffset_v2.prototype = new CABLES.Op();
CABLES.OPS["41a9655a-6e05-47ee-82b9-f19a33a5cfd4"]={f:Ops.Gl.TextureEffects.RGBOffset_v2,objName:"Ops.Gl.TextureEffects.RGBOffset_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.RectangleTexture_v4
// 
// **************************************************************

Ops.Gl.TextureEffects.RectangleTexture_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rectangle_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\n\nUNI float width;\nUNI float height;\nUNI float x;\nUNI float y;\n\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\n\nUNI float aspect;\nUNI float amount;\nUNI float rotate;\nUNI float roundness;\n\n#define DEG2RAD 0.785398163397\n\n{{CGL.BLENDMODES3}}\n\nmat2 rot(float angle)\n{\n    float s=sin(angle);\n    float c=cos(angle);\n\n    return mat2(c,-s,s,c);\n}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    vec4 col=vec4(r,g,b,a);\n    vec2 p=texCoord;\n\n    // p.y*=aspect;\n    float d=1.0;\n\n    vec2 pos=vec2(x,y);\n    pos=pos/2.0+0.5;\n\n\n    vec2 pp=p-pos;\n    #ifndef CENTER\n        pp-=vec2(width,height*aspect);\n    #endif\n\n    pp=pp*rot(rotate*DEG2RAD/45.0);\n\n    float roundn=roundness*min(width,height);\n\n    vec2 size=max(vec2(width,height*aspect)-roundn,0.0);\n    vec2 absPos=abs(pp)-size;\n\n    d=max(absPos.x,absPos.y);\n    d=min(d,length(max(absPos,0.0))-roundn);\n    d=step(0.0,d);\n\n\n    // col=vec4( _blend(base.rgb,vec3(r,g,b)) ,1.0);\n    // col=vec4( mix( col.rgb, base.rgb ,1.0-base.a*a*(1.0-d)*amount),1.0);\n    // outColor=col;\n\n    outColor=cgl_blendPixel(base,col,amount*(1.0-d));\n    // outColor=vec4(1.0,1.0,1.0,1.0-d);\n\n\n}\n\n\n\n",};
const render = op.inTrigger("render"),
    amount = op.inValueSlider("Amount", 1),
    blendMode = CGL.TextureEffect.AddBlendSelect(op),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    inCenterMode = op.inBool("Center", true),
    inWidth = op.inValueSlider("Width", 0.25),
    inHeight = op.inValueSlider("Height", 0.25),
    inPosX = op.inValueSlider("X", 0),
    inPosY = op.inValueSlider("Y", 0),
    inRot = op.inValue("Rotate", 0),
    inRoundness = op.inValueSlider("roundness", 0),
    r = op.inValueSlider("r", 1.0),
    g = op.inValueSlider("g", 1.0),
    b = op.inValueSlider("b", 1.0),
    a = op.inValueSlider("a", 1.0),
    trigger = op.outTrigger("trigger");

r.setUiAttribs({ "colorPick": true });

op.setPortGroup("Size", [inWidth, inHeight]);
op.setPortGroup("Position", [inPosX, inPosY]);
op.setPortGroup("Color", [r, g, b, a]);

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, "textureeffect rectangle");
shader.setSource(shader.getDefaultVertexShader(), attachments.rectangle_frag || "");

let textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniHeight = new CGL.Uniform(shader, "f", "height", inHeight),
    unWidth = new CGL.Uniform(shader, "f", "width", inWidth),
    uniX = new CGL.Uniform(shader, "f", "x", inPosX),
    uniY = new CGL.Uniform(shader, "f", "y", inPosY),
    uniRot = new CGL.Uniform(shader, "f", "rotate", inRot),
    uniRoundness = new CGL.Uniform(shader, "f", "roundness", inRoundness),
    uniformR = new CGL.Uniform(shader, "f", "r", r),
    uniformG = new CGL.Uniform(shader, "f", "g", g),
    uniformB = new CGL.Uniform(shader, "f", "b", b),
    uniformA = new CGL.Uniform(shader, "f", "a", a),
    uniformAmount = new CGL.Uniform(shader, "f", "amount", amount),
    uniformAspect = new CGL.Uniform(shader, "f", "aspect", 1);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

inCenterMode.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("CENTER", inCenterMode.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    const texture = cgl.currentTextureEffect.getCurrentSourceTexture();
    uniformAspect.set(cgl.currentTextureEffect.aspectRatio);

    cgl.setTexture(0, texture.tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.RectangleTexture_v4.prototype = new CABLES.Op();
CABLES.OPS["268ad86e-1f6d-4099-b5c0-e1e0150adbfb"]={f:Ops.Gl.TextureEffects.RectangleTexture_v4,objName:"Ops.Gl.TextureEffects.RectangleTexture_v4"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.RemoveAlpha
// 
// **************************************************************

Ops.Gl.TextureEffects.RemoveAlpha = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const render = op.inTrigger("render");
const trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

const srcFrag = ""

    .endl() + "#ifdef HAS_TEXTURES"
    .endl() + "  IN vec2 texCoord;"
    .endl() + "  uniform sampler2D tex;"
    .endl() + "#endif"
    .endl() + ""
    .endl() + ""
    .endl() + "void main()"
    .endl() + "{"
    .endl() + "   vec4 col=vec4(1.0,0.0,0.0,1.0);"
    .endl() + "   #ifdef HAS_TEXTURES"
    .endl() + "       col=texture2D(tex,texCoord);"
    .endl() + "       col.a=1.0;"
    .endl() + "   #endif"
    .endl() + "   outColor= col;"
    .endl() + "}";

shader.setSource(shader.getDefaultVertexShader(), srcFrag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.RemoveAlpha.prototype = new CABLES.Op();
CABLES.OPS["98875f07-5dfa-4dfa-921c-de317cdc357e"]={f:Ops.Gl.TextureEffects.RemoveAlpha,objName:"Ops.Gl.TextureEffects.RemoveAlpha"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.RepeatTexture_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.RepeatTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"repeat_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D mulTex;\nUNI float amount;\nUNI float amountX;\nUNI float amountY;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    float am=amount;\n\n    float mul=1.0;\n\n    #ifdef HAS_MASK\n        mul=texture(mulTex,texCoord).r;\n    #endif\n\n    vec2 coord = vec2(\n        mod(texCoord.x*amountX*mul,1.0),\n        mod(texCoord.y*amountY*mul,1.0));\n\n    vec4 col=texture(tex,coord);\n    vec4 base=texture(tex,texCoord);\n\n\n    #ifdef CLEAR\n        base.a=0.0;\n    #endif\n\n    outColor=cgl_blendPixel(base,col,am);\n}",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    amountX = op.inValue("x", 3),
    amountY = op.inValue("y", 3),
    trigger = op.outTrigger("trigger"),
    inClear=op.inBool("Clear",true),
    mulTex = op.inTexture("Multiply");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.repeat_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureMulUniform = new CGL.Uniform(shader, "t", "mulTex", 2),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    amountXUniform = new CGL.Uniform(shader, "f", "amountX", amountX),
    amountYUniform = new CGL.Uniform(shader, "f", "amountY", amountY);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

inClear.onChange =
mulTex.onChange =updateDefines;

function updateDefines()
{

    shader.toggleDefine("CLEAR", inClear.get());
    shader.toggleDefine("HAS_MASK", mulTex.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (mulTex.get())cgl.setTexture(2, mulTex.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.RepeatTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["ff9aa796-d781-444c-a9d4-a62157f82dd5"]={f:Ops.Gl.TextureEffects.RepeatTexture_v2,objName:"Ops.Gl.TextureEffects.RepeatTexture_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.RgbMultiply
// 
// **************************************************************

Ops.Gl.TextureEffects.RgbMultiply = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbmul_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float r;\nUNI float g;\nUNI float b;\n\nvoid main()\n{\n   vec4 col=vec4(1.0,0.0,0.0,1.0);\n   col=texture(tex,texCoord);\n   col.r*=r;\n   col.g*=g;\n   col.b*=b;\n   outColor= col;\n}\n",};
const render = op.inTrigger("render");
const r = op.inValue("r", 1);
const g = op.inValue("g", 1);
const b = op.inValue("b", 1);
const trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.rgbmul_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const uniformR = new CGL.Uniform(shader, "f", "r", r);
const uniformG = new CGL.Uniform(shader, "f", "g", g);
const uniformB = new CGL.Uniform(shader, "f", "b", b);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.RgbMultiply.prototype = new CABLES.Op();
CABLES.OPS["00f30153-f656-4701-9b93-244b033b2eaa"]={f:Ops.Gl.TextureEffects.RgbMultiply,objName:"Ops.Gl.TextureEffects.RgbMultiply"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.RgbToHsvTexture
// 
// **************************************************************

Ops.Gl.TextureEffects.RgbToHsvTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"tonormal_frag":"#ifdef HAS_TEXTURES\n  IN vec2 texCoord;\n  UNI sampler2D tex;\n#endif\n\nUNI float strength;\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main()\n{\n    vec4 col=texture(tex, texCoord);\n\n\n\n    #ifdef OUT_HSB\n        col.rgb=rgb2hsv(col.rgb).rgb;\n    #endif\n    #ifdef OUT_H\n        col.rgb=rgb2hsv(col.rgb).rrr;\n    #endif\n    #ifdef OUT_S\n        col.rgb=rgb2hsv(col.rgb).ggg;\n    #endif\n    #ifdef OUT_B\n        col.rgb=rgb2hsv(col.rgb).bbb;\n    #endif\n    #ifdef OUT_SB\n        col.rgb=rgb2hsv(col.rgb).ggg*rgb2hsv(col.rgb).bbb;\n    #endif\n\n\n    outColor=col;\n}",};
const
    render = op.inTrigger("render"),
    inMeth = op.inSwitch("Output RGB", ["HSB", "Hue", "Sat", "Bright", "Sat*Bright"], "HSB"),
    trigger = op.outTrigger("trigger"),
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.tonormal_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);

inMeth.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("OUT_HSB", inMeth.get() == "HSB");
    shader.toggleDefine("OUT_H", inMeth.get() == "Hue");
    shader.toggleDefine("OUT_S", inMeth.get() == "Sat");
    shader.toggleDefine("OUT_B", inMeth.get() == "Bright");
    shader.toggleDefine("OUT_SB", inMeth.get() == "Sat*Bright");
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.RgbToHsvTexture.prototype = new CABLES.Op();
CABLES.OPS["147ed29e-f04e-4f7c-b9d7-133d7c6cbef9"]={f:Ops.Gl.TextureEffects.RgbToHsvTexture,objName:"Ops.Gl.TextureEffects.RgbToHsvTexture"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.RotateTexture_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.RotateTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rotate_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D multiplierTex;\nUNI float amount;\nUNI float resX;\nUNI float resY;\nUNI float rotate;\n\n{{CGL.BLENDMODES3}}\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid main()\n{\n    float multiplier = 0.0;\n\n    #ifdef ROTATE_TEXTURE\n        multiplier = dot(vec3(0.2126,0.7152,0.0722), texture(multiplierTex,texCoord).rgb);\n    #endif\n\n    vec2 uv = texCoord;\n    vec2 res = vec2(resX,resY);\n    uv -= 0.5;\n    pR(uv.xy,(rotate + multiplier) * (TAU)  );\n    uv += 0.5;\n\n\n\n    vec4 col=texture(tex,uv);\n    vec4 base=texture(tex,texCoord);\n\n    #ifdef CLEAR\n        base.a=0.0;\n    #endif\n\n\n    #ifdef CROP_IMAGE\n    if(uv.x>1.0 ||uv.x<0.0  || uv.y>1.0 ||uv.y<0.0 )\n    {\n        base.a=0.0;\n        col.a=0.0;\n        // discard;\n        // return;\n    }\n    #endif\n\n    outColor=cgl_blendPixel(base,col,amount);\n}",};
const render = op.inTrigger("render"),
    multiplierTex = op.inTexture("Multiplier"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    inRotate = op.inValueSlider("Rotate", 0.125),
    crop = op.inValueBool("Crop", true),
    inClear=op.inBool("Clear",true),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "rotatetexture");

shader.setSource(shader.getDefaultVertexShader(), attachments.rotate_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureMultiplierUniform = new CGL.Uniform(shader, "t", "multiplierTex", 1),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    rotateUniform = new CGL.Uniform(shader, "f", "rotate", inRotate);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

crop.onChange =
    multiplierTex.onChange = updateDefines;

updateDefines();


function updateDefines()
{
    shader.toggleDefine("CLEAR", inClear.get());
    shader.toggleDefine("CROP_IMAGE", crop.get());
    shader.toggleDefine("ROTATE_TEXTURE", multiplierTex.isLinked());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (multiplierTex.get()) cgl.setTexture(1, multiplierTex.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.RotateTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["20b8a2e6-2419-474b-98a4-71a5e3178631"]={f:Ops.Gl.TextureEffects.RotateTexture_v2,objName:"Ops.Gl.TextureEffects.RotateTexture_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.RoundCorners
// 
// **************************************************************

Ops.Gl.TextureEffects.RoundCorners = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"roundcorners_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float radius;\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\n\nUNI float width;\nUNI float height;\n\nfloat roundRect(in vec2 distFromCenter)\n{\n    float r=radius*0.25*width+0.01;\n    float t = length(max(abs(distFromCenter) - (vec2(0.5*width,0.5*height) - vec2(r,r)), vec2(0.0))) - r;\n    return smoothstep(-0.001, 0.9,t);\n}\n\nvoid main()\n{\n    vec2 tc=texCoord;\n    vec4 col=texture(tex,tc);\n    float c=0.0;\n\n    c=roundRect(vec2(0.5*width,0.5*height)-vec2(gl_FragCoord));\n    outColor=mix(col,vec4(r,g,b,a),c);\n\n}",};
const
    render = op.inTrigger("render"),
    radius = op.inValueSlider("radius", 0.25),
    r = op.inValueSlider("r"),
    g = op.inValueSlider("g"),
    b = op.inValueSlider("b"),
    a = op.inValueSlider("a", 1),
    next = op.outTrigger("next");

let cgl = op.patch.cgl;
let shader = new CGL.Shader(cgl, op.name);
shader.setSource(shader.getDefaultVertexShader(), attachments.roundcorners_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
radius.uniform = new CGL.Uniform(shader, "f", "radius", radius);
r.uniform = new CGL.Uniform(shader, "f", "r", r);
g.uniform = new CGL.Uniform(shader, "f", "g", g);
b.uniform = new CGL.Uniform(shader, "f", "b", b);
a.uniform = new CGL.Uniform(shader, "f", "a", a);
r.setUiAttribs({ "colorPick": true });

let uniWidth = new CGL.Uniform(shader, "f", "width", 512);
let uniHeight = new CGL.Uniform(shader, "f", "height", 512);
let uniAspect = new CGL.Uniform(shader, "f", "aspect", 1);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    uniWidth.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniHeight.setValue(cgl.currentTextureEffect.getCurrentSourceTexture().height);

    let texture = cgl.currentTextureEffect.getCurrentSourceTexture();

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, texture.tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    next.trigger();
};


};

Ops.Gl.TextureEffects.RoundCorners.prototype = new CABLES.Op();
CABLES.OPS["f7e5d8c3-6f49-4769-a863-fbff2c466ce8"]={f:Ops.Gl.TextureEffects.RoundCorners,objName:"Ops.Gl.TextureEffects.RoundCorners"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.SSAO_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.SSAO_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"ssao_frag":"/*\nSSAO GLSL shader v1.2\nassembled by Martins Upitis (martinsh) (devlog-martinsh.blogspot.com)\noriginal technique is made by Arkano22 (www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n\nchangelog:\n1.2 - added fog calculation to mask AO. Minor fixes.\n1.1 - added spiral sampling method from here:\n(http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere)\n\n*/\n\n{{CGL.BLENDMODES}}\n\nIN vec2 texCoord;\n\nUNI float amount;\n\nUNI sampler2D texDepth;\nUNI sampler2D tex;\n// const float bgl_RenderedTextureWidth=800.0;\n// const float bgl_RenderedTextureHeight=600.0;\n\n#define PI    3.14159265\n\nUNI float width;\nUNI float height;\n// float width = 800.0; //texture width\n// float height = 600.0; //texture height\n\n// vec2 texCoord = texCoord.st;\n\n//------------------------------------------\n//general stuff\n\n//make sure that these two values are the same for your camera, otherwise distances will be wrong.\n\n// const float znear = 0.01; //Z-near\n// const float zfar = 20.0; //Z-far\nUNI float znear;\nUNI float zfar;\n\n//user variables\n// const int SAMPLES = 16; //ao sample count\n// UNI int SAMPLES;\n\n// const float radius = 3.0; //ao radius\n// const float aoclamp = 0.25; //depth clamp - reduces haloing at screen edges\n\nUNI float radius;\nUNI float aoclamp;\nUNI bool noise ; //use noise instead of pattern for sample dithering//*****\nUNI float noiseamount; //dithering amount//********\n\nconst float diffarea = 0.4; //self-shadowing reduction\nconst float gdisplace = 0.4; //gauss bell center\n\n// const bool mist = false; //use mist?\n// const float miststart = 0.0; //mist start\n// const float mistend = 16.0; //mist end\n\n// const bool onlyAO = false; //use only ambient occlusion pass?\n// const float lumInfluence = 0.7; //how much luminance affects occlusion\nUNI float lumInfluence;\n\n\n\n\n//--------------------------------------------------------\n\nvec2 rand(vec2 coord) //generating noise/pattern texture for dithering\n{\n\n    #ifndef NOISE\n    \treturn vec2(0.0,0.0);\n\t#endif\n\n    #ifdef NOISE\n\t\tfloat noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n\t\tfloat noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n    \treturn vec2(noiseX,noiseY)*noiseamount/100.0;\n    #endif\n}\n\n// float doMist()\n// {\n// \tfloat zdepth = texture(texDepth,texCoord.xy).x;\n// \tfloat depth = -zfar * znear / (zdepth * (zfar - znear) - zfar);\n// \treturn clamp((depth-miststart)/mistend,0.0,1.0);\n// }\n\nfloat readDepth(in vec2 coord)\n{\n\tif (texCoord.x<0.0||texCoord.y<0.0) return 1.0;\n\treturn (2.0 * znear) / (zfar + znear - texture(texDepth, coord ).x * (zfar-znear));\n}\n\nfloat compareDepths(in float depth1, in float depth2,inout int far)\n{\n\tfloat garea = 2.0; //gauss bell width\n\tfloat diff = (depth1 - depth2)*100.0; //depth difference (0-100)\n\t//reduce left bell width to avoid self-shadowing\n\tif (diff<gdisplace)\n\t{\n\tgarea = diffarea;\n\t}else{\n\tfar = 1;\n\t}\n\n\tfloat gauss = pow(2.7182,-2.0*(diff-gdisplace)*(diff-gdisplace)/(garea*garea));\n\treturn gauss;\n}\n\nfloat calAO(float depth,float dw, float dh)\n{\n\tfloat dd = (1.0-depth)*radius;\n\n\tfloat temp = 0.0;\n\tfloat temp2 = 0.0;\n\tfloat coordw = texCoord.x + dw*dd;\n\tfloat coordh = texCoord.y + dh*dd;\n\tfloat coordw2 = texCoord.x - dw*dd;\n\tfloat coordh2 = texCoord.y - dh*dd;\n\n\tvec2 coord = vec2(coordw , coordh);\n\tvec2 coord2 = vec2(coordw2, coordh2);\n\n\tint far = 0;\n\ttemp = compareDepths(depth, readDepth(coord),far);\n\t//DEPTH EXTRAPOLATION:\n\tif (far > 0)\n\t{\n\t\ttemp2 = compareDepths(readDepth(coord2),depth,far);\n\t\ttemp += (1.0-temp)*temp2;\n\t}\n\n\treturn temp;\n}\n\nvoid main(void)\n{\n\tvec2 noise = rand(texCoord);\n\tfloat depth = readDepth(texCoord);\n\n\tfloat w = (1.0 / width)/clamp(depth,aoclamp,1.0)+(noise.x*(1.0-noise.x));\n\tfloat h = (1.0 / height)/clamp(depth,aoclamp,1.0)+(noise.y*(1.0-noise.y));\n\n\tfloat pw;\n\tfloat ph;\n\n\tfloat ao;\n\n\tfloat dl = PI*(3.0-sqrt(5.0));\n\tfloat dz = 1.0/float(SAMPLES);\n\tfloat l = 0.0;\n\tfloat z = 1.0 - dz/2.0;\n\n\tfor (int i = 0; i <= SAMPLES; i ++)\n\t{\n\t\tfloat r = sqrt(1.0-z);\n\n\t\tpw = cos(l)*r;\n\t\tph = sin(l)*r;\n\t\tao += calAO(depth,pw*w,ph*h);\n\t\tz = z - dz;\n\t\tl = l + dl;\n\t}\n\n\tao /= float(SAMPLES);\n\tao = 1.0-ao;\n\tvec4 color = texture(tex,texCoord);\n\n\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\n\tfloat lum = dot(color.rgb, lumcoeff);\n\tvec3 luminance = vec3(lum, lum, lum);\n\tvec3 final = vec3(mix( clamp(vec3(ao),0.0,1.0),vec3(1.0),luminance*(1.0-amount)));//mix(color*ao, white, luminance)\n\n    vec4 col=vec4( _blend(color.rgb,final) ,1.0);\n\n    outColor=vec4( mix( col.rgb, color.rgb ,1.0-color.a*amount),1.0);\n}",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),

    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "multiply"),
    amount = op.inValueSlider("Amount", 1),

    depth = op.inTexture("depth texture"),
    zNear = op.inValue("Frustum Near", 0.1),
    zFar = op.inValue("Frustum Far", 20),
    samples = op.inValueInt("Samples", 4),
    aoRadius = op.inValue("Ao Radius", 3),
    aoClamp = op.inValueSlider("Ao Clamp", 0.25),
    lumInfluence = op.inValueSlider("Luminance Influence", 0.7),
    noise = op.inValueBool("Enable noise", false),
    noiseamount = op.inValueFloat("Noise amount", 0.0008);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

op.toWorkPortsNeedToBeLinked(depth, render);
op.setPortGroup("Noise", [noise, noiseamount]);

shader.setSource(shader.getDefaultVertexShader(), attachments.ssao_frag);
let textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
let textureAlpha = new CGL.Uniform(shader, "t", "texDepth", 1);
aoRadius.uniform = new CGL.Uniform(shader, "f", "radius", aoRadius);
aoClamp.uniform = new CGL.Uniform(shader, "f", "aoclamp", aoClamp);
lumInfluence.uniform = new CGL.Uniform(shader, "f", "lumInfluence", lumInfluence);
zNear.uniform = new CGL.Uniform(shader, "f", "znear", zNear);
zFar.uniform = new CGL.Uniform(shader, "f", "zfar", zFar);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
noiseamount.uniform = new CGL.Uniform(shader, "f", "noiseamount", noiseamount);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

noise.onChange = function ()
{
    shader.toggleDefine("NOISE", noise.get());
};

samples.onChange = function ()
{
    shader.define("SAMPLES", samples.get());
};

let uniWidth = new CGL.Uniform(shader, "f", "width", 1024),
    uniHeight = new CGL.Uniform(shader, "f", "height", 512);

shader.define("SAMPLES", samples.get());
aoClamp.uniform = new CGL.Uniform(shader, "f", "aoclamp", aoClamp);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;
    if (!depth.get()) return;

    uniWidth.setValue(depth.get().width);
    uniHeight.setValue(depth.get().height);

    cgl.pushShader(shader);

    cgl.currentTextureEffect.bind();
    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (depth.get() && depth.get().tex)
    {
        cgl.setTexture(1, depth.get().tex);
        // cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, depth.get().tex );
    }

    cgl.currentTextureEffect.finish();

    cgl.popShader();
    trigger.trigger();
};


};

Ops.Gl.TextureEffects.SSAO_v2.prototype = new CABLES.Op();
CABLES.OPS["049ad504-09a2-4bc0-bbf1-dad67608a3d2"]={f:Ops.Gl.TextureEffects.SSAO_v2,objName:"Ops.Gl.TextureEffects.SSAO_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ScaleTexture_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.ScaleTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"scale_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D multiplierTex;\nUNI float amount;\nUNI float uScaleX,uScaleY;\nUNI float offsetX,offsetY;\nUNI float centerX,centerY;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    float multiplier = 1.0;\n    vec2 uv = texCoord;\n\n    #ifdef MASK_SCALE\n        multiplier = dot(vec3(0.2126,0.7152,0.0722), texture(multiplierTex,texCoord).rgb);\n    #endif\n\n    uv.x = (uv.x - centerX) / (uScaleX * multiplier)  + centerX+offsetX ;\n    uv.y = (uv.y - centerY) / (uScaleY * multiplier)  + centerY+offsetY ;\n\n    vec4 col = texture(tex,uv);\n    vec4 base = texture(tex,texCoord);\n    float a=amount;\n\n    #ifdef CLEAR\n        base=vec4(0.0,0.0,0.0,0.0);\n    #endif\n\n    outColor=cgl_blendPixel(base,col,a);\n\n    if(uv.x>1.0||uv.y>1.0||uv.x<0.0||uv.y<0.0)\n        outColor.a=0.0;\n\n}\n",};
const
    render = op.inTrigger("render"),
    multiplierTex = op.inTexture("Multiplier"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    scaleX = op.inValue("Scale X", 1.5),
    scaleY = op.inValue("Scale Y", 1.5),
    offsetX = op.inFloat("offset X", 0),
    offsetY = op.inFloat("offset Y", 0),
    centerX = op.inFloat("center X", 0.5),
    centerY = op.inFloat("center Y", 0.5),
    inClear = op.inBool("Clear", true),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.scale_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureMultiplierUniform = new CGL.Uniform(shader, "t", "multiplierTex", 1),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    scaleXUniform = new CGL.Uniform(shader, "f", "uScaleX", scaleX),
    scaleYUniform = new CGL.Uniform(shader, "f", "uScaleY", scaleY),
    centerXUniform = new CGL.Uniform(shader, "f", "centerX", centerX),
    centerYUniform = new CGL.Uniform(shader, "f", "centerY", centerY),
    offsetXUniform = new CGL.Uniform(shader, "f", "offsetX", offsetX),
    offsetYUniform = new CGL.Uniform(shader, "f", "offsetY", offsetY);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

inClear.onChange =
multiplierTex.onChange = function ()
{
    shader.toggleDefine("MASK_SCALE", multiplierTex.isLinked());
    shader.toggleDefine("CLEAR", inClear.get());
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    if (multiplierTex.get()) cgl.setTexture(1, multiplierTex.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.ScaleTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["942ef040-9be9-4848-9122-61cb28cb7789"]={f:Ops.Gl.TextureEffects.ScaleTexture_v2,objName:"Ops.Gl.TextureEffects.ScaleTexture_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ScrollTexture
// 
// **************************************************************

Ops.Gl.TextureEffects.ScrollTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"scroll_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amountX;\nUNI float amountY;\n\n#ifdef HAS_MASK\n    UNI sampler2D texMask;\n#endif\n\nvoid main()\n{\n    float amX=amountX;\n    float amY=amountY;\n\n    #ifdef HAS_MASK\n        vec4 m=texture(texMask,texCoord);\n\n\n        amX*=(m.r-0.5)*2.0;\n        amY*=(m.g-0.5)*2.0;\n    #endif\n\n    vec4 col=vec4(0.0,0.0,0.0,1.0);\n    float x=mod(texCoord.x+amX,1.0);\n    float y=mod(texCoord.y+amY,1.0);\n\n\n    #ifdef NO_REPEAT\n        x=texCoord.x+amX*0.1;\n        y=texCoord.y+amY*0.1;\n    #endif\n\n    col=texture(tex,vec2(x,y));\n\n    #ifdef NO_REPEAT\n        if(x>1.0 || x<0.0 || y>1.0 || y<0.0) col=vec4(0.0,0.0,0.0,0.0);\n    #endif\n    outColor= col;\n}",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    amountX = op.inValue("amountX"),
    amountY = op.inValue("amountY"),
    textureMask = op.inTexture("Mask"),
    repeat = op.inValueBool("Repeat", true);

repeat.onChange = updateRepeat;

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);
shader.setSource(shader.getDefaultVertexShader(), attachments.scroll_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountXUniform = new CGL.Uniform(shader, "f", "amountX", amountX),
    amountYUniform = new CGL.Uniform(shader, "f", "amountY", amountY),
    unitexMask = new CGL.Uniform(shader, "t", "texMask", 1);

updateRepeat();

textureMask.onChange = function ()
{
    if (textureMask.get())shader.define("MASK");
    else shader.removeDefine("MASK");
};

function updateRepeat()
{
    if (!repeat.get())shader.define("NO_REPEAT");
    else shader.removeDefine("NO_REPEAT");
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (textureMask.get()) cgl.setTexture(1, textureMask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.ScrollTexture.prototype = new CABLES.Op();
CABLES.OPS["9b151d99-7888-4948-81c7-cd23b334e8d4"]={f:Ops.Gl.TextureEffects.ScrollTexture,objName:"Ops.Gl.TextureEffects.ScrollTexture"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Shapes2d_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Shapes2d_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"shapes_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float aspect;\n\nUNI bool mirrorX;\nUNI bool mirrorY;\n\nUNI float xPos;\nUNI float yPos;\n\nUNI bool invertColor;\nUNI bool fillShape;\n\nUNI float width;\nUNI float height;\nUNI float lineThickness;\n\nUNI float rotate;\n\nUNI float r;\nUNI float g;\nUNI float b;\nUNI float a;\n\n{{CGL.BLENDMODES3}}\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p , in float size )\n{\n    const float k = sqrt(3.0);\n    p/= vec2(size);\n    p.x = abs(p.x) - 1.0;\n    p.y = -p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return (-length(p)*sign(p.y))*size;\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n\n    p.y +=0.5;\n    p.x = abs(p.x);\n\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b )\n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nvoid main()\n{\n    vec2 p = texCoord-0.5;\n    p.y/=aspect;\n\n    p *= 2.0;\n\n    float d =0.0;\n\n    if(mirrorX)p.x = abs(p.x);\n    if(mirrorY)p.y = abs(p.y);\n\n    p -= vec2(xPos,yPos/aspect);\n\n    pR(p,rotate * (TAU) + PI);\n\n    #ifdef IS_CIRCLE\n\n        d = sdCircle(p,width);\n    #endif\n\n    #ifdef IS_EQUI_TRIANGLE\n        d = sdEquilateralTriangle(p,width);\n    #endif\n\n    #ifdef IS_ISO_TRIANGLE\n        d = sdTriangleIsosceles(p,vec2(width,height));\n    #endif\n\n    #ifdef IS_BOX\n        d = sdBox(p,vec2(width,height));\n    #endif\n\n    #ifdef IS_RHOMBUS\n        d = sdRhombus(p,vec2(width,height));\n    #endif\n\n    #ifdef IS_PENTAGON\n        d = sdPentagon(p,width);\n    #endif\n\n    #ifdef IS_HEXAGON\n        d = sdHexagon(p,width);\n    #endif\n\n    #ifdef IS_OCTOGON\n        d = sdOctogon(p,width);\n    #endif\n\n    #ifdef IS_HEXAGRAM\n        d = sdHexagram(p*2.0,width);\n    #endif\n\n    if (fillShape == false)\n    {\n        d = abs(d)-abs(lineThickness*0.01);\n    }\n    if(invertColor)\n    {\n        d = sign(d);\n    }\n    else\n    {\n        d = 1.0 - sign(d);\n    }\n\n    d = clamp(d,0.0,1.0);\n\n    vec4 col = vec4(vec4(r,g,b,a)) ;\n    vec4 base = texture(tex,texCoord);\n    outColor = cgl_blendPixel(base,col,d*amount);\n}\n\n\n",};
/*
Shaders are from Iq's webapge
https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
*/

const render = op.inTrigger("render");
const blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal");
const maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op);

const amount = op.inValueSlider("Amount", 1);

const shapeSelect = op.inValueSelect("Shape", ["circle", "eqi triangle", "iso triangle", "box", "rhombus", "pentagon",
    "hexagon", "octogon", "hexagram"], "circle");
const mirrorX = op.inValueBool("Mirror X", false);
const mirrorY = op.inValueBool("Mirror Y", false);

const xPos = op.inValueFloat("Offset X", 0.0);
const yPos = op.inValueFloat("Offset Y", 0.0);

const fillShape = op.inValueBool("fillShape", true);
const lineThickness = op.inValue("Line thickness", 1.0);
const invertColor = op.inValueBool("Invert color", false);

const width = op.inValue("width", 0.5);
const height = op.inValue("height", 0.5);

const inRotate = op.inValueSlider("Rotate", 0.0);

const r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    a = op.inValueSlider("a", 1.0);
r.setUiAttribs({ "colorPick": true });

const trigger = op.outTrigger("trigger");

let selectIndex = 0;

function onFilterChange()
{
    let selectedMode = shapeSelect.get();

    if ((selectedMode === "circle") || (selectedMode === "eqi triangle") || (selectedMode === "pentagon")
            || (selectedMode === "hexagon") || (selectedMode === "octogon") || (selectedMode === "hexagram"))
        selectIndex = 0;

    else if ((selectedMode === "box") || (selectedMode === "iso triangle") || (selectedMode === "rhombus"))
        selectIndex = 1;

    if (selectIndex === 0)
    {
        height.setUiAttribs({ "greyout": true });
        width.setUiAttribs({ "title": "Size" });
    }
    else if (selectIndex === 1)
    {
        height.setUiAttribs({ "greyout": false });
        width.setUiAttribs({ "title": "Width" });
    }
}

fillShape.onChange = function ()
{
    lineThickness.setUiAttribs({ "greyout": fillShape.get() });
};

op.init = shapeSelect.onChange = function ()
{
    onFilterChange();
    // choose shape
    shader.toggleDefine("IS_CIRCLE", shapeSelect.get());
    shader.toggleDefine("IS_EQUI_TRIANGLE", shapeSelect.get() === "eqi triangle");
    shader.toggleDefine("IS_ISO_TRIANGLE", shapeSelect.get() === "iso triangle");
    shader.toggleDefine("IS_BOX", shapeSelect.get() === "box");
    shader.toggleDefine("IS_RHOMBUS", shapeSelect.get() === "rhombus");
    shader.toggleDefine("IS_PENTAGON", shapeSelect.get() === "pentagon");
    shader.toggleDefine("IS_HEXAGON", shapeSelect.get() === "hexagon");
    shader.toggleDefine("IS_OCTOGON", shapeSelect.get() === "octogon");
    shader.toggleDefine("IS_HEXAGRAM", shapeSelect.get() === "hexagram");
};

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.shapes_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);
const mirrorXUniform = new CGL.Uniform(shader, "b", "mirrorX", mirrorX);
const mirrorYUniform = new CGL.Uniform(shader, "b", "mirrorY", mirrorY);

const xPosUniform = new CGL.Uniform(shader, "f", "xPos", xPos);
const yPosUniform = new CGL.Uniform(shader, "f", "yPos", yPos);
const invertColorUniform = new CGL.Uniform(shader, "b", "invertColor", invertColor);
const fillShapeUniform = new CGL.Uniform(shader, "b", "fillShape", fillShape);

const uniWidth = new CGL.Uniform(shader, "f", "width", width);
const uniHeight = new CGL.Uniform(shader, "f", "height", height);
const uniModifier = new CGL.Uniform(shader, "f", "lineThickness", lineThickness);
const rotateUniform = new CGL.Uniform(shader, "f", "rotate", inRotate);

let uniformR = new CGL.Uniform(shader, "f", "r", r);
let uniformG = new CGL.Uniform(shader, "f", "g", g);
let uniformB = new CGL.Uniform(shader, "f", "b", b);
let uniformA = new CGL.Uniform(shader, "f", "a", a);
let uniformAspect = new CGL.Uniform(shader, "f", "aspect", 1);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = update;
function update()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    fillShapeUniform.setValue(fillShape.get());
    uniformAspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
}


};

Ops.Gl.TextureEffects.Shapes2d_v2.prototype = new CABLES.Op();
CABLES.OPS["1b81100b-7c09-4171-ae82-8865b905720e"]={f:Ops.Gl.TextureEffects.Shapes2d_v2,objName:"Ops.Gl.TextureEffects.Shapes2d_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Sharpen
// 
// **************************************************************

Ops.Gl.TextureEffects.Sharpen = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"sharpen_frag":"\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\n\nUNI float pX,pY;\n\nconst vec4 lumcoeff = vec4(0.299,0.587,0.114, 0.);\n\nfloat desaturate(vec4 color)\n{\n  vec3 c= vec3(dot(vec3(0.2126,0.7152,0.0722), color.rgb));\n  return (c.r+c.g+c.b)/3.0;\n}\n\n\n\nvoid main()\n{\n    \n    vec4 col=vec4(1.0,0.0,0.0,1.0);\n    col=texture(tex,texCoord);\n    \n    \n    float colorL = desaturate(texture(tex, texCoord+vec2(-pX,0) ));\n    float colorR = desaturate(texture(tex, texCoord+vec2( pX,0) ));\n    float colorA = desaturate(texture(tex, texCoord+vec2( 0,-pY) ));\n    float colorB = desaturate(texture(tex, texCoord+vec2( 0, pY) ));\n    \n    float colorLA = desaturate(texture(tex, texCoord+vec2(-pX,pY)));\n    float colorRA = desaturate(texture(tex, texCoord+vec2( pX,pY)));\n    float colorLB = desaturate(texture(tex, texCoord+vec2(-pX,-pY)));\n    float colorRB = desaturate(texture(tex, texCoord+vec2( pX,-pY)));\n    \n    vec4 final = col + col * amount * (8.0*desaturate(col) - colorL - colorR - colorA - colorB - colorLA - colorRA - colorLB - colorRB);\n\n    outColor= final;\n\n}",};
const render = op.inTrigger("Render");
const trigger = op.outTrigger("Trigger");
const amount = op.inValueSlider("amount", 0.5);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.sharpen_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

const uniPx = new CGL.Uniform(shader, "f", "pX", 1 / 1024);
const uniPy = new CGL.Uniform(shader, "f", "pY", 1 / 1024);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    uniPx.setValue(1 / cgl.currentTextureEffect.getCurrentSourceTexture().width);
    uniPy.setValue(1 / cgl.currentTextureEffect.getCurrentSourceTexture().height);

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Sharpen.prototype = new CABLES.Op();
CABLES.OPS["55647083-131d-4c70-b667-21fecf311ea5"]={f:Ops.Gl.TextureEffects.Sharpen,objName:"Ops.Gl.TextureEffects.Sharpen"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.SkewStretchImage_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.SkewStretchImage_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"invert_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float stretchTopX;\nUNI float stretchBotX;\nUNI float stretchLeft;\nUNI float stretchRight;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 col=vec4(1.0,0.0,0.0,1.0);\n\n    vec2 tc=texCoord;\n\n    #ifdef SMOOTHSTEP\n        tc.y=smoothstep(0.,1.,tc.y);\n        tc.x=smoothstep(0.,1.,tc.x);\n    #endif\n\n    vec2 tcnorm=texCoord;\n\n    tcnorm-=0.5;\n    tcnorm*=2.0;\n\n    tcnorm.x=mix(tcnorm.x*stretchBotX,tcnorm.x,tc.y);\n    tcnorm.x=mix(tcnorm.x*stretchTopX,tcnorm.x,1.0-tc.y);\n\n    tcnorm.y=mix(tcnorm.y*stretchLeft,tcnorm.y,tc.x);\n    tcnorm.y=mix(tcnorm.y*stretchRight,tcnorm.y,1.0-tc.x);\n\n    tc=tcnorm/2.0+0.5;\n\n    col=texture(tex,tc);\n\n    #ifdef CLAMP\n        if(tc.x<0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0) col=vec4(0.0,0.0,0.0,0.0);\n    #endif\n\n    vec4 base=texture(tex,texCoord);\n    base.a=0.0;\n\n    outColor=cgl_blendPixel(base,col,amount);\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    inClamp = op.inBool("Clamp", true),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "skewstrechimage");
shader.setSource(shader.getDefaultVertexShader(), attachments.invert_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

shader.addUniformFrag("f", "stretchTopX", op.inFloat("Stretch Top", 1));
shader.addUniformFrag("f", "stretchBotX", op.inFloat("Stretch Bottom", 1));
shader.addUniformFrag("f", "stretchLeft", op.inFloat("Stretch Left", 1));
shader.addUniformFrag("f", "stretchRight", op.inFloat("Stretch Right", 1));

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

inClamp.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    shader.toggleDefine("CLAMP", inClamp.get());
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.SkewStretchImage_v2.prototype = new CABLES.Op();
CABLES.OPS["665bbc0c-2fd7-4683-a1df-e57d8f17da93"]={f:Ops.Gl.TextureEffects.SkewStretchImage_v2,objName:"Ops.Gl.TextureEffects.SkewStretchImage_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Stripes_v4
// 
// **************************************************************

Ops.Gl.TextureEffects.Stripes_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"stripes_v3_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float num;\nUNI float width;\nUNI float axis;\nUNI float offset;\nUNI float rotate;\n\nUNI float r;\nUNI float g;\nUNI float b;\n\n\n{{CGL.BLENDMODES3}}\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvoid main()\n{\n    vec2 uv = texCoord-0.5;\n    pR(uv.xy,rotate*TAU);\n    float stripe=0.0;\n\n    float v=0.0;\n    float c=1.0;\n    v=uv.y;\n    v+=offset;\n\n    float m=mod(v,1.0/num);\n\n    #ifdef CIRCULAR\n        m=mod((length(uv)+offset)*1.5,1.0/num);\n    #endif\n\n    float rm=width*2.0*1.0/num/2.0;\n\n    if(m>rm)\n       stripe=mix(stripe,1.,1.0);\n\n    #ifdef STRIPES_SMOOTHED\n       m*=2.0;\n       stripe= r * smoothstep(0.,1., abs((((m-rm) )/(rm))));\n    #endif\n\n    #ifdef INVERT\n    stripe=1.0-stripe;\n    #endif\n\n    //blend section\n    vec4 col=vec4(vec3(r,g,b),1.0);\n    vec4 base=texture(tex,texCoord);\n\n    outColor=cgl_blendPixel(base,col,amount*stripe);\n}\n",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    num = op.inValue("Num", 5),
    width = op.inValue("Width", 0.5),
    rotate = op.inValueSlider("Rotate", 0),
    offset = op.inValue("Offset", 0),
    smoothed = op.inValueBool("Gradients"),
    circular = op.inValueBool("Circular"),
    invert = op.inValueBool("Invert"),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    trigger = op.outTrigger("trigger");

r.setUiAttribs({ "colorPick": true });

smoothed.onChange =
    circular.onChange =
    invert.onChange = updateDefines;

function updateDefines()
{
    shader.toggleDefine("STRIPES_SMOOTHED", smoothed.get());
    shader.toggleDefine("CIRCULAR", circular.get());
    shader.toggleDefine("INVERT", invert.get());
}

const
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, "textureeffect stripes");

shader.setSource(shader.getDefaultVertexShader(), attachments.stripes_v3_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    rotateUniform = new CGL.Uniform(shader, "f", "rotate", rotate),
    numUniform = new CGL.Uniform(shader, "f", "num", num),
    uniWidth = new CGL.Uniform(shader, "f", "width", width),
    uniOffset = new CGL.Uniform(shader, "f", "offset", offset),
    uniformR = new CGL.Uniform(shader, "f", "r", r),
    uniformG = new CGL.Uniform(shader, "f", "g", g),
    uniformB = new CGL.Uniform(shader, "f", "b", b);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Stripes_v4.prototype = new CABLES.Op();
CABLES.OPS["a1d57718-20a0-4d18-89d3-69947b0d1acf"]={f:Ops.Gl.TextureEffects.Stripes_v4,objName:"Ops.Gl.TextureEffects.Stripes_v4"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.TexMathModulo
// 
// **************************************************************

Ops.Gl.TextureEffects.TexMathModulo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"invert_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D texMask;\nUNI float amount;\nUNI float modulo;\n\n{{CGL.BLENDMODES}}\n\nvoid main()\n{\n   vec4 col=vec4(1.0);\n   col=texture(tex,texCoord);\n\n    #ifdef USE_MASK\n        #ifdef MASK_INVERT\n            if(texture(texMask,texCoord).r>0.5)\n            {\n                outColor= col;\n                return;\n            }\n        #endif\n\n        #ifndef MASK_INVERT\n            if(texture(texMask,texCoord).r<0.5)\n            {\n                outColor= col;\n                return;\n            }\n        #endif\n    #endif\n\n   vec4 invert = vec4(mod(col.rgb,modulo),1.0);\n\n   outColor=cgl_blend(col,invert,amount);\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),

    maskInvert = op.inBool("Mask Invert", false),
    mask = op.inTexture("Mask"),

    amount = op.inValueSlider("Amount", 1),
    modulo = op.inValueSlider("modulo", 1),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "texmodulo");

shader.setSource(shader.getDefaultVertexShader(), attachments.invert_frag);
const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    moduloUniform = new CGL.Uniform(shader, "f", "modulo", modulo),
    textureMaskUniform = new CGL.Uniform(shader, "t", "texMask", 1);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

maskInvert.onChange =
mask.onChange = () =>
{
    shader.toggleDefine("USE_MASK", mask.isLinked());
    shader.toggleDefine("MASK_INVERT", maskInvert.get());
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (mask.get())cgl.setTexture(1, mask.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.TexMathModulo.prototype = new CABLES.Op();
CABLES.OPS["9105dc83-9cb9-4a5e-9ec0-db641436dbe2"]={f:Ops.Gl.TextureEffects.TexMathModulo,objName:"Ops.Gl.TextureEffects.TexMathModulo"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.TextureDifference
// 
// **************************************************************

Ops.Gl.TextureEffects.TextureDifference = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"tex_difference_frag":"\nIN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D tex1;\nUNI sampler2D tex2;\n\nvoid main()\n{\n\n   vec4 col=texture(tex,texCoord);\n   \n   vec4 col1=texture(tex1,texCoord);\n   vec4 col2=texture(tex2,texCoord);\n\n\n   outColor = col1-col2;\n   outColor.a=1.0;\n\n}\n",};
const render = op.inTrigger("render");
const texture1 = op.inTexture("Texture 1");
const texture2 = op.inTexture("Texture 2");

const trigger = op.outTrigger("Next");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.tex_difference_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const unitex1 = new CGL.Uniform(shader, "t", "tex1", 1);
const unitex2 = new CGL.Uniform(shader, "t", "tex2", 2);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    if (texture1.get() && texture2.get())
    {
        let texture = cgl.currentTextureEffect.getCurrentSourceTexture();

        cgl.pushShader(shader);
        cgl.currentTextureEffect.bind();

        cgl.setTexture(0, texture.tex);
        cgl.setTexture(1, texture1.get().tex);
        cgl.setTexture(2, texture2.get().tex);

        cgl.currentTextureEffect.finish();
        cgl.popShader();
    }

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.TextureDifference.prototype = new CABLES.Op();
CABLES.OPS["e8f01999-ad25-4a75-9cac-46468551ba67"]={f:Ops.Gl.TextureEffects.TextureDifference,objName:"Ops.Gl.TextureEffects.TextureDifference"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ToNormalMap_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.ToNormalMap_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"tonormal_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI vec2 size;\nUNI float strength;\nUNI float sizeMul;\n\nvoid main()\n{\n    float tl = abs(texture(tex, texCoord + (size*sizeMul) * vec2(-1.0, -1.0)).x);   // top left\n    float  l = abs(texture(tex, texCoord + (size*sizeMul) * vec2(-1.0,  0.0)).x);   // left\n    float bl = abs(texture(tex, texCoord + (size*sizeMul) * vec2(-1.0,  1.0)).x);   // bottom left\n    float  t = abs(texture(tex, texCoord + (size*sizeMul) * vec2( 0.0, -1.0)).x);   // top\n    float  b = abs(texture(tex, texCoord + (size*sizeMul) * vec2( 0.0,  1.0)).x);   // bottom\n    float tr = abs(texture(tex, texCoord + (size*sizeMul) * vec2( 1.0, -1.0)).x);   // top right\n    float  r = abs(texture(tex, texCoord + (size*sizeMul) * vec2( 1.0,  0.0)).x);   // right\n    float br = abs(texture(tex, texCoord + (size*sizeMul) * vec2( 1.0,  1.0)).x);   // bottom right\n\n    // Compute dx using Sobel:\n    //           -1 0 1\n    //           -2 0 2\n    //           -1 0 1\n    float dX = tr + 2.0*r + br -tl - 2.0*l - bl;\n\n    // Compute dy using Sobel:\n    //           -1 -2 -1\n    //            0  0  0\n    //            1  2  1\n    float dY = bl + 2.0*b + br -tl - 2.0*t - tr;\n\n    // Build the normalized normal\n    vec4 N = vec4(normalize(vec3(dX,dY, 1.0 / strength)), 1.0);\n    N= N * 0.5 + 0.5;\n\n    outColor= N;\n}",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    strength = op.inValue("Strength", 4),
    sizeMul = op.inValue("Step Multiplier", 1);

const
    cgl = op.patch.cgl,
    shader = new CGL.Shader(cgl, op.name);

// from: https://forum.openframeworks.cc/t/compute-normal-map-from-image/1400/11
shader.setSource(shader.getDefaultVertexShader(), attachments.tonormal_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    uniStrength = new CGL.Uniform(shader, "f", "strength", strength),
    unisizeMul = new CGL.Uniform(shader, "f", "sizeMul", sizeMul),
    uniSize = new CGL.Uniform(shader, "2f", "size", 0,0);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    const effectTex=cgl.currentTextureEffect.getCurrentSourceTexture();

    cgl.setTexture(0, effectTex.tex);

    uniSize.setValue([1/effectTex.width,1/effectTex.height]);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.ToNormalMap_v2.prototype = new CABLES.Op();
CABLES.OPS["5dfb2856-b589-4bd9-8f4e-b518da115d11"]={f:Ops.Gl.TextureEffects.ToNormalMap_v2,objName:"Ops.Gl.TextureEffects.ToNormalMap_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Twirl_v4
// 
// **************************************************************

Ops.Gl.TextureEffects.Twirl_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"twirl_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\nUNI float twistAmount;\nUNI float times;\nUNI float radius;\nUNI float centerX;\nUNI float centerY;\nUNI float aspect;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec2 center=vec2(centerX,centerY);\n    center =((center+1.0)/2.0);\n    vec2 tc = texCoord;\n    tc -= center;\n\n    float dist = length(vec2(tc.x,tc.y/aspect));\n    if (dist < radius)\n    {\n        float percent = (radius - dist) / radius;\n        float theta = percent * percent * twistAmount * 8.0;\n        float s = sin(theta);\n        float c = cos(theta);\n        tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));\n    }\n    tc += center;\n\n    vec4 col = texture(tex, tc);\n    vec4 base=texture(tex,texCoord);\n    outColor=cgl_blendPixel(base,col,amount);\n}\n",};
const render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    twistAmount = op.inValue("Twist amount", 500),
    radius = op.inValue("Radius", 0.5),
    centerX = op.inValue("Center X", 0),
    centerY = op.inValue("Center Y", 0),
    trigger = op.outTrigger("Next");

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.twirl_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniTwistAmount = new CGL.Uniform(shader, "f", "twistAmount", 1),
    uniRadius = new CGL.Uniform(shader, "f", "radius", radius),
    uniAspect = new CGL.Uniform(shader, "f", "aspect", 1),
    unicenterX = new CGL.Uniform(shader, "f", "centerX", centerX),
    unicenterY = new CGL.Uniform(shader, "f", "centerY", centerY);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    let texture = cgl.currentTextureEffect.getCurrentSourceTexture();

    uniTwistAmount.setValue(twistAmount.get() * (1 / texture.width));
    uniAspect.setValue(cgl.currentTextureEffect.aspectRatio);

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Twirl_v4.prototype = new CABLES.Op();
CABLES.OPS["6691bf7f-602d-4a24-b648-cab4b2a2c15e"]={f:Ops.Gl.TextureEffects.Twirl_v4,objName:"Ops.Gl.TextureEffects.Twirl_v4"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Vibrance
// 
// **************************************************************

Ops.Gl.TextureEffects.Vibrance = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"vibrance_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float amount;\n\nconst vec4 lumcoeff = vec4(0.299,0.587,0.114, 0.);\n\nvoid main()\n{\n   vec4 col=vec4(1.0,0.0,0.0,1.0);\n   col=texture(tex,texCoord);\n\n   float luma = dot(col, lumcoeff);\n   vec4 mask = (col - vec4(luma));\n   mask = clamp(mask, 0.0, 1.0);\n   float lumaMask = dot(lumcoeff, mask);\n   lumaMask = 1.0 - lumaMask;\n   vec4 vibrance = mix(vec4(luma), col, 1.0 + amount * lumaMask);\n   outColor= vibrance;\n}",};
const render = op.inTrigger("Render");
const trigger = op.outTrigger("Trigger");
const amount = op.inValue("amount", 2);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.vibrance_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0);
const amountUniform = new CGL.Uniform(shader, "f", "amount", amount);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Vibrance.prototype = new CABLES.Op();
CABLES.OPS["9c71c980-e439-4397-9c2b-c2ae085eaed9"]={f:Ops.Gl.TextureEffects.Vibrance,objName:"Ops.Gl.TextureEffects.Vibrance"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Vignette_v3
// 
// **************************************************************

Ops.Gl.TextureEffects.Vignette_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"vignette_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float lensRadius1;\nUNI float aspect;\nUNI float amount;\nUNI float strength;\nUNI float sharp;\n\nUNI vec3 vcol;\n\n{{CGL.BLENDMODES3}}\n\nvoid main()\n{\n    vec4 base=texture(tex,texCoord);\n    vec4 vvcol=vec4(vcol,1.0);\n    vec4 col=texture(tex,texCoord);\n    vec2 tcPos=vec2(texCoord.x,(texCoord.y-0.5)*aspect+0.5);\n    float dist = distance(tcPos, vec2(0.5,0.5));\n    float am = (1.0-smoothstep( (lensRadius1+0.5), (lensRadius1*0.99+0.5)*sharp, dist));\n\n    col=mix(col,vvcol,am*strength);\n\n    #ifndef ALPHA\n        outColor=cgl_blendPixel(base,col,amount);\n    #endif\n\n    #ifdef ALPHA\n        outColor=vec4(base.rgb,base.a*(1.0-am*strength));\n    #endif\n}\n",};
const
    render = op.inTrigger("Render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    amount = op.inValueSlider("Amount", 1),
    trigger = op.outTrigger("Trigger"),
    strength = op.inValueSlider("Strength", 1),
    lensRadius1 = op.inValueSlider("Radius", 0.3),
    sharp = op.inValueSlider("Sharp", 0.25),
    aspect = op.inValue("Aspect", 1),
    r = op.inValueSlider("r", 0),
    g = op.inValueSlider("g", 0),
    b = op.inValueSlider("b", 0),
    alpha = op.inBool("Alpha", false);

r.setUiAttribs({ "colorPick": true });

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "vignette");

shader.setSource(shader.getDefaultVertexShader(), attachments.vignette_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniLensRadius1 = new CGL.Uniform(shader, "f", "lensRadius1", lensRadius1),
    uniaspect = new CGL.Uniform(shader, "f", "aspect", aspect),
    unistrength = new CGL.Uniform(shader, "f", "strength", strength),
    unisharp = new CGL.Uniform(shader, "f", "sharp", sharp),
    unir = new CGL.Uniform(shader, "3f", "vcol", r, g, b);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

alpha.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("ALPHA", alpha.get());

    r.setUiAttribs({ "greyout": alpha.get() });
    g.setUiAttribs({ "greyout": alpha.get() });
    b.setUiAttribs({ "greyout": alpha.get() });
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Vignette_v3.prototype = new CABLES.Op();
CABLES.OPS["588302cb-f5a7-4129-90d2-ba66212d69e5"]={f:Ops.Gl.TextureEffects.Vignette_v3,objName:"Ops.Gl.TextureEffects.Vignette_v3"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.WaveformGradient_v4
// 
// **************************************************************

Ops.Gl.TextureEffects.WaveformGradient_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"waveform_v2_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI float uFreq;\nUNI float uOffset;\nUNI float uPow;\nUNI float uRotate;\nUNI float amount;\n\nUNI float r;\nUNI float g;\nUNI float b;\n\n{{CGL.BLENDMODES3}}\n\n#define PI 3.14159265359\n#define TAU (2.0 * PI)\n\nvoid pR(inout vec2 p, float a)\n{\n    float s = sin(a),c=cos(a); p *= mat2(c,s,-s,c);\n}\n\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0) * 2.0 - 1.0;\n\treturn c;\n}\n\nvoid main()\n{\n    vec2 uv = texCoord;\n    float v = 0.0;\n\n    uv -= 0.5;\n    pR(uv,TAU * uRotate);\n    uv += 0.5 + uOffset;\n\n    uv.x *= uFreq;\n\n    #ifdef MODE_SINE\n        uv.x += 0.5;\n        pModMirror1(uv.x,1.0);\n        v = pow(cos(PI * uv.x / 2.0),uPow);\n    #endif\n\n    #ifdef MODE_SAW\n        uv.x = mod(uv.x,1.0);\n        v = pow(min(cos(PI * uv.x /2.0),1.0 - abs(uv.x)),uPow);\n    #endif\n\n    #ifdef MODE_TRI\n        uv.x += 0.5;\n        pModMirror1(uv.x,1.0);\n        uv.x = -abs(uv.x);\n        uv.x = fract(uv.x);\n        v = pow(uv.x,uPow);\n    #endif\n\n    #ifdef MODE_SQR\n        pModMirror1(uv.x,1.0);\n        uv.x = -abs(uv.x);\n        uv.x = fract(uv.x);\n        v = step(uv.x,uPow);\n    #endif\n\n    vec4 col = vec4(vec3(v*r,v*g,v*b),1.0);\n    vec4 base = texture(tex,texCoord);\n\n    outColor = cgl_blendPixel(base,col,amount);\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    amount = op.inValueSlider("Amount", 1),
    mode = op.inValueSelect("Mode", ["Sine", "Sawtooth", "Triangle", "Square"], "Sine"),
    freq = op.inValue("Frequency", 4),
    pow = op.inValue("Pow factor", 6),
    offset = op.inValue("Offset", 0),
    rotate = op.inFloatSlider("Rotate", 0),
    r = op.inValueSlider("r", 1.0),
    g = op.inValueSlider("g", 1.0),
    b = op.inValueSlider("b", 1.0),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Waveform", [mode, freq, pow, offset, rotate]);
op.setPortGroup("Color", [r, g, b]);
r.setUiAttribs({ "colorPick": true });

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.waveform_v2_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    freqUniform = new CGL.Uniform(shader, "f", "uFreq", freq),
    offsetUniform = new CGL.Uniform(shader, "f", "uOffset", offset),
    powUniform = new CGL.Uniform(shader, "f", "uPow", pow),
    rotateUniform = new CGL.Uniform(shader, "f", "uRotate", rotate),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniformR = new CGL.Uniform(shader, "f", "r", r),
    uniformG = new CGL.Uniform(shader, "f", "g", g),
    uniformB = new CGL.Uniform(shader, "f", "b", b);

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount,maskAlpha);
mode.onChange = updateMode;
updateMode();


function updateMode()
{
    shader.toggleDefine("MODE_SAW",mode.get() == "Sawtooth");
    shader.toggleDefine("MODE_SINE",mode.get() == "Sine");
    shader.toggleDefine("MODE_TRI",mode.get() == "Triangle");
    shader.toggleDefine("MODE_SQR",mode.get() == "Square");
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op,3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.WaveformGradient_v4.prototype = new CABLES.Op();
CABLES.OPS["0f9561ce-ea3c-4630-9990-9dae77893517"]={f:Ops.Gl.TextureEffects.WaveformGradient_v4,objName:"Ops.Gl.TextureEffects.WaveformGradient_v4"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Waveform_v3
// 
// **************************************************************

Ops.Gl.TextureEffects.Waveform_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"wave_v2_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D tex1;\nUNI float amount;\n\nUNI float r;\nUNI float g;\nUNI float b;\n\nUNI float uAmp;\nUNI float uFreq;\nUNI float uWidth;\nUNI float uGlow;\nUNI float uWaveSelect;\nUNI bool uInvert;\nUNI bool uSolid;\n\nUNI float uOffSetX;\nUNI float uOffSetY;\nUNI float uRotate;\n\n{{CGL.BLENDMODES3}}\n\n#define PI 3.14159265359\n#define TAU (2.0*PI)\n\nfloat vmax(vec2 v)\n{\n\treturn max(v.x, v.y);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n    float s = sin(a),c=cos(a); p *= mat2(c,s,-s,c);\n}\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat pModMirror1(inout float p, float size)\n{\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0) * 2.0 - 1.0;\n\treturn c;\n}\n\nfloat fCapsule2D(vec2 p, float r, float c)\n{\n\treturn mix(abs(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat SineWave(vec2 p, float amplitude, float frequency, float line_width, float line_glow, bool solid)\n{\n    float v = sin(p.x * frequency * PI);\n    v *= amplitude;\n\n    float d = 0.0;\n\n    if (solid == false)\n    {\n        d = abs(v * amplitude - p.y * 0.5);\n        d -= line_width;\n        return smoothstep(0.0, line_glow, d);\n    }\n    else\n    {\n        d = v * amplitude - p.y * 0.5;\n        d -= -line_width;\n        return smoothstep(0.0, line_glow, -d);\n    }\n}\n\nfloat SawWave(vec2 p, float amplitude, float frequency, float line_width, float line_glow, bool solid)\n{\n    float inverse_frequency = 2.0 / frequency;\n    vec2 p1 = p;\n    pMod1(p1.x, inverse_frequency);\n\n    float d1 = fCapsule2D(p1, 0.0, amplitude);\n    p.x += inverse_frequency * 0.5;\n    pMod1(p.x, inverse_frequency);\n    pR(p, atan(inverse_frequency, amplitude * 2.0));\n\n    float d = fCapsule2D(p, 0.0, 0.5 * length(vec2(inverse_frequency, 2.0 * amplitude)));\n\td = min(d, d1);\n    d -= line_width;\n\n    if(solid == false)\n    {\n        return smoothstep(0.0, line_glow, d);\n    }\n    else\n        return smoothstep(0.0, line_glow, min(d,p.x));\n}\n\nfloat TriangleWave(vec2 p, float amplitude, float frequency, float line_width, float line_glow, bool solid)\n{\n    float inverse_frequency = 1.0 / frequency;\n    p.x -= inverse_frequency;\n    pModMirror1(p.x, inverse_frequency);\n    pR(p, atan(inverse_frequency, amplitude * 2.0));\n\n    float d = fCapsule2D(p, 0.0, 0.5 * length(vec2(inverse_frequency, 2.0 * amplitude)));\n    d -= line_width;\n\n    if (solid == false)\n    {\n        return smoothstep(0.0, line_glow, d);\n    }\n    else\n        return smoothstep(0.0, line_glow, min(d,p.x));\n}\n\nfloat SquareWave(vec2 p, float amplitude, float frequency, float line_width, float line_glow, bool solid)\n{\n    float inverse_frequency = 0.5 / frequency;\n    vec2 p1 = p;\n    pMod1(p1.x, 2.0 * inverse_frequency);\n\n    float d1 = fCapsule2D(p1, 0.0, abs(amplitude));\n    p.x -= inverse_frequency * 0.5;\n    float cell = pMod1(p.x, inverse_frequency);\n\n    if(cell < 0.0) cell = -cell + 1.0;\n    if(int(cell * 0.5) % 2 == 1) p.y -= amplitude;\n        else p.y += amplitude;\n\n    float d = fCapsule2D(p.yx, 0.0, abs(inverse_frequency));\n    d = min(d, d1);\n    d -= line_width;\n\n    if (solid == false)\n    {\n        return smoothstep(0.0, line_glow, d);\n    }\n    else\n        return smoothstep(0.0, line_glow, p.y);\n}\n\nvoid main()\n{\n    vec4 rgb = vec4(r,g,b,1.0);\n\tvec2 uv = texCoord;\n\n    uv -= 0.5;\n    pR(uv.xy,uRotate * TAU);\n    uv += 0.5;\n\n    float wave = 0.0;\n    #ifdef SINE\n        wave = 1.0 - SineWave     (uv - vec2(uOffSetX,uOffSetY), uAmp,  uFreq , uWidth, uGlow, uSolid);\n    #endif\n    #ifdef SAWTOOTH\n        wave = 1.0 - SawWave      (uv - vec2(uOffSetX,uOffSetY), uAmp,  uFreq, uWidth, uGlow, uSolid);\n    #endif\n    #ifdef TRIANGLE\n        wave = 1.0 - TriangleWave (uv - vec2(uOffSetX,uOffSetY), uAmp,  uFreq, uWidth, uGlow, uSolid);\n    #endif\n    #ifdef SQUARE\n        wave = 1.0 - SquareWave   (uv - vec2(uOffSetX,uOffSetY), uAmp,  uFreq, uWidth, uGlow, uSolid);\n    #endif\n\n    #ifdef INVERT\n        wave = 1.0-wave;\n    #endif\n\n    vec4 col = vec4(r,g,b,1.0);\n\n    vec4 base=texture(tex,texCoord);\n\n    outColor=cgl_blendPixel(base,col,wave*amount);\n}\n",};
const
    render = op.inTrigger("render"),
    blendMode = CGL.TextureEffect.AddBlendSelect(op, "Blend Mode", "normal"),
    amount = op.inValueSlider("Amount", 1),
    maskAlpha = CGL.TextureEffect.AddBlendAlphaMask(op),
    waveSelect = op.inValueSelect("Waveform", ["Sine", "Sawtooth", "Triangle", "Square"], "Sine"),
    amplitude = op.inValueSlider("Amplitude", 0.5),
    frequency = op.inFloat("Frequency", 2.0),
    lineWidth = op.inValueSlider("Line Width", 0.1),
    lineGlow = op.inValueSlider("Line Glow", 0.1),
    invertCol = op.inValueBool("invert color", false),
    solidFill = op.inValueBool("Solid fill", false),
    offsetX = op.inValueSlider("Offset X", 0.0),
    offsetY = op.inValueSlider("Offset Y", 0.5),
    rotate = op.inValueSlider("Rotate", 0.0),
    r = op.inValueSlider("r", 1.0),
    g = op.inValueSlider("g", 1.0),
    b = op.inValueSlider("b", 1.0);

const trigger = op.outTrigger("trigger");

r.setUiAttribs({ "colorPick": true });

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.wave_v2_frag);

const textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    amountUniform = new CGL.Uniform(shader, "f", "amount", amount),
    uniformR = new CGL.Uniform(shader, "f", "r", r),
    uniformG = new CGL.Uniform(shader, "f", "g", g),
    uniformB = new CGL.Uniform(shader, "f", "b", b),
    amplitudeUniform = new CGL.Uniform(shader, "f", "uAmp", amplitude),
    frequencyUniform = new CGL.Uniform(shader, "f", "uFreq", frequency),
    lineWidthUniform = new CGL.Uniform(shader, "f", "uWidth", lineWidth),
    lineGlowUniform = new CGL.Uniform(shader, "f", "uGlow", lineGlow),
    waveSelectUniform = new CGL.Uniform(shader, "f", "uWaveSelect", 1),
    invertUniform = new CGL.Uniform(shader, "b", "uInvert", invertCol),
    solidFillUniform = new CGL.Uniform(shader, "b", "uSolid", solidFill),
    offSetXUniform = new CGL.Uniform(shader, "f", "uOffSetX", offsetX),
    offSetYUniform = new CGL.Uniform(shader, "f", "uOffSetY", offsetY),
    rotateUniform = new CGL.Uniform(shader, "f", "uRotate", rotate);

waveSelect.onChange = invertCol.onChange = updateDefines;
updateDefines();

function updateDefines()
{
    shader.toggleDefine("SINE", waveSelect.get() == "Sine");
    shader.toggleDefine("SAWTOOTH", waveSelect.get() == "Sawtooth");
    shader.toggleDefine("TRIANGLE", waveSelect.get() == "Triangle");
    shader.toggleDefine("SQUARE", waveSelect.get() == "Square");
    shader.toggleDefine("INVERT", invertCol.get());
}

CGL.TextureEffect.setupBlending(op, shader, blendMode, amount, maskAlpha);

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Waveform_v3.prototype = new CABLES.Op();
CABLES.OPS["fce7d8bc-5a2e-49b8-8f55-8ab8784493d5"]={f:Ops.Gl.TextureEffects.Waveform_v3,objName:"Ops.Gl.TextureEffects.Waveform_v3"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.Wobble_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.Wobble_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"wobble_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI sampler2D texMask;\nUNI float time;\nUNI float speedX;\nUNI float speedY;\nUNI float repeatX;\nUNI float repeatY;\nUNI float mul;\n\n{{CGL.LUMINANCE}}\n\nvoid main()\n{\n    float mult=1.0;\n    #ifdef HAS_MASK\n        #ifdef MASK_SRC_R\n            mult*=texture(texMask,texCoord).r;\n        #endif\n        #ifdef MASK_SRC_G\n            mult*=texture(texMask,texCoord).g;\n        #endif\n        #ifdef MASK_SRC_B\n            mult*=texture(texMask,texCoord).b;\n        #endif\n        #ifdef MASK_SRC_A\n            mult*=texture(texMask,texCoord).a;\n        #endif\n        #ifdef MASK_SRC_LUM\n            mult*=cgl_luminance(texture(texMask,texCoord).rgb);\n        #endif\n        #ifdef MASK_INV\n            mult=1.0-mult;\n        #endif\n    #endif\n\n    mult*=mul;\n\n    vec2 tc = texCoord + cos( (time*vec2(speedX, speedY) + vec2(texCoord.s*repeatX,texCoord.t*repeatY)))*mult;\n    vec4 col=texture(tex,tc);\n\n    outColor= col;\n}",};
const
    render = op.inTrigger("Render"),
    time = op.inValue("time", 0),
    speedX = op.inValue("SpeedX", 4),
    speedY = op.inValue("SpeedY", 8),

    repeatX = op.inValue("RepeatX", 11),
    repeatY = op.inValue("RepeatY", 11),
    mul = op.inValue("Multiply", 0.01),

    inMaskTex = op.inTexture("Amount Map"),
    inMaskSource = op.inSwitch("Source Amount Map", ["R", "G", "B", "A", "Lum"], "R"),
    inMaskInv = op.inBool("Invert Amount Map", false),

    trigger = op.outTrigger("Trigger");

op.setPortGroup("Amount Map", [inMaskTex, inMaskSource, inMaskInv]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, op.name);

shader.setSource(shader.getDefaultVertexShader(), attachments.wobble_frag);
const textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    timeUniform = new CGL.Uniform(shader, "f", "time", time),
    speedXUniform = new CGL.Uniform(shader, "f", "speedX", speedX),
    speedYUniform = new CGL.Uniform(shader, "f", "speedY", speedY),
    repeatXUniform = new CGL.Uniform(shader, "f", "repeatX", repeatX),
    repeatYUniform = new CGL.Uniform(shader, "f", "repeatY", repeatY),
    mulUniform = new CGL.Uniform(shader, "f", "mul", mul),
    maskUniform = new CGL.Uniform(shader, "t", "texMask", 1);

inMaskTex.onChange =
inMaskSource.onChange =
inMaskInv.onChange = () =>
{
    shader.toggleDefine("HAS_MASK", inMaskTex.isLinked());
    shader.toggleDefine("MASK_SRC_R", inMaskSource.get() == "R");
    shader.toggleDefine("MASK_SRC_G", inMaskSource.get() == "G");
    shader.toggleDefine("MASK_SRC_B", inMaskSource.get() == "B");
    shader.toggleDefine("MASK_SRC_A", inMaskSource.get() == "A");
    shader.toggleDefine("MASK_SRC_LUM", inMaskSource.get() == "Lum");
    shader.toggleDefine("MASK_INV", inMaskInv.get());
    inMaskSource.setUiAttribs({ "greyout": !inMaskTex.isLinked() });
    inMaskInv.setUiAttribs({ "greyout": !inMaskTex.isLinked() });
};

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op)) return;

    cgl.pushShader(shader);
    cgl.currentTextureEffect.bind();

    cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);
    if (inMaskTex.get()) cgl.setTexture(1, inMaskTex.get().tex);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    trigger.trigger();
};


};

Ops.Gl.TextureEffects.Wobble_v2.prototype = new CABLES.Op();
CABLES.OPS["04a8a8bc-feb9-4791-8724-ee24bbb150db"]={f:Ops.Gl.TextureEffects.Wobble_v2,objName:"Ops.Gl.TextureEffects.Wobble_v2"};




// **************************************************************
// 
// Ops.Gl.TextureEffects.ZoomBlur_v2
// 
// **************************************************************

Ops.Gl.TextureEffects.ZoomBlur_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"zoomblur_frag":"UNI sampler2D tex;\nUNI float x;\nUNI float y;\nUNI float strength;\nIN vec2 texCoord;\n\n#ifdef HAS_MASK\n    UNI sampler2D texMask;\n#endif\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\n#ifdef MASK_SRC_LUM\n    {{CGL.LUMINANCE}}\n#endif\n\nvoid main()\n{\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n    vec2 center=vec2(x,y);\n    center=(center/2.0)+0.5;\n\n    vec2 texSize=vec2(1.0,1.0);\n    vec2 toCenter = center - texCoord * texSize;\n\n    /* randomize the lookup values to hide the fixed number of samples */\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    float am = strength;\n\n    #ifdef HAS_MASK\n\n        float mul=1.0;\n        #ifdef MASK_SRC_R\n            mul=texture(texMask,texCoord).r;\n        #endif\n        #ifdef MASK_SRC_G\n            mul=texture(texMask,texCoord).g;\n        #endif\n        #ifdef MASK_SRC_B\n            mul=texture(texMask,texCoord).b;\n        #endif\n        #ifdef MASK_SRC_A\n            mul=texture(texMask,texCoord).a;\n        #endif\n        #ifdef MASK_SRC_LUM\n            mul=cgl_luminance(texture(texMask,texCoord).rgb);\n        #endif\n\n        #ifdef MASK_INV\n            mul=1.0-mul;\n        #endif\n\n        am=am*mul;\n\n        if(am<=0.02)\n        {\n            outColor=texture(tex, texCoord);\n            return;\n        }\n    #endif\n\n    for (float t = 0.0; t <= 40.0; t++)\n    {\n        float percent = (t + offset) / 40.0;\n        float weight = 4.0 * (percent - percent * percent);\n        vec4 smpl = texture(tex, texCoord + toCenter * percent * am / texSize);\n\n        smpl.rgb *= smpl.a;\n\n        color += smpl * weight;\n        total += weight;\n    }\n\n    outColor = color / total;\n}",};
const
    render = op.inTrigger("render"),
    strength = op.inValueSlider("Strength", 0.5),
    x = op.inValue("X", 0),
    y = op.inValue("Y", 0),
    inMaskTex = op.inTexture("Strength Map"),
    inMaskSource = op.inSwitch("Source Strength Map", ["R", "G", "B", "A", "Lum"], "R"),
    inMaskInv = op.inBool("Invert Strength Map", false),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Strengh Map", [inMaskTex, inMaskSource, inMaskInv]);

const cgl = op.patch.cgl;
const shader = new CGL.Shader(cgl, "zoomblur");

shader.setSource(shader.getDefaultVertexShader(), attachments.zoomblur_frag);

const
    textureUniform = new CGL.Uniform(shader, "t", "tex", 0),
    textureMask = new CGL.Uniform(shader, "t", "texMask", 1),
    uniX = new CGL.Uniform(shader, "f", "x", x),
    uniY = new CGL.Uniform(shader, "f", "y", y),
    strengthUniform = new CGL.Uniform(shader, "f", "strength", strength);

inMaskSource.onChange =
    inMaskInv.onChange =
    inMaskTex.onChange = updateDefines;

updateDefines();

function updateDefines()
{
    shader.toggleDefine("HAS_MASK", inMaskTex.isLinked());

    shader.toggleDefine("MASK_SRC_R", inMaskSource.get() == "R");
    shader.toggleDefine("MASK_SRC_G", inMaskSource.get() == "G");
    shader.toggleDefine("MASK_SRC_B", inMaskSource.get() == "B");
    shader.toggleDefine("MASK_SRC_A", inMaskSource.get() == "A");
    shader.toggleDefine("MASK_SRC_LUM", inMaskSource.get() == "Lum");

    shader.toggleDefine("MASK_INV", inMaskInv.get());

    inMaskSource.setUiAttribs({ "greyout": !inMaskTex.isLinked() });
    inMaskInv.setUiAttribs({ "greyout": !inMaskTex.isLinked() });
}

render.onTriggered = function ()
{
    if (!CGL.TextureEffect.checkOpInEffect(op, 3)) return;

    if (strength.get() > 0)
    {
        cgl.pushShader(shader);
        cgl.currentTextureEffect.bind();

        cgl.setTexture(0, cgl.currentTextureEffect.getCurrentSourceTexture().tex);

        if (inMaskTex.get() && inMaskTex.get().tex) cgl.setTexture(1, inMaskTex.get().tex);

        cgl.currentTextureEffect.finish();
        cgl.popShader();
    }
    trigger.trigger();
};


};

Ops.Gl.TextureEffects.ZoomBlur_v2.prototype = new CABLES.Op();
CABLES.OPS["b720a2f5-5501-48ef-90de-94a280ba6fbd"]={f:Ops.Gl.TextureEffects.ZoomBlur_v2,objName:"Ops.Gl.TextureEffects.ZoomBlur_v2"};




// **************************************************************
// 
// Ops.Gl.TextureFromColorArray
// 
// **************************************************************

Ops.Gl.TextureFromColorArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExe = op.inTrigger("Update"),
    inArr = op.inArray("array"),
    inWidth = op.inValueInt("width", 32),
    inHeight = op.inValueInt("height", 32),
    tfilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"], "nearest"),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "repeat"),
    outNext = op.outTrigger("Next"),
    outTex = op.outTexture("Texture out");

inExe.onTriggered = update;

const cgl = op.patch.cgl;
let tex = new CGL.Texture(cgl);

let arrayResized = true;
let pixels = new Uint8Array(8);

let cgl_filter = CGL.Texture.FILTER_NEAREST;
let cgl_wrap = CGL.Texture.WRAP_REPEAT;

tfilter.onChange =
    wrap.onChange =
    inWidth.onChange =
    inHeight.onChange = function ()
    {
        if (tex)tex.delete();
        tex = null;
        arrayResized = true;

        if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
        else if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
        else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;
        else if (tfilter.get() == "Anisotropic") cgl_filter = CGL.Texture.FILTER_ANISOTROPIC;

        if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
        else if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
        else if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    };

const emptyTex = CGL.Texture.getEmptyTexture(cgl);

function update()
{
    let error = false;
    let w = inWidth.get();
    let h = inHeight.get();
    let data = inArr.get();

    if (w <= 0 || h <= 0 || !data) error = true;

    if (error)
    {
        outTex.set(emptyTex);
        return;
    }

    if (arrayResized)
    {
        pixels = new Uint8Array(w * h * 4);
        arrayResized = false;
    }
    let i = 0;

    for (i = 0; i < data.length; i++)
    {
        pixels[i] = data[i] * 255;
    }
    for (i = data.length; i < w * h * 4; i++)
    {
        pixels[i] = 255;
    }

    if (!tex)tex = new CGL.Texture(cgl);

    tex.initFromData(pixels, w, h, cgl_filter, cgl_wrap);

    outTex.set(tex);

    outNext.trigger();
}


};

Ops.Gl.TextureFromColorArray.prototype = new CABLES.Op();
CABLES.OPS["7984c105-5b33-471a-833c-0fb310916e30"]={f:Ops.Gl.TextureFromColorArray,objName:"Ops.Gl.TextureFromColorArray"};




// **************************************************************
// 
// Ops.Gl.TextureToPointArray3
// 
// **************************************************************

Ops.Gl.TextureToPointArray3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    cgl = op.patch.cgl,
    pUpdate = op.inTrigger("update"),
    inCenter = op.inBool("Center", true),
    inThresh = op.inFloatSlider("Threshold Remove", 0),
    inMulZ = op.inFloat("Z Multiply", 1),
    tex = op.inObject("texture"),
    inWidth = op.inFloat("Width", 2),
    inHeight = op.inFloat("Height", 2),
    outTrigger = op.outTrigger("trigger"),
    outCoords = op.outArray("Points"),
    outNum = op.outNumber("Total Points"),
    outMinZ = op.outNumber("Min Z"),
    outMaxZ = op.outNumber("Max Z");

op.setPortGroup("Size", [inWidth, inHeight]);

let
    fb = null,
    pixelData = null,
    coords = null,
    texChanged = false;
tex.onChange = function () { texChanged = true; };

op.toWorkPortsNeedToBeLinked(tex, outCoords);

let isFloatingPoint = false;
let channelType = op.patch.cgl.gl.UNSIGNED_BYTE;

pUpdate.onTriggered = function ()
{
    let realTexture = tex.get(), gl = cgl.gl;

    if (!realTexture)
    {
        outCoords.set(null);
        outMaxZ.set(0);
        outNum.set(0);
        return;
    }
    if (!fb) fb = gl.createFramebuffer();
    if (!coords)coords = [];

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

    if (texChanged)
    {
        gl.framebufferTexture2D(
            gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D, realTexture.tex, 0
        );

        channelType = gl.UNSIGNED_BYTE;

        const size = realTexture.width * realTexture.height * 4;

        pixelData = new Uint8Array(size);

        texChanged = false;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

    gl.readPixels(
        0, 0,
        realTexture.width,
        realTexture.height,
        gl.RGBA,
        channelType,
        pixelData
    );

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    coords.length = 0;

    let offX = 0;
    let offY = 0;

    let w = inWidth.get();
    let h = inHeight.get();
    const thresh = inThresh.get() * 256;
    const mulz = inMulZ.get() / 256;
    let maxZ = 0;
    let minZ = 99999999;

    if (inCenter.get())
    {
        offX = realTexture.width / 2;
        offY = realTexture.height / 2;
    }

    for (let x = 0; x < realTexture.width; x++)
    {
        for (let y = 0; y < realTexture.height; y++)
        {
            if (
                pixelData[(x + (y * realTexture.width)) * 4 + 0] >= thresh ||
                pixelData[(x + (y * realTexture.width)) * 4 + 1] >= thresh ||
                pixelData[(x + (y * realTexture.width)) * 4 + 2] >= thresh)
            {
                const zz = pixelData[(x + (y * realTexture.width)) * 4 + 0] * mulz;
                coords.push((x - offX) / realTexture.width * w, (y - offY) / realTexture.height * h,
                    zz);
                maxZ = Math.max(zz, maxZ);
                minZ = Math.min(zz, minZ);
            }
        }
    }

    outMinZ.set(minZ);
    outMaxZ.set(maxZ);
    outCoords.set(null);
    outNum.set(coords.length / 3);
    outCoords.set(coords);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    outTrigger.trigger();
};


};

Ops.Gl.TextureToPointArray3.prototype = new CABLES.Op();
CABLES.OPS["93f03721-4b1e-4dee-aef9-7ef17c9cd6c1"]={f:Ops.Gl.TextureToPointArray3,objName:"Ops.Gl.TextureToPointArray3"};




// **************************************************************
// 
// Ops.Gl.TextureToPoints
// 
// **************************************************************

Ops.Gl.TextureToPoints = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    cgl = op.patch.cgl,
    pUpdate = op.inTriggerButton("update"),
    inNum = op.inValueInt("Num Points", 2000),
    inSeed = op.inValueFloat("Seed", 1),
    zPos = op.inSwitch("Z Position", ["None", "Red", "Green", "Blue", "Alpha"], "Red"),
    zMultiply = op.inValueFloat("Z Multiply", 1.0),
    tex = op.inObject("texture"),
    outTrigger = op.outTrigger("trigger"),
    outPoints = op.outArray("Points"),
    outPointsNum = op.outValue("NumPoints");

let fb = null,
    pixelData = null,
    texChanged = false;

op.toWorkPortsNeedToBeLinked(tex, outPoints);

tex.onChange = function () { texChanged = true; };

let channelType = op.patch.cgl.gl.UNSIGNED_BYTE;
let points = [];

pUpdate.onTriggered = updatePixels;

const NUM_COL_CHANNELS = 4;

function updatePixels()
{
    let realTexture = tex.get(), gl = cgl.gl;

    if (!realTexture) return;
    if (!fb) fb = gl.createFramebuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

    if (texChanged)
    {
        gl.framebufferTexture2D(
            gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D, realTexture.tex, 0
        );

        pixelData = new Uint8Array(realTexture.width * realTexture.height * NUM_COL_CHANNELS);
        texChanged = false;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

    gl.readPixels(
        0, 0,
        realTexture.width,
        realTexture.height,
        gl.RGBA,
        channelType,
        pixelData
    );

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    let num = inNum.get();
    let numPixels = pixelData.length;

    if (num * 3 != points.length)points.length = num * 3;

    Math.randomSeed = inSeed.get();

    let pixelStepX = 1 / realTexture.width;
    let pixelStepY = 1 / realTexture.height;

    let offsetX = pixelStepX * realTexture.width / 2;
    let offsetY = pixelStepY * realTexture.height / 2;

    let ind = 0;
    let count = 0;

    let colChanOffset = 0;
    if (zPos.get() == "Green")colChanOffset = 1;
    else if (zPos.get() == "Blue")colChanOffset = 2;
    else if (zPos.get() == "Alpha")colChanOffset = 3;
    else if (zPos.get() == "None")colChanOffset = 4;

    while (ind < num * 3)
    {
        count++;
        if (count > num * 3 * 100) return;
        let x = Math.floor(Math.seededRandom() * realTexture.width);
        let y = Math.floor(Math.seededRandom() * realTexture.height);
        let intens = pixelData[(x + (y * realTexture.width)) * NUM_COL_CHANNELS + colChanOffset];

        if (intens > 10)
        {
            points[ind++] = ((x * pixelStepX) - (offsetX));
            points[ind++] = ((y * pixelStepY) - (offsetY));

            if (colChanOffset < 4) points[ind++] = (intens / 255) * zMultiply.get();
            else points[ind++] = 0;
        }
    }

    outPointsNum.set(ind / 3);
    outPoints.set(null);
    outPoints.set(points);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    outTrigger.trigger();
}


};

Ops.Gl.TextureToPoints.prototype = new CABLES.Op();
CABLES.OPS["ff757f51-fbb0-4728-b158-644094cd160e"]={f:Ops.Gl.TextureToPoints,objName:"Ops.Gl.TextureToPoints"};




// **************************************************************
// 
// Ops.Gl.Texture_v2
// 
// **************************************************************

Ops.Gl.Texture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    filename = op.inUrl("File", [".jpg", ".png", ".webp", ".jpeg", ".avif"]),
    tfilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"]),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"),
    aniso = op.inSwitch("Anisotropic", [0, 1, 2, 4, 8, 16], 0),
    flip = op.inValueBool("Flip", false),
    unpackAlpha = op.inValueBool("Pre Multiplied Alpha", false),
    active = op.inValueBool("Active", true),
    inFreeMemory = op.inBool("Save Memory", true),
    textureOut = op.outTexture("Texture"),
    width = op.outNumber("Width"),
    height = op.outNumber("Height"),
    ratio = op.outNumber("Aspect Ratio"),
    loaded = op.outNumber("Loaded", false),
    loading = op.outNumber("Loading", false);

op.setPortGroup("Size", [width, height]);

unpackAlpha.setUiAttribs({ "hidePort": true });

op.toWorkPortsNeedToBeLinked(textureOut);

const cgl = op.patch.cgl;

let loadedFilename = null;
let loadingId = null;
let tex = null;
let cgl_filter = CGL.Texture.FILTER_MIPMAP;
let cgl_wrap = CGL.Texture.WRAP_REPEAT;
let cgl_aniso = 0;
let timedLoader = 0;

filename.onChange = flip.onChange = function () { reloadSoon(); };
aniso.onChange = tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;
unpackAlpha.onChange = function () { reloadSoon(); };

tfilter.set("mipmap");
wrap.set("repeat");

textureOut.set(CGL.Texture.getEmptyTexture(cgl));

active.onChange = function ()
{
    if (active.get())
    {
        if (loadedFilename != filename.get() || !tex) reloadSoon();
        else textureOut.set(tex);
    }
    else
    {
        textureOut.set(CGL.Texture.getEmptyTexture(cgl));
        width.set(CGL.Texture.getEmptyTexture(cgl).width);
        height.set(CGL.Texture.getEmptyTexture(cgl).height);
        if (tex)tex.delete();
        tex = null;
    }
};

const setTempTexture = function ()
{
    const t = CGL.Texture.getTempTexture(cgl);
    textureOut.set(t);
};

function reloadSoon(nocache)
{
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function ()
    {
        realReload(nocache);
    }, 30);
}

function realReload(nocache)
{
    if (!active.get()) return;
    // if (filename.get() === null) return;
    if (!loadingId)loadingId = cgl.patch.loading.start("textureOp", filename.get());

    let url = op.patch.getFilePath(String(filename.get()));

    if (nocache)url += "?rnd=" + CABLES.uuid();

    if (String(filename.get()).indexOf("data:") == 0) url = filename.get();

    let needsRefresh = false;
    if (loadedFilename != filename.get()) needsRefresh = true;
    loadedFilename = filename.get();

    if ((filename.get() && filename.get().length > 1))
    {
        loaded.set(false);
        loading.set(true);

        const fileToLoad = filename.get();

        op.setUiAttrib({ "extendTitle": CABLES.basename(url) });
        if (needsRefresh) op.refreshParams();

        cgl.patch.loading.addAssetLoadingTask(() =>
        {
            op.setUiError("urlerror", null);

            CGL.Texture.load(cgl, url,
                function (err, newTex)
                {
                    if (filename.get() != fileToLoad)
                    {
                        cgl.patch.loading.finished(loadingId);
                        loadingId = null;
                        return;
                    }

                    if (err)
                    {
                        setTempTexture();
                        op.setUiError("urlerror", "could not load texture: \"" + filename.get() + "\"", 2);
                        cgl.patch.loading.finished(loadingId);
                        return;
                    }

                    textureOut.set(newTex);

                    width.set(newTex.width);
                    height.set(newTex.height);
                    ratio.set(newTex.width / newTex.height);

                    // if (!newTex.isPowerOfTwo()) op.setUiError("npot", "Texture dimensions not power of two! - Texture filtering will not work in WebGL 1.", 0);
                    // else op.setUiError("npot", null);

                    if (tex)tex.delete();
                    tex = newTex;
                    textureOut.set(null);
                    textureOut.set(tex);

                    loading.set(false);
                    loaded.set(true);

                    if (inFreeMemory.get()) tex.image = null;

                    cgl.patch.loading.finished(loadingId);
                }, {
                    "anisotropic": cgl_aniso,
                    "wrap": cgl_wrap,
                    "flip": flip.get(),
                    "unpackAlpha": unpackAlpha.get(),
                    "filter": cgl_filter
                });

            // textureOut.set(null);
            // textureOut.set(tex);
        });
    }
    else
    {
        cgl.patch.loading.finished(loadingId);
        setTempTexture();
    }
}

function onFilterChange()
{
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;
    else if (tfilter.get() == "Anisotropic") cgl_filter = CGL.Texture.FILTER_ANISOTROPIC;

    cgl_aniso = parseFloat(aniso.get());

    reloadSoon();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reloadSoon();
}

op.onFileChanged = function (fn)
{
    if (filename.get() && filename.get().indexOf(fn) > -1)
    {
        textureOut.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
        textureOut.set(CGL.Texture.getTempTexture(cgl));
        realReload(true);
    }
};


};

Ops.Gl.Texture_v2.prototype = new CABLES.Op();
CABLES.OPS["790f3702-9833-464e-8e37-6f0f813f7e16"]={f:Ops.Gl.Texture_v2,objName:"Ops.Gl.Texture_v2"};




// **************************************************************
// 
// Ops.Gl.Textures.Base64ToTexture
// 
// **************************************************************

Ops.Gl.Textures.Base64ToTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    dataIn = op.inStringEditor("Base64 / Data URI", ""),
    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    twrap = op.inValueSelect("wrap", ["clamp to edge", "repeat", "mirrored repeat"], "clamp to edge"),
    textureOut = op.outTexture("Texture"),
    loadingOut = op.outBool("Loading");

const image = new Image();

let doUpdateTex = false;
let selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;
let selectedFilter = CGL.Texture.FILTER_LINEAR;

function createTex()
{
    const tex = CGL.Texture.createFromImage(op.patch.cgl, image,
        {
            "filter": selectedFilter,
            "wrap": selectedWrap
        });
    textureOut.set(tex);
    loadingOut.set(false);
}

image.onload = function (e)
{
    op.patch.cgl.addNextFrameOnceCallback(createTex.bind(this));
};

dataIn.onChange = () =>
{
    updateTex();
};

twrap.onChange =
    tfilter.onChange = () =>
    {
        if (tfilter.get() == "nearest") selectedFilter = CGL.Texture.FILTER_NEAREST;
        else if (tfilter.get() == "linear") selectedFilter = CGL.Texture.FILTER_LINEAR;
        else if (tfilter.get() == "mipmap") selectedFilter = CGL.Texture.FILTER_MIPMAP;

        if (twrap.get() == "repeat") selectedWrap = CGL.Texture.WRAP_REPEAT;
        else if (twrap.get() == "mirrored repeat") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
        else if (twrap.get() == "clamp to edge") selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

        updateTex();
    };

function updateTex()
{
    loadingOut.set(true);
    let data = dataIn.get();
    if (data && !data.startsWith("data:"))
    {
        data = "data:;base64," + data;
    }
    image.src = data;
}


};

Ops.Gl.Textures.Base64ToTexture.prototype = new CABLES.Op();
CABLES.OPS["cd07e587-432a-4a81-a2b7-51273cf32171"]={f:Ops.Gl.Textures.Base64ToTexture,objName:"Ops.Gl.Textures.Base64ToTexture"};




// **************************************************************
// 
// Ops.Gl.Textures.ColorTexture
// 
// **************************************************************

Ops.Gl.Textures.ColorTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    a = op.inValueSlider("a", 1.0),
    texOut = op.outTexture("texture_out");

r.setUiAttribs({ "colorPick": true });
const cgl = op.patch.cgl;
let fb = null;

r.onChange =
    g.onChange =
    b.onChange =
    a.onChange = () => { cgl.addNextFrameOnceCallback(render); };

cgl.addNextFrameOnceCallback(render);

function render()
{
    if (!fb)
    {
        if (cgl.glVersion == 1) fb = new CGL.Framebuffer(cgl, 8, 8, { "name": "colorTexture" });
        else fb = new CGL.Framebuffer2(cgl, 8, 8, { "name": "colorTexture", "depth": false });
        fb.setFilter(CGL.Texture.FILTER_MIPMAP);
    }

    fb.renderStart();
    cgl.gl.clearColor(r.get(), g.get(), b.get(), a.get());
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
    fb.renderEnd();
    texOut.set(fb.getTextureColor());
}


};

Ops.Gl.Textures.ColorTexture.prototype = new CABLES.Op();
CABLES.OPS["59b94270-0364-4c0f-a9fc-ba2561696a23"]={f:Ops.Gl.Textures.ColorTexture,objName:"Ops.Gl.Textures.ColorTexture"};




// **************************************************************
// 
// Ops.Gl.Textures.CombineTextures
// 
// **************************************************************

Ops.Gl.Textures.CombineTextures = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbe2fp_frag":"UNI sampler2D texR;\nUNI sampler2D texG;\nUNI sampler2D texB;\nUNI sampler2D texA;\nIN vec2 texCoord;\n\nUNI float defaultR;\nUNI float defaultG;\nUNI float defaultB;\nUNI float defaultA;\n\nvoid main()\n{\n    float r=defaultR, g=defaultG, b=defaultB, a=defaultA;\n\n    #ifdef HAS_R\n        #ifdef R_SRC_R\n            r=texture(texR,texCoord).r;\n        #endif\n        #ifdef R_SRC_G\n            r=texture(texR,texCoord).g;\n        #endif\n        #ifdef R_SRC_B\n            r=texture(texR,texCoord).b;\n        #endif\n        #ifdef R_SRC_A\n            r=texture(texR,texCoord).a;\n        #endif\n    #endif\n\n    #ifdef HAS_G\n        #ifdef G_SRC_R\n            g=texture(texG,texCoord).r;\n        #endif\n        #ifdef G_SRC_G\n            g=texture(texG,texCoord).g;\n        #endif\n        #ifdef G_SRC_B\n            g=texture(texG,texCoord).b;\n        #endif\n        #ifdef G_SRC_A\n            g=texture(texG,texCoord).a;\n        #endif\n    #endif\n\n    #ifdef HAS_B\n        #ifdef B_SRC_R\n            b=texture(texB,texCoord).r;\n        #endif\n        #ifdef B_SRC_G\n            b=texture(texB,texCoord).g;\n        #endif\n        #ifdef B_SRC_B\n            b=texture(texB,texCoord).b;\n        #endif\n        #ifdef B_SRC_A\n            b=texture(texB,texCoord).a;\n        #endif\n    #endif\n\n    #ifdef HAS_A\n        #ifdef A_SRC_R\n            a=texture(texA,texCoord).r;\n        #endif\n        #ifdef A_SRC_G\n            a=texture(texA,texCoord).g;\n        #endif\n        #ifdef A_SRC_B\n            a=texture(texA,texCoord).b;\n        #endif\n        #ifdef A_SRC_A\n            a=texture(texA,texCoord).a;\n        #endif\n    #endif\n\n    #ifdef INV_R\n        r=1.0-r;\n    #endif\n    #ifdef INV_G\n        g=1.0-g;\n    #endif\n    #ifdef INV_B\n        b=1.0-b;\n    #endif\n    #ifdef INV_A\n        a=1.0-a;\n    #endif\n\n\n    outColor = vec4(r,g,b,a);\n}\n\n\n",};
const
    exec = op.inTrigger("Execute"),
    tfilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"], "linear"),
    twrap = op.inValueSelect("Wrap", ["clamp to edge", "repeat", "mirrored repeat"], "repeat"),
    inPixel = op.inDropDown("Pixel Format", CGL.Texture.PIXELFORMATS, CGL.Texture.PFORMATSTR_RGBA8UB),

    inTexR = op.inTexture("R"),
    inSrcR = op.inSwitch("R Source", ["R", "G", "B", "A"], "R"),
    inSrcRVal = op.inSwitch("R Value", ["Source", "Invert"], "Source"),
    inSrcRDefault = op.inFloatSlider("R Default", 1),
    inTexG = op.inTexture("G"),
    inSrcG = op.inSwitch("G Source", ["R", "G", "B", "A"], "G"),
    inSrcGVal = op.inSwitch("G Value", ["Source", "Invert"], "Source"),
    inSrcGDefault = op.inFloatSlider("G Default", 1),
    inTexB = op.inTexture("B"),
    inSrcB = op.inSwitch("B Source", ["R", "G", "B", "A"], "B"),
    inSrcBVal = op.inSwitch("B Value", ["Source", "Invert"], "Source"),
    inSrcBDefault = op.inFloatSlider("B Default", 1),
    inTexA = op.inTexture("A"),
    inSrcA = op.inSwitch("A Source", ["R", "G", "B", "A"], "R"),
    inSrcAVal = op.inSwitch("A Value", ["Source", "Invert"], "Source"),
    inSrcADefault = op.inFloatSlider("A Default", 1),

    next = op.outTrigger("Next"),
    outTex = op.outTexture("Texture");

op.setPortGroup("Red", [inSrcRDefault, inTexR, inSrcR, inSrcRVal]);
op.setPortGroup("Green", [inSrcGDefault, inTexG, inSrcG, inSrcGVal]);
op.setPortGroup("Blue", [inSrcBDefault, inTexB, inSrcB, inSrcBVal]);
op.setPortGroup("Alpha", [inSrcADefault, inTexA, inSrcA, inSrcAVal]);

const cgl = op.patch.cgl;
let needsUpdate = true;
let tc = null;
let unitexR, unitexG, unitexB, unitexA, uniFloatR, uniFloatG, uniFloatB, uniFloatA;

inSrcRDefault.onChange =
    inSrcGDefault.onChange =
    inSrcBDefault.onChange =
    inSrcADefault.onChange =
    inTexR.onChange =
    inTexG.onChange =
    inTexB.onChange =
    inPixel.onChange =
    inTexA.onChange = () =>
    {
        needsUpdate = true;
    };

inTexR.onLinkChanged =
    inTexG.onLinkChanged =
    inTexB.onLinkChanged =
    inTexA.onLinkChanged =
    inSrcR.onChange =
    inSrcG.onChange =
    inSrcB.onChange =
    inSrcA.onChange =
    inSrcRVal.onChange =
    inSrcGVal.onChange =
    inSrcBVal.onChange =
    inSrcAVal.onChange = updateDefines;

tfilter.onChange =
    twrap.onChange = initShader;

function initShader()
{
    let wrap = CGL.Texture.WRAP_REPEAT;
    if (twrap.get() == "mirrored repeat") wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (twrap.get() == "clamp to edge") wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    let filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") filter = CGL.Texture.FILTER_LINEAR;
    if (tfilter.get() == "mipmap") filter = CGL.Texture.FILTER_MIPMAP;

    if (tc)tc.dispose();
    tc = new CGL.CopyTexture(cgl, "combinetextures",
        {
            "shader": attachments.rgbe2fp_frag,
            "isFloatingPointTexture": inPixel.get() == CGL.Texture.PFORMATSTR_RGBA32F,
            "filter": filter,
            "wrap": wrap
        });

    unitexR = new CGL.Uniform(tc.bgShader, "t", "texR", 0);
    unitexG = new CGL.Uniform(tc.bgShader, "t", "texG", 1);
    unitexB = new CGL.Uniform(tc.bgShader, "t", "texB", 2);
    unitexA = new CGL.Uniform(tc.bgShader, "t", "texA", 3);

    uniFloatR = new CGL.Uniform(tc.bgShader, "f", "defaultR", inSrcRDefault);
    uniFloatG = new CGL.Uniform(tc.bgShader, "f", "defaultG", inSrcGDefault);
    uniFloatB = new CGL.Uniform(tc.bgShader, "f", "defaultB", inSrcBDefault);
    uniFloatA = new CGL.Uniform(tc.bgShader, "f", "defaultA", inSrcADefault);

    updateDefines();
    needsUpdate = true;
}

function updateDefines()
{
    if (!tc) return;

    inSrcR.setUiAttribs({ "greyout": !inTexR.isLinked() });
    inSrcG.setUiAttribs({ "greyout": !inTexG.isLinked() });
    inSrcB.setUiAttribs({ "greyout": !inTexB.isLinked() });
    inSrcA.setUiAttribs({ "greyout": !inTexA.isLinked() });

    inSrcRVal.setUiAttribs({ "greyout": !inTexR.isLinked() });
    inSrcGVal.setUiAttribs({ "greyout": !inTexG.isLinked() });
    inSrcBVal.setUiAttribs({ "greyout": !inTexB.isLinked() });
    inSrcAVal.setUiAttribs({ "greyout": !inTexA.isLinked() });

    inSrcRDefault.setUiAttribs({ "greyout": inTexR.isLinked() });
    inSrcGDefault.setUiAttribs({ "greyout": inTexG.isLinked() });
    inSrcBDefault.setUiAttribs({ "greyout": inTexB.isLinked() });
    inSrcADefault.setUiAttribs({ "greyout": inTexA.isLinked() });

    tc.bgShader.toggleDefine("R_SRC_R", inSrcR.get() == "R");
    tc.bgShader.toggleDefine("R_SRC_G", inSrcR.get() == "G");
    tc.bgShader.toggleDefine("R_SRC_B", inSrcR.get() == "B");
    tc.bgShader.toggleDefine("R_SRC_A", inSrcR.get() == "A");

    tc.bgShader.toggleDefine("G_SRC_R", inSrcG.get() == "R");
    tc.bgShader.toggleDefine("G_SRC_G", inSrcG.get() == "G");
    tc.bgShader.toggleDefine("G_SRC_B", inSrcG.get() == "B");
    tc.bgShader.toggleDefine("G_SRC_A", inSrcG.get() == "A");

    tc.bgShader.toggleDefine("B_SRC_R", inSrcB.get() == "R");
    tc.bgShader.toggleDefine("B_SRC_G", inSrcB.get() == "G");
    tc.bgShader.toggleDefine("B_SRC_B", inSrcB.get() == "B");
    tc.bgShader.toggleDefine("B_SRC_A", inSrcB.get() == "A");

    tc.bgShader.toggleDefine("A_SRC_R", inSrcA.get() == "R");
    tc.bgShader.toggleDefine("A_SRC_G", inSrcA.get() == "G");
    tc.bgShader.toggleDefine("A_SRC_B", inSrcA.get() == "B");
    tc.bgShader.toggleDefine("A_SRC_A", inSrcA.get() == "A");

    tc.bgShader.toggleDefine("INV_R", inSrcRVal.get() == "Invert");
    tc.bgShader.toggleDefine("INV_G", inSrcGVal.get() == "Invert");
    tc.bgShader.toggleDefine("INV_B", inSrcBVal.get() == "Invert");
    tc.bgShader.toggleDefine("INV_A", inSrcAVal.get() == "Invert");

    tc.bgShader.toggleDefine("HAS_R", inTexR.isLinked());
    tc.bgShader.toggleDefine("HAS_G", inTexG.isLinked());
    tc.bgShader.toggleDefine("HAS_B", inTexB.isLinked());
    tc.bgShader.toggleDefine("HAS_A", inTexA.isLinked());

    needsUpdate = true;
}

exec.onTriggered = () =>
{
    if (needsUpdate && !op.patch.cgl.frameStore.shadowPass)
    {
        if (!tc)initShader();
        tc.bgShader.popTextures();

        if (inTexR.get()) tc.bgShader.pushTexture(unitexR, inTexR.get().tex);
        else tc.bgShader.pushTexture(unitexR, CGL.Texture.getEmptyTexture(cgl).tex);
        if (inTexG.get()) tc.bgShader.pushTexture(unitexG, inTexG.get().tex);
        else tc.bgShader.pushTexture(unitexG, CGL.Texture.getEmptyTexture(cgl).tex);
        if (inTexB.get()) tc.bgShader.pushTexture(unitexB, inTexB.get().tex);
        else tc.bgShader.pushTexture(unitexB, CGL.Texture.getEmptyTexture(cgl).tex);
        if (inTexA.get()) tc.bgShader.pushTexture(unitexA, inTexA.get().tex);
        else tc.bgShader.pushTexture(unitexA, CGL.Texture.getEmptyTexture(cgl).tex);

        uniFloatR.setValue(inSrcRDefault.get());
        uniFloatG.setValue(inSrcGDefault.get());
        uniFloatB.setValue(inSrcBDefault.get());
        uniFloatA.setValue(inSrcADefault.get());

        outTex.set(CGL.Texture.getEmptyTexture(cgl));
        outTex.set(tc.copy(inTexR.get() || inTexG.get() || inTexB.get() || inTexA.get() || CGL.Texture.getEmptyTexture(cgl)));

        needsUpdate = false;
    }

    next.trigger();
};


};

Ops.Gl.Textures.CombineTextures.prototype = new CABLES.Op();
CABLES.OPS["5f33dd4a-a553-4f0f-b3b1-66a80cd240a7"]={f:Ops.Gl.Textures.CombineTextures,objName:"Ops.Gl.Textures.CombineTextures"};




// **************************************************************
// 
// Ops.Gl.Textures.CopyTexture
// 
// **************************************************************

Ops.Gl.Textures.CopyTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"copytexture_frag":"UNI float a;\nUNI sampler2D tex;\n\n#ifdef TEX_MASK\nUNI sampler2D texMask;\n#endif\n\nIN vec2 texCoord;\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n\n    #ifdef TEX_MASK\n        col.a=texture(texMask,texCoord).r;\n    #endif\n\n\n    #ifdef GREY_R\n        col.rgb=vec3(col.r);\n    #endif\n\n    #ifdef GREY_G\n        col.rgb=vec3(col.g);\n    #endif\n\n    #ifdef GREY_B\n        col.rgb=vec3(col.b);\n    #endif\n\n    #ifdef GREY_A\n        col.rgb=vec3(col.a);\n    #endif\n\n    #ifdef GREY_LUMI\n        col.rgb=vec3( dot(vec3(0.2126,0.7152,0.0722), col.rgb) );\n    #endif\n\n\n    #ifdef INVERT_A\n        col.a=1.0-col.a;\n    #endif\n\n    #ifdef INVERT_R\n        col.r=1.0-col.r;\n    #endif\n\n    #ifdef INVERT_G\n        col.g=1.0-col.g;\n    #endif\n\n    #ifdef INVERT_B\n        col.b=1.0-col.b;\n    #endif\n\n    #ifdef ALPHA_1\n        col.a=1.0;\n    #endif\n\n\n\n\n    outColor= col;\n}",};
const
    render = op.inTriggerButton("render"),
    inTexture = op.inTexture("Texture"),
    inTextureMask = op.inTexture("Alpha Mask"),
    useVPSize = op.inValueBool("use original size", true),
    width = op.inValueInt("width", 640),
    height = op.inValueInt("height", 360),
    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    twrap = op.inValueSelect("wrap", ["clamp to edge", "repeat", "mirrored repeat"], "clamp to edge"),
    fpTexture = op.inValueBool("HDR"),
    alphaMaskMethod = op.inSwitch("Alpha Mask Source", ["A", "1"], "A"),
    greyscale = op.inSwitch("Convert Greyscale", ["Off", "R", "G", "B", "A", "Luminance"], "Off"),
    invertR = op.inBool("Invert R", false),
    invertG = op.inBool("Invert G", false),
    invertB = op.inBool("Invert B", false),
    invertA = op.inBool("Invert A", false),

    trigger = op.outTrigger("trigger"),
    texOut = op.outTexture("texture_out", null),
    outRatio = op.outNumber("Aspect Ratio");

alphaMaskMethod.setUiAttribs({ "hidePort": true });
greyscale.setUiAttribs({ "hidePort": true });
invertR.setUiAttribs({ "hidePort": true });
invertG.setUiAttribs({ "hidePort": true });
invertB.setUiAttribs({ "hidePort": true });

let autoRefreshTimeout = null;
const cgl = op.patch.cgl;
let lastTex = null;
let effect = null;
let tex = null;
let needsResUpdate = true;

let w = 2, h = 2;
const prevViewPort = [0, 0, 0, 0];
let reInitEffect = true;

op.setPortGroup("Size", [useVPSize, width, height]);

const bgShader = new CGL.Shader(cgl, "copytexture");
bgShader.setSource(bgShader.getDefaultVertexShader(), attachments.copytexture_frag);
const textureUniform = new CGL.Uniform(bgShader, "t", "tex", 0);
let textureMaskUniform = new CGL.Uniform(bgShader, "t", "texMask", 1);

let selectedFilter = CGL.Texture.FILTER_LINEAR;
let selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

alphaMaskMethod.onChange =
    greyscale.onChange =
    invertR.onChange =
    invertG.onChange =
    invertB.onChange =
    twrap.onChange =
    tfilter.onChange =
    fpTexture.onChange =
    inTextureMask.onChange = updateSoon;

render.onLinkChanged =
inTexture.onLinkChanged =
inTexture.onChange = () =>
{
    // if (!inTexture.get() || inTexture.get() == CGL.Texture.getEmptyTexture(cgl)) texOut.set(CGL.Texture.getEmptyTexture(cgl));
    updateSoon();
};

render.onTriggered = doRender;
updateSizePorts();

function initEffect()
{
    if (effect)effect.delete();
    if (tex)
    {
        tex.delete();
        tex = null;
    }

    effect = new CGL.TextureEffect(cgl, { "isFloatingPointTexture": fpTexture.get(), "clear": false });

    if (!tex ||
        tex.width != Math.floor(width.get()) ||
        tex.height != Math.floor(height.get()) ||
        tex.wrap != selectedWrap ||
        tex.isFloatingPoint() != fpTexture.get()
    )
    {
        if (tex) tex.delete();
        tex = new CGL.Texture(cgl,
            {
                "name": "copytexture_" + op.id,
                "isFloatingPointTexture": fpTexture.get(),
                "filter": selectedFilter,
                "wrap": selectedWrap,
                "width": Math.floor(width.get()),
                "height": Math.floor(height.get()),
            });
    }

    effect.setSourceTexture(tex);
    texOut.set(null);
    reInitEffect = false;
}

function updateSoon()
{
    updateParams();
    if (render.links.length === 0)
    {
        reInitEffect = true;

        // clearTimeout(autoRefreshTimeout);
        // autoRefreshTimeout = setTimeout(() => { doRender(); }, 100);
        op.patch.cgl.off(autoRefreshTimeout);
        autoRefreshTimeout = op.patch.cgl.on("beginFrame", () =>
        {
            op.patch.cgl.off(autoRefreshTimeout);

            if (needsResUpdate)updateResolution();
            if (!effect)op.log("has no effect");
            if (!inTexture.get()) op.log("has no intexture");

            doRender();
        });
    }
}

function updateResolution()
{
    if (!inTexture.get() || inTexture.get() == CGL.Texture.getEmptyTexture(cgl)) return;
    if (!effect)initEffect();

    if (useVPSize.get())
    {
        w = inTexture.get().width;
        h = inTexture.get().height;
    }
    else
    {
        w = Math.floor(width.get());
        h = Math.floor(height.get());
    }

    if ((w != tex.width || h != tex.height) && (w !== 0 && h !== 0))
    {
        height.set(h);
        width.set(w);
        tex.filter = selectedFilter;
        tex.setSize(w, h);
        outRatio.set(w / h);
        effect.setSourceTexture(tex);
    }

    if (texOut.get() && selectedFilter != CGL.Texture.FILTER_NEAREST)
    {
        if (!texOut.get().isPowerOfTwo()) op.setUiError("hintnpot", "texture dimensions not power of two! - texture filtering when scaling will not work on ios devices.", 0);
        else op.setUiError("hintnpot", null, 0);
    }
    else op.setUiError("hintnpot", null, 0);

    needsResUpdate = false;
}

function updateSizePorts()
{
    width.setUiAttribs({ "greyout": useVPSize.get() });
    height.setUiAttribs({ "greyout": useVPSize.get() });
}

function updateResolutionLater()
{
    needsResUpdate = true;
    updateSoon();
}

useVPSize.onChange = function ()
{
    updateSizePorts();
    if (useVPSize.get())
    {
        width.onChange = null;
        height.onChange = null;
    }
    else
    {
        width.onChange = updateResolutionLater;
        height.onChange = updateResolutionLater;
    }
    updateResolution();
};

function doRender()
{
    // op.patch.removeOnAnimCallback(doRender);
    // if (!inTexture.get())

    if (!inTexture.get() || inTexture.get() == CGL.Texture.getEmptyTexture(cgl)) texOut.set(CGL.Texture.getEmptyTexture(cgl));

    if (!inTexture.get() || inTexture.get() == CGL.Texture.getEmptyTexture(cgl))
    {
        lastTex = null;// CGL.Texture.getEmptyTexture(cgl);
        trigger.trigger();
        return;
    }
    else
    if (!effect || reInitEffect || lastTex != inTexture.get())
    {
        initEffect();
    }
    const vp = cgl.getViewPort();
    prevViewPort[0] = vp[0];
    prevViewPort[1] = vp[1];
    prevViewPort[2] = vp[2];
    prevViewPort[3] = vp[3];

    updateResolution();

    lastTex = inTexture.get();
    const oldEffect = cgl.currentTextureEffect;
    cgl.currentTextureEffect = effect;
    effect.setSourceTexture(tex);

    effect.startEffect();

    // render background color...
    cgl.pushShader(bgShader);
    cgl.currentTextureEffect.bind();
    cgl.setTexture(0, inTexture.get().tex);
    if (inTextureMask.get())cgl.setTexture(1, inTextureMask.get().tex);

    cgl.pushBlend(false);

    cgl.currentTextureEffect.finish();
    cgl.popShader();

    cgl.popBlend();

    texOut.set(effect.getCurrentSourceTexture());

    effect.endEffect();

    cgl.setViewPort(prevViewPort[0], prevViewPort[1], prevViewPort[2], prevViewPort[3]);

    cgl.currentTextureEffect = oldEffect;

    cgl.setTexture(0, CGL.Texture.getEmptyTexture(cgl).tex);

    trigger.trigger();
}

function updateParams()
{
    bgShader.toggleDefine("TEX_MASK", inTextureMask.get());

    bgShader.toggleDefine("GREY_R", greyscale.get() === "R");
    bgShader.toggleDefine("GREY_G", greyscale.get() === "G");
    bgShader.toggleDefine("GREY_B", greyscale.get() === "B");
    bgShader.toggleDefine("GREY_A", greyscale.get() === "A");
    bgShader.toggleDefine("GREY_LUMI", greyscale.get() === "Luminance");

    bgShader.toggleDefine("ALPHA_1", alphaMaskMethod.get() === "1");
    bgShader.toggleDefine("ALPHA_A", alphaMaskMethod.get() === "A");

    bgShader.toggleDefine("INVERT_R", invertR.get());
    bgShader.toggleDefine("INVERT_G", invertG.get());
    bgShader.toggleDefine("INVERT_B", invertB.get());
    bgShader.toggleDefine("INVERT_A", invertA.get());

    if (twrap.get() == "repeat") selectedWrap = CGL.Texture.WRAP_REPEAT;
    else if (twrap.get() == "mirrored repeat") selectedWrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (twrap.get() == "clamp to edge") selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    if (tfilter.get() == "nearest") selectedFilter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") selectedFilter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") selectedFilter = CGL.Texture.FILTER_MIPMAP;

    if (bgShader.needsRecompile())
    {
        reInitEffect = true;
    }
    if (tex && (
        tex.width != Math.floor(width.get()) ||
        tex.height != Math.floor(height.get()) ||
        tex.wrap != selectedWrap ||
        tex.isFloatingPoint() != fpTexture.get()
    ))
    {
        reInitEffect = true;
    }
}


};

Ops.Gl.Textures.CopyTexture.prototype = new CABLES.Op();
CABLES.OPS["18a6d1f4-a7f8-4a3e-ab1d-0c2d2efe3861"]={f:Ops.Gl.Textures.CopyTexture,objName:"Ops.Gl.Textures.CopyTexture"};




// **************************************************************
// 
// Ops.Gl.Textures.EmptyTexture
// 
// **************************************************************

Ops.Gl.Textures.EmptyTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const width = op.inValue("width", 8);
const height = op.inValue("height", 8);
const textureOut = op.outTexture("texture");

const cgl = op.patch.cgl;
const tex = new CGL.Texture(cgl);

width.onChange = sizeChanged;
height.onChange = sizeChanged;

sizeChanged();

function sizeChanged()
{
    tex.setSize(width.get(), height.get());
    textureOut.set(tex);
}


};

Ops.Gl.Textures.EmptyTexture.prototype = new CABLES.Op();
CABLES.OPS["fc124913-0916-4f5c-83e0-702ddf66420c"]={f:Ops.Gl.Textures.EmptyTexture,objName:"Ops.Gl.Textures.EmptyTexture"};




// **************************************************************
// 
// Ops.Gl.Textures.ExrTexture
// 
// **************************************************************

Ops.Gl.Textures.ExrTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inFile = op.inUrl("EXR File", [".exr"]),
    inAlpha = op.inBool("Remove Alpha", false),
    inFilter = op.inSwitch("Filter", ["Nearest", "Linear"], "Nearest"),
    outTex = op.outTexture("Texture"),
    outWidth = op.outNumber("Width"),
    outHeight = op.outNumber("Height"),
    outChannels = op.outString("Channels"),
    outLoading = op.outBool("Loading");

let
    loadingId = null,
    timedLoader = null,
    finishedLoading = false;

const cgl = op.patch.cgl;

inFilter.onChange =
inAlpha.onChange =
inFile.onChange = reloadSoon;

function reloadSoon(nocache)
{
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function () { loadBin(nocache); }, 30);
}

function loadBin(addCacheBuster)
{
    // if (!inActive.get()) return;

    if (!loadingId)loadingId = op.patch.loading.start("gltf" + inFile.get(), inFile.get());

    let url = op.patch.getFilePath(String(inFile.get()));
    if (addCacheBuster)url += "?rnd=" + CABLES.generateUUID();
    finishedLoading = false;
    outLoading.set(true);
    const oReq = new XMLHttpRequest();
    oReq.open("GET", url, true);
    oReq.responseType = "arraybuffer";

    op.patch.loading.addAssetLoadingTask(() =>
    {
        oReq.onload = (oEvent) =>
        {
            const arrayBuffer = oReq.response;
            const l = new CABLES.EXRLoader();

            try
            {
                const p = l.parse(arrayBuffer);
                outTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));

                if (p)
                {
                    const arr = new Float32Array(p.data.length);
                    for (let i = 0; i < p.data.length; i++)
                        arr[i] = p.data[i];

                    if (inAlpha.get())
                        for (let i = 3; i < arr.length; i += 4)arr[i] = 1;

                    let channels = "";
                    for (let i = 0; i < p.header.channels.length; i++)
                        channels += p.header.channels[i].name;

                    outChannels.set(channels);

                    let filter = CGL.Texture.FILTER_NEAREST;
                    if (inFilter.get() === "Linear")filter = CGL.Texture.FILTER_LINEAR;
                    const tex = new CGL.Texture(cgl, {
                        "filter": filter,
                        "wrap": filter,
                        "isFloatingPointTexture": true });

                    tex.initFromData(arr, p.width, p.height, filter, filter);
                    outTex.set(tex);
                    outWidth.set(p.width);
                    outHeight.set(p.height);
                }
                else
                {
                    outWidth.set(0);
                    outHeight.set(0);
                }
            }
            catch (e)
            {
                op.logError(e);
            }

            cgl.patch.loading.finished(loadingId);
            finishedLoading = true;
            outLoading.set(false);
        };

        oReq.send(null);
    });
}

op.onFileChanged = function (fn)
{
    if (inFile.get() && inFile.get().indexOf(fn) > -1)
    {
        outTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
        reloadSoon(true);
    }
};


};

Ops.Gl.Textures.ExrTexture.prototype = new CABLES.Op();
CABLES.OPS["81a807c3-f814-4815-a43c-5914c223faf4"]={f:Ops.Gl.Textures.ExrTexture,objName:"Ops.Gl.Textures.ExrTexture"};




// **************************************************************
// 
// Ops.Gl.Textures.GraphTexture
// 
// **************************************************************

Ops.Gl.Textures.GraphTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    trigger = this.inTrigger("trigger"),
    value = this.inValueFloat("value"),
    index = this.inValueInt("index"),
    inReset = this.inTriggerButton("reset"),
    inShowMinMax = op.inValueBool("Show Min/Max"),
    inSeed = op.inValueFloat("Color Random Seed", 23),
    inWidth = op.inValueInt("Texture Width", 512),
    inHeight = op.inValueInt("Texture Height", 512),
    inLineWidth = op.inFloat("Line Width", 2),

    texOut = op.outTexture("Texture"),
    outCanvas = op.outObject("Canvas Element");

const cgl = op.patch.cgl;

let canvas = document.createElement("canvas");
canvas.id = "graph_" + Math.random();
canvas.width = 512;
canvas.height = 512;
// canvas.style.display   = "none";
// var body = document.getElementsByTagName("body")[0];
// body.appendChild(canvas);
outCanvas.set(canvas);

// let canvImage = document.getElementById(canvas.id);
let ctx = canvas.getContext("2d");

inWidth.onChange = inHeight.onChange = function ()
{
    canvas.width = inWidth.get();
    canvas.height = inHeight.get();
};

let buff = [];

let maxValue = -Number.MAX_VALUE;
let minValue = Number.MAX_VALUE;
let colors = [];
let lastTime = Date.now();

value.onLinkChanged = reset;
index.onLinkChanged = reset;
inReset.onTriggered = reset;

value.onChange = function ()
{
    addValue(value.get(), Math.round(index.get()));
};

trigger.onTriggered = function ()
{
    for (let i = 0; i < buff.length; i++)
        if (buff[i]) addValue(buff[i][buff[i].length - 1], i);

    updateGraph();
};

function reset()
{
    buff.length = 0;
    maxValue = -999999;
    minValue = 999999;
}

function addValue(val, currentIndex)
{
    maxValue = Math.max(maxValue, parseFloat(val));
    minValue = Math.min(minValue, parseFloat(val));

    if (!buff[currentIndex])
    {
        buff[currentIndex] = [];
        Math.randomSeed = inSeed.get() + currentIndex;

        colors[currentIndex] = "rgba(" + Math.round(Math.seededRandom() * 255) + "," + Math.round(Math.seededRandom() * 255) + "," + Math.round(Math.seededRandom() * 255) + ",1)";
    }

    let buf = buff[currentIndex];
    buf.push(val);

    if (!trigger.isLinked()) if (Date.now() - lastTime > 30)updateGraph();
}

function updateGraph()
{
    function getPos(v)
    {
        return canvas.height - ((v / h * canvas.height / 2 * 0.9) + canvas.height / 2);
    }

    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#444";
    ctx.fillRect(0, getPos(0), canvas.width, 1);

    for (let b = 0; b < buff.length; b++)
    {
        let buf = buff[b];
        if (!buf) continue;

        ctx.lineWidth = inLineWidth.get();

        var h = Math.max(Math.abs(maxValue), Math.abs(minValue));
        let heightmul = canvas.height / h;
        let start = Math.max(0, buf.length - canvas.width);

        ctx.beginPath();
        ctx.strokeStyle = colors[b];

        ctx.moveTo(0, getPos(buf[start]));

        for (let i = start; i < buf.length; i++)
        {
            ctx.lineTo(
                1 + i - start,
                getPos(buf[i]));
        }
        ctx.stroke();
    }

    ctx.font = "22px monospace";

    if (inShowMinMax.get())
    {
        ctx.fillStyle = "#fff";
        ctx.fillText("max:" + (Math.round(maxValue * 100) / 100), 10, canvas.height - 10);
        ctx.fillText("min:" + (Math.round(minValue * 100) / 100), 10, canvas.height - 30);
    }

    if (texOut.get()) texOut.get().initTexture(canvas);
    else texOut.set(new CGL.Texture.createFromImage(cgl, canvas,
        {
            "filter": CGL.Texture.FILTER_MIPMAP

        }));

    lastTime = Date.now();
}


};

Ops.Gl.Textures.GraphTexture.prototype = new CABLES.Op();
CABLES.OPS["98d1c79e-71ea-468b-81fc-17da2cd3da89"]={f:Ops.Gl.Textures.GraphTexture,objName:"Ops.Gl.Textures.GraphTexture"};




// **************************************************************
// 
// Ops.Gl.Textures.Histogram
// 
// **************************************************************

Ops.Gl.Textures.Histogram = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"histogram_frag":"void main()\n{\n    float p=1.0/256.0;\n    outColor = vec4(1.0,1.0,1.0,p);\n}\n","histogram_vert":"IN vec3 vPosition;\nIN vec2 attrTexCoord;\nUNI sampler2D tex;\n\nfloat lumi(vec3 color)\n{\n   return dot(vec3(0.2126,0.7152,0.0722), color);\n}\n\nvoid main()\n{\n    vec2 tc=attrTexCoord;\n\n    float strength;\n    highp float pos=0.0;\n    #ifdef HISTOGRAM_R\n        strength=texture(tex,tc).r;\n        pos=1.0;\n    #endif\n\n    #ifdef HISTOGRAM_G\n        strength=texture(tex,tc).g;\n        pos=0.75;\n    #endif\n\n    #ifdef HISTOGRAM_B\n        strength=texture(tex,tc).b;\n        pos=0.5;\n    #endif\n\n    #ifdef HISTOGRAM_LUMI\n        strength=lumi(texture(tex,tc).rgb);\n        pos=0.25;\n    #endif\n\n    vec4 model= vec4(strength*2.0-1.0, pos , 0.0,1.0);\n\n    gl_PointSize=1.0;\n    gl_Position= model;\n}\n","histogram_wave_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\n\nvoid main()\n{\n    vec4 col=vec4(0.0,0.0,0.0,1.0);\n    float strengthR=texture(tex,vec2(texCoord.x,1.0-0.0)).r;\n    float strengthG=texture(tex,vec2(texCoord.x,1.0-0.2)).r;\n    float strengthB=texture(tex,vec2(texCoord.x,1.0-0.3)).r;\n    float strengthL=texture(tex,vec2(texCoord.x,1.0-0.4)).r;\n\n    strengthR*=strengthR;\n    strengthG*=strengthG;\n    strengthB*=strengthB;\n    strengthL*=strengthL;\n\n\n\n    if(strengthR*0.5>texCoord.y) col.r=1.0;\n    if(strengthG*0.5>texCoord.y) col.g=1.0;\n    if(strengthB*0.5>texCoord.y) col.b=1.0;\n\n    if(strengthL > texCoord.y*2.0-1.0 && texCoord.y>0.5) col.rgb=vec3(1.0);\n\n    outColor= col;\n}\n",};
const
    exe = op.inTrigger("Trigger"),
    inTex = op.inTexture("Texture"),
    outTex = op.outTexture("Histogram Texture"),
    outTexData = op.outTexture("Histogram Data");

const cgl = op.patch.cgl;
let meshPoints = null;
let fb = new CGL.Framebuffer2(cgl, 256, 8, { "isFloatingPointTexture": true,
    "filter": CGL.Texture.FILTER_NEAREST,
    "wrap": CGL.Texture.WRAP_CLAMP_TO_EDGE });

// fb.setFilter(CGL.Texture.FILTER_NEAREST);
let effect = null;

function initEffect()
{
    if (effect)effect.delete();
    effect = new CGL.TextureEffect(cgl, { "isFloatingPointTexture": false });

    let tex = new CGL.Texture(cgl,
        {
            "isFloatingPointTexture": false,
            "filter": CGL.Texture.FILTER_NEAREST,
            "wrap": CGL.Texture.WRAP_CLAMP_TO_EDGE,
            "width": 256,
            "height": 256,
        });

    effect.setSourceTexture(tex);
    outTex.set(null);
}

function setUpPointVerts()
{
    const geom = new CGL.Geometry(op.name);
    let res = 256;
    let verts = [];
    let texCoords = [];
    let i = 0;
    verts.length = res * res * 3;
    texCoords.length = res * res * 2;
    for (let x = 0; x < res; x++)
    {
        for (let y = 0; y < res; y++)
        {
            i++;
            verts[i * 3 + 2] = verts[i * 3 + 1] = verts[i * 3 + 0] = 0;
            texCoords[i * 2] = x / res;
            texCoords[i * 2 + 1] = y / res;
        }
    }
    geom.setPointVertices(verts);
    geom.texCoords = texCoords;

    meshPoints = new CGL.Mesh(cgl, geom, cgl.gl.POINTS);
    meshPoints.setGeom(geom);
}

let shaderWave = new CGL.Shader(cgl, "imgcompose bg");
shaderWave.setSource(shaderWave.getDefaultVertexShader(), attachments.histogram_wave_frag);
shaderWave.textureUniform = new CGL.Uniform(shaderWave, "t", "tex", 2);

let shaderPointsR = new CGL.Shader(cgl, "histogram r");
shaderPointsR.setSource(attachments.histogram_vert, attachments.histogram_frag);
shaderPointsR.textureUniform = new CGL.Uniform(shaderPointsR, "t", "tex", 0);
shaderPointsR.define("HISTOGRAM_R");

let shaderPointsG = new CGL.Shader(cgl, "histogram g");
shaderPointsG.setSource(attachments.histogram_vert, attachments.histogram_frag);
shaderPointsG.textureUniform = new CGL.Uniform(shaderPointsG, "t", "tex", 0);
shaderPointsG.define("HISTOGRAM_G");

let shaderPointsB = new CGL.Shader(cgl, "histogram b");
shaderPointsB.setSource(attachments.histogram_vert, attachments.histogram_frag);
shaderPointsB.textureUniform = new CGL.Uniform(shaderPointsB, "t", "tex", 0);
shaderPointsB.define("HISTOGRAM_B");

let shaderPointsLumi = new CGL.Shader(cgl, "histogram lumi");
shaderPointsLumi.setSource(attachments.histogram_vert, attachments.histogram_frag);
shaderPointsLumi.textureUniform = new CGL.Uniform(shaderPointsLumi, "t", "tex", 0);
shaderPointsLumi.define("HISTOGRAM_LUMI");

setUpPointVerts();
initEffect();
let prevViewPort = [0, 0, 0, 0];

exe.onTriggered = function ()
{
    if (meshPoints && inTex.get())
    {
        cgl.pushBlendMode(CGL.BLEND_NORMAL, false);
        cgl.pushBlend(true);

        let vp = cgl.getViewPort();
        prevViewPort[0] = vp[0];
        prevViewPort[1] = vp[1];
        prevViewPort[2] = vp[2];
        prevViewPort[3] = vp[3];

        // setup data
        fb.renderStart(cgl);

        cgl.setTexture(0, inTex.get().tex);
        meshPoints.render(shaderPointsR);
        meshPoints.render(shaderPointsG);
        meshPoints.render(shaderPointsB);
        meshPoints.render(shaderPointsLumi);

        fb.renderEnd(cgl);
        outTexData.set(fb.getTextureColor());

        // render wave

        cgl.currentTextureEffect = effect;

        effect.startEffect();

        cgl.pushShader(shaderWave);
        cgl.currentTextureEffect.bind();

        cgl.setTexture(2, fb.getTextureColor().tex);
        cgl.currentTextureEffect.finish();
        cgl.popShader();

        outTex.set(effect.getCurrentSourceTexture());

        effect.endEffect();

        cgl.setViewPort(prevViewPort[0], prevViewPort[1], prevViewPort[2], prevViewPort[3]);

        cgl.popBlend();
        cgl.popBlendMode();

        cgl.currentTextureEffect = null;
    }
};


};

Ops.Gl.Textures.Histogram.prototype = new CABLES.Op();
CABLES.OPS["966cefee-8349-4ef3-b64e-69afca0395f5"]={f:Ops.Gl.Textures.Histogram,objName:"Ops.Gl.Textures.Histogram"};




// **************************************************************
// 
// Ops.Gl.Textures.NoiseTexture
// 
// **************************************************************

Ops.Gl.Textures.NoiseTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const

    inWidth = op.inValueInt("Width", 256),
    inHeight = op.inValueInt("Height", 256),
    tfilter = op.inSwitch("Filter", ["nearest", "linear"], "nearest"),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "repeat"),
    inColor = op.inValueBool("Color", false),
    inPixel = op.inDropDown("Pixel Format", CGL.Texture.PIXELFORMATS, CGL.Texture.PFORMATSTR_RGBA8UB),

    inSeed = op.inFloat("Seed", 0),
    inOutR = op.inBool("Channel R", true),
    inMinR = op.inFloat("Min R", 0),
    inMaxR = op.inFloat("Max R", 1),
    inOutG = op.inBool("Channel G", true),
    inMinG = op.inFloat("Min G", 0),
    inMaxG = op.inFloat("Max G", 1),
    inOutB = op.inBool("Channel B", true),
    inMinB = op.inFloat("Min B", 0),
    inMaxB = op.inFloat("Max B", 1),
    outTex = op.outTexture("Texture");

const cgl = op.patch.cgl;

inSeed.onChange =
    inWidth.onChange =
    inHeight.onChange =
    inPixel.onChange =
    inMinR.onChange =
    inMaxR.onChange =
    inMinG.onChange =
    inMaxG.onChange =
    inMinB.onChange =
    inMaxB.onChange =
    inOutR.onChange =
    inOutB.onChange =
    inOutG.onChange =
    tfilter.onChange =
    wrap.onChange =
    inColor.onChange = update;

update();

function update()
{
    const isFp = inPixel.get() == CGL.Texture.PFORMATSTR_RGBA32F;
    if (!isFp)
    {
        if (
            inMinR.get() < 0.0 || inMinR.get() > 1.0 ||
            inMinG.get() < 0.0 || inMinG.get() > 1.0 ||
            inMinB.get() < 0.0 || inMinB.get() > 1.0 ||
            inMaxR.get() < 0.0 || inMaxR.get() > 1.0 ||
            inMaxG.get() < 0.0 || inMaxG.get() > 1.0 ||
            inMaxB.get() < 0.0 || inMaxB.get() > 1.0) op.setUiError("nonfprange", "Non floating point textures have to be between 0 and 1");
        else op.setUiError("nonfprange", null);
    }
    else op.setUiError("nonfprange", null);

    inMinG.setUiAttribs({ "greyout": !inColor.get() });
    inMaxG.setUiAttribs({ "greyout": !inColor.get() });
    inMinB.setUiAttribs({ "greyout": !inColor.get() });
    inMaxB.setUiAttribs({ "greyout": !inColor.get() });

    let width = Math.ceil(inWidth.get());
    let height = Math.ceil(inHeight.get());

    if (width < 1)width = 1;
    if (height < 1)height = 1;

    let pixels;
    const num = width * 4 * height;

    const minR = inMinR.get();
    const diffR = inMaxR.get() - minR;

    const minG = inMinG.get();
    const diffG = inMaxG.get() - minG;

    const minB = inMinB.get();
    const diffB = inMaxB.get() - minB;

    Math.randomSeed = inSeed.get();

    if (isFp)
    {
        pixels = new Float32Array(num);

        if (inColor.get())
        {
            for (let i = 0; i < num; i += 4)
            {
                pixels[i + 0] = minR + Math.seededRandom() * diffR;
                pixels[i + 1] = minG + Math.seededRandom() * diffG;
                pixels[i + 2] = minB + Math.seededRandom() * diffB;
                pixels[i + 3] = 1;
            }
        }
        else
        {
            for (let i = 0; i < num; i += 4)
            {
                let c = minR + Math.seededRandom() * diffR;
                pixels[i + 0] = pixels[i + 1] = pixels[i + 2] = c;
                pixels[i + 3] = 1;
            }
        }
    }
    else
    {
        pixels = new Uint8Array(num);

        if (inColor.get())
        {
            for (let i = 0; i < num; i += 4)
            {
                pixels[i + 0] = (minR + Math.seededRandom() * diffR) * 255;
                pixels[i + 1] = (minG + Math.seededRandom() * diffG) * 255;
                pixels[i + 2] = (minB + Math.seededRandom() * diffB) * 255;
                pixels[i + 3] = 255;
            }
        }
        else
        {
            for (let i = 0; i < num; i += 4)
            {
                pixels[i + 0] =
                pixels[i + 1] =
                pixels[i + 2] = (minR + Math.seededRandom() * diffR) * 255;
                pixels[i + 3] = 255;
            }
        }
    }

    if (!inOutR.get()) for (let i = 0; i < num; i += 4)pixels[i + 0] = 0.0;
    if (!inOutG.get()) for (let i = 0; i < num; i += 4)pixels[i + 1] = 0.0;
    if (!inOutB.get()) for (let i = 0; i < num; i += 4)pixels[i + 2] = 0.0;

    let cgl_filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    // else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;
    // else if (tfilter.get() == "Anisotropic") cgl_filter = CGL.Texture.FILTER_ANISOTROPIC;

    let cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    let tex = new CGL.Texture(cgl, { "isFloatingPointTexture": isFp });

    tex.initFromData(pixels, width, height, cgl_filter, cgl_wrap);

    outTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl, isFp));
    outTex.set(tex);
}


};

Ops.Gl.Textures.NoiseTexture.prototype = new CABLES.Op();
CABLES.OPS["b781bc6b-b2cf-44fe-80eb-a840e430d27d"]={f:Ops.Gl.Textures.NoiseTexture,objName:"Ops.Gl.Textures.NoiseTexture"};




// **************************************************************
// 
// Ops.Gl.Textures.PaletteTexture
// 
// **************************************************************

Ops.Gl.Textures.PaletteTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    arrayInPalette = op.inArray("Palette array"),
    inLinear = op.inValueBool("Smooth"),
    arrOut = op.outArray("Color Array"),
    textureOut = op.outTexture("Texture");

const cgl = op.patch.cgl;

let canvas = document.createElement("canvas");
canvas.id = "canvas_" + CABLES.generateUUID();
canvas.width = 5;
canvas.height = 8;
canvas.style.display = "none";

let body = document.getElementsByTagName("body")[0];
body.appendChild(canvas);
let ctx = canvas.getContext("2d");

textureOut.set(CGL.Texture.getEmptyTexture(cgl));

let arr = [];
let lastFilter = null;

let r = 0;
let g = 0;
let b = 0;

inLinear.onChange = arrayInPalette.onChange = buildTexture;

function hexToR(h)
{
    return parseInt((cutHex(h)).substring(0, 2), 16);
}

function hexToG(h)
{
    return parseInt((cutHex(h)).substring(2, 4), 16);
}

function hexToB(h)
{
    return parseInt((cutHex(h)).substring(4, 6), 16);
}

function cutHex(h)
{
    return (h.charAt(0) == "#") ? h.substring(1, 7) : h;
}

function buildTexture()
{
    let colors = arrayInPalette.get();
    let isHexCode;
    if (!colors)
    {
        return;
    }

    let stringTest = colors[0];
    let paletteSize = 0;

    if (typeof stringTest === "string")
    {
        isHexCode = true;
        paletteSize = colors.length;
        canvas.width = paletteSize;
        arr.length = colors.length;
    }
    else
    {
        isHexCode = false;
        paletteSize = Math.floor(colors.length / 3);
        canvas.width = paletteSize;
        arr.length = paletteSize;
    }

    for (let i = 0; i < paletteSize; i++)
    {
        if (isHexCode)
        {
            r = hexToR(colors[i]);
            g = hexToG(colors[i]);
            b = hexToB(colors[i]);

            arr[i * 3 + 0] = r / 255;
            arr[i * 3 + 1] = g / 255;
            arr[i * 3 + 2] = b / 255;
        }
        else
        {
            r = Math.floor(colors[i * 3 + 0] * 255);
            g = Math.floor(colors[i * 3 + 1] * 255);
            b = Math.floor(colors[i * 3 + 2] * 255);

            arr[i * 3 + 0] = colors[i * 3 + 0];
            arr[i * 3 + 1] = colors[i * 3 + 1];
            arr[i * 3 + 2] = colors[i * 3 + 2];
        }

        ctx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
        ctx.fillRect(
            canvas.width / paletteSize * i,
            0,
            canvas.width / paletteSize,
            canvas.height
        );
    }

    let filter = CGL.Texture.FILTER_NEAREST;
    if (inLinear.get())filter = CGL.Texture.FILTER_LINEAR;

    if (lastFilter == filter && textureOut.get()) textureOut.get().initTexture(canvas, filter);
    else textureOut.set(new CGL.Texture.createFromImage(op.patch.cgl, canvas, { "filter": filter }));

    arrOut.set(null);
    arrOut.set(arr);
    textureOut.get().unpackAlpha = false;
    lastFilter = filter;
}

arrayInPalette.onLinkChanged = function ()
{
    if (!arrayInPalette.isLinked())
    {
        arrOut.set(null);
        textureOut.set(CGL.Texture.getEmptyTexture(cgl));
        lastFilter = null;
    }
};

op.onDelete = function ()
{
    canvas.remove();
};

buildTexture();


};

Ops.Gl.Textures.PaletteTexture.prototype = new CABLES.Op();
CABLES.OPS["8117ed3b-a264-4a46-83a4-3cdb3f743d10"]={f:Ops.Gl.Textures.PaletteTexture,objName:"Ops.Gl.Textures.PaletteTexture"};




// **************************************************************
// 
// Ops.Gl.Textures.SwitchTextures_v2
// 
// **************************************************************

Ops.Gl.Textures.SwitchTextures_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("exec"),
    num = this.inValueInt("num"),
    defaultTransparent = op.inValueBool("Default Texture Transparent", true),
    next = op.outTrigger("Next"),
    textureOut = this.outTexture("texture");

const cgl = op.patch.cgl;
const texturePorts = [];
let index = 0;
let lastIndex = -1;
let tempTexture = CGL.Texture.getEmptyTexture(cgl);

op.toWorkPortsNeedToBeLinked(exec);
exec.onTriggered = function () { updateTexture(); next.trigger(); };


defaultTransparent.onChange = function ()
{
    if (defaultTransparent.get()) tempTexture = CGL.Texture.getEmptyTexture(cgl);
    else tempTexture = CGL.Texture.getTempTexture(cgl);

    updateTexture(true);
};

for (let i = 0; i < 16; i++)
{
    const tex = op.inTexture("texture" + i);
    texturePorts.push(tex);
    tex.onChange = forceUpdateTexture;
}

function forceUpdateTexture()
{
    updateTexture(true);
}

function updateTexture(force)
{
    index = parseInt(num.get(), 10);
    if (!force)
    {
        if (index == lastIndex) return;
        if (index != index) return;
    }
    if (
	    isNaN(index) ||
	    index < 0 ||
	    index > texturePorts.length - 1
    )
        index = 0;

    if (texturePorts[index].get()) textureOut.set(texturePorts[index].get());
    else textureOut.set(tempTexture);

    lastIndex = index;
}


};

Ops.Gl.Textures.SwitchTextures_v2.prototype = new CABLES.Op();
CABLES.OPS["a82ae429-ac07-4760-882b-595a857c7ae0"]={f:Ops.Gl.Textures.SwitchTextures_v2,objName:"Ops.Gl.Textures.SwitchTextures_v2"};




// **************************************************************
// 
// Ops.Gl.Textures.TextTexture_v4
// 
// **************************************************************

Ops.Gl.Textures.TextTexture_v4 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"text_frag":"UNI sampler2D tex;\nUNI float a;\nUNI vec3 color;\nIN vec2 texCoord;\n\nvec4 myround(vec4 col)\n{\n    if(col.a>0.5)return vec4(1.0,1.0,1.0,1.0);\n    else return vec4(1.0,1.0,1.0,0.0);\n}\n\nvoid main()\n{\n    vec4 col;\n\n    #ifndef HARD_EDGE\n        // col= vec4(1.0,1.0,1.0,texture(tex,vec2(texCoord.x,(1.0-texCoord.y))).r*a);\n        col = texture(tex,vec2(texCoord.x,(1.0-texCoord.y)));\n    #endif\n    #ifdef HARD_EDGE\n\n        float step=0.7;\n        col=texture(tex,vec2(texCoord.x,1.0-texCoord.y));\n        vec4 col2=texture(tex,vec2(texCoord.x-(fwidth(texCoord.x)*step),1.0-texCoord.y-(fwidth(texCoord.y)*step)));\n        vec4 col3=texture(tex,vec2(texCoord.x+(fwidth(texCoord.x)*step),1.0-texCoord.y+(fwidth(texCoord.y)*step)));\n        vec4 col4=texture(tex,vec2(texCoord.x+(fwidth(texCoord.x)*step),1.0-texCoord.y-(fwidth(texCoord.y)*step)));\n        vec4 col5=texture(tex,vec2(texCoord.x-(fwidth(texCoord.x)*step),1.0-texCoord.y+(fwidth(texCoord.y)*step)));\n\n        float f=smoothstep(col.a,0.5,0.8);\n\n        col=myround(col);\n        col2=myround(col2);\n        col3=myround(col3);\n        col4=myround(col4);\n        col5=myround(col5);\n\n        // col.a=(col.a+col2.a+col3.a+col4.a+col5.a)/5.0*a;\n\n    #endif\n\n    col.rgb=color.rgb;\n\n    outColor=col;\n\n}\n","text_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\nUNI float aspect;\nOUT vec2 texCoord;\nIN vec2 attrTexCoord;\n\nvoid main()\n{\n   vec4 pos=vec4(vPosition,  1.0);\n\n    pos.x*=aspect;\n\n   texCoord=vec2(attrTexCoord.x,1.0-attrTexCoord.y);;\n\n   gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
function componentToHex(c)
{
    const hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b)
{
    return "#" + componentToHex(Math.floor(r * 255)) + componentToHex(Math.floor(g * 255)) + componentToHex(Math.floor(b * 255));
}

const
    render = op.inTriggerButton("Render"),
    text = op.inString("text", "cables"),
    font = op.inString("font", "Arial"),
    weight = op.inString("weight", "normal"),
    maximize = op.inValueBool("Maximize Size", true),
    inFontSize = op.inValueFloat("fontSize", 30),
    lineDistance = op.inValueFloat("Line Height", 1),
    lineOffset = op.inValueFloat("Vertical Offset", 0),
    // letterSpacing = op.inValueFloat("Spacing", 0),
    drawDebug = op.inBool("Show Debug", false),
    limitLines = op.inValueInt("Limit Lines", 0),
    texWidth = op.inValueInt("texture width", 512),
    texHeight = op.inValueInt("texture height", 128),
    tfilter = op.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"),
    aniso = op.inSwitch("Anisotropic", [0, 1, 2, 4, 8, 16], 0),
    align = op.inSwitch("align", ["left", "center", "right"], "center"),
    valign = op.inSwitch("vertical align", ["top", "center", "bottom"], "center"),
    cachetexture = op.inValueBool("Reuse Texture", true),
    drawMesh = op.inValueBool("Draw Mesh", true),
    meshScale = op.inValueFloat("Scale Mesh", 1.0),
    renderHard = op.inValueBool("Hard Edges", false),
    inOpacity = op.inFloatSlider("Opacity", 1),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),
    next = op.outTrigger("Next"),
    outRatio = op.outNumber("Ratio"),
    textureOut = op.outTexture("texture"),
    outAspect = op.outNumber("Aspect", 1),
    outLines = op.outNumber("Num Lines");

r.setUiAttribs({ "colorPick": true });

op.setPortGroup("Color", [r, g, b]);
op.setPortGroup("Size", [font, weight, maximize, inFontSize, lineDistance, lineOffset]);
op.setPortGroup("Texture", [texWidth, texHeight, tfilter, aniso]);
op.setPortGroup("Alignment", [valign, align]);
op.setPortGroup("Rendering", [drawMesh, renderHard, meshScale]);

align.onChange =
    valign.onChange =
    text.onChange =
    inFontSize.onChange =
    weight.onChange =
    aniso.onChange =
    font.onChange =
    lineOffset.onChange =
    lineDistance.onChange =
    cachetexture.onChange =
    // letterSpacing.onChange =
    limitLines.onChange =
    texWidth.onChange =
    texHeight.onChange =
    maximize.onChange = function () { needsRefresh = true; };

wrap.onChange = () =>
{
    if (tex)tex.delete();
    tex = null;
    needsRefresh = true;
};

r.onChange = g.onChange = b.onChange = inOpacity.onChange = function ()
{
    if (!drawMesh.get() || textureOut.isLinked())
        needsRefresh = true;
};
textureOut.onLinkChanged = () =>
{
    if (textureOut.isLinked()) needsRefresh = true;
};

op.patch.on("fontLoaded", (fontName) =>
{
    if (fontName == font.get())
    {
        needsRefresh = true;
    }
});

render.onTriggered = doRender;

aniso.onChange =
tfilter.onChange = () =>
{
    tex = null;
    needsRefresh = true;
};

textureOut.ignoreValueSerialize = true;

const cgl = op.patch.cgl;
const body = document.getElementsByTagName("body")[0];

let tex = new CGL.Texture(cgl);
const fontImage = document.createElement("canvas");
fontImage.id = "texturetext_" + CABLES.generateUUID();
fontImage.style.display = "none";
body.appendChild(fontImage);

const ctx = fontImage.getContext("2d");
let needsRefresh = true;
const mesh = CGL.MESHES.getSimpleRect(cgl, "texttexture rect");
const vScale = vec3.create();

const shader = new CGL.Shader(cgl, "texttexture");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.text_vert, attachments.text_frag);
const texUni = new CGL.Uniform(shader, "t", "tex");
const aspectUni = new CGL.Uniform(shader, "f", "aspect", 0);
const opacityUni = new CGL.Uniform(shader, "f", "a", inOpacity);
const uniColor = new CGL.Uniform(shader, "3f", "color", r, g, b);
// const uniformColor = new CGL.Uniform(shader, "4f", "")

if (op.patch.isEditorMode()) CABLES.UI.SIMPLEWIREFRAMERECT = CABLES.UI.SIMPLEWIREFRAMERECT || new CGL.WireframeRect(cgl);

if (cgl.glVersion < 2)
{
    cgl.gl.getExtension("OES_standard_derivatives");
    shader.enableExtension("GL_OES_standard_derivatives");
}

renderHard.onChange = function ()
{
    shader.toggleDefine("HARD_EDGE", renderHard.get());
};

function doRender()
{
    if (ctx.canvas.width != texWidth.get())needsRefresh = true;
    if (needsRefresh)
    {
        reSize();
        refresh();
    }

    if (drawMesh.get())
    {
        vScale[0] = vScale[1] = vScale[2] = meshScale.get();
        cgl.pushBlendMode(CGL.BLEND_NORMAL, false);
        cgl.pushModelMatrix();
        mat4.scale(cgl.mMatrix, cgl.mMatrix, vScale);

        shader.popTextures();
        shader.pushTexture(texUni, tex.tex);
        aspectUni.set(outAspect.get());

        if (cgl.shouldDrawHelpers(op))
            CABLES.UI.SIMPLEWIREFRAMERECT.render(outAspect.get(), 1, 1);

        cgl.pushShader(shader);
        mesh.render(shader);

        cgl.popShader();
        cgl.popBlendMode();
        cgl.popModelMatrix();
    }

    next.trigger();
}

function reSize()
{
    if (!tex) return;
    tex.setSize(texWidth.get(), texHeight.get());

    ctx.canvas.width = fontImage.width = texWidth.get();
    ctx.canvas.height = fontImage.height = texHeight.get();

    outAspect.set(fontImage.width / fontImage.height);

    needsRefresh = true;
}

maximize.onChange = function ()
{
    inFontSize.setUiAttribs({ "greyout": maximize.get() });
    needsRefresh = true;
};

function getLineHeight(fontSize)
{
    return lineDistance.get() * fontSize;
}

function removeEmptyLines(lines)
{
    if (lines[lines.length - 1] === "" || lines[lines.length - 1] === "\n")
    {
        lines.length--;
        lines = removeEmptyLines(lines);
    }
    return lines;
}

function refresh()
{
    cgl.checkFrameStarted("texttrexture refresh");

    // const num=String(parseInt(letterSpacing.get()));
    //     fontImage.style["letter-spacing"] = num+"px";
    // fontImage.style["font-kerning"]="normal";

    ctx.clearRect(0, 0, fontImage.width, fontImage.height);
    const rgbString = "rgba(" + Math.floor(r.get() * 255) + ","
        + Math.floor(g.get() * 255) + "," + Math.floor(b.get() * 255) + ","
        + inOpacity.get() + ")";
    // ctx.fillStyle = "white";
    ctx.fillStyle = rgbString;
    // op.log("rgbstring", rgbString);
    let fontSize = parseFloat(inFontSize.get());
    let fontname = font.get();
    if (fontname.indexOf(" ") > -1) fontname = "\"" + fontname + "\"";
    ctx.font = weight.get() + " " + fontSize + "px " + fontname + "";
    // ctx["font-weight"] = 300;

    ctx.textAlign = align.get();

    let txt = (text.get() + "").replace(/<br\/>/g, "\n");
    let strings = txt.split("\n");

    needsRefresh = false;

    strings = removeEmptyLines(strings);

    if (maximize.get())
    {
        fontSize = texWidth.get();
        let count = 0;
        let maxWidth = 0;
        let maxHeight = 0;

        do
        {
            count++;
            if (count > (texHeight.get() + texWidth.get()) / 2)
            {
                op.log("too many iterations - maximize size");
                break;
            }
            fontSize -= 5;
            ctx.font = weight.get() + " " + fontSize + "px \"" + font.get() + "\"";
            maxWidth = 0;

            maxHeight = (fontSize + (strings.length - 1) * getLineHeight(fontSize)) * 1.2;
            for (let i = 0; i < strings.length; i++) maxWidth = Math.max(maxWidth, ctx.measureText(strings[i]).width);
        }
        while (maxWidth > ctx.canvas.width || maxHeight > ctx.canvas.height);
    }
    else
    {
        let found = true;

        if (texWidth.get() > 128)
        {
            found = false;
            let newString = "";

            for (let i = 0; i < strings.length; i++)
            {
                if (!strings[i])
                {
                    newString += "\n";
                    continue;
                }
                let sumWidth = 0;
                const words = strings[i].split(" ");

                for (let j = 0; j < words.length; j++)
                {
                    if (!words[j]) continue;
                    sumWidth += ctx.measureText(words[j] + " ").width;

                    if (sumWidth > texWidth.get())
                    {
                        found = true;
                        newString += "\n" + words[j] + " ";
                        sumWidth = ctx.measureText(words[j] + " ").width;
                    }
                    else
                    {
                        newString += words[j] + " ";
                    }
                }
                newString += "\n";
            }
            txt = newString;
            strings = txt.split("\n");
        }
        strings = removeEmptyLines(strings);

        if (limitLines.get() > 0 && strings.length > limitLines.get())
        {
            strings.length = limitLines.get();
            strings[strings.length - 1] += "...";
        }
    }

    strings = removeEmptyLines(strings);
    const firstLineHeight = fontSize;
    const textHeight = firstLineHeight + (strings.length - 1) * getLineHeight(fontSize);

    let posy = lineOffset.get() * fontSize;

    if (valign.get() == "top") posy += firstLineHeight;
    else if (valign.get() == "center") posy += (ctx.canvas.height / 2) - (textHeight / 2) + firstLineHeight;
    else if (valign.get() == "bottom") posy += ctx.canvas.height - textHeight + firstLineHeight;

    let miny = 999999;
    let maxy = -999999;

    const dbg = drawDebug.get();

    for (let i = 0; i < strings.length; i++)
    {
        let posx = 0;
        if (align.get() == "center") posx = ctx.canvas.width / 2;
        if (align.get() == "right") posx = ctx.canvas.width;

        ctx.fillText(strings[i], posx, posy);

        miny = Math.min(miny, posy - firstLineHeight);
        maxy = Math.max(maxy, posy);

        if (dbg)
        {
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#FF0000";
            ctx.beginPath();
            ctx.moveTo(0, posy);
            ctx.lineTo(21000, posy);
            ctx.stroke();
        }

        posy += getLineHeight(fontSize);
    }

    if (dbg)
    {
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#FF0000";
        ctx.strokeRect(0, miny, ctx.canvas.width - 3, maxy - miny);
    }

    ctx.restore();

    outRatio.set(ctx.canvas.height / ctx.canvas.width);
    outLines.set(strings.length);
    textureOut.set(CGL.Texture.getEmptyTexture(cgl));

    let cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    let f = CGL.Texture.FILTER_LINEAR;
    if (tfilter.get() == "nearest") f = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "mipmap") f = CGL.Texture.FILTER_MIPMAP;

    if (!cachetexture.get() || !tex || !textureOut.get() || tex.width != fontImage.width || tex.height != fontImage.height || tex.anisotropic != parseFloat(aniso.get()))
    {
        if (tex)tex.delete();
        tex = new CGL.Texture.createFromImage(cgl, fontImage, { "filter": f, "anisotropic": parseFloat(aniso.get()), "wrap": cgl_wrap });
    }

    tex.flip = false;
    tex.initTexture(fontImage, f);
    textureOut.set(tex);
    tex.unpackAlpha = true;
}


};

Ops.Gl.Textures.TextTexture_v4.prototype = new CABLES.Op();
CABLES.OPS["afab973f-c9ac-47fd-914c-70b42af5c5d4"]={f:Ops.Gl.Textures.TextTexture_v4,objName:"Ops.Gl.Textures.TextTexture_v4"};




// **************************************************************
// 
// Ops.Gl.Textures.TextureInfo
// 
// **************************************************************

Ops.Gl.Textures.TextureInfo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTex = op.inObject("Texture"),
    outName = op.outNumber("Name"),
    outWidth = op.outNumber("Width"),
    outHeight = op.outNumber("Height"),
    outRatio = op.outNumber("Ratio"),
    outFilter = op.outNumber("Filter"),
    outWrap = op.outNumber("Wrap"),
    outFlipped = op.outNumber("Flipped"),
    outFp = op.outNumber("HDR"),
    outDefaultEmpty = op.outNumber("Is Empty Default Texture", false),
    outDefaultTex = op.outNumber("Is Default Texture", false),
    outId = op.outNumber("Id");

outFp.setUiAttribs({ "title": "Pixelformat Float 32bit" });

const emptyTex = CGL.Texture.getEmptyTexture(op.patch.cgl);
const defaultTex = CGL.Texture.getTempTexture(op.patch.cgl);

inTex.onChange = function ()
{
    if (inTex.get())
    {
        outName.set(inTex.get().name);
        outWidth.set(inTex.get().width);
        outHeight.set(inTex.get().height);
        outRatio.set(inTex.get().width / inTex.get().height);

        let strFilter = "unknown";
        if (inTex.get().filter == CGL.Texture.FILTER_NEAREST)strFilter = "nearest";
        else if (inTex.get().filter == CGL.Texture.FILTER_LINEAR)strFilter = "linear";
        else if (inTex.get().filter == CGL.Texture.FILTER_MIPMAP)strFilter = "mipmap";

        outFilter.set(inTex.get().filter + " " + strFilter);

        let strWrap = "unknown";

        if (inTex.get().wrap == CGL.Texture.WRAP_CLAMP_TO_EDGE) strWrap = "clamp to edge";
        else if (inTex.get().wrap == CGL.Texture.WRAP_REPEAT) strWrap = "repeat";
        else if (inTex.get().wrap == CGL.Texture.WRAP_MIRRORED_REPEAT) strWrap = "mirrored repeat";

        outWrap.set(inTex.get().wrap + " " + strWrap);

        outId.set(inTex.get().id);
        outFlipped.set(inTex.get().flipped);
        outFp.set(inTex.get().textureType == CGL.Texture.TYPE_FLOAT);
    }
    else
    {
        outName.set("no texture");
        outWidth.set(0);
        outHeight.set(0);
        outRatio.set(0);
        outFilter.set(null);
        outWrap.set(null);
        outId.set(null);
        outFlipped.set(false);
        outFp.set(false);
    }

    outDefaultEmpty.set(inTex.get() == emptyTex);
    outDefaultTex.set(inTex.get() == defaultTex);
};


};

Ops.Gl.Textures.TextureInfo.prototype = new CABLES.Op();
CABLES.OPS["71e5ee4c-3455-4c09-abb2-67abf382f35b"]={f:Ops.Gl.Textures.TextureInfo,objName:"Ops.Gl.Textures.TextureInfo"};




// **************************************************************
// 
// Ops.Gl.Textures.TextureSVG_v2
// 
// **************************************************************

Ops.Gl.Textures.TextureSVG_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    filename = op.inUrl("File"),
    texWidth = op.inValueInt("Texture width"),
    texHeight = op.inValueInt("Texture height"),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "repeat"),
    tfilter = op.inValueSelect("Filter", ["nearest", "linear", "mipmap"], "mipmap"),
    textureOut = op.outTexture("Texture"),
    outLoaded = op.outBoolNum("Loaded");

tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;

texWidth.set(1024);
texHeight.set(1024);

const cgl = op.patch.cgl;
let canvas = null;
let ctx = null;

function removeCanvas()
{
    if (!canvas) return;
    canvas.remove();
    canvas = null;
}

function createCanvas()
{
    if (canvas)removeCanvas();
    canvas = document.createElement("canvas");
    canvas.id = "svgcanvas";
    ctx = canvas.getContext("2d", { "alpha": true });

    ctx.canvas.width = canvas.width = texWidth.get();
    ctx.canvas.height = canvas.height = texHeight.get();

    canvas.style.display = "none";
    const body = document.getElementsByTagName("body")[0];
    body.appendChild(canvas);
}

textureOut.set(new CGL.Texture(cgl));

function reSize()
{
    update();
}

let data = "data:image/svg+xml," +
            "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"200\">" +
           "<foreignObject width=\"100%\" height=\"100%\">" +
           "<div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"font-size:40px\">" +
           "</div>" +
           "</foreignObject>" +
           "</svg>";

let cgl_filter = CGL.Texture.FILTER_MIPMAP;
let cgl_wrap = CGL.Texture.WRAP_REPEAT;

function onFilterChange()
{
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;

    reload();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    else if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reload();
}

function reload()
{
    const loadingId = op.patch.loading.start("svg file", filename.get());
    CABLES.ajax(
        op.patch.getFilePath(filename.get()),
        function (err, _data, xhr)
        {
            data = "data:image/svg+xml," + _data;

            data = data.replace(/#/g, "%23");

            op.patch.loading.finished(loadingId);
            update();
        }
    );
}

let startTime = 0;

function update()
{
    const img = new Image();
    const loadingId = op.patch.loading.start("svg2texture", filename.get());

    img.onabort = img.onerror = function (e)
    {
        outLoaded.set(false);
        op.logError("could not load file",);
        op.patch.loading.finished(loadingId);

        //     op.patch.loading.finished(loadingId);
        op.setUiError("error", "Could not load SVG file!");
    };

    outLoaded.set(false);

    img.onload = function ()
    {
        cgl.addNextFrameOnceCallback(() =>
        {
            createCanvas();
            op.patch.loading.finished(loadingId);
            canvas.width = texWidth.get();
            canvas.height = texHeight.get();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            textureOut.set(new CGL.Texture.createFromImage(cgl, canvas,
                {
                    "wrap": cgl_wrap,
                    "filter": cgl_filter,
                    "width": canvas.width,
                    "height": canvas.height,
                    "unpackAlpha": true
                }));
            removeCanvas();
            outLoaded.set(true);
        });
    };

    img.src = data;
    startTime = performance.now();
}

op.onFileChanged = function (fn)
{
    if (filename.get() && filename.get().endsWith(fn))
    {
        reload();
    }
};

filename.onChange = reload;
texWidth.onChange = texHeight.onChange = reSize;

createCanvas();
reSize();

tfilter.set("mipmap");


};

Ops.Gl.Textures.TextureSVG_v2.prototype = new CABLES.Op();
CABLES.OPS["e4f3d8f1-8a49-460a-896c-4d7adcda2494"]={f:Ops.Gl.Textures.TextureSVG_v2,objName:"Ops.Gl.Textures.TextureSVG_v2"};




// **************************************************************
// 
// Ops.Gl.Textures.TextureToBase64
// 
// **************************************************************

Ops.Gl.Textures.TextureToBase64 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTex = op.inTexture("Texture"),
    start = op.inTriggerButton("Trigger"),
    jpeg = op.inBool("Use JPEG", false),
    dataUrl = op.inBool("Output dataUrl", false),
    outString = op.outString("Base64 string"),
    outLoading = op.outBoolNum("Loading");

const gl = op.patch.cgl.gl;
let fb = null;
outString.ignoreValueSerialize = true;

// Create a 2D canvas to store the result
const canvas = document.createElement("canvas");

jpeg.onChange = update;
dataUrl.onChange = update;
start.onTriggered = update;

function update()
{
    op.uiAttr({ "error": null });
    if (!inTex.get() || !inTex.get().tex) return;
    outLoading.set(true);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    const width = inTex.get().width;
    const height = inTex.get().height;

    if (!fb)fb = gl.createFramebuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, inTex.get().tex, 0);

    const canRead = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    if (!canRead)
    {
        outLoading.set(true);
        op.uiAttr({ "error": "cannot read texture!" });
        return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    const data = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");

    // Copy the pixels to a 2D canvas
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);

    const data2 = imageData.data;

    // flip image
    Array.from({ "length": height }, (val, i) => { return data2.slice(i * width * 4, (i + 1) * width * 4); })
        .forEach((val, i) => { return data2.set(val, (height - i - 1) * width * 4); });

    context.putImageData(imageData, 0, 0);
    let dataString = "";
    if (jpeg.get())
    {
        dataString = canvas.toDataURL("image/jpeg", 1.0);
    }
    else
    {
        dataString = canvas.toDataURL();
    }
    if (!dataUrl.get())
    {
        dataString = dataString.split(",", 2)[1];
    }
    outString.set(dataString);
    outLoading.set(false);
}

function dataURIToBlob(dataURI, callback)
{
    const binStr = atob(dataURI.split(",")[1]),
        len = binStr.length,
        arr = new Uint8Array(len);
    for (let i = 0; i < len; i++) arr[i] = binStr.charCodeAt(i);
    callback(new Blob([arr], { "type": "image/png" }));
}


};

Ops.Gl.Textures.TextureToBase64.prototype = new CABLES.Op();
CABLES.OPS["dcc29c06-c3df-434f-9782-736548220bda"]={f:Ops.Gl.Textures.TextureToBase64,objName:"Ops.Gl.Textures.TextureToBase64"};




// **************************************************************
// 
// Ops.Gl.Textures.TextureToCoordinateGrid
// 
// **************************************************************

Ops.Gl.Textures.TextureToCoordinateGrid = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"rgbe2fp_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\nUNI float aspect;\nUNI float threshold;\n\nvoid main()\n{\n    vec4 col=texture(tex,texCoord);\n    vec4 outCol=vec4(111111110.0);\n\n    if(col.r>threshold)\n    {\n        outCol=vec4(vec2((texCoord.x-0.5)*aspect,texCoord.y-0.5),0.0,1.0);\n        // outCol=vec4(texCoord,0.0,1.0);\n    }\n\n\n    outColor = outCol;\n}",};
const
    exec = op.inTrigger("Execute"),
    inTex = op.inTexture("RGBE Texture"),
    inAspect = op.inFloat("Aspect", 1),
    inThreshold = op.inFloatSlider("Threshold", 0.2),
    next = op.outTrigger("Next"),
    outFpTex = op.outTexture("HDR Texture");

const tc = new CGL.CopyTexture(op.patch.cgl, "rgbe2hdr",
    {
        "shader": attachments.rgbe2fp_frag,
        "isFloatingPointTexture": true
    });

const uni1 = new CGL.Uniform(tc.bgShader, "f", "aspect", inAspect);
const uni2 = new CGL.Uniform(tc.bgShader, "f", "threshold", inThreshold);

exec.onTriggered = () =>
{
    if (!inTex.get()) return;

    outFpTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
    outFpTex.set(tc.copy(inTex.get()));

    next.trigger();
};


};

Ops.Gl.Textures.TextureToCoordinateGrid.prototype = new CABLES.Op();
CABLES.OPS["91f30465-4a4c-4447-9b16-072252f0a977"]={f:Ops.Gl.Textures.TextureToCoordinateGrid,objName:"Ops.Gl.Textures.TextureToCoordinateGrid"};




// **************************************************************
// 
// Ops.Gl.Textures.VideoTexture_v3
// 
// **************************************************************

Ops.Gl.Textures.VideoTexture_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Update"),
    filename = op.inUrl("file", "video"),
    play = op.inValueBool("play"),
    loop = op.inValueBool("loop", true),

    volume = op.inValueSlider("Volume", 1),
    muted = op.inValueBool("mute", true),

    fps = op.inValueFloat("Update FPS", 30),
    tfilter = op.inSwitch("Filter", ["nearest", "linear"], "linear"),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"),
    flip = op.inValueBool("flip", true),

    speed = op.inValueFloat("speed", 1),
    time = op.inValueFloat("set time"),
    rewind = op.inTriggerButton("Rewind"),

    inPreload = op.inValueBool("Preload", true),
    inShowSusp = op.inBool("Show Interaction needed Button", true),

    outNext = op.outTrigger("Next"),
    textureOut = op.outTexture("texture", null, "texture"),
    outDuration = op.outNumber("duration"),
    outProgress = op.outNumber("progress"),
    outInteractionNeeded = op.outBoolNum("Interaction Needed"),
    outTime = op.outNumber("CurrentTime"),
    loading = op.outBoolNum("Loading"),
    outPlaying = op.outBoolNum("Playing"),
    canPlayThrough = op.outBoolNum("Can Play Through", false),

    outWidth = op.outNumber("Width"),
    outHeight = op.outNumber("Height"),
    outAspect = op.outNumber("Aspect Ratio"),
    outHasError = op.outBoolNum("Has Error"),
    outError = op.outString("Error Message");

op.setPortGroup("Texture", [tfilter, wrap, flip, fps]);
op.setPortGroup("Audio", [muted, volume]);
op.setPortGroup("Timing", [time, rewind, speed]);

let videoElementPlaying = false;
let embedded = false;
let interActionNeededButton = false;
let addedListeners = false;
let cgl_filter = 0;
let cgl_wrap = 0;
let tex = null;
let timeout = null;
let firstTime = true;
let needsUpdate = true;
let lastTime = 0;

const cgl = op.patch.cgl;
const videoElement = document.createElement("video");
videoElement.setAttribute("playsinline", "");
videoElement.setAttribute("webkit-playsinline", "");
videoElement.setAttribute("autoplay", "autoplay");

const emptyTexture = CGL.Texture.getEmptyTexture(cgl);
op.toWorkPortsNeedToBeLinked(textureOut);
textureOut.set(tex);
textureOut.set(CGL.Texture.getEmptyTexture(cgl));
play.onChange = updatePlayState;
filename.onChange = reload;
volume.onChange = updateVolume;
op.onMasterVolumeChanged = updateVolume;

tfilter.onChange = wrap.onChange = () =>
{
    tex = null;
};

op.onDelete = () =>
{
    if (tex)tex.delete();
    videoElement.remove();
};

inExec.onTriggered = () =>
{
    if (performance.now() - lastTime > 1000 / fps.get())needsUpdate = true;

    if (needsUpdate)
    {
        lastTime = performance.now();
        updateTexture();
    }

    outPlaying.set(!videoElement.paused);

    if (interActionNeededButton && !videoElement.paused && play.get())
    {
        // remove button after player says no but plays anyhow after some time...
        op.log("weirdness...");
        interActionNeededButton = false;
        CABLES.interActionNeededButton.remove("videoplayer");
    }
    outInteractionNeeded.set(interActionNeededButton);

    outNext.trigger();
};

function reInitTexture()
{
    if (tex)tex.delete();

    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;

    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    tex = new CGL.Texture(cgl,
        {
            "wrap": cgl_wrap,
            "filter": cgl_filter
        });
}

rewind.onTriggered = function ()
{
    videoElement.currentTime = 0;
    textureOut.set(emptyTexture);
    needsUpdate = true;
};

time.onChange = function ()
{
    videoElement.currentTime = time.get() || 0;
    needsUpdate = true;
};

fps.onChange = function ()
{
    needsUpdate = true;
};

function doPlay()
{
    videoElement.playbackRate = speed.get();
}

function updatePlayState()
{
    if (!embedded)
    {
        embedVideo(true);
    }

    if (play.get())
    {
        videoElement.currentTime = time.get() || 0;

        const promise = videoElement.play();

        if (promise)
            promise.then(function ()
            {
                doPlay();
            }).catch(function (error)
            {
                op.warn("exc", error);
                op.log(error);
                op.log(videoElement);

                if (videoElement.paused && inShowSusp.get())
                {
                    interActionNeededButton = true;
                    CABLES.interActionNeededButton.add(op.patch, "videoplayer", () =>
                    {
                        interActionNeededButton = false;
                        videoElement.play();
                        doPlay();
                        CABLES.interActionNeededButton.remove("videoplayer");
                    });
                }
                // Automatic playback failed.
                // Show a UI element to let the user manually start playback.
            });
    }
    else videoElement.pause();
}

speed.onChange = function ()
{
    videoElement.playbackRate = speed.get();
};

loop.onChange = function ()
{
    videoElement.loop = loop.get();
};

muted.onChange = function ()
{
    videoElement.muted = muted.get();
};

function updateTexture()
{
    const force = needsUpdate;

    if (!filename.get())
    {
        textureOut.set(emptyTexture);
        return;
    }

    if (!videoElementPlaying) return;

    if (!tex)reInitTexture();
    if (tex.width != videoElement.videoWidth || tex.height != videoElement.videoHeight)
    {
        op.log("video size", videoElement.videoWidth, videoElement.videoHeight);
        tex.setSize(videoElement.videoWidth, videoElement.videoHeight);
    }

    // tex.height = videoElement.videoHeight;
    // tex.width = videoElement.videoWidth;

    outWidth.set(tex.width);
    outHeight.set(tex.height);
    outAspect.set(tex.width / tex.height);

    if (!canPlayThrough.get()) return;
    if (!videoElementPlaying) return;
    if (!videoElement) return;
    if (videoElement.videoHeight <= 0)
    {
        op.setUiError("videosize", "video width is 0!");
        op.log(videoElement);
        return;
    }
    if (videoElement.videoWidth <= 0)
    {
        op.setUiError("videosize", "video height is 0!");
        op.log(videoElement);
        return;
    }

    const perc = (videoElement.currentTime) / videoElement.duration;
    if (!isNaN(perc)) outProgress.set(perc);

    outTime.set(videoElement.currentTime);

    cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, tex.tex);

    if (firstTime)
    {
        cgl.gl.pixelStorei(cgl.gl.UNPACK_FLIP_Y_WEBGL, flip.get());
        cgl.gl.texImage2D(cgl.gl.TEXTURE_2D, 0, cgl.gl.RGBA, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, videoElement);
        tex._setFilter();
    }
    else
    {
        cgl.gl.pixelStorei(cgl.gl.UNPACK_FLIP_Y_WEBGL, flip.get());
        cgl.gl.texSubImage2D(cgl.gl.TEXTURE_2D, 0, 0, 0, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, videoElement);
    }

    if (flip.get()) cgl.gl.pixelStorei(cgl.gl.UNPACK_FLIP_Y_WEBGL, false);

    firstTime = false;

    textureOut.set(tex);
    needsUpdate = false;

    op.patch.cgl.profileData.profileVideosPlaying++;

    if (videoElement.readyState == 4) loading.set(false);
    else loading.set(false);
}

function initVideo()
{
    videoElement.controls = false;
    videoElement.muted = muted.get();
    videoElement.loop = loop.get();

    needsUpdate = true;
    canPlayThrough.set(true);
}

function updateVolume()
{
    videoElement.volume = Math.min(1, Math.max(0, (volume.get() || 0) * op.patch.config.masterVolume));
}

function loadedMetaData()
{
    outDuration.set(videoElement.duration);
    updatePlayState();
}

function embedVideo(force)
{
    outHasError.set(false);
    outError.set("");
    canPlayThrough.set(false);
    if (filename.get() && String(filename.get()).length > 1) firstTime = true;

    if (!filename.get())
    {
        outError.set(true);
    }

    if (inPreload.get() || force)
    {
        clearTimeout(timeout);
        loading.set(true);
        videoElement.preload = "true";

        let url = op.patch.getFilePath(filename.get());
        if (String(filename.get()).indexOf("data:") == 0) url = filename.get();
        if (!url) return;

        op.setUiError("onerror", null);
        videoElement.style.display = "none";
        videoElement.setAttribute("src", url);
        videoElement.setAttribute("crossOrigin", "anonymous");
        videoElement.playbackRate = speed.get();

        if (!addedListeners)
        {
            addedListeners = true;
            videoElement.addEventListener("canplaythrough", initVideo, true);
            videoElement.addEventListener("loadedmetadata", loadedMetaData);
            videoElement.addEventListener("playing", function () { videoElementPlaying = true; }, true);
            videoElement.onerror = function ()
            {
                outHasError.set(true);
                if (videoElement)
                {
                    outError.set("Error " + videoElement.error.code + "/" + videoElement.error.message);
                    op.setUiError("onerror", "Could not load video / " + videoElement.error.message, 2);
                }
            };
        }
        embedded = true;
    }
}

function loadVideo()
{
    setTimeout(embedVideo, 100);
}

function reload()
{
    if (!filename.get()) return;
    loadVideo();
}


};

Ops.Gl.Textures.VideoTexture_v3.prototype = new CABLES.Op();
CABLES.OPS["9d66516f-d234-4114-b1d3-67b8e60f5dc6"]={f:Ops.Gl.Textures.VideoTexture_v3,objName:"Ops.Gl.Textures.VideoTexture_v3"};




// **************************************************************
// 
// Ops.Gl.Textures.WebcamTexture_v3
// 
// **************************************************************

Ops.Gl.Textures.WebcamTexture_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"texcopy_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\n\n\nvoid main()\n{\n    vec2 tc=vec2(texCoord.x,texCoord.y);\n\n    #ifdef FLIPX\n        tc.x=1.0-texCoord.x;\n    #endif\n    #ifdef FLIPY\n        tc.y=1.0-texCoord.y;\n    #endif\n    outColor=texture(tex,tc);\n}",};
const
    inTrigger = op.inTrigger("Render"),
    inActive = op.inBool("Active", true),
    inGenTex = op.inValueBool("Generate Texture", true),
    inInputDevices = op.inDropDown("Webcam Input", ["Default"], "Default"),
    inWidth = op.inValueInt("Requested Width", 1280),
    inHeight = op.inValueInt("Requested Height", 720),

    flipX = op.inValueBool("Flip X", false),
    flipY = op.inValueBool("Flip Y", false),

    inAsDOM = op.inValueBool("Show HTML Element", false),
    inCss = op.inStringEditor("CSS", "z-index:99999;\nposition:absolute;\n", "inline-css"),
    htmlFlipX = op.inValueBool("Element Flip X", false),
    htmlFlipY = op.inValueBool("Element Flip Y", false),

    next = op.outTrigger("Next"),
    textureOut = op.outTexture("Texture"),

    outRatio = op.outNumber("Ratio"),
    available = op.outBoolNum("Available"),
    outWidth = op.outNumber("Size Width"),
    outHeight = op.outNumber("Size Height"),
    outError = op.outString("Error"),
    outElement = op.outObject("HTML Element", null, "element"),
    outDevices = op.outArray("Available devices"),
    outSelectedDevice = op.outString("Active device"),
    outUpdate = op.outTrigger("Texture updated");

op.setPortGroup("Camera", [inInputDevices, inWidth, inHeight]);
op.setPortGroup("Texture", [flipX, flipY]);
op.setPortGroup("Video Element", [inAsDOM, inCss, htmlFlipX, htmlFlipY]);

let tries = 0;
const cgl = op.patch.cgl;
const emptyTexture = CGL.Texture.getEmptyTexture(cgl);
const videoElement = document.createElement("video");
const eleId = "webcam" + op.id;

videoElement.setAttribute("id", eleId);
videoElement.setAttribute("autoplay", "");
videoElement.setAttribute("muted", "");
videoElement.setAttribute("playsinline", "");
videoElement.setAttribute("style", inCss.get());
op.patch.cgl.canvas.parentElement.appendChild(videoElement);

let tex = null;
let initingDevices = false;
let restarting = false;
let started = false;
let camsLoaded = false;
let loadingId = null;
let currentStream = null;
let camInputDevices = null;
let active = false;
let alreadyRetried = false;
let constraints = null;

textureOut.set(emptyTexture);

flipX.onChange =
flipY.onChange = initCopyShader;

inInputDevices.onChange =
    inWidth.onChange =
    inHeight.onChange = restartWebcam;
htmlFlipX.onChange = htmlFlipY.onChange = flipVideoElement;
op.onDelete = removeElement;
inAsDOM.onChange = inCss.onChange = updateStyle;

initTexture();
updateStyle();

let tc = null;

op.on("loadedValueSet", () =>
{
    if (inActive.get()) initDevices();
});

inActive.onChange = () =>
{
    if (inActive.get()) initDevices();
};

function initCopyShader()
{
    if (!tc)tc = new CGL.CopyTexture(cgl, "webcamFlippedTexture", { "shader": attachments.texcopy_frag });
    tc.bgShader.toggleDefine("FLIPX", flipX.get());
    tc.bgShader.toggleDefine("FLIPY", !flipY.get());
}

function initTexture()
{
    if (tex)tex.delete();
    tex = new CGL.Texture(cgl, { "name": "webcam" });
    if (videoElement) tex.setSize(videoElement.videoWidth, videoElement.videoHeight);
}

function removeElement()
{
    if (videoElement) videoElement.remove();
}

function updateStyle()
{
    if (!inAsDOM.get()) videoElement.setAttribute("style", "display:none;");
    else videoElement.setAttribute("style", inCss.get());

    inCss.setUiAttribs({ "greyout": !inAsDOM.get() });
    htmlFlipX.setUiAttribs({ "greyout": !inAsDOM.get() });
    htmlFlipY.setUiAttribs({ "greyout": !inAsDOM.get() });
}

function flipVideoElement()
{
    if (htmlFlipX.get() && !htmlFlipY.get()) videoElement.style.transform = "scaleX(-1)";
    else if (!htmlFlipX.get() && htmlFlipY.get()) videoElement.style.transform = "scaleY(-1)";
    else if (htmlFlipX.get() && htmlFlipY.get()) videoElement.style.transform = "scale(-1, -1)";
    else videoElement.style.transform = "unset";
}

function playCam(shouldPlay)
{
    if (started && camsLoaded)
    {
        if (shouldPlay)
        {
            active = true;
            videoElement.play();
        }
        else
        {
            active = false;
            videoElement.pause();
        }
    }
}

inGenTex.onChange = () =>
{
    playCam(inGenTex.get());
};

function updateTexture()
{
    cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, tex.tex);

    cgl.gl.texImage2D(cgl.gl.TEXTURE_2D, 0, cgl.gl.RGBA, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, videoElement);
    cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, null);
    textureOut.set(emptyTexture);

    if (!tc)initCopyShader();
    if (tc)textureOut.set(tc.copy(tex));
}

function stopStream()
{
    if (!currentStream) return;

    playCam(false);
    available.set(false);

    currentStream.getTracks().forEach((track) =>
    {
        track.stop();
    });
    currentStream = null;
}

function camInitComplete(stream)
{
    currentStream = stream;
    videoElement.srcObject = stream;
    videoElement.onloadedmetadata = (e) =>
    {
        outSelectedDevice.set(stream.getTracks()[0].label);
        if (inInputDevices.get() != "Default" && stream.getTracks()[0].label != inInputDevices.get() && tries < 3)
        {
            tries++;
            return restartWebcam();
        }

        const settings = stream.getTracks()[0].getSettings();
        restarting = false;

        const w = settings.width || inWidth.get();
        const h = settings.height || inHeight.get();

        outHeight.set(h);
        outWidth.set(w);
        outRatio.set(settings.aspectRatio || w / h);
        outError.set("");

        videoElement.setAttribute("width", settings.width);
        videoElement.setAttribute("height", settings.height);

        outElement.set(videoElement);

        tex.setSize(w, h);

        available.set(true);
        playCam(inGenTex.get());
    };
}

function isCorrectSize()
{
    const constraints = getCamConstraints();
    const check = constraints.video.width == videoElement.videoWidth && constraints.video.height == videoElement.videoHeight;
    return check;
}

function getCamConstraints()
{
    let constr = { "audio": false, "video": {} };

    if (camsLoaded)
    {
        let deviceLabel = inInputDevices.get();
        let deviceInfo = null;

        if (!deviceLabel || deviceLabel === "Default" || deviceLabel === "...")
        {
            deviceInfo = Object.values(camInputDevices)[0];
        }
        else
        {
            deviceInfo = camInputDevices.filter((d) => { return d.label === deviceLabel; });
            if (deviceInfo)
            {
                deviceInfo = deviceInfo[0];
            }
            else
            { // otherwise get by number
                deviceInfo = Object.values(camInputDevices)[deviceLabel];
            }

            if (!deviceInfo)
            {
                deviceInfo = Object.values(camInputDevices)[0];
            }
        }
        constr.video = { "deviceId": { "exact": deviceInfo.deviceId } };
    }

    // constr.video.facingMode = { "exact": inFacing.get() };

    const w = inWidth.get();
    const h = inHeight.get();
    let width = { "min": 640 };
    let height = { "min": 480 };

    if (w)
        width.ideal = w;

    if (h)
        height.ideal = h;

    constr.video.width = width;
    constr.video.height = height;

    return constr;
}

function restartWebcam()
{
    if (!inActive.get()) return;
    stopStream();
    restarting = true;

    const constr = getCamConstraints();

    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia;

    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
    {
        navigator.mediaDevices.getUserMedia(constr)
            .then(camInitComplete)
            .catch((error) =>
            {
                restarting = false;
                op.logError(error.name + ": " + error.message, error);
                outError.set(error.name + ": " + error.message);
            });
    }
    else if (navigator.getUserMedia)
    {
        restarting = false;
        navigator.getUserMedia(constr, camInitComplete, () => { return available.set(false); });
    }
}

function initDevices()
{
    if (!inActive.get()) return;
    initingDevices = true;
    loadingId = cgl.patch.loading.start("Webcam inputs", "");
    const constraints = getCamConstraints();

    navigator.mediaDevices.getUserMedia(constraints)
        .then((res) => { return navigator.mediaDevices.enumerateDevices(); })
        .then((devices) =>
        {
            camInputDevices = devices
                .filter((device) => { return device.kind === "videoinput"; });

            initingDevices = false;
            inInputDevices.uiAttribs.values = camInputDevices.map((d, idx) => { return d.label || idx; });
            inInputDevices.uiAttribs.values.unshift("Default");
            outDevices.set(inInputDevices.uiAttribs.values);
            cgl.patch.loading.finished(loadingId);

            camsLoaded = true;

            restartWebcam();
            started = true;
        }).catch((e) =>
        {
            initingDevices = false;
            op.error("error", e);
            outError.set(e.name + ": " + e.message);
            cgl.patch.loading.finished(loadingId);
            camsLoaded = false;
        });
}

inTrigger.onTriggered = () =>
{
    if (!initingDevices && inActive.get())
    {
        if (started && camsLoaded && active)
        {
            updateTexture();
            outUpdate.trigger();
        }

        if (!started && camsLoaded)
        {
            restartWebcam();
        }
    }

    next.trigger();
};


};

Ops.Gl.Textures.WebcamTexture_v3.prototype = new CABLES.Op();
CABLES.OPS["71c0468d-e942-4574-a91d-b3d7271922d0"]={f:Ops.Gl.Textures.WebcamTexture_v3,objName:"Ops.Gl.Textures.WebcamTexture_v3"};




// **************************************************************
// 
// Ops.Gl.TriggerOnCanvasResize
// 
// **************************************************************

Ops.Gl.TriggerOnCanvasResize = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const onResize = op.outTrigger("Resized");

let listener = op.patch.cgl.on("resize", resize);

function resize()
{
    onResize.trigger();
}

op.onDelete = () =>
{
    op.patch.cgl.off(listener);
};


};

Ops.Gl.TriggerOnCanvasResize.prototype = new CABLES.Op();
CABLES.OPS["856de8cf-b8d1-4668-b8ff-80c68bc73ddd"]={f:Ops.Gl.TriggerOnCanvasResize,objName:"Ops.Gl.TriggerOnCanvasResize"};




// **************************************************************
// 
// Ops.Gl.ValidTexture
// 
// **************************************************************

Ops.Gl.ValidTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
 const
    inTex=op.inTexture("Texture"),
    inWhich=op.inSwitch("Default",['Empty','Stripes'],'Empty'),
    outTex=op.outTexture("Result");


let tex=CGL.Texture.getEmptyTexture(op.patch.cgl);

inWhich.onChange=function()
{
    if(inWhich.get()=="Empty")tex=CGL.Texture.getEmptyTexture(op.patch.cgl);
    else tex=CGL.Texture.getTempTexture(op.patch.cgl);
};

inTex.onChange=function()
{
    let t=inTex.get();

    if(!t) t=tex;

    outTex.set(t);
};

};

Ops.Gl.ValidTexture.prototype = new CABLES.Op();
CABLES.OPS["51c24850-aa8b-41e4-936e-68ba718b5e39"]={f:Ops.Gl.ValidTexture,objName:"Ops.Gl.ValidTexture"};




// **************************************************************
// 
// Ops.Gl.ViewPortSize
// 
// **************************************************************

Ops.Gl.ViewPortSize = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Exec"),
    next = op.outTrigger("Next"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outW = op.outNumber("Width"),
    outH = op.outNumber("Height");

exec.onTriggered = function ()
{
    const vp = op.patch.cgl.getViewPort();

    outX.set(vp[0]);
    outY.set(vp[1]);
    outW.set(vp[2]);
    outH.set(vp[3]);

    next.trigger();
};


};

Ops.Gl.ViewPortSize.prototype = new CABLES.Op();
CABLES.OPS["7cb99d8f-d7ef-478e-902b-54e054e387a0"]={f:Ops.Gl.ViewPortSize,objName:"Ops.Gl.ViewPortSize"};




// **************************************************************
// 
// Ops.Gl.Viewport2
// 
// **************************************************************

Ops.Gl.Viewport2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    ratio = op.inDropDown("ratio", [0.5, 0.5625, 0.75, 1, 1.25, 1.3333333333, 1.777777777778, 2.33333333333333, 3, 4]),
    trigger = op.outTrigger("trigger");

ratio.set(1.777777777778);

const posX = op.inValueSelect("Pos X", ["Left", "Right", "Center"], "Center");

const cgl = op.patch.cgl;

let w = 1000, h = 1000;

function resize()
{
    let _w = cgl.canvasHeight * ratio.get();
    let _h = cgl.canvasHeight;
    let _x = 0;
    let _y = 0;

    if (_w > cgl.canvasWidth)
    {
        _w = cgl.canvasWidth;
        _h = cgl.canvasWidth / ratio.get();
    }

    if (_w < cgl.canvasWidth) _x = (cgl.canvasWidth - _w) / 2;
    if (_h < cgl.canvasHeight) _y = (cgl.canvasHeight - _h) / 2;

    if (_w != w || _h != h)
    {
        w = _w;
        h = _h;

        const vp = cgl.getViewPort();

        // cgl.setViewPort(0,vp[2]-h,w,h);

        for (let i = 0; i < op.patch.ops.length; i++)
        {
            if (op.patch.ops[i].onResize)op.patch.ops[i].onResize();
        }
    }
}

op.onDelete = function ()
{
    cgl.resetViewPort();
};

const prevViewPort = [];

render.onTriggered = function ()
{
    resize();

    w = Math.round(w);
    h = Math.round(h);

    cgl.gl.enable(cgl.gl.SCISSOR_TEST);
    const vp = cgl.getViewPort();
    prevViewPort[0] = vp[0];
    prevViewPort[1] = vp[1];
    prevViewPort[2] = vp[2];
    prevViewPort[3] = vp[3];

    vp[2] = cgl.canvasWidth;
    vp[3] = cgl.canvasHeight;
    vp[0] = 0;
    vp[1] = 0;

    let x = 0;
    if (posX.get() == "Right") x = vp[2] - w;
    if (posX.get() == "Center") x = (vp[2] - w) / 2;

    x = Math.round(x);

    cgl.gl.scissor(x, vp[3] - h, w, h);
    cgl.setViewPort(x, vp[3] - h, w, h);

    mat4.perspective(cgl.pMatrix, 45, ratio.get(), 0.1, 1100.0);

    trigger.trigger();
    cgl.gl.disable(cgl.gl.SCISSOR_TEST);
    cgl.setViewPort(prevViewPort[0], prevViewPort[1], prevViewPort[2], prevViewPort[3]);
};


};

Ops.Gl.Viewport2.prototype = new CABLES.Op();
CABLES.OPS["1444ab6f-a4da-462c-8abe-a1deef2084da"]={f:Ops.Gl.Viewport2,objName:"Ops.Gl.Viewport2"};




// **************************************************************
// 
// Ops.Gl.WebGlVersion
// 
// **************************************************************

Ops.Gl.WebGlVersion = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const ver = op.outNumber("Major Version", op.patch.cgl.glVersion);

op.onLoaded = function ()
{
    ver.set(op.patch.cgl.glVersion);
};


};

Ops.Gl.WebGlVersion.prototype = new CABLES.Op();
CABLES.OPS["d6554d6c-0742-4559-b0a4-29ad0ae1e25b"]={f:Ops.Gl.WebGlVersion,objName:"Ops.Gl.WebGlVersion"};




// **************************************************************
// 
// Ops.Graphics.Geometry.ObjGeometry
// 
// **************************************************************

Ops.Graphics.Geometry.ObjGeometry = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// todo: support quads
const
    inStr = op.inString("Obj", ""),
    outGeom = op.outObject("Geometry", null, "geometry"),
    outStatus = op.outString("Status");

inStr.onChange = () => { parse(inStr.get()); };

function obj(name)
{
    const a = {
        "prim": 0,
        "name": name,
        "verts": [],
        "vertNorms": [],
        "texCoords": [],
        "indexVerts": [],
        "indexNorms": [],
        "indexTexcoords": []
    };

    return a;
}

function parseTri(parts, o)
{
    for (let j = 0; j < parts.length; j++)
    {
        const faceParts = parts[j].split("/");

        if (faceParts.length == 3)
        {
            o.indexVerts.push(parseInt(faceParts[0]) - 1);
            if (faceParts[1])o.indexTexcoords.push(parseInt(faceParts[1]) - 1);
            o.indexNorms.push(parseInt(faceParts[2]) - 1);
        }
        else if (faceParts.length == 1)
        {
            o.indexVerts.push(parseInt(faceParts[0]) - 1);
        }
        else if (faceParts.length == 2)
        {
            o.indexVerts.push(parseInt(faceParts[0]) - 1);
            o.indexTexcoords.push(parseInt(faceParts[2]) - 1);
        }
        else op.warn("unknown face structure", faceParts);
    }
}

function parse(str)
{
    if (!str) return outGeom.set(null);

    let objects = [];
    let strStatus = "";
    const lines = str.split("\n");

    {
        let o = obj("unknown");

        for (let i = 0; i < lines.length; i++)
        {
            lines[i] = lines[i].replaceAll("  ", " ");
            lines[i] = lines[i].replaceAll(" \r", "");
            lines[i] = lines[i].replaceAll(" \n", "\n");

            if (lines[i].length < 3 || lines[i].charAt(0) == "#") continue;

            // vertices
            if (lines[i].charAt(0) == "o" && lines[i].charAt(1) == " ")
            {
                const parts = lines[i].split(" ");
                o.name = obj(parts[1] || "unknown");
                continue;
            }

            if (lines[i].charAt(0) == "v")
            {
                if (o.indexVerts.length > 0)
                {
                    // new object...
                    if (o.indexVerts.length > 0) objects.push(o);
                    o = obj("unknown");
                }

                // vertices
                if (lines[i].charAt(1) == " ")
                {
                    const parts = lines[i].split(" ");
                    o.verts.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
                    continue;
                }

                // texcoords
                if (lines[i].charAt(1) == "t" && lines[i].charAt(2) == " ")
                {
                    const parts = lines[i].split(" ");
                    o.texCoords.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
                    continue;
                }

                // normals
                if (lines[i].charAt(1) == "n" && lines[i].charAt(2) == " ")
                {
                    const parts = lines[i].split(" ");
                    o.vertNorms.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
                    continue;
                }
            }

            // faces
            if (lines[i].charAt(0) == "f" && lines[i].charAt(1) == " ")
            {
                const parts = lines[i].split(" ");
                parts.shift();
                while (parts[parts.length - 1] == "")
                {
                    parts.pop();
                }

                if (o.prim == 0) o.prim = parts.length;

                if (o.prim == 3 && parts.length == 3) // tris
                {
                    parseTri(parts, o);
                }
                else if (o.prim == 4 && parts.length == 4) // quads
                {
                    parseTri([parts[0], parts[1], parts[2]], o);
                    parseTri([parts[0], parts[2], parts[3]], o);
                }
                continue;
            }
        }
        objects.push(o);
    }

    op.log("objects", objects);

    let finalgeom = new CGL.Geometry("objfile");
    for (let io = 0; io < objects.length; io++)
    {
        const geom = new CGL.Geometry("objfile");
        geom.clear();

        let o = objects[io];
        op.log(o);

        if (o.indexVerts.length > 0)
        {
            let gVerts = [];
            let gNorms = [];
            let gTexCoords = [];
            let isIndexed = true;

            for (let i = 0; i < o.indexVerts.length; i++)
            {
                if (isIndexed)
                {
                    if (!(o.indexVerts[i] == o.indexNorms[i] && o.indexNorms[i] == o.indexTexcoords[i]))
                    {
                        op.log("false");
                        isIndexed = false;
                        break;
                    }
                }
            }

            op.log("isIndexed", isIndexed);
            if (isIndexed)
            {
                geom.verticesIndices = o.indexVerts;
                gNorms = o.vertNorms;

                gTexCoords = [];
                for (let i = 0; i < o.texCoords.length; i += 3)
                {
                    gTexCoords.push(o.texCoords[i + 0], o.texCoords[i + 1]);
                }
                gVerts = o.verts;
            }
            else
                for (let i = 0; i < o.indexVerts.length; i++)
                {
                    for (let j = 0; j < 3; j++)
                    {
                        gVerts.push(o.verts[o.indexVerts[i] * 3 + j]);
                        if (o.indexNorms.length > 0)gNorms.push(o.vertNorms[o.indexNorms[i] * 3 + j]);
                        if (o.indexTexcoords.length > 0 && j < 2)gTexCoords.push(o.texCoords[o.indexTexcoords[i] * 3 + j]);
                    }
                }

            geom.vertices = gVerts;
            geom.vertexNormals = gNorms;
            geom.texCoords = gTexCoords;

            if (geom.vertexNormals.length == 0)
            {
                geom.calculateNormals();
            }
        }
        finalgeom.merge(geom);
        // finalgeom = geom;
    }

    finalgeom.calcTangentsBitangents();

    outGeom.set(null);
    outGeom.set(finalgeom);

    outStatus.set(strStatus);
}


};

Ops.Graphics.Geometry.ObjGeometry.prototype = new CABLES.Op();
CABLES.OPS["8cebb27b-2a6e-4580-a543-b36a91f14879"]={f:Ops.Graphics.Geometry.ObjGeometry,objName:"Ops.Graphics.Geometry.ObjGeometry"};




// **************************************************************
// 
// Ops.Html.AppendChild_v2
// 
// **************************************************************

Ops.Html.AppendChild_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// constants
let CANVAS_ELEMENT = op.patch.cgl.canvas.parentElement;

// variables
let lastParent = null;
let lastChild = null;

// inputs
let parentPort = op.inObject("Parent", null, "element");
let childPort = op.inObject("Child", null, "element");

// outputs
let parentOutPort = op.outObject("Parent Out", null, "element");
let childOutPort = op.outObject("Child Out", null, "element");

// change listeners
parentPort.onChange = update;
childPort.onChange = update;

// functions

function update()
{
    let parent = parentPort.get();
    let child = childPort.get();
    if (parent !== lastParent)
    {
        if (parent)
        {
            handleParentConnect(parent, child);
        }
        else
        {
            handleParentDisconnect(parent, child);
        }
        lastParent = parent;
    }
    if (child !== lastChild)
    {
        if (child)
        {
            handleChildConnect(parent, child);
        }
        else
        {
            handleChildDisconnect(parent, child);
        }
        lastChild = child;
    }
    parentOutPort.set(parent);
    childOutPort.set(child);
}

function handleParentConnect(parent, child)
{
    if (child)
    {
        parent.appendChild(child);
    }
}

function handleParentDisconnect(parent, child)
{
    if (child)
    {
        CANVAS_ELEMENT.appendChild(child); // if there is no parent, append to patch
    }
}

function handleChildConnect(parent, child)
{
    if (parent)
    {
        parent.appendChild(child);
    }
}

function handleChildDisconnect(parent, child)
{
    if (lastChild)
    {
        CANVAS_ELEMENT.appendChild(lastChild);
    }
}


};

Ops.Html.AppendChild_v2.prototype = new CABLES.Op();
CABLES.OPS["e15cfbc7-d2fa-4348-8964-66d02aec77aa"]={f:Ops.Html.AppendChild_v2,objName:"Ops.Html.AppendChild_v2"};




// **************************************************************
// 
// Ops.Html.AudioMediaElement
// 
// **************************************************************

Ops.Html.AudioMediaElement = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    fileName = op.inUrl("file", "audio"),
    inPlay = op.inValueBool("Play"),
    volume = op.inValueSlider("Volume"),

    doLoop = op.inValueBool("Loop"),
    outPlaying = op.outNumber("Playing"),
    outEle = op.outObject("Element", null, "element"),
    outEnded = op.outTrigger("Has Ended");

volume.set(1.0);
let audio = null;
let playing = false;
outPlaying.set(false);
volume.onChange = updateVolume;

function play()
{
    if (audio)
    {
        playing = true;
        audio.play();
    }
}

inPlay.onChange = function ()
{
    if (inPlay.get())
    {
        play();
    }
    else
    {
        playing = false;
        audio.pause();
    }
    outPlaying.set(playing);
};

this.onDelete = function ()
{
    if (audio) audio.pause();
};

doLoop.onChange = function ()
{
    if (audio) audio.loop = doLoop.get();
};

function playPause()
{
    if (!audio) return;

    if (op.patch.timer.isPlaying()) audio.play();
    else audio.pause();
}

function updateVolume()
{
    if (audio)audio.volume = volume.get() * op.patch.config.masterVolume;
}

op.onMasterVolumeChanged = updateVolume;

fileName.onChange = function ()
{
    if (!fileName.get()) return;

    let loadingId = op.patch.loading.start("audioplayer", fileName.get());

    if (audio)
    {
        audio.pause();
        outPlaying.set(false);
    }
    audio = new Audio();
    audio.crossOrigin = "anonymous";
    audio.src = op.patch.getFilePath(fileName.get());
    audio.loop = doLoop.get();
    audio.controls = "true";
    audio.crossOrigin = "anonymous";

    outEle.set(audio);

    var canplaythrough = function ()
    {
        if (inPlay.get()) play();
        op.patch.loading.finished(loadingId);
        audio.removeEventListener("canplaythrough", canplaythrough, false);
    };

    audio.addEventListener("canplaythrough", canplaythrough, false);

    audio.addEventListener("ended", function ()
    {
        outPlaying.set(false);
        playing = false;
        outEnded.trigger();
        if (doLoop.get()) play();
    }, false);
};


};

Ops.Html.AudioMediaElement.prototype = new CABLES.Op();
CABLES.OPS["82c14cd9-e2e7-4944-a04e-cca1bf3ed63e"]={f:Ops.Html.AudioMediaElement,objName:"Ops.Html.AudioMediaElement"};




// **************************************************************
// 
// Ops.Html.BackgroundImage_v2
// 
// **************************************************************

Ops.Html.BackgroundImage_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEle = op.inObject("Element"),
    active = op.inValueBool("active", true),
    filename = op.inUrl("image file"),
    inSize = op.inValueSelect("Size", ["auto", "length", "cover", "contain", "initial", "inherit", "75%", "50%", "40%", "30%", "25%", "20%", "10%"], "cover"),
    inRepeat = op.inValueSelect("Repeat", ["no-repeat", "repeat", "repeat-x", "repeat-y"], "no-repeat"),
    inPosition = op.inValueSelect("Position", ["left top", "left center", "left bottom", "right top", "right center", "right bottom", "center top", "center center", "center bottom"], "center center"),
    outEle = op.outObject("HTML Element");

op.onLoadedValueSet =
op.onLoaded =
inPosition.onChange =
inSize.onChange =
inEle.onChange =
inRepeat.onChange =
active.onChange =
filename.onChange = update;

let ele = null;
let cacheBust = null;

op.onFileChanged = function (fn)
{
    if (filename.get() && filename.get().indexOf(fn) > -1)
    {
        if (ele)ele.style["background-image"] = "none";
        cacheBust = CABLES.uuid();
        update();
    }
};

function remove()
{
    if (ele)
    {
        ele.style["background-image"] = "none";
        ele.style["background-size"] = "initial";
        ele.style["background-position"] = "initial";
        ele.style["background-repeat"] = "initial";
    }
}

function update()
{
    if (!inEle.get())
    {
        remove();
        return;
    }

    op.setUiAttrib({ "extendTitle": CABLES.basename(filename.get()) });

    ele = inEle.get();

    if (ele && ele.style && filename.get())
    {
        if (!active.get())
        {
            ele.style["background-image"] = "none";
        }
        else
        {
            let cb = "";
            if (cacheBust)cb = "?cb=" + cacheBust;

            ele.style["background-image"] = "url(" + op.patch.getFilePath(String(filename.get())) + cb + ")";
            ele.style["background-size"] = inSize.get();
            ele.style["background-position"] = inPosition.get();
            ele.style["background-repeat"] = inRepeat.get();
        }
    }
    // else
    // {
    //     // really needed ?
    //     setTimeout(update,100);
    // }

    outEle.set(inEle.get());
}


};

Ops.Html.BackgroundImage_v2.prototype = new CABLES.Op();
CABLES.OPS["081c4328-984d-4acd-8758-5d1379cc3a30"]={f:Ops.Html.BackgroundImage_v2,objName:"Ops.Html.BackgroundImage_v2"};




// **************************************************************
// 
// Ops.Html.BrowserSpecificFile_v2
// 
// **************************************************************

Ops.Html.BrowserSpecificFile_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

// input ports
const chromeFilePort = op.inUrl("Chrome File");
const firefoxFilePort = op.inUrl("Firefox File");
const safariFilePort = op.inUrl("Safari File");
const ieFilePort = op.inUrl("IE <= 11 File");
const edgeFilePort = op.inUrl("Edge File");
const operaFilePort = op.inUrl("Opera File");
const defaultFilePort = op.inUrl("Default File");

// output port
const outFile = op.outString("Browser Specific File");
const detectedBrowserPort = op.outString("Detected Browser");

// change listeners
chromeFilePort.onChange = checkBrowserAndSetOutput;
firefoxFilePort.onChange = checkBrowserAndSetOutput;
safariFilePort.onChange = checkBrowserAndSetOutput;
ieFilePort.onChange = checkBrowserAndSetOutput;
edgeFilePort.onChange = checkBrowserAndSetOutput;
operaFilePort.onChange = checkBrowserAndSetOutput;
defaultFilePort.onChange = checkBrowserAndSetOutput;

const pf = platform;

// functions
const isOpera = pf.name === "Opera" || pf.name === "Opera Mobile";
const isSafari = pf.name === "Safari" || pf.name === "Firefox for iOS";
const isIE = pf.name === "IE" || pf.name === "IE Mobile";
const isEdge = pf.name === "Microsoft Edge";
const isChrome = pf.name === "Chrome" || pf.name === "Chrome Mobile";
const isFirefox = pf.name === "Firefox" || pf.name === "Firefox Mobile";


checkBrowserAndSetOutput();

function checkBrowserAndSetOutput() {
    if(isOpera) {
        outFile.set(operaFilePort.get() || defaultFilePort.get());
    } else if(isFirefox) {
        detectedBrowserPort.set("Firefox");
        outFile.set(firefoxFilePort.get() || defaultFilePort.get());
    } else if(isSafari) {
        detectedBrowserPort.set("Safari");
        outFile.set(safariFilePort.get() || defaultFilePort.get());
    } else if(isIE) {
        detectedBrowserPort.set("IE");
        outFile.set(ieFilePort.get() || defaultFilePort.get());
    } else if(isEdge) {
        detectedBrowserPort.set("Edge");
        outFile.set(edgeFilePort.get() || defaultFilePort.get());
    } else if(isChrome) {
        detectedBrowserPort.set("Chrome");
        outFile.set(chromeFilePort.get() || defaultFilePort.get());
    } else {
        detectedBrowserPort.set(pf.name);
        outFile.set(defaultFilePort.get());
    }
    detectedBrowserPort.set(pf.name);
}


};

Ops.Html.BrowserSpecificFile_v2.prototype = new CABLES.Op();
CABLES.OPS["d6432fde-9bc5-4183-a9be-bd87ffcb5392"]={f:Ops.Html.BrowserSpecificFile_v2,objName:"Ops.Html.BrowserSpecificFile_v2"};




// **************************************************************
// 
// Ops.Html.CSSFilter
// 
// **************************************************************

Ops.Html.CSSFilter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inEle = op.inObject("Element");
const inMethod = op.inValueSelect("method", ["-", "blur", "brightness", "contrast", "grayscale", "hue-rotate", "invert", "opacity", "saturate", "sepia"]);
const inVal = op.inValue("Value");

let suffix = "";
let prefix = "";

inVal.onChange = setValue;
inEle.onChange = setValue;

let oldEle = null;

function getCSSFilterString()
{
    return inMethod.get() + "(" + inVal.get() + suffix + ")";
}

inEle.onLinkChanged = function ()
{
    // remove style when deleting op
    if (inEle.isLinked()) return;

    const ele = oldEle;// inEle.get();

    if (ele && ele.style)
    {
        let filter = ele.style.filter;
        var str = "";

        if (filter && filter.length > 0)
        {
            var str = "";
            let parts = filter.split(" ");
            for (let i = 0; i < parts.length; i++)
            {
                if (parts[i].indexOf(inMethod.get()) == 0)
                    parts[i] = "";
            }

            str = parts.join(" ");
        }
        ele.style.filter = str;
    }
};

function setValue()
{
    const ele = inEle.get();
    let str = "";

    if (ele && ele.style)
    {
        if (ele != oldEle) oldEle = ele;
        let foundMyFilter = false;
        let filter = ele.style.filter;

        if (filter && filter.length > 0)
        {
            let parts = filter.split(" ");
            for (let i = 0; i < parts.length; i++)
            {
                if (parts[i].indexOf(inMethod.get()) == 0)
                {
                    foundMyFilter = true;
                    parts[i] = getCSSFilterString();
                }
            }

            str = parts.join(" ");
        }

        if (!foundMyFilter)
            str += " " + getCSSFilterString();

        ele.style.filter = str;
    }
}

inMethod.onChange = function ()
{
    let m = inMethod.get();

    prefix = inMethod.get() + ":";

    if (m == "blur") suffix = "px";
    if (m == "brightness") suffix = "";
    if (m == "contrast") suffix = "%";
    if (m == "grayscale") suffix = "%";
    if (m == "hue-rotate") suffix = "deg";
    if (m == "invert") suffix = "%";
    if (m == "opacity") suffix = "%";
    if (m == "saturate") suffix = "";
    if (m == "sepia") suffix = "%";
    setValue();
};


};

Ops.Html.CSSFilter.prototype = new CABLES.Op();
CABLES.OPS["33befabf-7eef-45f6-869f-30e0e4f44739"]={f:Ops.Html.CSSFilter,objName:"Ops.Html.CSSFilter"};




// **************************************************************
// 
// Ops.Html.CSSPropertyString
// 
// **************************************************************

Ops.Html.CSSPropertyString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEle = op.inObject("Element"),
    inProperty = op.inString("Property"),
    inValue = op.inString("Value"),
    outEle = op.outObject("HTML Element");

op.setPortGroup("Element", [inEle]);
op.setPortGroup("Attributes", [inProperty, inValue]);

inProperty.onChange = updateProperty;
inValue.onChange = update;
let ele = null;

inEle.onChange = inEle.onLinkChanged = function ()
{
    if (ele && ele.style)
    {
        ele.style[inProperty.get()] = "initial";
    }
    update();
};

function updateProperty()
{
    update();
    op.setUiAttrib({ "extendTitle": inProperty.get() + "" });
}

function update()
{
    ele = inEle.get();
    if (ele && ele.style)
    {
        const str = inValue.get();
        try
        {
            ele.style[inProperty.get()] = str;
        }
        catch (e)
        {
            op.logError(e);
        }
    }

    outEle.set(inEle.get());
}


};

Ops.Html.CSSPropertyString.prototype = new CABLES.Op();
CABLES.OPS["a7abdfb9-4c2a-4ddb-8fc6-55b3fdfbdaf3"]={f:Ops.Html.CSSPropertyString,objName:"Ops.Html.CSSPropertyString"};




// **************************************************************
// 
// Ops.Html.CSSProperty_v2
// 
// **************************************************************

Ops.Html.CSSProperty_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEle = op.inObject("Element"),
    inProperty = op.inString("Property"),
    inValue = op.inFloat("Value"),
    inValueSuffix = op.inString("Value Suffix", "px"),
    outEle = op.outObject("HTML Element");

op.setPortGroup("Element", [inEle]);
op.setPortGroup("Attributes", [inProperty, inValue, inValueSuffix]);

inProperty.onChange = updateProperty;
inValue.onChange = update;
inValueSuffix.onChange = update;
let ele = null;

inEle.onChange = inEle.onLinkChanged = function ()
{
    if (ele && ele.style)
    {
        ele.style[inProperty.get()] = "initial";
    }
    update();
};

function updateProperty()
{
    update();
    op.setUiAttrib({ "extendTitle": inProperty.get() + "" });
}

function update()
{
    ele = inEle.get();
    if (ele && ele.style)
    {
        const str = inValue.get() + inValueSuffix.get();
        try
        {
            if (ele.style[inProperty.get()] != str)
                ele.style[inProperty.get()] = str;
        }
        catch (e)
        {
            op.logError(e);
        }
    }
    else
    {
        setTimeout(update, 50);
    }

    outEle.set(inEle.get());
}


};

Ops.Html.CSSProperty_v2.prototype = new CABLES.Op();
CABLES.OPS["c179aa0e-b558-4130-8c2d-2deab2919a07"]={f:Ops.Html.CSSProperty_v2,objName:"Ops.Html.CSSProperty_v2"};




// **************************************************************
// 
// Ops.Html.CSS_v2
// 
// **************************************************************

Ops.Html.CSS_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const code = op.inStringEditor("css code");

code.setUiAttribs(
    {
        "editorSyntax": "css",
        "ignoreBigPort": true
    });

let styleEle = null;
const eleId = "css_" + CABLES.uuid();

code.onChange = update;
update();

function getCssContent()
{
    let css = code.get();
    if (css)
    {
        let patchId = null;
        if (op.storage && op.storage.blueprint && op.storage.blueprint.patchId)
        {
            patchId = op.storage.blueprint.patchId;
        }
        css = css.replace(new RegExp("{{ASSETPATH}}", "g"), op.patch.getAssetPath(patchId));
    }
    return css;
}

function update()
{
    styleEle = document.getElementById(eleId);

    if (styleEle)
    {
        styleEle.textContent = getCssContent();
    }
    else
    {
        styleEle = document.createElement("style");
        styleEle.type = "text/css";
        styleEle.id = eleId;
        styleEle.textContent = attachments.css_spinner;

        const head = document.getElementsByTagName("body")[0];
        head.appendChild(styleEle);
    }
}

op.onDelete = function ()
{
    styleEle = document.getElementById(eleId);
    if (styleEle)styleEle.remove();
};


};

Ops.Html.CSS_v2.prototype = new CABLES.Op();
CABLES.OPS["a56d3edd-06ad-44ed-9810-dbf714600c67"]={f:Ops.Html.CSS_v2,objName:"Ops.Html.CSS_v2"};




// **************************************************************
// 
// Ops.Html.CablesLink
// 
// **************************************************************

Ops.Html.CablesLink = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let size = op.inValue("size", 40);
let opacity = op.inValue("Opacity", 0.5);

let element = document.createElement("div");

size.onChange = function ()
{
    element.style.width = size.get() + "px";
    element.style.height = size.get() + "px";
};

opacity.onChange = function ()
{
    element.style.opacity = opacity.get();
};

element.style.padding = "10px";
element.style = "cableslink";
element.style.position = "absolute";
element.style.right = "0px";
element.style.bottom = "0px";
element.style.width = "40px";
element.style.height = "40px";
element.style.opacity = "0.4";
element.style.cursor = "pointer";
element.style["background-image"] = "url(https://cables.gl/img/cables-logo.svg)";
element.style["z-index"] = "9999";
element.style["background-size"] = "80%";
element.style["background-repeat"] = "no-repeat";

let canvas = op.patch.cgl.canvas.parentElement;
canvas.appendChild(element);

element.addEventListener("click", function ()
{
    document.location.href = "https://cables.gl";
});

op.onDelete = function ()
{
    element.remove();
};


};

Ops.Html.CablesLink.prototype = new CABLES.Op();
CABLES.OPS["aba114d1-b042-484a-9b66-a9bfe6590b3d"]={f:Ops.Html.CablesLink,objName:"Ops.Html.CablesLink"};




// **************************************************************
// 
// Ops.Html.Cursor_v2
// 
// **************************************************************

Ops.Html.Cursor_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTriggerButton("Update"),

    cursorPort = op.inDropDown("CSS Cursors", ["auto", "crosshair", "pointer", "hand", "move", "n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize", "ew-resize", "text", "wait", "help", "none"], "pointer"),

    next = op.outTrigger("Next");

const cursorStr = "";

exec.onLinkChanged =
next.onLinkChanged = () =>
{
    op.patch.cgl.setCursor("auto");
};

exec.onTriggered = () =>
{
    op.patch.cgl.setCursor(cursorPort.get());
    next.trigger();
};


};

Ops.Html.Cursor_v2.prototype = new CABLES.Op();
CABLES.OPS["39486799-bdad-42d3-a300-4642c23578a8"]={f:Ops.Html.Cursor_v2,objName:"Ops.Html.Cursor_v2"};




// **************************************************************
// 
// Ops.Html.DivElement_v2
// 
// **************************************************************

Ops.Html.DivElement_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inText = op.inString("Text", "Hello Div"),
    inId = op.inString("Id"),
    inClass = op.inString("Class"),
    inStyle = op.inValueEditor("Style", "position:absolute;\nz-index:100;", "inline-css"),
    inInteractive = op.inValueBool("Interactive", false),
    inVisible = op.inValueBool("Visible", true),
    inBreaks = op.inValueBool("Convert Line Breaks", false),
    inPropagation = op.inValueBool("Propagate Click-Events", true),
    outElement = op.outObject("DOM Element", null, "element"),
    outHover = op.outBoolNum("Hover"),
    outClicked = op.outTrigger("Clicked");

let listenerElement = null;
let oldStr = null;
let prevDisplay = "block";
let div = null;

const canvas = op.patch.cgl.canvas.parentElement;

createElement();

inClass.onChange = updateClass;
inBreaks.onChange = inText.onChange = updateText;
inStyle.onChange = updateStyle;
inInteractive.onChange = updateInteractive;
inVisible.onChange = updateVisibility;

updateText();
updateStyle();
warning();
updateInteractive();

op.onDelete = removeElement;

outElement.onLinkChanged = updateStyle;

function createElement()
{
    div = document.createElement("div");
    div.dataset.op = op.id;
    div.classList.add("cablesEle");

    if (inId.get()) div.id = inId.get();

    canvas.appendChild(div);
    outElement.set(div);
}

function removeElement()
{
    if (div) removeClasses();
    if (div && div.parentNode) div.parentNode.removeChild(div);
    oldStr = null;
    div = null;
}

function setCSSVisible(visible)
{
    if (!visible)
    {
        div.style.visibility = "hidden";
        prevDisplay = div.style.display || "block";
        div.style.display = "none";
    }
    else
    {
        // prevDisplay=div.style.display||'block';
        if (prevDisplay == "none") prevDisplay = "block";
        div.style.visibility = "visible";
        div.style.display = prevDisplay;
    }
}

function updateVisibility()
{
    setCSSVisible(inVisible.get());
}

function updateText()
{
    let str = inText.get();

    if (oldStr === str) return;
    oldStr = str;

    if (str && inBreaks.get()) str = str.replace(/(?:\r\n|\r|\n)/g, "<br>");

    if (div.innerHTML != str) div.innerHTML = str;
    outElement.set(null);
    outElement.set(div);
}

// inline css inisde div
function updateStyle()
{
    if (!div) return;
    // if (inStyle.get() != div.style)
    // {
    div.setAttribute("style", inStyle.get());
    updateVisibility();
    outElement.set(null);
    outElement.set(div);
    // }

    if (!div.parentElement)
    {
        canvas.appendChild(div);
    }

    warning();
}

let oldClassesStr = "";

function removeClasses()
{
    if (!div) return;

    const classes = (inClass.get() || "").split(" ");
    for (let i = 0; i < classes.length; i++)
    {
        if (classes[i]) div.classList.remove(classes[i]);
    }
    oldClassesStr = "";
}

function updateClass()
{
    const classes = (inClass.get() || "").split(" ");
    const oldClasses = (oldClassesStr || "").split(" ");

    let found = false;

    for (let i = 0; i < oldClasses.length; i++)
    {
        if (
            oldClasses[i] &&
            classes.indexOf(oldClasses[i].trim()) == -1)
        {
            found = true;
            div.classList.remove(oldClasses[i]);
        }
    }

    for (let i = 0; i < classes.length; i++)
    {
        if (classes[i])
        {
            div.classList.add(classes[i].trim());
        }
    }

    oldClassesStr = inClass.get();
    warning();
}

function onMouseEnter(e)
{
    outHover.set(true);
}

function onMouseLeave(e)
{
    outHover.set(false);
}

function onMouseClick(e)
{
    if (!inPropagation.get())
    {
        e.stopPropagation();
    }
    outClicked.trigger();
}

function updateInteractive()
{
    removeListeners();
    if (inInteractive.get()) addListeners();
}

inId.onChange = function ()
{
    div.id = inId.get();
};

function removeListeners()
{
    if (listenerElement)
    {
        listenerElement.removeEventListener("pointerdown", onMouseClick);
        listenerElement.removeEventListener("pointerleave", onMouseLeave);
        listenerElement.removeEventListener("pointerenter", onMouseEnter);
        listenerElement = null;
    }
}

function addListeners()
{
    if (listenerElement)removeListeners();

    listenerElement = div;

    if (listenerElement)
    {
        listenerElement.addEventListener("pointerdown", onMouseClick);
        listenerElement.addEventListener("pointerleave", onMouseLeave);
        listenerElement.addEventListener("pointerenter", onMouseEnter);
    }
}

op.addEventListener("onEnabledChange", function (enabled)
{
    removeElement();
    if (enabled)
    {
        createElement();
        updateStyle();
        updateClass();
        updateText();
        updateInteractive();
    }
    // if(enabled) updateVisibility();
    // else setCSSVisible(false);
});

function warning()
{
    if (inClass.get() && inStyle.get())
    {
        op.setUiError("error", "DIV uses external and inline CSS", 1);
    }
    else
    {
        op.setUiError("error", null);
    }
}


};

Ops.Html.DivElement_v2.prototype = new CABLES.Op();
CABLES.OPS["db36db6d-83e4-4d27-b84c-8a20067aaffc"]={f:Ops.Html.DivElement_v2,objName:"Ops.Html.DivElement_v2"};




// **************************************************************
// 
// Ops.Html.ElementChilds_v2
// 
// **************************************************************

Ops.Html.ElementChilds_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    parentPort = op.inObject("Parent", null, "element"),
    outParent = op.outObject("Parent Out", null, "element");

const canvas = op.patch.cgl.canvas.parentElement;

const inPorts = [];
for (let i = 0; i < 10; i++)
{
    const p = op.inObject("Child " + (i + 1));
    inPorts.push(p);
    p.onChange = () =>
    {
        rebuild();
        if (!p.get())
        {
            const selector = "[data-cables-child-id='" + op.id + "_" + i + "']";
            const currentChild = canvas.querySelector(selector);
            if (currentChild) delete currentChild.dataset.cablesChildId;
        }
    };
    p.onLinkChanged = () =>
    {
        if (!p.isLinked())
        {
            const selector = "[data-cables-child-id='" + op.id + "_" + i + "']";
            const currentChild = canvas.querySelector(selector);
            if (currentChild) currentChild.remove();
        }
    };
}

parentPort.onLinkChanged = () =>
{
    if (!parentPort.isLinked())
    {
        cleanUp();
    }
    else
    {
        rebuild();
    }
};

outParent.onLinkChanged = () =>
{
    if (!outParent.isLinked())
    {
        const parentDiv = parentPort.get();
        if (parentDiv && parentDiv.dataset.op)
        {
            const inDoc = canvas.querySelector("[data-op=' " + parentDiv.dataset.op + " ']");
            if (!inDoc)
            {
                canvas.appendChild(parentDiv);
            }
        }
    }
};

parentPort.onChange = () =>
{
    if (!parentPort.get())
    {
        cleanUp();
    }
    rebuild();
};

function cleanUp()
{
    for (let i = 0; i < inPorts.length; i++)
    {
        const selector = "[data-cables-child-id='" + op.id + "_" + i + "']";
        const currentChild = canvas.querySelector(selector);
        if (currentChild && currentChild.parentNode)
        {
            currentChild.remove();
        }
    }
    outParent.set(null);
}

function rebuild()
{
    const parent = parentPort.get();
    if (!parent)
    {
        outParent.set(null);
        return;
    }


    if (!parent.querySelector)
    {
        outParent.set(null);
        return;
    }

    for (let i = 0; i < inPorts.length; i++)
    {
        const selector = "[data-cables-child-id='" + op.id + "_" + i + "']";
        const currentChild = parent.querySelector(selector);
        if (currentChild)
        {
            currentChild.remove();
        }
        const p = inPorts[i].get();
        if (p && parent)
        {
            p.dataset.cablesChildId = op.id + "_" + i;
            parent.appendChild(p);
        }
    }

    outParent.set(null);
    outParent.set(parent);
}


};

Ops.Html.ElementChilds_v2.prototype = new CABLES.Op();
CABLES.OPS["ad7eea9a-f4af-4ab7-bb70-922242529681"]={f:Ops.Html.ElementChilds_v2,objName:"Ops.Html.ElementChilds_v2"};




// **************************************************************
// 
// Ops.Html.ElementClientRect
// 
// **************************************************************

Ops.Html.ElementClientRect = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpd=op.inTriggerButton("Update"),
    inEle=op.inObject("Element",null,"element"),
    outWidth=op.outNumber("Width"),
    outHeight=op.outNumber("Height"),
    outX=op.outNumber("X"),
    outY=op.outNumber("Y");

inUpd.onTriggered=()=>
{
    let ele=inEle.get();
    if(!ele)
    {
        outX.set(0);
        outY.set(0);
        outWidth.set(0);
        outHeight.set(0);
        return;
    }
    const r=ele.getBoundingClientRect();
    const rCanv=op.patch.cgl.canvas.getBoundingClientRect();

    outX.set(r.left-rCanv.left);
    outY.set(r.top-rCanv.top);
    outWidth.set(r.width);
    outHeight.set(r.height);

};


};

Ops.Html.ElementClientRect.prototype = new CABLES.Op();
CABLES.OPS["7a046f98-2adc-4f8e-ad47-c600e3ef5bca"]={f:Ops.Html.ElementClientRect,objName:"Ops.Html.ElementClientRect"};




// **************************************************************
// 
// Ops.Html.ElementCssTransform
// 
// **************************************************************

Ops.Html.ElementCssTransform = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEle = op.inObject("Element", null, "element"),
    inDoTranslate = op.inBool("Translate Active", true),
    inTransX = op.inFloat("Translate X", 0),
    inTransY = op.inFloat("Translate Y", 0),
    inTransUnit = op.inSwitch("Unit", ["px", "%"], "px"),

    inDoScale = op.inBool("Scale Active", true),
    inScale = op.inFloat("Scale", 1),

    inDoRot = op.inBool("Rotate Active", true),
    inRot = op.inFloat("Rot Z", 0),

    inDoOrigin = op.inBool("Set Origin", true),
    inOriginX = op.inSwitch("Origin X", ["left", "center", "right"], "center"),
    inOriginY = op.inSwitch("Origin Y", ["top", "center", "bottom"], "center");

op.setPortGroup("Element", [inEle]);
op.setPortGroup("Translation", [inDoTranslate, inTransY, inTransX, inTransUnit]);
op.setPortGroup("Scaling", [inScale, inDoScale]);
op.setPortGroup("Rotation", [inDoRot, inRot]);
op.setPortGroup("Origin", [inDoOrigin, inOriginX, inOriginY]);

inTransUnit.onChange =
    inDoScale.onChange =
    inDoOrigin.onChange =
    inOriginX.onChange =
    inOriginY.onChange =
    inDoRot.onChange =
    inDoTranslate.onChange =
    inDoRot.onChange =
    inTransX.onChange =
    inTransY.onChange =
    inScale.onChange =
    inRot.onChange = update;

let ele = null;

inEle.onChange = inEle.onLinkChanged = function ()
{
    if (ele && ele.style)
    {
        ele.style.transform = "initial";
    }
    update();
};

function update()
{
    ele = inEle.get();
    if (ele && ele.style)
    {
        let str = "";

        if (inDoTranslate.get())
            if (inTransY.get() || inTransX.get())
                str += "translate(" + inTransX.get() + inTransUnit.get() + " , " + inTransY.get() + inTransUnit.get() + ") ";

        if (inDoScale.get())
            if (inScale.get() != 1.0)
                str += "scale(" + inScale.get() + ") ";

        if (inDoRot.get())
            if (inRot.get() != 0.0)
                str += "rotateZ(" + inRot.get() + "deg) ";

        try
        {
            ele.style.transform = str;

            if (inDoOrigin.get())
                ele.style["transform-origin"] = inOriginY.get() + " " + inOriginX.get();
            else
                ele.style["transform-origin"] = "initial";
        }
        catch (e)
        {
            op.logError(e);
        }
    }
    else
    {
        setTimeout(update, 50);
    }

    // outEle.set(inEle.get());
}


};

Ops.Html.ElementCssTransform.prototype = new CABLES.Op();
CABLES.OPS["777d00c6-5605-43c5-9b6a-b20d465bd3ba"]={f:Ops.Html.ElementCssTransform,objName:"Ops.Html.ElementCssTransform"};




// **************************************************************
// 
// Ops.Html.ElementFadeInOut
// 
// **************************************************************

Ops.Html.ElementFadeInOut = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"fadeInOut_css":"\n.CABLES_animFadedOut\n{\n    display:none !important;\n    opacity:0;\n}\n\n.CABLES_animFadeOut\n{\n    animation: CABLES_keysFadeOut $LENGTHs normal forwards ease-in-out;\n}\n\n.CABLES_animFadeIn\n{\n    /*display:block;*/\n    animation: CABLES_keysFadeIn $LENGTHs normal forwards ease-in-out;\n}\n\n@keyframes CABLES_keysFadeIn {\n    from { opacity: 0; }\n    to   { opacity: $FULLOPACITY; }\n}\n\n@keyframes CABLES_keysFadeOut {\n    from { opacity: $FULLOPACITY; }\n    to   { opacity: 0; }\n}\n",};
const inEle = op.inObject("HTML Element");
const inVisible = op.inValueBool("Visible", true);
const inDuration = op.inValue("Duration", 0.5);
const inOpacity = op.inValue("Opacity", 1);
const outShowing = op.outBoolNum("Is Showing", false);

let theTimeout = null;
inDuration.onChange = update;
inOpacity.onChange = update;

inVisible.onChange = updateVisibility;
inEle.onChange = updateVisibility;

let styleEle = null;
const eleId = "css_" + CABLES.uuid();

update();

let oldEle = null;
let loaded = true;
const oldvis = null;
loaded = true;

op.onLoaded = function ()
{
    loaded = true;
    updateVisibility();
    outShowing.set(inVisible.get());
};

function updateVisibility()
{
    const ele = inEle.get();

    if (!loaded)
    {
        setTimeout(updateVisibility, 50);
        return;
    }

    if (styleEle && ele)
    {
        // if (ele == oldEle) return;
        // oldEle = ele;
        if (inVisible.get())
        {
            outShowing.set(true);
            if (ele && ele.classList && !ele.classList.contains("CABLES_animFadeIn"))
            {
                clearTimeout(theTimeout);
                ele.classList.remove("CABLES_animFadedOut");
                ele.classList.remove("CABLES_animFadeOut");
                ele.classList.add("CABLES_animFadeIn");
                theTimeout = setTimeout(function ()
                {
                    ele.classList.remove("CABLES_animFadeIn");
                    outShowing.set(true);
                }, inDuration.get() * 1000);
            }
        }
        else
        {
            outShowing.set(true);
            if (ele && ele.classList && !ele.classList.contains("CABLES_animFadeOut"))
            {
                clearTimeout(theTimeout);
                ele.classList.remove("CABLES_animFadeIn");
                ele.classList.add("CABLES_animFadeOut");
                theTimeout = setTimeout(function ()
                {
                    ele.classList.add("CABLES_animFadedOut");
                    outShowing.set(false);
                }, inDuration.get() * 1000);
            }
        }
    }
    else
    {
        // op.logError("no html element");
    }
}

function getCssContent()
{
    let css = attachments.fadeInOut_css;

    while (css.indexOf("$LENGTH") > -1)css = css.replace("$LENGTH", inDuration.get());
    while (css.indexOf("$FULLOPACITY") > -1)css = css.replace("$FULLOPACITY", inOpacity.get());

    return css;
}

function update()
{
    styleEle = document.getElementById(eleId);

    if (styleEle)
    {
        styleEle.textContent = getCssContent();
    }
    else
    {
        styleEle = document.createElement("style");
        styleEle.type = "text/css";
        styleEle.id = eleId;
        styleEle.textContent = getCssContent();

        const head = document.getElementsByTagName("body")[0];
        head.appendChild(styleEle);
    }
}

op.onDelete = function ()
{
    const ele = inEle.get();

    if (ele && ele.classList)
    {
        ele.classList.remove("CABLES_animFadeIn");
        ele.classList.remove("CABLES_animFadedOut");
        ele.classList.remove("CABLES_animFadeOut");
    }

    styleEle = document.getElementById(eleId);
    if (styleEle)styleEle.remove();
};


};

Ops.Html.ElementFadeInOut.prototype = new CABLES.Op();
CABLES.OPS["392e65eb-4ebe-4adb-8711-e4cfe059c6c9"]={f:Ops.Html.ElementFadeInOut,objName:"Ops.Html.ElementFadeInOut"};




// **************************************************************
// 
// Ops.Html.ElementInteraction
// 
// **************************************************************

Ops.Html.ElementInteraction = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEle = op.inObject("Element"),
    inAct = op.inBool("Active", true),
    outIsDownLeft = op.outBool("Mouse Is Down Left"),
    outIsDownRight = op.outBool("Mouse Is Down Right"),
    outDownLeft = op.outTrigger("Mouse Down Left"),
    outDownRight = op.outTrigger("Mouse Down Right"),
    outUpLeft = op.outTrigger("Mouse Up Left"),
    outUpRight = op.outTrigger("Mouse Up Right"),
    outOver = op.outBool("Mouse Over"),
    outEnter = op.outTrigger("Mouse Enter"),
    outLeave = op.outTrigger("Mouse Leave"),
    outPosX = op.outNumber("Offset X"),
    outPosY = op.outNumber("Offset Y");

let ele = null;

inEle.onChange = () =>
{
    const el = inEle.get();

    if (el) addListeners(el);
    else removeListeners();
};

function addListeners(el)
{
    ele = el;

    ele.addEventListener("pointerenter", onEnter);
    ele.addEventListener("pointerleave", onLeave);
    ele.addEventListener("pointermove", onMove);
    ele.addEventListener("pointerdown", onDown);
    ele.addEventListener("pointerup", onUp);
    // ele.addEventListener("touchstart",onDown);
}

function removeListeners()
{
    if (!ele) return;
    ele.removeEventListener("pointerenter", onEnter);
    ele.removeEventListener("pointerleave", onLeave);
    ele.removeEventListener("pointermove", onMove);
    ele.removeEventListener("pointerdown", onDown);
    ele.removeEventListener("pointerup", onUp);
    // ele.removeEventListener("touchstart",onDown);
}

function onMove(e)
{
    outPosX.set(e.offsetX);
    outPosY.set(e.offsetY);
    outIsDownLeft.set(e.buttons == 1);
    outIsDownRight.set(e.buttons == 2);
}

function onDown(e)
{
    outPosX.set(e.offsetX);
    outPosY.set(e.offsetY);

    if (e.buttons == 1)outDownLeft.trigger();
    if (e.buttons == 2)outDownRight.trigger();

    ele.setPointerCapture(e.pointerId);

    outIsDownLeft.set(e.buttons == 1);
    outIsDownRight.set(e.buttons == 2);
}

function onUp(e)
{
    outPosX.set(e.offsetX);
    outPosY.set(e.offsetY);

    ele.releasePointerCapture(e.pointerId);

    if (e.buttons == 1)outUpLeft.trigger();
    if (e.buttons == 2)outUpRight.trigger();
    outIsDownRight.set(false);
    outIsDownLeft.set(false);
}

function onEnter()
{
    outEnter.trigger();
    outOver.set(true);
}

function onLeave()
{
    outLeave.trigger();
    outIsDownLeft.set(false);
    outOver.set(false);
}


};

Ops.Html.ElementInteraction.prototype = new CABLES.Op();
CABLES.OPS["bc2903a0-ee7f-4918-b1d8-ea3a6262e3ee"]={f:Ops.Html.ElementInteraction,objName:"Ops.Html.ElementInteraction"};




// **************************************************************
// 
// Ops.Html.ElementSize
// 
// **************************************************************

Ops.Html.ElementSize = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExe=op.inTrigger("Update"),
    inMode=op.inSwitch("Position",['Relative','Absolute'],'Relative'),
    inEle=op.inObject("Element"),
    outX=op.outNumber("x"),
    outY=op.outNumber("y"),
    outWidth=op.outNumber("Width"),
    outHeight=op.outNumber("Height");

inMode.onChange=updateMode;
updateMode();

function updateMode()
{
    if(inMode.get()=="Relative")
    {
        inEle.onChange=updateRel;
        inExe.onTriggered=updateRel;
    }
    else
    {
        inEle.onChange=updateAbs;
        inExe.onTriggered=updateAbs;
    }
}

function updateAbs()
{
    const ele=inEle.get();
    if(!ele)return;

    const r=ele.getBoundingClientRect();

    outX.set(r.x);
    outY.set(r.y);
    outWidth.set(r.width);
    outHeight.set(r.height);
}

function updateRel()
{
    const ele=inEle.get();
    if(!ele)return;

    const rcanv=op.patch.cgl.canvas.getBoundingClientRect();
    const r=ele.getBoundingClientRect();
    outX.set(r.x-rcanv.x);
    outY.set(r.y-rcanv.y);
    outWidth.set(r.width);
    outHeight.set(r.height);
}

};

Ops.Html.ElementSize.prototype = new CABLES.Op();
CABLES.OPS["fb23c251-a43e-4677-9d03-ccd512fee82e"]={f:Ops.Html.ElementSize,objName:"Ops.Html.ElementSize"};




// **************************************************************
// 
// Ops.Html.ElementsPositionsByClass
// 
// **************************************************************

Ops.Html.ElementsPositionsByClass = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpd=op.inTriggerButton("Update"),
    inClassName=op.inString("Classname",""),
    outPosArr=op.outArray("Position"),
    outSizeArr=op.outArray("Size");

inUpd.onTriggered=()=>
{
    outPosArr.set(null);
    outSizeArr.set(null);

    const arrPos=[];
    const arrSize=[];

    const els=document.getElementsByClassName(inClassName.get());
    const rCanv=op.patch.cgl.canvas.getBoundingClientRect();

    for(let i=0;i<els.length;i++)
    {
        // inClassName.get();
        let ele=els[i];
        const r=ele.getBoundingClientRect();

        arrPos.push(r.left-rCanv.left,r.top-rCanv.top,0);
        arrSize.push(r.width,r.height,1);

    }
    outPosArr.set(arrPos);
    outSizeArr.set(arrSize);

    // outX.set(r.left-rCanv.left);
    // outY.set(r.top-rCanv.top);
    // outWidth.set(r.width);
    // outHeight.set(r.height);

};


};

Ops.Html.ElementsPositionsByClass.prototype = new CABLES.Op();
CABLES.OPS["43cf60ec-1a62-4bd0-98ee-2aa85681020f"]={f:Ops.Html.ElementsPositionsByClass,objName:"Ops.Html.ElementsPositionsByClass"};




// **************************************************************
// 
// Ops.Html.Event.CustomEventListener
// 
// **************************************************************

Ops.Html.Event.CustomEventListener = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// constants
let EVENT_NAME_DEFAULT = "";
let USE_CAPTURE_DEFAULT = false;
let PREVENT_DEFAULT_DEFAULT = true;
let STOP_PROPAGATION_DEFAULT = true;

// variables
let lastElement = null; // stores the last connected element, so we can remove prior event listeners
let lastEventName = EVENT_NAME_DEFAULT;
let lastUseCapture = USE_CAPTURE_DEFAULT;

// inputs
let elementPort = op.inObject("Element");
let eventNamePort = op.inValueString("Event Name", EVENT_NAME_DEFAULT);
let useCapturePort = op.inValueBool("Use Capture", USE_CAPTURE_DEFAULT);
let preventDefaultPort = op.inValueBool("Prevent Default", PREVENT_DEFAULT_DEFAULT);
let stopPropagationPort = op.inValueBool("Stop Propagation", STOP_PROPAGATION_DEFAULT);

// outputs
let triggerPort = op.outTrigger("Event Trigger");
let eventObjPort = op.outObject("Event Object");

// change listeners
elementPort.onChange = update;
eventNamePort.onChange = update;
useCapturePort.onChange = update;

function update()
{
    let element = elementPort.get();
    let eventName = eventNamePort.get();
    let useCapture = useCapturePort.get();
    removeListener();
    addListener(element, eventName, useCapture);
    lastElement = element;
    lastEventName = eventName;
    lastUseCapture = useCapture;
}

function removeListener()
{
    if (lastElement && lastEventName)
    {
        lastElement.removeEventListener(lastEventName, handleEvent, lastUseCapture);
    }
}

function addListener(el, name, useCapture)
{
    if (el && name)
    {
        el.addEventListener(name, handleEvent, useCapture);
    }
}

function handleEvent(ev)
{
    eventObjPort.set(ev);
    if (preventDefaultPort.get()) { ev.preventDefault(); }
    if (stopPropagationPort.get()) { ev.stopPropagation(); }
    triggerPort.trigger();
}


};

Ops.Html.Event.CustomEventListener.prototype = new CABLES.Op();
CABLES.OPS["0e299bb2-d9e8-4b95-9dd5-ad730c26a791"]={f:Ops.Html.Event.CustomEventListener,objName:"Ops.Html.Event.CustomEventListener"};




// **************************************************************
// 
// Ops.Html.Event.PreventDefault
// 
// **************************************************************

Ops.Html.Event.PreventDefault = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
let executePort = op.inTriggerButton("Execute");
executePort.onTriggered = update;
let eventInPort = op.inObject("Event In");

// outputs
let nextPort = op.outTrigger("Next");
let eventOutPort = op.outObject("Event Out");

function update()
{
    let event = eventInPort.get();
    if (event && event.preventDefault)
    {
        event.preventDefault();
    }
    eventOutPort.set(event);
    nextPort.trigger();
}


};

Ops.Html.Event.PreventDefault.prototype = new CABLES.Op();
CABLES.OPS["f5eaa284-2c01-4f1d-ab12-7f392bbbcadf"]={f:Ops.Html.Event.PreventDefault,objName:"Ops.Html.Event.PreventDefault"};




// **************************************************************
// 
// Ops.Html.Event.StopPropagation
// 
// **************************************************************

Ops.Html.Event.StopPropagation = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
let executePort = op.inTriggerButton("Execute");
executePort.onTriggered = update;
let eventInPort = op.inObject("Event In");

// outputs
let nextPort = op.outTrigger("Next");
let eventOutPort = op.outObject("Event Out");

function update()
{
    let event = eventInPort.get();
    if (event && event.stopPropagation)
    {
        event.stopPropagation();
        op.log("Stopped Propa", event);
    }
    eventOutPort.set(event);
    nextPort.trigger();
}


};

Ops.Html.Event.StopPropagation.prototype = new CABLES.Op();
CABLES.OPS["8a0f1c05-3ed7-4d50-b8ec-e8298050988d"]={f:Ops.Html.Event.StopPropagation,objName:"Ops.Html.Event.StopPropagation"};




// **************************************************************
// 
// Ops.Html.EventListener
// 
// **************************************************************

Ops.Html.EventListener = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// variables
let lastElement = null; // stores the last connected element, so we can remove prior event listeners
let subscribedEvents = []; // array of event-names the currrent element is subscribed to

/**
 * events to subscribe to
 * displayName is used for the port names
 * will later hold the trigger port and handler-function,
 * e.g. { name: 'mousedown', displayName: 'Mouse Down', port: ..., handler: ... }
 */
let events = [
    {
        "name": "mousedown",
        "displayName": "Mouse Down"
    },
    {
        "name": "mouseup",
        "displayName": "Mouse Up"
    },
    {
        "name": "click",
        "displayName": "Click"
    },
    {
        "name": "mousemove",
        "displayName": "Mouse Move"
    },
    {
        "name": "touchstart",
        "displayName": "Touch Start"
    },
    {
        "name": "touchmove",
        "displayName": "Touch Move"
    },
    {
        "name": "touchend",
        "displayName": "Touch End"
    },
    {
        "name": "touchcancel",
        "displayName": "Touch Cancel"
    },
];

/**
 * Creates an event handler function
 * @param {object} event an element of the events array (see top)
 */
function handlerFactory(event)
{
    function handleEvent(ev)
    {
        eventPort.set(ev); // set the event object port
        eventNamePort.set(ev.type);
        ev.preventDefault(); // TODO: maybe add a toggle for every event. but then we need port-groups...
        event.port.trigger(); // trigger the appropriate port
    }

    return handleEvent;
}

/**
 * Creates an event handler for the active (bool) ports
 */
function toggleHandlerFactory(event)
{
    function onToggleChange(port, isActive)
    {
        if (isActive)
        {
            addListener(elementPort.get(), event);
        }
        else
        {
            removeListener(elementPort.get(), event.name);
        }
    }

    return onToggleChange;
}

/**
 * Creates a trigger port for each event type, add the port to the events object-array
 */
function createPorts()
{
    events.forEach(function (event)
    {
        event.port = op.outTrigger(event.displayName);
        event.handler = handlerFactory(event);
        event.togglePort = op.inValueBool(event.displayName + " Active", true);
        event.togglePort.onChange = toggleHandlerFactory(event);
    });
    op.log(events);
}

// ports
let elementPort = op.inObject("Dom Element");
elementPort.onChange = onElementChanged;
let eventPort = op.outObject("Event Object");
createPorts();
let eventNamePort = op.outString("Event Name");

/**
 * Called when element port (DOM elemenet) changed
 */
function onElementChanged()
{
    let element = elementPort.get();
    if (lastElement !== element)
    {
        removeAllListeners(lastElement);
    }
    if (element)
    {
        addListeners(element);
    }
    checkListeners(element);
    lastElement = element;
}

/**
 * Checks all toggle-ports and adds / removes listeners accordingly
 */
function checkListeners(element)
{
    events.forEach(function (event)
    {
        if (event.togglePort.get())
        {
            addListener(element, event);
        }
        else
        {
            removeListener(element, event.name);
        }
    });
}

/**
 * Removes all listeners added by this op for the element
 */
function removeAllListeners(element)
{
    if (element)
    {
        for (let i = subscribedEvents.length - 1; i >= 0; i--)
        {
            removeListener(element, subscribedEvents[i]);
        }
    }
}

function removeListener(element, eventName)
{
    if (!element || !eventName || !arrayContainsValue(subscribedEvents, eventName)) { return; }
    let subscribedEventIndex = subscribedEvents.indexOf(eventName);
    element.removeEventListener(eventName, getEventByName(eventName).handler);
    subscribedEvents.splice(subscribedEventIndex, 1);
}

/*
function removeFromArray(arr, v) {
    let i = arr.indexOf(v);
    if(i > -1) {
        arr.splice(i, 1);
    }
}
*/

function arrayContainsValue(arr, v)
{
    return arr && arr.indexOf(v) > -1;
}

/**
 * Returns an event-object from the events array
 * @param {string} name e.g. 'mousedown'
 */
function getEventByName(eventName)
{
    for (let i = 0; i < events.length; i++)
    {
        if (events[i].name == eventName)
        {
            return events[i];
        }
    }
    return null;
}

/**
 * Adds all listeners to the element and saves it in the events array
 */
function addListeners(element)
{
    if (!element) { return; }
    events.forEach(function (event)
    {
        addListener(element, event);
    });
}

/**
 * Adds a listener to the element
 * @param {object} element the HTML DOM element
 * @param {object} event the event object from the events-array
 */
function addListener(element, event)
{
    if (!element || !event) { return; }
    if (subscribedEvents.indexOf(event.name) > -1) { return; } // already subscribed
    if (!event.togglePort.get()) { return; } // toggle for event not set
    element.addEventListener(event.name, event.handler);
    subscribedEvents.push(event.name);
}

op.onDelete = function ()
{
    removeAllListeners(lastElement);
    removeAllListeners(elementPort.get());
};


};

Ops.Html.EventListener.prototype = new CABLES.Op();
CABLES.OPS["73dc05e9-7b63-444b-980b-bd63f511b94a"]={f:Ops.Html.EventListener,objName:"Ops.Html.EventListener"};




// **************************************************************
// 
// Ops.Html.FontFile_v2
// 
// **************************************************************

Ops.Html.FontFile_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    filename = op.inUrl("file", [".otf", ".ttf", ".woff", ".woff2"]),
    fontname = op.inString("family"),
    outLoaded = op.outBoolNum("Loaded"),
    loadedTrigger = op.outTrigger("Loaded Trigger");

let loadingId = null;

filename.onChange = function ()
{
    outLoaded.set(false);
    addStyle();
};

fontname.onChange = addStyle;

let fontFaceObj;

function addStyle()
{
    if (filename.get() && fontname.get())
    {
        if (document.fonts)
        {
            fontFaceObj = new FontFace(fontname.get(), "url(" + op.patch.getFilePath(String(filename.get())) + ")");

            loadingId = op.patch.cgl.patch.loading.start("FontFile", filename.get());

            // Add the FontFace to the FontFaceSet
            document.fonts.add(fontFaceObj);

            // Get the current status of the FontFace
            // (should be 'unloaded')

            // Load the FontFace
            fontFaceObj.load();

            // Get the current status of the Fontface
            // (should be 'loading' or 'loaded' if cached)

            // Wait until the font has been loaded, log the current status.
            fontFaceObj.loaded.then((fontFace) =>
            {
                outLoaded.set(true);
                loadedTrigger.trigger();
                op.patch.cgl.patch.loading.finished(loadingId);

                op.patch.emitEvent("fontLoaded", fontname.get());

                // Throw an error if loading wasn't successful
            }, (fontFace) =>
            {
                op.setUiError("loadingerror", "Font loading error!" + fontFaceObj.status);
                // op.logError("Font loading error! Current status", fontFaceObj.status);
            });
        }
        else
        { // font loading api not supported
            const fileUrl = op.patch.getFilePath(String(filename.get()));
            const styleStr = ""
                .endl() + "@font-face"
                .endl() + "{"
                .endl() + "  font-family: \"" + fontname.get() + "\";"
                .endl() + "  src: url(\"" + fileUrl + "\") format(\"truetype\");"
                .endl() + "}";

            const style = document.createElement("style");
            style.type = "text/css";
            style.innerHTML = styleStr;
            document.getElementsByTagName("head")[document.getElementsByTagName("head").length - 1].appendChild(style);
            // TODO: Poll if font loaded
        }
    }
}


};

Ops.Html.FontFile_v2.prototype = new CABLES.Op();
CABLES.OPS["68177370-116e-4c76-aef3-3b10d68e7227"]={f:Ops.Html.FontFile_v2,objName:"Ops.Html.FontFile_v2"};




// **************************************************************
// 
// Ops.Html.FullscreenMode
// 
// **************************************************************

Ops.Html.FullscreenMode = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    doRequest = op.inTriggerButton("Request Fullscreen"),
    doExit = op.inTriggerButton("Exit Fullscreen"),
    inEle = op.inSwitch("Element", ["Canvas", "Document"], "Canvas"),
    isFullscreen = op.outBoolNum("Is Fullscreen");

doExit.onTriggered = exitFs;
doRequest.onTriggered = startFs;

let countStarts = 0;

function setState()
{
    const isFull = (!window.screenTop && !window.screenY);
    isFullscreen.set(isFull);
}

function startFs()
{
    countStarts++;
    if (countStarts > 30)
    {
        doRequest.onTriggered = null;
        op.setUiAttrib({ "error": "Fullscreen Request shound not triggered that often: op disabled" });
        exitFs();
    }

    let elem = null;
    if (inEle == "Canvas") elem = op.patch.cgl.canvas.parentElement;
    else elem = document.documentElement;

    if (elem.requestFullScreen) elem.requestFullScreen();
    else if (elem.mozRequestFullScreen) elem.mozRequestFullScreen();
    else if (elem.webkitRequestFullScreen)elem.webkitRequestFullScreen();
    else if (elem.msRequestFullScreen)elem.msRequestFullScreen();

    setTimeout(setState, 100);
    setTimeout(setState, 500);
    setTimeout(setState, 1000);
}

function exitFs()
{
    countStarts--;
    if (document.exitFullscreen) document.exitFullscreen();
    else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
    else if (document.msExitFullscreen)document.msExitFullscreen();

    setTimeout(setState, 100);
    setTimeout(setState, 500);
    setTimeout(setState, 1000);
}


};

Ops.Html.FullscreenMode.prototype = new CABLES.Op();
CABLES.OPS["fe933b35-696d-4738-be03-c0c011ed67a0"]={f:Ops.Html.FullscreenMode,objName:"Ops.Html.FullscreenMode"};




// **************************************************************
// 
// Ops.Html.GetCssVariable
// 
// **************************************************************

Ops.Html.GetCssVariable = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTriggerButton("Update"),
    varname = op.inString("Var Name"),
    result = op.outString("Result");

const root = document.documentElement;

exe.onTriggered = function ()
{
    result.set(root.style.getPropertyValue("--" + varname.get()));
};


};

Ops.Html.GetCssVariable.prototype = new CABLES.Op();
CABLES.OPS["ef03f407-e365-47c7-9829-be54ba53c54d"]={f:Ops.Html.GetCssVariable,objName:"Ops.Html.GetCssVariable"};




// **************************************************************
// 
// Ops.Html.HyperLink_v2
// 
// **************************************************************

Ops.Html.HyperLink_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTriggerButton("Open"),
    inUrl = op.inString("URL", "https://cables.gl"),
    inTarget = op.inString("Target Name", "_self"),
    inSpecs = op.inString("Specs", "");

exec.onTriggered = function ()
{
    // document.location.href=inUrl.get();
    window.open(inUrl.get(), inTarget.get(), inSpecs.get());
};


};

Ops.Html.HyperLink_v2.prototype = new CABLES.Op();
CABLES.OPS["a669d4f7-1e35-463c-bf8b-08c9f1b68e04"]={f:Ops.Html.HyperLink_v2,objName:"Ops.Html.HyperLink_v2"};




// **************************************************************
// 
// Ops.Html.IFrame_v3
// 
// **************************************************************

Ops.Html.IFrame_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    src = op.inString("URL", "https://undev.studio"),
    elId = op.inString("ID"),
    active = op.inBool("Active", true),
    inStyle = op.inStringEditor("Style", "position:absolute;\nz-index:9999;\nborder:0;\nwidth:50%;\nheight:50%;"),
    outEle = op.outObject("Element");

op.setPortGroup("Attributes", [src, elId]);

let element = null;

op.onDelete = removeEle;

op.onLoadedValueSet = op.init = () =>
{
    addElement();
    updateSoon();
    inStyle.onChange =
        src.onChange =
        elId.onChange = updateSoon;

    active.onChange = updateActive;
};

function addElement()
{
    if (!active.get()) return;
    if (element) removeEle();
    element = document.createElement("iframe");
    updateAttribs();
    const parent = op.patch.cgl.canvas.parentElement;
    parent.appendChild(element);
    outEle.set(element);
}

let timeOut = null;

function updateSoon()
{
    clearTimeout(timeOut);
    timeOut = setTimeout(updateAttribs, 30);
}

function updateAttribs()
{
    if (!element) return;
    element.setAttribute("style", inStyle.get());
    element.setAttribute("src", src.get());
    element.setAttribute("id", elId.get());
}

function removeEle()
{
    if (element && element.parentNode)element.parentNode.removeChild(element);
    element = null;
    outEle.set(element);
}

function updateActive()
{
    if (!active.get())
    {
        removeEle();
        return;
    }

    addElement();
}


};

Ops.Html.IFrame_v3.prototype = new CABLES.Op();
CABLES.OPS["9e74b275-a1ed-4d10-aba4-4b3311363a99"]={f:Ops.Html.IFrame_v3,objName:"Ops.Html.IFrame_v3"};




// **************************************************************
// 
// Ops.Html.LoadingIndicator
// 
// **************************************************************

Ops.Html.LoadingIndicator = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"css_ellipsis_css":".lds-ellipsis {\n\n}\n.lds-ellipsis div {\n  position: absolute;\n  /*top: 33px;*/\n  margin-top:-12px;\n  margin-left:-13px;\n  width: 13px;\n  height: 13px;\n  border-radius: 50%;\n  background: #fff;\n  animation-timing-function: cubic-bezier(0, 1, 1, 0);\n}\n.lds-ellipsis div:nth-child(1) {\n  left: 8px;\n  animation: lds-ellipsis1 0.6s infinite;\n}\n.lds-ellipsis div:nth-child(2) {\n  left: 8px;\n  animation: lds-ellipsis2 0.6s infinite;\n}\n.lds-ellipsis div:nth-child(3) {\n  left: 32px;\n  animation: lds-ellipsis2 0.6s infinite;\n}\n.lds-ellipsis div:nth-child(4) {\n  left: 56px;\n  animation: lds-ellipsis3 0.6s infinite;\n}\n@keyframes lds-ellipsis1 {\n  0% {\n    transform: scale(0);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n@keyframes lds-ellipsis3 {\n  0% {\n    transform: scale(1);\n  }\n  100% {\n    transform: scale(0);\n  }\n}\n@keyframes lds-ellipsis2 {\n  0% {\n    transform: translate(0, 0);\n  }\n  100% {\n    transform: translate(24px, 0);\n  }\n}\n","css_ring_css":".lds-ring {\n}\n.lds-ring div {\n  box-sizing: border-box;\n  display: block;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  border: 3px solid #fff;\n  border-radius: 50%;\n  animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;\n  border-color: #fff transparent transparent transparent;\n}\n.lds-ring div:nth-child(1) {\n  animation-delay: -0.45s;\n}\n.lds-ring div:nth-child(2) {\n  animation-delay: -0.3s;\n}\n.lds-ring div:nth-child(3) {\n  animation-delay: -0.15s;\n}\n@keyframes lds-ring {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n","css_spinner_css":"._cables_spinner {\n  /*width: 40px;*/\n  /*height: 40px;*/\n  /*margin: 100px auto;*/\n  background-color: #777;\n\n  border-radius: 100%;\n  -webkit-animation: sk-scaleout 1.0s infinite ease-in-out;\n  animation: sk-scaleout 1.0s infinite ease-in-out;\n}\n\n@-webkit-keyframes sk-scaleout {\n  0% { -webkit-transform: scale(0) }\n  100% {\n    -webkit-transform: scale(1.0);\n    opacity: 0;\n  }\n}\n\n@keyframes sk-scaleout {\n  0% {\n    -webkit-transform: scale(0);\n    transform: scale(0);\n  } 100% {\n    -webkit-transform: scale(1.0);\n    transform: scale(1.0);\n    opacity: 0;\n  }\n}",};
const
    inVisible = op.inBool("Visible", true),
    inStyle = op.inSwitch("Style", ["Spinner", "Ring", "Ellipsis"], "Ring");

const div = document.createElement("div");
div.dataset.op = op.id;
const canvas = op.patch.cgl.canvas.parentElement;

inStyle.onChange = updateStyle;

div.appendChild(document.createElement("div"));
div.appendChild(document.createElement("div"));
div.appendChild(document.createElement("div"));

const size = 50;

div.style.width = size + "px";
div.style.height = size + "px";
div.style.top = "50%";
div.style.left = "50%";
// div.style.border="1px solid red";

div.style["margin-left"] = "-" + size / 2 + "px";
div.style["margin-top"] = "-" + size / 2 + "px";

div.style.position = "absolute";
div.style["z-index"] = "9999999";

inVisible.onChange = updateVisible;

let eleId = "css_loadingicon_" + CABLES.uuid();

const styleEle = document.createElement("style");
styleEle.type = "text/css";
styleEle.id = eleId;

let head = document.getElementsByTagName("body")[0];
head.appendChild(styleEle);

op.onDelete = () =>
{
    remove();
    if (styleEle)styleEle.remove();
};

updateStyle();

function updateStyle()
{
    const st = inStyle.get();
    if (st == "Spinner")
    {
        div.classList.add("_cables_spinner");
        styleEle.textContent = attachments.css_spinner_css;
    }
    else div.classList.remove("_cables_spinner");

    if (st == "Ring")
    {
        div.classList.add("lds-ring");
        styleEle.textContent = attachments.css_ring_css;
    }
    else div.classList.remove("lds-ring");

    if (st == "Ellipsis")
    {
        div.classList.add("lds-ellipsis");
        styleEle.textContent = attachments.css_ellipsis_css;
    }
    else div.classList.remove("lds-ellipsis");
}

function remove()
{
    div.remove();
    // if (styleEle)styleEle.remove();
}

function updateVisible()
{
    remove();
    if (inVisible.get()) canvas.appendChild(div);
}


};

Ops.Html.LoadingIndicator.prototype = new CABLES.Op();
CABLES.OPS["e102834c-6dcf-459c-9e22-44ebccfc0d3b"]={f:Ops.Html.LoadingIndicator,objName:"Ops.Html.LoadingIndicator"};




// **************************************************************
// 
// Ops.Html.MailtoLink
// 
// **************************************************************

Ops.Html.MailtoLink = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEmail = op.inString("Email", "test@test.com"),
    inSubject = op.inString("Subject", ""),
    exec = op.inTriggerButton("Execute");

exec.onTriggered = function ()
{
    let str = "mailto:";
    str += inEmail.get();
    if (inSubject.get())str += "?subject=" + inSubject.get();
    window.location.href = str;
};


};

Ops.Html.MailtoLink.prototype = new CABLES.Op();
CABLES.OPS["6d03ec3b-f8b2-4544-bdb3-df771e857069"]={f:Ops.Html.MailtoLink,objName:"Ops.Html.MailtoLink"};




// **************************************************************
// 
// Ops.Html.MarkdownToHtml
// 
// **************************************************************

Ops.Html.MarkdownToHtml = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inStringEditor("Markdown", "##hello\n\nthis is some text...", "markdown"),
    outStr = op.outString("Html");

inStr.onChange = update;
update();

function update()
{
    let str = inStr.get();

    str = marked.parse(str);
    outStr.set(str);
}


};

Ops.Html.MarkdownToHtml.prototype = new CABLES.Op();
CABLES.OPS["26c97760-6e6b-4ff7-9715-dc510d23ab22"]={f:Ops.Html.MarkdownToHtml,objName:"Ops.Html.MarkdownToHtml"};




// **************************************************************
// 
// Ops.Html.ModalOverlay
// 
// **************************************************************

Ops.Html.ModalOverlay = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEle = op.inObject("Content Element"),
    inShow = op.inTriggerButton("Show"),
    inClose = op.inTriggerButton("Close"),
    closeButton = op.inBool("Show Closebutton", true),
    inOpacity = op.inFloatSlider("Opacity", 0.5),
    outVisible = op.outBool("Visible"),
    outClosed = op.outTrigger("Closed"),
    outElement = op.outObject("Element");

const eleContainer = document.createElement("div");
const eleClose = document.createElement("div");

eleClose.innerHTML = "&times;";
eleClose.style.color = "white";
eleClose.style.position = "fixed";
eleClose.style.top =
eleClose.style.right = "25px";
eleClose.style["line-height"] = "25px";
eleClose.style["z-index"] = "9999";
eleClose.style.cursor = "pointer";
eleClose.style["font-size"] = "50px";
eleClose.addEventListener("pointerdown", hide);
eleContainer.addEventListener("pointerdown", hide);
eleContainer.appendChild(eleClose);

inOpacity.onChange = updateBgColor;
eleContainer.style.display = "none";
inShow.onTriggered = show;
inClose.onTriggered = hide;

closeButton.onChange = updateCloseButton;

function updateCloseButton()
{
    if (!eleClose) return;
    if (closeButton.get()) eleClose.style.display = "block";
    else eleClose.style.display = "none";
}

inEle.onChange = function ()
{
    let ele = inEle.get();
    if (ele && eleContainer) eleContainer.appendChild(ele);
};

function hide()
{
    outVisible.set(false);
    eleContainer.style.display = "none";
    outClosed.trigger();
}

function updateBgColor()
{
    eleContainer.style["background-color"] = "rgba(0,0,0," + inOpacity.get() + ")";
}

function show()
{
    outVisible.set(true);
    updateCloseButton();
    eleContainer.style.display = "block";

    eleContainer.dataset.op = op.id;
    let parent = op.patch.cgl.canvas.parentElement;

    eleContainer.style = "overflow:auto;top:0;width:100%;height:100%;position:absolute;z-index:9999";
    updateBgColor();

    parent.appendChild(eleContainer);
    outElement.set(eleContainer);
}


};

Ops.Html.ModalOverlay.prototype = new CABLES.Op();
CABLES.OPS["a8ba593a-4d5a-4b55-8ee7-9b6f9920da1f"]={f:Ops.Html.ModalOverlay,objName:"Ops.Html.ModalOverlay"};




// **************************************************************
// 
// Ops.Html.MouseCursorImage_v2
// 
// **************************************************************

Ops.Html.MouseCursorImage_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTriggerButton("Update"),
    filename = op.inUrl("file"),
    offX = op.inValueInt("Offset X"),
    offY = op.inValueInt("Offset Y"),
    next = op.outTrigger("Next");

offX.onChange =
    offY.onChange =
    filename.onChange = updateStr;

exec.onTriggered = update;

let str = "auto";

function updateStr()
{
    str = "url(" + op.patch.getFilePath(String(filename.get())) + ") " + offX.get() + " " + offX.get() + ", auto";
}

function update()
{
    op.patch.cgl.setCursor(str);
    next.trigger();
}

exec.onLinkChanged =
next.onLinkChanged = () =>
{
    op.patch.cgl.setCursor("auto");
};


};

Ops.Html.MouseCursorImage_v2.prototype = new CABLES.Op();
CABLES.OPS["2a6be938-3db8-438e-82f2-60167529eb47"]={f:Ops.Html.MouseCursorImage_v2,objName:"Ops.Html.MouseCursorImage_v2"};




// **************************************************************
// 
// Ops.Html.Notification
// 
// **************************************************************

Ops.Html.Notification = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"defaultstyle_txt":"visibility: hidden;\nbackground-color: #282828;\ncolor: #fff;\n\npadding: 16px;\nposition: absolute;\nz-index: 9999;\nfont-size: 17px;\nopacity:0;\nborder-radius:10px;\ntext-align:center;\nleft: 50%;\ntransform: translate(-50%, 0);\n",};
const
    triggerAnim = op.inTriggerButton("Trigger animation"),
    inText = op.inString("Text", "Hello! <br> This is a pop up"),
    inClass = op.inString("Class"),
    inStyle = op.inValueEditor("Style", attachments.defaultstyle_txt, "none"),
    inVisible = op.inValueBool("Active", true),
    inBreaks = op.inValueBool("Convert Line Breaks", false),
    fadeInDuration = op.inFloat("Fade in", 0.5),
    holdDuration = op.inFloat("Hold ", 2.0),
    fadeOutDuration = op.inFloat("Fade out", 0.8),
    percentOrPixel = op.inSwitch("mode", ["%", "px"], "%"),
    divSide = op.inSwitch("Side", ["bottom", "top"], "bottom"),
    startPosition = op.inFloat("Starting position", 0),
    endPosition = op.inFloat("Ending position", 5),
    finishedTrigger = op.outTrigger("Finished trigger"),
    finished = op.outBool("Finished", false),
    outElement = op.outObject("DOM Element");

op.setPortGroup("Animation", [fadeInDuration, holdDuration, fadeOutDuration]);
op.setPortGroup("HTML CSS", [inText, inClass, inStyle, inVisible, inBreaks]);
op.setPortGroup("Positioning", [percentOrPixel, divSide, startPosition, endPosition]);

const divid = "notification_" + CABLES.uuid();

// inStyle.setUiAttribs({editorSyntax:'css'});
const listenerElement = null;
let oldStr = null;

let prevDisplay = "block";

const div = document.createElement("div");
div.dataset.op = op.id;
div.id = divid;

const canvas = op.patch.cgl.canvas.parentElement;

canvas.appendChild(div);
outElement.set(div);

inClass.onChange = updateClass;
inBreaks.onChange = inText.onChange = updateText;
inStyle.onChange = updateStyle;
inVisible.onChange = updateVisibility;

triggerAnim.onTriggered = popUpAnim;

updateText();
updateStyle();
warning();

op.onDelete = removeElement;

outElement.onLinkChanged = updateStyle;

let animInProgress = false;

function setCSSVisible(visible)
{
    if (!visible)
    {
        div.style.visibility = "hidden";
        prevDisplay = div.style.display || "block";
        div.style.display = "none";
    }
    else
    {
        if (prevDisplay == "none") prevDisplay = "block";
        div.style.visibility = "visible";
        div.style.display = "none";
    }
}

function updateVisibility()
{
    setCSSVisible(inVisible.get());
}

function updateText()
{
    let str = inText.get();

    if (oldStr === str) return;
    oldStr = str;

    if (str && inBreaks.get()) str = str.replace(/(?:\r\n|\r|\n)/g, "<br>");

    if (div.innerHTML != str) div.innerHTML = str;
    outElement.set(null);
    outElement.set(div);
}

function removeElement()
{
    if (div && div.parentNode) div.parentNode.removeChild(div);
}
// inline css inisde div
function updateStyle()
{
    if (inStyle.get() != div.style)
    {
        div.setAttribute("style", inStyle.get());

        updateVisibility();
        outElement.set(null);
        outElement.set(div);
    }
    warning();
}

function updateClass()
{
    div.setAttribute("class", inClass.get());
    warning();
}

op.addEventListener("onEnabledChange", function (enabled)
{
    op.log("css changed");
    setCSSVisible(div.style.visibility != "visible");
});

function warning()
{
    if (inClass.get() && inStyle.get()) op.setUiError("error", "DIV uses external and inline CSS", 1);
    else op.setUiError("error", null);
}

function popUpAnim()
{
    if (!inVisible.get()) return;

    const mode = percentOrPixel.get();
    const start = startPosition.get() + mode;
    const end = endPosition.get() + mode;

    const targetDiv = document.getElementById(divid);
    div.style.display = "block";

    const animData = {};
    // this function cascades into each stage when started
    startAnim(mode, start, end, animData);
}

function startAnim(mode, start, end, animData)
{
    // stop the glitches from it being triggered multiple times
    if (animInProgress) return;

    finished.set(false);
    animInProgress = true;

    animData.easing = ["cubic-bezier(0.0, 0.0, 0.2, 1.0)", "linear"];
    animData.opacity = [0, 1];

    if (divSide.get() == "bottom") animData.bottom = [start, end];
    else animData.top = [start, end];

    document.getElementById(divid).animate(
        animData, fadeInDuration.get() * 1000).onfinish = function ()
    {
        holdAnim(mode, start, end, animData);
    };
}

function holdAnim(mode, start, end, animData)
{
    animData.easing = ["linear", "linear"];
    animData.opacity = [1, 1];

    if (divSide.get() == "bottom") animData.bottom = [end, end];
    else animData.top = [end, end];

    document.getElementById(divid).animate(animData, holdDuration.get() * 1000).onfinish =
        function ()
        {
            endAnim(mode, start, end, animData);
        };
}

function endAnim(mode, start, end, animData)
{
    animData.easing = ["cubic-bezier(0.0, 0.0, 0.2, 1.0)", "linear"];
    animData.opacity = [1, 0];

    if (divSide.get() == "bottom") animData.bottom = [end, start];
    else animData.top = [end, start];

    document.getElementById(divid).animate(
        animData, fadeOutDuration.get() * 1000).onfinish = function ()
    {
        div.style.display = "none";
        animInProgress = false;
        finishedTrigger.trigger();
        finished.set(true);
    };
}


};

Ops.Html.Notification.prototype = new CABLES.Op();
CABLES.OPS["cf3960f3-ced0-4928-9082-a9cf7f8573a6"]={f:Ops.Html.Notification,objName:"Ops.Html.Notification"};




// **************************************************************
// 
// Ops.Html.PlayerControlPanel_v2
// 
// **************************************************************

Ops.Html.PlayerControlPanel_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"css_progressui_css":".progressUI\n{\n    padding: 10px;\n    position: absolute;\n    border-radius: 10px;\n    background-color: rgba(0,0,0,0.45);\n    margin: 20px;\n    bottom: 10px;\n    height:30px;\n    margin-left:50%;\n    transform: translate(-50%);\n    display: flex;\n    align-items: center;\n}\n\n.progressUI .buttonContainer {\n    display: flex;\n    align-content: center;\n    height: 100%;\n}\n\n.progressUI .progress\n{\n    font-family: Monospace;\n    float:left;\n    color:white;\n    width: auto;\n    margin-left:15px;\n    margin-right: 10px;\n}\n\n.progressUI .progressContainer\n{\n    width:200px;\n    overflow: hidden;\n    background: rgba(0,0,0,0.4);\n    border-radius: 4px;\n    float:left;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    height: 100%;\n}\n\n.progressUI .button\n{\n    cursor: pointer;\n    box-sizing: border-box;\n    background: rgba(0,0,0,0.4);\n    display: flex;\n    align-content: center;\n    padding: 5px;\n    padding-left: 10px;\n    padding-right: 10px;\n    margin-right: 5px;\n    border-radius: 5px;\n    float:left;\n    display: flex;\n    align-items: center;\n}\n\n.progressUIIcon\n{\n    display: inline-block;\n    vertical-align: middle;\n    width: 15px;\n    height: 15px;\n    background-color: white;\n    -webkit-mask-repeat: no-repeat !important;\n    -webkit-mask-size: 100% !important;\n}\n\n.progressUI .progressContainer .progressbar {\n    height: 100%;\n    width: 97%;\n}\n\n.progressUI_icon-play {\n    -webkit-mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='%23fff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-play'%3E%3Cpath d='M5 3l14 9-14 9V3z'/%3E%3C/svg%3E\");\n    mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='%23fff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-play'%3E%3Cpath d='M5 3l14 9-14 9V3z'/%3E%3C/svg%3E\");\n}\n\n.progressUI_icon-pause {\n    -webkit-mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='%23fff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-pause'%3E%3Cpath d='M6 4h4v16H6zM14 4h4v16h-4z'/%3E%3C/svg%3E\");\n    mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='%23fff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-pause'%3E%3Cpath d='M6 4h4v16H6zM14 4h4v16h-4z'/%3E%3C/svg%3E\");\n}\n\n.progressUI_icon-rewind {\n    -webkit-mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-rewind'%3E%3Cpath d='M11 19l-9-7 9-7v14zM22 19l-9-7 9-7v14z'/%3E%3C/svg%3E\");\n    mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-rewind'%3E%3Cpath d='M11 19l-9-7 9-7v14zM22 19l-9-7 9-7v14z'/%3E%3C/svg%3E\");\n}\n\n.progressUI_icon-fast-forward {\n    -webkit-mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-fast-forward'%3E%3Cpath d='M13 19l9-7-9-7v14zM2 19l9-7-9-7v14z'/%3E%3C/svg%3E\");\n    mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-fast-forward'%3E%3Cpath d='M13 19l9-7-9-7v14zM2 19l9-7-9-7v14z'/%3E%3C/svg%3E\");\n}\n\n.progressUI_icon-skip-back {\n    -webkit-mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-skip-back'%3E%3Cpath d='M19 20L9 12l10-8v16zM5 19V5'/%3E%3C/svg%3E\");\n    mask: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-skip-back'%3E%3Cpath d='M19 20L9 12l10-8v16zM5 19V5'/%3E%3C/svg%3E\");\n}\n",};
const inMax = op.inFloat("Length", 30);
const inCurrent = op.inFloat("Current", 0);
const inClamp = op.inBool("Clamp", false);
const inIsPlaying = op.inBool("Is Playing", false);
const inVisible = op.inBool("Visible", true);
const inShowValue = op.inBool("Show Time");
const inShowSkip = op.inBool("Show Skip Buttons");

const outPlay = op.outTrigger("Play clicked");
const outPause = op.outTrigger("Pause clicked");
const outRewind = op.outTrigger("Rewind clicked");
const outBack = op.outTrigger("Skip Back clicked");
const outForward = op.outTrigger("Skip Forward clicked");

const outDragged = op.outTrigger("Dragged");
const outValue = op.outNumber("Current Value");
const outDragging = op.outBoolNum("Dragging", false);
const outElement = op.outObject("DOM Element", null, "element");

let div = document.createElement("div");
div.id = "progressUI_" + op.id;
div.classList.add("progressUI");
outElement.set(div);

const cgl = op.patch.cgl;
let canvas = op.patch.cgl.canvas.parentElement;
canvas.appendChild(div);

let progressContainer = document.createElement("div");
if (!inVisible.get())
{
    div.style.display = "none";
}
let progressbar = document.createElement("input");
let progress = document.createElement("div");
const buttonContainer = document.createElement("div");

progressContainer.classList.add("progressContainer");

progressContainer.appendChild(progressbar);

progressbar.setAttribute("type", "range");
progressbar.setAttribute("step", 0.01);
progressbar.setAttribute("min", 0);
progressbar.setAttribute("max", inMax.get());
progressbar.setAttribute("value", inCurrent.get());
progressbar.classList.add("progressbar");
progressbar.addEventListener("input", handleInput);
let wasPlaying = false;
let isDragging = false;

div.appendChild(buttonContainer);
div.appendChild(progressContainer);
div.appendChild(progress);

let eleId = "css_progressui_" + CABLES.uuid();

const styleEle = document.createElement("style");
styleEle.type = "text/css";
styleEle.id = eleId;

let head = document.getElementsByTagName("body")[0];
head.appendChild(styleEle);

buttonContainer.classList.add("buttonContainer");

let skipbackbutton = addButton("", "progressUI_icon-skip-back");
buttonContainer.appendChild(skipbackbutton);

let rewindButton = addButton("", "progressUI_icon-rewind", "skip");
if (!inShowSkip.get())
{
    rewindButton.style.display = "none";
}
buttonContainer.appendChild(rewindButton);
rewindButton.addEventListener("pointerdown", () =>
{
    outBack.trigger();
});

let playButton = addButton("", "progressUI_icon-play");
buttonContainer.appendChild(playButton);

let forwardButton = addButton("", "progressUI_icon-fast-forward", "skip");
if (!inShowSkip.get())
{
    forwardButton.style.display = "none";
}
buttonContainer.appendChild(forwardButton);

forwardButton.addEventListener("pointerdown", () =>
{
    outForward.trigger();
});

progress.classList.add("progress");
progress.innerHTML = "00:00:000";

function addButton(title, icon, additionalClass)
{
    let button = document.createElement("div");
    button.classList.add("button");
    button.classList.add(additionalClass);
    button.innerHTML = title;

    if (icon)
    {
        let buttonicon = document.createElement("div");
        buttonicon.classList.add("progressUIIcon");
        buttonicon.classList.add(icon);
        button.appendChild(buttonicon);
    }
    return button;
}

inMax.onChange = () =>
{
    progressbar.setAttribute("max", inMax.get());
};

inVisible.onChange = () =>
{
    if (inVisible.get())
    {
        div.style.removeProperty("display");
    }
    else
    {
        div.style.display = "none";
    }
};

inShowValue.onChange = () =>
{
    if (inShowValue.get())
    {
        div.classList.add("showValue");
        progress.style.display = "block";
    }
    else
    {
        div.classList.remove("showValue");
        progress.style.display = "none";
    }
};

inShowSkip.onChange = () =>
{
    if (inShowSkip.get())
    {
        div.querySelectorAll(".button.skip").forEach((skip) =>
        {
            skip.style.display = "block";
        });
    }
    else
    {
        div.querySelectorAll(".button.skip").forEach((skip) =>
        {
            skip.style.display = "none";
        });
    }
};

if (!inShowValue.get())
{
    progress.style.display = "none";
}
progressbar.addEventListener("pointerdown", () =>
{
    isDragging = true;
    if (inIsPlaying.get())
    {
        wasPlaying = true;
        outPause.trigger();
        updatePlayButton();
    }
});
progressbar.addEventListener("pointermove", () =>
{
    const currentProgress = progressbar.value;
    if (isDragging)
    {
        outDragging.set(isDragging);
        updateProgressDisplay(currentProgress);
        outValue.set(currentProgress);
        outDragged.trigger();
    }
});

progressbar.addEventListener("pointerup", () =>
{
    const currentProgress = progressbar.value;
    updateProgressDisplay(currentProgress);
    outValue.set(currentProgress);

    if (isDragging)
    {
        outDragged.trigger();
    }

    isDragging = false;
    outDragging.set(isDragging);
    if (wasPlaying)
    {
        wasPlaying = false;
        outPlay.trigger();
        updatePlayButton();
    }
});

function updateStyle()
{
    styleEle.textContent = attachments.css_progressui_css;
}

function updatePlayButton()
{
    playButton.querySelector(".progressUIIcon").classList.remove("progressUI_icon-play");
    playButton.querySelector(".progressUIIcon").classList.remove("progressUI_icon-pause");
    if (inIsPlaying.get())
    {
        playButton.querySelector(".progressUIIcon").classList.add("progressUI_icon-pause");
    }
    else
    {
        playButton.querySelector(".progressUIIcon").classList.add("progressUI_icon-play");
    }
}

playButton.addEventListener("pointerdown", function ()
{
    if (inIsPlaying.get())
    {
        outPause.trigger();
    }
    else
    {
        outPlay.trigger();
    }
    updatePlayButton();
});

skipbackbutton.addEventListener("pointerdown", () =>
{
    outValue.set(0);
    outRewind.trigger();
});

op.onDelete = function ()
{
    if (div) div.remove();
    if (styleEle) styleEle.remove();
};

function handleInput(e)
{
    inCurrent.onChange = null;
    const newValue = e.target.value;
    outValue.set(newValue);
    inCurrent.onChange = currentValueChange;
}

function currentValueChange()
{
    let currentValue = inCurrent.get();
    if (inClamp.get() && currentValue > inMax.get())
    {
        currentValue = inMax.get();
    }
    progressbar.value = currentValue;
    outValue.set(currentValue);
    updateProgressDisplay();
}

let lasttime = 0;
function updateProgressDisplay(currentValue = null)
{
    let displayValue = currentValue || inCurrent.get();
    let t = displayValue;
    if (t != lasttime)
    {
        progress.innerHTML = formatValue(t);
        lasttime = t;
    }
}

function formatValue(t)
{
    const minutes = String(new Date(t * 1000).getUTCMinutes()).padStart(2, "0");
    const seconds = String(new Date(t * 1000).getUTCSeconds()).padStart(2, "0");
    const millis = String(new Date(t * 1000).getUTCMilliseconds()).padStart(2, "0").padEnd(3, "0");
    const html = minutes + ":" + seconds + ":" + millis;
    return html;
}

updateStyle();
updatePlayButton();

inCurrent.onChange = currentValueChange;
inIsPlaying.onChange = updatePlayButton;


};

Ops.Html.PlayerControlPanel_v2.prototype = new CABLES.Op();
CABLES.OPS["12ac1d94-f043-454d-92a8-60733d2908b2"]={f:Ops.Html.PlayerControlPanel_v2,objName:"Ops.Html.PlayerControlPanel_v2"};




// **************************************************************
// 
// Ops.Html.QrCode
// 
// **************************************************************

Ops.Html.QrCode = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    text = op.inString("Text", "https://cables.gl"),
    outDataUrl = op.outString("Image DataUrl"),
    outElement=op.outObject("Element",null,"element");

const cgl = op.patch.cgl;
const parentEle = document.createElement("div");
parentEle.id = "qrcode_" + CABLES.generateUUID();
parentEle.style.display = "none";
const body = document.getElementsByTagName("body")[0];
body.appendChild(parentEle);


const img = document.createElement("img");


text.onChange = generate;

let qrCanvas=null;
generate();


function generate()
{

    while (parentEle.hasChildNodes())
    {
        parentEle.removeChild(parentEle.lastChild);
    }
    const q=new QRCode(parentEle, {
        "text": text.get(),
        "width": 256,
        "height": 256,
        "colorDark": "#000000",
        "colorLight": "#ffffff",
        "correctLevel": QRCode.CorrectLevel.H
    });




    qrCanvas = document.querySelector("#" + parentEle.id + " canvas");
    qrCanvas.style.display="block";



    outElement.set(null);
    outElement.set(img);

    const dataurl=qrCanvas.toDataURL("image/png");
    img.src=dataurl;
    outDataUrl.set(dataurl);

}


};

Ops.Html.QrCode.prototype = new CABLES.Op();
CABLES.OPS["7e27a058-8162-4fd3-b08d-eba16f0fb551"]={f:Ops.Html.QrCode,objName:"Ops.Html.QrCode"};




// **************************************************************
// 
// Ops.Html.QuerySelectorAll
// 
// **************************************************************

Ops.Html.QuerySelectorAll = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpdate = op.inTriggerButton("Update"),
    queryPort = op.inString("Query"),
    inMode = op.inValueSelect("Mode", ["document", "string input"], "document"),
    inMimeType = op.inValueSelect("Type", ["text/html", "text/xml"], "text/html"),
    inSource = op.inStringEditor("Document", "xml"),
    elementPort = op.outArray("Elements");

if (inMode.get() === "document")
{
    inSource.setUiAttribs({ "greyout": true });
    inMimeType.set("text/html");
    inMimeType.setUiAttribs({ "greyout": true });
}

inUpdate.onTriggered =
queryPort.onChange =
inMimeType.onChange =
inSource.onChange = update;

inMode.onChange = modeChange;

function update()
{
    const q = queryPort.get();
    const theDocument = inSource.get();
    const mode = inMode.get();
    if (mode === "string input" && theDocument)
    {
        let parser = new DOMParser();
        let htmlDoc = null;
        try
        {
            htmlDoc = parser.parseFromString(theDocument, inMimeType.get());
            const el = Array.from(htmlDoc.querySelectorAll(q));
            elementPort.set(el);
        }
        catch (e)
        {
            op.logError(e);
        }
    }
    else
    {
        try
        {
            const el = Array.from(document.querySelectorAll(q));
            elementPort.set(el);
        }
        catch (e)
        {
            op.logError(e);
        }
    }
}

function modeChange()
{
    if (inMode.get() === "document")
    {
        inSource.setUiAttribs({ "greyout": true });
        inMimeType.set("text/html");
        inMimeType.setUiAttribs({ "greyout": true });
    }
    else
    {
        inSource.setUiAttribs({ "greyout": false });
        inMimeType.setUiAttribs({ "greyout": false });
    }
}


};

Ops.Html.QuerySelectorAll.prototype = new CABLES.Op();
CABLES.OPS["001799c7-9ddf-4f3e-b260-e865f0ed2c0e"]={f:Ops.Html.QuerySelectorAll,objName:"Ops.Html.QuerySelectorAll"};




// **************************************************************
// 
// Ops.Html.QuerySelector_v2
// 
// **************************************************************

Ops.Html.QuerySelector_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpdate = op.inTriggerButton("Update"),
    queryPort = op.inString("Query"),
    inMode = op.inValueSelect("Mode", ["document", "string input"], "document"),
    inMimeType = op.inValueSelect("Type", ["text/html", "text/xml"], "text/html"),
    inSource = op.inStringEditor("Document", "xml"),
    elementPort = op.outObject("Element");

if (inMode.get() === "document")
{
    inSource.setUiAttribs({ "greyout": true });
    inMimeType.set("text/html");
    inMimeType.setUiAttribs({ "greyout": true });
}

inUpdate.onTriggered =
queryPort.onChange =
inMimeType.onChange =
inSource.onChange = update;

inMode.onChange = modeChange;

function update()
{
    const q = queryPort.get();
    const theDocument = inSource.get();
    const mode = inMode.get();
    if (mode === "string input" && theDocument)
    {
        let parser = new DOMParser();
        let htmlDoc = null;
        try
        {
            htmlDoc = parser.parseFromString(theDocument, inMimeType.get());
            const el = htmlDoc.querySelector(q);
            elementPort.set(el);
        }
        catch (e)
        {
            op.logError(e);
        }
    }
    else
    {
        try
        {
            const el = document.querySelector(q);
            elementPort.set(el);
        }
        catch (e)
        {
            op.logError(e);
        }
    }
}

function modeChange()
{
    if (inMode.get() === "document")
    {
        inSource.setUiAttribs({ "greyout": true });
        inMimeType.set("text/html");
        inMimeType.setUiAttribs({ "greyout": true });
    }
    else
    {
        inSource.setUiAttribs({ "greyout": false });
        inMimeType.setUiAttribs({ "greyout": false });
    }
}


};

Ops.Html.QuerySelector_v2.prototype = new CABLES.Op();
CABLES.OPS["a1a2189b-564c-4dd7-b3d9-a6cebc0cd94e"]={f:Ops.Html.QuerySelector_v2,objName:"Ops.Html.QuerySelector_v2"};




// **************************************************************
// 
// Ops.Html.ReloadPage
// 
// **************************************************************

Ops.Html.ReloadPage = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
var exec=op.inTrigger("Exec");

exec.onTriggered=function()
{
    location.reload();

};

};

Ops.Html.ReloadPage.prototype = new CABLES.Op();
CABLES.OPS["d0060a4e-ffed-4a8d-8f6d-bfd9a23319de"]={f:Ops.Html.ReloadPage,objName:"Ops.Html.ReloadPage"};




// **************************************************************
// 
// Ops.Html.RemoveAllClasses
// 
// **************************************************************

Ops.Html.RemoveAllClasses = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe=op.inTriggerButton("Remove");
const inName=op.inValueString("Classname");

exe.onTriggered=function()
{
    var els=document.getElementsByClassName(inName.get());
    
    for(var i=0;i<els.length;i++)
    {
        els[i].classList.remove( inName.get() );
    }
    
};


};

Ops.Html.RemoveAllClasses.prototype = new CABLES.Op();
CABLES.OPS["4b5cf767-59ab-48ac-901f-c484cf2b6760"]={f:Ops.Html.RemoveAllClasses,objName:"Ops.Html.RemoveAllClasses"};




// **************************************************************
// 
// Ops.Html.ScrollPosition
// 
// **************************************************************

Ops.Html.ScrollPosition = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const sleft = op.addOutPort(new CABLES.Port(op, "left"));
const stop = op.addOutPort(new CABLES.Port(op, "top"));

document.addEventListener("scroll", updateScroll);
updateScroll();

function updateScroll()
{
    sleft.set((window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft);
    stop.set((window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop);
}


};

Ops.Html.ScrollPosition.prototype = new CABLES.Op();
CABLES.OPS["1bc6bbfa-9574-40ef-8eb0-f045d88f828d"]={f:Ops.Html.ScrollPosition,objName:"Ops.Html.ScrollPosition"};




// **************************************************************
// 
// Ops.Html.SetCssVariableColor
// 
// **************************************************************

Ops.Html.SetCssVariableColor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    varname = op.inString("Var Name"),
    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random());

let root = document.documentElement;

r.setUiAttribs({ "colorPick": true });
r.onChange =
    g.onChange =
    b.onChange =
    varname.onChange = update;

function toHex(c)
{
    c = (Math.floor(c * 255));
    let hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}

function update()
{
    const hex = "#" + toHex(r.get()) + toHex(g.get()) + toHex(b.get());
    root.style.setProperty("--" + varname.get(), hex);
}


};

Ops.Html.SetCssVariableColor.prototype = new CABLES.Op();
CABLES.OPS["3a478c83-1dcd-4d06-baa9-96d02ebf941f"]={f:Ops.Html.SetCssVariableColor,objName:"Ops.Html.SetCssVariableColor"};




// **************************************************************
// 
// Ops.Html.SetCssVariableString
// 
// **************************************************************

Ops.Html.SetCssVariableString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    varname = op.inString("Var Name"),
    val = op.inString("Value"),
    quoted = op.inBool("Output quoted string", false);

const root = document.documentElement;

val.onChange = varname.onChange = quoted.onChange = update;

function update()
{
    op.setUiAttrib({ "extendTitle": varname.get() });
    let value = val.get();
    if (quoted.get())
    {
        value = "\"" + value + "\"";
    }

    root.style.setProperty("--" + varname.get(), value);
}


};

Ops.Html.SetCssVariableString.prototype = new CABLES.Op();
CABLES.OPS["e7b4ea20-ef7e-461d-92f8-6aff58c5ba6f"]={f:Ops.Html.SetCssVariableString,objName:"Ops.Html.SetCssVariableString"};




// **************************************************************
// 
// Ops.Html.TextArea_v2
// 
// **************************************************************

Ops.Html.TextArea_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let visible = op.inValueBool("visible", true);
let inFocus = op.inTriggerButton("focus");
let inBlur = op.inTriggerButton("blur");

let text = op.outString("text", "");
let cursorPos = op.outNumber("cursorPos");
let focussed = op.outBoolNum("focussed");
let escapeButton = op.outTrigger("escape pressed");
let outEle = op.outObject("Element");

let element = document.createElement("textarea");
element.id = "thetextarea";
element.style.position = "absolute";
element.style.top = "0px";
element.style.width = "300px";
element.style.opacity = 0.75;
element.style.height = "100px";
element.style.overflow = "hidden";
element.style.border = "none";
element.style.padding = 0;
element.style["z-index"] = "999999";

outEle.set(element);

let canvas = document.body;
canvas.appendChild(element);

element.addEventListener("input", update);
element.onkeydown = update;
update();

visible.onChange = function ()
{
    if (!visible.get())
    {
        element.style.width = "0px";
        element.style.height = "0px";
    }
    else
    {
        element.style.width = "300px";
        element.style.height = "100px";
    }
};

element.onfocus = function ()
{
    element.focus();
    focussed.set(true);
};

element.onblur = function ()
{
    focussed.set(false);
    canvas.focus();
};

element.onkeyup = function (e)
{
    if (e.keyCode == 27)
    {
        focussed.set(false);
        escapeButton.trigger();
    }
};

op.onDelete = function ()
{
    element.remove();
};

inFocus.onTriggered = function ()
{
    element.focus();
};

inBlur.onTriggered = function ()
{
    element.blur();
};

function update()
{
    text.set(element.value || "");
    cursorPos.set(element.selectionStart);
}


};

Ops.Html.TextArea_v2.prototype = new CABLES.Op();
CABLES.OPS["5a9075e6-0550-46df-99b9-7402b2fbd953"]={f:Ops.Html.TextArea_v2,objName:"Ops.Html.TextArea_v2"};




// **************************************************************
// 
// Ops.Html.ToggleClass
// 
// **************************************************************

Ops.Html.ToggleClass = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEle = op.inObject("HTML Element"),
    inClassName = op.inString("Classname"),
    inActive = op.inValueBool("Active", true);

inActive.onChange =
    inClassName.onChange =
    inEle.onChange = update;

op.onDelete = remove;

let oldEle = null;
let oldName = null;

function remove(ele)
{
    if (ele && ele.classList) ele.classList.remove(oldName);
}

function update()
{
    let ele = inEle.get();
    let cn = inClassName.get();

    if (!inEle.isLinked()) remove(oldEle);

    if (!cn || !ele || !ele.classList) return;
    if (oldEle && ele != oldEle)oldEle.classList.remove(cn);
    remove(ele);

    if (!inActive.get()) ele.classList.remove(cn);
    else ele.classList.add(cn);

    oldName = cn;
    oldEle = ele;
}


};

Ops.Html.ToggleClass.prototype = new CABLES.Op();
CABLES.OPS["6dd90fb9-7f28-427f-acd8-589f21a906bb"]={f:Ops.Html.ToggleClass,objName:"Ops.Html.ToggleClass"};




// **************************************************************
// 
// Ops.Html.TransformElement
// 
// **************************************************************

Ops.Html.TransformElement = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Exec"),
    inEle = op.inObject("Element"),
    next = op.outTrigger("Next"),
    inScale = op.inFloat("Scale", 1),
    inOrtho = op.inBool("Orthogonal", false),
    inRotate = op.inFloat("Rotate", 0),
    inHideBehind = op.inBool("Hide out of view", false),
    inAlignVert = op.inSwitch("Align Vertical", ["Left", "Center", "Right"], "Left"),
    inAlignHor = op.inSwitch("Align Horizontal", ["Top", "Center", "Bottom"], "Top"),
    inActive = op.inBool("Active", true);

const cgl = op.patch.cgl;
let x = 0;
let y = 0;
let visible = 0;
const m = mat4.create();
const pos = vec3.create();
const trans = vec3.create();

let cachedTop = -1;
let cachedLeft = -1;

exec.onTriggered =
() =>
{
    if (!inActive.get()) return next.trigger();

    setProperties();
    next.trigger();
};

op.onDelete = removeProperties;

let oldEle = null;

inAlignHor.onChange =
    inAlignVert.onChange =
    inRotate.onChange =
    inScale.onChange = updateTransform;

function updateTransform()
{
    const ele = inEle.get();
    if (!ele)
    {
        oldEle = null;
        return;
    }

    let translateStr = "";
    if (inAlignVert.get() == "Left")translateStr = "0%";
    if (inAlignVert.get() == "Center")translateStr = "-50%";
    if (inAlignVert.get() == "Right")translateStr = "-100%";

    translateStr += ", ";
    if (inAlignHor.get() == "Top")translateStr += "0%";
    if (inAlignHor.get() == "Center")translateStr += "-50%";
    if (inAlignHor.get() == "Bottom")translateStr += "-100%";

    const str = "translate(" + translateStr + ") scale(" + inScale.get() + ") rotate(" + inRotate.get() + "deg)";

    if (ele.style.transform != str) ele.style.transform = str;
}

inEle.onChange = function ()
{
    const ele = inEle.get();
    if (!ele)
    {
        removeProperties(oldEle);

        oldEle = null;
        return;
    }

    updateTransform();
    setProperties();
};

inEle.onLinkChanged = function ()
{
    cachedLeft = -1;
    cachedTop = -1;

    if (!inEle.isLinked())
    {
        if (oldEle)
        {
            removeProperties(oldEle);
        }
    }
    else
    {
        oldEle = inEle.get();
    }
    updateTransform();
};

function getScreenCoord()
{
    mat4.multiply(m, cgl.vMatrix, cgl.mMatrix);
    vec3.transformMat4(pos, [0, 0, 0], m);
    vec3.transformMat4(trans, pos, cgl.pMatrix);

    const vp = cgl.getViewPort();

    const w = cgl.canvasWidth / cgl.pixelDensity;
    const h = cgl.canvasHeight / cgl.pixelDensity;

    if (inOrtho.get())
    {
        x = ((w * 0.5 + trans[0] * w * 0.5 / 1));
        y = ((h * 0.5 - trans[1] * h * 0.5 / 1));
    }
    else
    {
        x = (w - (w * 0.5 - trans[0] * w * 0.5)); //  / trans[2]
        y = (h - (h * 0.5 + trans[1] * h * 0.5)); //  / trans[2]
    }

    visible = pos[2] < 0.0 && x > 0 && x < vp[2] && y > 0 && y < vp[3];
}

function setProperties()
{
    const ele = inEle.get();
    oldEle = ele;
    if (ele && ele.style)
    {
        getScreenCoord();
        const yy = cgl.canvas.offsetTop + y;

        if (yy != cachedTop)
        {
            ele.style.top = yy + "px";
            cachedTop = yy;
        }

        if (x != cachedLeft)
        {
            ele.style.left = x + "px";
            cachedLeft = x;
        }

        if (inHideBehind.get())
        {
            if (visible)ele.style.display = "initial";
            else ele.style.display = "none";
        }
    }
}

function removeProperties(ele)
{
    cachedLeft = -1;
    cachedTop = -1;

    if (!ele) ele = inEle.get();
    if (ele && ele.style)
    {
        ele.style.top = "initial";
        ele.style.left = "initial";
        ele.style.transform = "initial";
    }
}

op.addEventListener("onEnabledChange", function (enabled)
{
    if (enabled) setProperties();
    else removeProperties();
});


};

Ops.Html.TransformElement.prototype = new CABLES.Op();
CABLES.OPS["caca0307-d460-47df-8674-b7d2601239ab"]={f:Ops.Html.TransformElement,objName:"Ops.Html.TransformElement"};




// **************************************************************
// 
// Ops.Html.VideoElement
// 
// **************************************************************

Ops.Html.VideoElement = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    // src=op.inString("URL",'https://undev.studio'),
    src = op.inUrl("File", null, ""),
    elId = op.inString("ID"),
    play = op.inBool("Play"),
    controls = op.inBool("Controls", true),
    active = op.inBool("Active", true),
    loop = op.inBool("Loop", false),
    inMuted = op.inBool("Muted", false),
    inStyle = op.inStringEditor("Style", "position:absolute;\nz-index:9999;\nborder:0;\nwidth:50%;\nheight:50%;"),
    rewind = op.inTriggerButton("Rewind"),
    outEle = op.outObject("Element"),
    outPlaying = op.outBool("Playing"),
    outCanplaythrough = op.outBool("Can Play Through"),
    outTime = op.outNumber("Time"),
    outEnded = op.outTrigger("Ended"),
    outHasError = op.outBool("Has Error"),
    outError = op.outString("Error Message");
op.setPortGroup("Attributes", [src, elId]);

let element = document.createElement("video");
let timeOut = null;

op.onDelete = removeEle;

op.onLoaded = init;

function init()
{
    addElement();
    updateSoon();

    inStyle.onChange =
    src.onChange =
    elId.onChange = updateSoon;

    active.onChange = updateActive;
}

init();

loop.onChange =
controls.onChange =
inMuted.onChange = updateVideoSettings;

function updateVideoSettings()
{
    if (!element) return;
    if (controls.get()) element.controls = "true";
    else
    {
        element.controls = "true";
        element.removeAttribute("controls");
    }

    if (loop.get()) element.loop = "true";
    else element.removeAttribute("loop");

    if (inMuted.get()) element.muted = "true";
    else element.removeAttribute("muted");
}

function updatePlay()
{
    if (!element) return;
    if (play.get())element.play();
    else element.pause();
}

play.onChange = () =>
{
    updatePlay();
};

rewind.onTriggered = function ()
{
    if (element) element.currentTime = 0;
};

function addElement()
{
    if (!active.get()) return;
    if (element) removeEle();
    element = document.createElement("video");
    element.setAttribute("playsinline", "");
    element.setAttribute("webkit-playsinline", "");
    element.preload = "true";
    updateVideoSettings();
    element.setAttribute("crossOrigin", "anonymous");
    outCanplaythrough.set(false);

    outHasError.set(false);
    outError.set("");

    element.addEventListener("canplaythrough", () =>
    {
        outCanplaythrough.set(true);
    }, true);
    element.addEventListener("play", () =>
    {
        outPlaying.set(true);
    }, true);
    element.addEventListener("ended", () =>
    {
        outEnded.trigger();
    }, true);
    element.addEventListener("pause", () =>
    {
        outPlaying.set(false);
    }, true);

    element.addEventListener("timeupdate", () =>
    {
        if (element)outTime.set(element.currentTime);
    }, true);

    element.onerror = function ()
    {
        outHasError.set(true);
        if (element && element.error)
        {
            outError.set("Error " + element.error.code + "/" + element.error.message);
            op.log("Error " + element.error.code + "; details: " + element.error.message);
        }
    };

    // element.playbackRate = speed.get();
    // if (!addedListeners)
    // {
    //     addedListeners = true;
    //     element.addEventListener("canplaythrough", initVideo, true);
    //     element.addEventListener("loadedmetadata", loadedMetaData);
    //     element.addEventListener("playing", function () { videoElementPlaying = true; }, true);
    // }

    updateAttribs();
    const parent = op.patch.cgl.canvas.parentElement;
    parent.appendChild(element);

    updateVideoSettings();

    if (play.get())updatePlay();

    outEle.set(element);
}

function updateSoon()
{
    clearTimeout(timeOut);
    timeOut = setTimeout(updateAttribs, 30);
}

function updateAttribs()
{
    if (!element || !src.get()) return;
    element.setAttribute("style", inStyle.get());
    element.setAttribute("src", src.get());
    element.setAttribute("id", elId.get());
}

function removeEle()
{
    if (element && element.parentNode)element.parentNode.removeChild(element);
    element = null;
    outEle.set(element);
}

function updateActive()
{
    if (!active.get())
    {
        removeEle();
        return;
    }

    addElement();
}


};

Ops.Html.VideoElement.prototype = new CABLES.Op();
CABLES.OPS["5315a156-3a4f-4ff3-80c7-1b73c839d388"]={f:Ops.Html.VideoElement,objName:"Ops.Html.VideoElement"};




// **************************************************************
// 
// Ops.Html.WindowClose
// 
// **************************************************************

Ops.Html.WindowClose = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec=op.inTriggerButton("Close");

inExec.onTriggered=function()
{
    window.close();
};

};

Ops.Html.WindowClose.prototype = new CABLES.Op();
CABLES.OPS["4f5d56b9-28a0-47fe-86f7-7b765268d694"]={f:Ops.Html.WindowClose,objName:"Ops.Html.WindowClose"};




// **************************************************************
// 
// Ops.Html.WindowHasFocus
// 
// **************************************************************

Ops.Html.WindowHasFocus = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    outFocussed = op.outBool("has focus"),
    outVisible = op.outBool("Tab Visible", true);

const focused = true;

outFocussed.set(document.hasFocus());

window.addEventListener("blur", handleBlur);
window.addEventListener("focus", handleFocus);

document.addEventListener("visibilitychange", updateVisibility);

op.onDelete = function ()
{
    document.removeEventListener("visibilitychange", updateVisibility);
};

function handleFocus()
{
    outFocussed.set(true);
}

function handleBlur()
{
    outFocussed.set(false);
}

function updateVisibility(e)
{
    outVisible.set(!document.hidden);
}


};

Ops.Html.WindowHasFocus.prototype = new CABLES.Op();
CABLES.OPS["6542896e-aa13-4b57-81e0-163597f4149a"]={f:Ops.Html.WindowHasFocus,objName:"Ops.Html.WindowHasFocus"};




// **************************************************************
// 
// Ops.Html.WindowInfo
// 
// **************************************************************

Ops.Html.WindowInfo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    outWidth = op.outNumber("clientWidth"),
    outHeight = op.outNumber("clientHeight"),
    outHeightBody = op.outNumber("body scroll Height"),
    outIframeChild = op.outBoolNum("Iframe Parent", window.top != window.self);

window.addEventListener("resize", update);

update();

function update()
{
    outWidth.set(window.innerWidth);
    outHeight.set(window.innerHeight);

    outHeightBody.set(document.documentElement.scrollHeight);
}


};

Ops.Html.WindowInfo.prototype = new CABLES.Op();
CABLES.OPS["9655045c-3539-457d-be65-a1456a58906a"]={f:Ops.Html.WindowInfo,objName:"Ops.Html.WindowInfo"};




// **************************************************************
// 
// Ops.Html.YoutubePlayer
// 
// **************************************************************

Ops.Html.YoutubePlayer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    src = op.inString("Video Id", "dQw4w9WgXcQ"),
    active = op.inBool("Active", true),
    inStyle = op.inStringEditor("Style"),
    elId = op.inString("ElementID"),
    paramAutoplay = op.inBool("Autoplay", false),
    paramCC = op.inBool("Display Captions", false),
    paramLoop = op.inBool("Loop", false),
    paramFs = op.inBool("Allow Fullscreen", true),
    paramControls = op.inBool("Hide Controls", false),
    paramStart = op.inInt("Start at Second", 0),

    outEle = op.outObject("Element"),
    outDirectLink = op.outString("Direct Link");
    // outImageMax=op.outString("Thumbnail Max");

const defaultStyle = "position:absolute;\n\
z-index:9;\n\
border:0;\n";

op.setPortGroup("Youtube Options", [paramAutoplay, paramCC, paramLoop, paramFs, paramControls, paramStart]);

// https://developers.google.com/youtube/player_parameters

let element = null;
let initialized = false;

paramStart.onChange =
    paramAutoplay.onChange =
    paramCC.onChange =
    paramLoop.onChange =
    paramFs.onChange =
    paramControls.onChange =
    src.onChange = updateURL;

elId.onChange = updateID;
inStyle.onChange = updateStyle;
op.onDelete = removeEle;

active.onChange = update;

op.init = function ()
{
    initialized = true;
    setTimeout(() => { update(); }, 100);
};

inStyle.set(defaultStyle);

function update()
{
    if (!active.get())
    {
        removeEle();
        return;
    }

    addElement();
}

function addElement()
{
    if (!initialized) return;
    if (element) removeEle();

    const parent = op.patch.cgl.canvas.parentElement;
    element = document.createElement("iframe");
    element.dataset.op = op.id;
    element.style.position = "absolute";
    element.allowfullscreen = true;
    element.frameborder = 0;
    element.allow = "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture";

    parent.appendChild(element);

    updateURL();
    updateID();
    updateStyle();

    outEle.set(null);
    outEle.set(element);
}

function removeEle()
{
    if (element && element.parentNode) element.parentNode.removeChild(element);
    element = null;
    outEle.set(null);
}

function updateURL()
{
    if (src.get()) outDirectLink.set("https://www.youtube.com/watch?v=" + src.get());

    if (!initialized) return;
    if (!active.get()) return;
    const urlParams = [];

    if (paramAutoplay.get()) urlParams.push("autoplay=1");
    if (paramCC.get()) urlParams.push("cc_load_policy=1");
    if (paramLoop.get()) urlParams.push("loop=1");
    if (paramFs.get()) urlParams.push("fs=1");
    if (paramControls.get()) urlParams.push("controls=0");
    if (paramStart.get() > 0) urlParams.push("start=" + paramStart.get());

    let urlParamsStr = "";
    if (urlParams.length > 0) urlParamsStr = "?" + urlParams.join("&") + "&rel=0";

    const urlStr = "https://www.youtube.com/embed/" + src.get() + urlParamsStr;
    if (element)
        element.setAttribute("src", urlStr);
}

function updateID()
{
    if (!active.get()) return;
    if (element) element.setAttribute("id", elId.get());
}

function updateStyle()
{
    if (!active.get()) return;
    if (element) element.style = inStyle.get();
}


};

Ops.Html.YoutubePlayer.prototype = new CABLES.Op();
CABLES.OPS["b60ad395-d6ad-4309-86c5-c6bbffaf176c"]={f:Ops.Html.YoutubePlayer,objName:"Ops.Html.YoutubePlayer"};




// **************************************************************
// 
// Ops.Json.AjaxRequest_v2
// 
// **************************************************************

Ops.Json.AjaxRequest_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const filename = op.inUrl("file"),
    jsonp = op.inValueBool("JsonP", false),
    headers = op.inObject("headers", {}),
    inBody = op.inStringEditor("body", ""),
    inMethod = op.inDropDown("HTTP Method", ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "CONNECT", "OPTIONS", "TRACE"], "GET"),
    inContentType = op.inString("Content-Type", "application/json"),
    inParseJson = op.inBool("parse json", true),
    inAutoRequest = op.inBool("Auto request", true),
    reloadTrigger = op.inTriggerButton("reload"),
    outData = op.outObject("data"),
    outString = op.outString("response"),
    isLoading = op.outBoolNum("Is Loading", false),
    outTrigger = op.outTrigger("Loaded");

filename.setUiAttribs({ "title": "URL" });
reloadTrigger.setUiAttribs({ "buttonTitle": "trigger request" });

outData.ignoreValueSerialize = true;
outString.ignoreValueSerialize = true;

inAutoRequest.onChange = filename.onChange = jsonp.onChange = headers.onChange = inMethod.onChange = inParseJson.onChange = function ()
{
    delayedReload(false);
};

reloadTrigger.onTriggered = function ()
{
    delayedReload(true);
};

let loadingId = 0;
let reloadTimeout = 0;

function delayedReload(force = false)
{
    clearTimeout(reloadTimeout);
    reloadTimeout = setTimeout(function () { reload(null, force); }, 100);
}

op.onFileChanged = function (fn)
{
    if (filename.get() && filename.get().indexOf(fn) > -1) reload(true);
};

function reload(addCachebuster, force = false)
{
    if (!inAutoRequest.get() && !force) return;
    if (!filename.get()) return;

    op.patch.loading.finished(loadingId);

    loadingId = op.patch.loading.start("jsonFile", "" + filename.get());
    isLoading.set(true);

    op.setUiAttrib({ "extendTitle": CABLES.basename(filename.get()) });
    op.setUiError("jsonerr", null);

    let httpClient = CABLES.ajax;
    if (jsonp.get()) httpClient = CABLES.jsonp;

    let url = op.patch.getFilePath(filename.get());
    if (addCachebuster)url += "?rnd=" + CABLES.generateUUID();

    op.patch.loading.addAssetLoadingTask(() =>
    {
        const body = inBody.get();
        httpClient(
            url,
            (err, _data, xhr) =>
            {
                outData.set(null);
                outString.set(null);
                if (err)
                {
                    op.patch.loading.finished(loadingId);
                    isLoading.set(false);

                    op.logError(err);
                    return;
                }
                try
                {
                    let data = _data;
                    if (typeof data === "string" && inParseJson.get())
                    {
                        data = JSON.parse(_data);
                        outData.set(data);
                    }
                    outString.set(_data);
                    op.uiAttr({ "error": null });
                    op.patch.loading.finished(loadingId);
                    outTrigger.trigger();
                    isLoading.set(false);
                }
                catch (e)
                {
                    op.logError(e);
                    op.setUiError("jsonerr", "Problem while loading json:<br/>" + e);
                    op.patch.loading.finished(loadingId);
                    isLoading.set(false);
                }
            },
            inMethod.get(),
            (body && body.length > 0) ? body : null,
            inContentType.get(),
            null,
            headers.get() || {}
        );
    });
}


};

Ops.Json.AjaxRequest_v2.prototype = new CABLES.Op();
CABLES.OPS["e0879058-5505-4dc4-b9ff-47a3d3c8a71a"]={f:Ops.Json.AjaxRequest_v2,objName:"Ops.Json.AjaxRequest_v2"};




// **************************************************************
// 
// Ops.Json.ArrayGetArrayByPath
// 
// **************************************************************

Ops.Json.ArrayGetArrayByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inArray("Array");
const pathIn = op.inString("Path");
const resultOut = op.outArray("Output");
const foundOut = op.outBool("Found");

objectIn.onChange = update;
pathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    const path = pathIn.get();
    op.setUiError("missing", null);
    if (data && path)
    {
        if (!Array.isArray(data) && !(typeof data === "object"))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input object of type " + (typeof data) + " is not travesable by path");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            op.setUiAttrib({ "extendTitle": parts[parts.length - 1] + "" });
            let result = resolve(path, data);
            if (result === undefined)
            {
                const errorMsg = "could not find element at path " + path;
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else if (!Array.isArray(result))
            {
                const errorMsg = "element at path " + path + " is not an array";
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else
            {
                foundOut.set(true);
            }
            resultOut.set(result);
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ArrayGetArrayByPath.prototype = new CABLES.Op();
CABLES.OPS["f8fd1e41-d56a-4046-83a1-2ca194c828fc"]={f:Ops.Json.ArrayGetArrayByPath,objName:"Ops.Json.ArrayGetArrayByPath"};




// **************************************************************
// 
// Ops.Json.ArrayGetArrayValuesByPath
// 
// **************************************************************

Ops.Json.ArrayGetArrayValuesByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inArray("Array");
const pathIn = op.inString("Path");
const resultOut = op.outArray("Output");
const foundOut = op.outBool("Found");

objectIn.onChange = update;
pathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    let result = [];
    const path = pathIn.get();
    op.setUiError("path", null);

    if (data && path)
    {
        if (!Array.isArray(data))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input of type " + (typeof data) + " is not an array");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            foundOut.set(false);

            const pathSuffix = parts.slice(1).join(".");

            for (let i = 0; i < data.length; i++)
            {
                const resolvePath = i + "." + pathSuffix;
                const resolvedData = resolve(resolvePath, data);
                if (typeof resolvedData !== "undefined")
                {
                    foundOut.set(true);
                }
                result.push(resolvedData);
            }
            const titleParts = pathIn.get().split(".");
            op.setUiAttrib({ "extendTitle": titleParts[titleParts.length - 1] + "" });
            if (foundOut.get())
            {
                resultOut.set(result);
            }
            else
            {
                op.setUiError("path", "given path seems to be invalid!", 1);
                resultOut.set([]);
            }
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ArrayGetArrayValuesByPath.prototype = new CABLES.Op();
CABLES.OPS["f4aa5756-c681-47ac-a997-b4f91760db96"]={f:Ops.Json.ArrayGetArrayValuesByPath,objName:"Ops.Json.ArrayGetArrayValuesByPath"};




// **************************************************************
// 
// Ops.Json.ArrayGetNumberByPath
// 
// **************************************************************

Ops.Json.ArrayGetNumberByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inArray("Array");
const pathIn = op.inString("Path");
const resultOut = op.outNumber("Output");
const foundOut = op.outBool("Found");

objectIn.onChange = update;
pathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    const path = pathIn.get();
    op.setUiError("missing", null);
    if (data && path)
    {
        if (!Array.isArray(data) && !(typeof data === "object"))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input object of type " + (typeof data) + " is not travesable by path");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            op.setUiAttrib({ "extendTitle": parts[parts.length - 1] + "" });
            let result = resolve(path, data);
            if (result === undefined)
            {
                const errorMsg = "could not find element at path " + path;
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else if (typeof result !== "number")
            {
                const errorMsg = "element at path " + path + " is not a number";
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else
            {
                foundOut.set(true);
            }
            resultOut.set(result);
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ArrayGetNumberByPath.prototype = new CABLES.Op();
CABLES.OPS["9a8ac7c9-dc88-44cb-b4f7-fead5ebb9ed7"]={f:Ops.Json.ArrayGetNumberByPath,objName:"Ops.Json.ArrayGetNumberByPath"};




// **************************************************************
// 
// Ops.Json.ArrayGetObjectByPath
// 
// **************************************************************

Ops.Json.ArrayGetObjectByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inArray("Array");
const pathIn = op.inString("Path");
const resultOut = op.outObject("Output");
const foundOut = op.outBool("Found");

objectIn.onChange = update;
pathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    const path = pathIn.get();
    op.setUiError("missing", null);
    if (data && path)
    {
        if (!Array.isArray(data) && !(typeof data === "object"))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input object of type " + (typeof data) + " is not travesable by path");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            op.setUiAttrib({ "extendTitle": parts[parts.length - 1] + "" });
            let result = resolve(path, data);
            if (result === undefined)
            {
                const errorMsg = "could not find element at path " + path;
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else if (Array.isArray(result) || result === null || typeof result !== "object")
            {
                const errorMsg = "element at path " + path + " is not an object";
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else
            {
                foundOut.set(true);
            }
            resultOut.set(result);
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ArrayGetObjectByPath.prototype = new CABLES.Op();
CABLES.OPS["c73970f0-f8fb-4d12-af19-649d17b0195f"]={f:Ops.Json.ArrayGetObjectByPath,objName:"Ops.Json.ArrayGetObjectByPath"};




// **************************************************************
// 
// Ops.Json.ArrayGetStringByPath
// 
// **************************************************************

Ops.Json.ArrayGetStringByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inArray("Array");
const pathIn = op.inString("Path");
const returnPathIn = op.inBool("Return path if missing", false);
const resultOut = op.outString("Output");
const foundOut = op.outBool("Found");

objectIn.onChange = update;
pathIn.onChange = update;
returnPathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    const path = pathIn.get();
    op.setUiError("missing", null);
    if (data && path)
    {
        if (!Array.isArray(data) && !(typeof data === "object"))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input object of type " + (typeof data) + " is not travesable by path");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            op.setUiAttrib({ "extendTitle": parts[parts.length - 1] + "" });
            let result = resolve(path, data);
            if (result === undefined)
            {
                const errorMsg = "could not find element at path " + path;
                let errorLevel = 2;
                result = null;
                foundOut.set(false);
                if (returnPathIn.get())
                {
                    result = path;
                    errorLevel = 1;
                }
                else
                {
                    result = null;
                }
                op.setUiError("missing", errorMsg, errorLevel);
            }
            else
            {
                foundOut.set(true);
                result = String(result);
            }
            resultOut.set(result);
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ArrayGetStringByPath.prototype = new CABLES.Op();
CABLES.OPS["064fc275-f61d-4c5f-9692-28c2062248bf"]={f:Ops.Json.ArrayGetStringByPath,objName:"Ops.Json.ArrayGetStringByPath"};




// **************************************************************
// 
// Ops.Json.CsvArray
// 
// **************************************************************

Ops.Json.CsvArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    filename = op.inUrl("file"),
    result = op.outArray("result"),
    len = op.outNumber("num items");

const reload = function ()
{
    CABLES.ajax(
        op.patch.getFilePath(filename.get()),
        function (err, _data, xhr)
        {
            try
            {
                const data = JSON.parse(_data);
                result.set(data);
                len.set(data.length);
            }
            catch (e)
            {
                op.logError(e);
                result.set(null);
                len.set(0);
            }
        });
};

filename.onChange = reload;


};

Ops.Json.CsvArray.prototype = new CABLES.Op();
CABLES.OPS["2e76c1f8-19ac-4e9d-8db8-58b2f9fbc1d3"]={f:Ops.Json.CsvArray,objName:"Ops.Json.CsvArray"};




// **************************************************************
// 
// Ops.Json.CsvColumnArray_v2
// 
// **************************************************************

Ops.Json.CsvColumnArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    colName = op.inString("Column Name", "name"),
    inArr = op.inArray("CSV Array"),
    inNumbers = op.inBool("Numbers", false),
    result = op.outArray("Result");

colName.onChange =
inNumbers.onChange =
    inArr.onChange = update;

function update()
{
    let iArr = inArr.get();
    let iName = colName.get();

    if (!iArr)
    {
        result.set(null);
        return;
    }

    op.setUiError("notfound", null);
    op.setUiError("notnum", null);

    if (iArr[0].hasOwnProperty(iName))
    {
        let arr = [];

        let hasStrings = false;

        if (inNumbers.get())
        {
            for (let i = 0; i < iArr.length; i++)
            {
                let n = Number(iArr[i][iName] || 0);
                arr.push(n);
                if (!CABLES.UTILS.isNumeric(iArr[i][iName]))
                {
                    hasStrings = true;
                }
            }

            if (hasStrings)
            {
                op.setUiError("notnum", "Parse Error / Not all values numerical!");
            }
        }
        else
        {
            for (let i = 0; i < iArr.length; i++)
                arr.push(iArr[i][iName]);
        }
        result.set(arr);
    }
    else
        op.setUiError("notfound", "Column not found");
}


};

Ops.Json.CsvColumnArray_v2.prototype = new CABLES.Op();
CABLES.OPS["2503021e-1599-40d9-b038-bf5a36c6b2c7"]={f:Ops.Json.CsvColumnArray_v2,objName:"Ops.Json.CsvColumnArray_v2"};




// **************************************************************
// 
// Ops.Json.FilterValidObject
// 
// **************************************************************

Ops.Json.FilterValidObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj=op.inObject("Object"),
    outObject=op.outObject("Last Valid Object"),
    outValid=op.outBool("Is Valid");

inObj.onChange=
    update;


function update()
{
    const obj=inObj.get();

    var r=true;

    if(!obj) r=false;

    if(r) outObject.set(obj);

    outValid.set(r);
}

};

Ops.Json.FilterValidObject.prototype = new CABLES.Op();
CABLES.OPS["a851cddb-74e5-41e7-ac75-709beae914fd"]={f:Ops.Json.FilterValidObject,objName:"Ops.Json.FilterValidObject"};




// **************************************************************
// 
// Ops.Json.GateObject
// 
// **************************************************************

Ops.Json.GateObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    valueInPort = op.inObject("Object In"),
    passThroughPort = op.inValueBool("Pass Through", false),
    onlyValid = op.inValueBool("Only Valid Objects", false),
    valueOutPort = op.outObject("Object Out");

valueInPort.onChange =
    passThroughPort.onChange = update;
valueInPort.changeAlways = true;

function update()
{
    if (!valueInPort.get() && onlyValid.get()) return;
    if (passThroughPort.get()) valueOutPort.set(valueInPort.get());
    // else valueOutPort.set(null);
}


};

Ops.Json.GateObject.prototype = new CABLES.Op();
CABLES.OPS["95e04331-49d6-42da-81d8-5a75261ab22f"]={f:Ops.Json.GateObject,objName:"Ops.Json.GateObject"};




// **************************************************************
// 
// Ops.Json.GetStringFromObject
// 
// **************************************************************

Ops.Json.GetStringFromObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    data = op.inObject("data"),
    key = op.inString("key"),
    result = op.outString("result");

result.ignoreValueSerialize = true;
data.ignoreValueSerialize = true;

data.onChange = exec;

key.onChange = function ()
{
    op.setUiAttrib({ "extendTitle": key.get() });
    exec();
};

function exec()
{
    const dat = data.get();
    const theKey = key.get();

    if (dat && dat.hasOwnProperty(theKey)) result.set(dat[theKey]);
    else result.set(null);
}


};

Ops.Json.GetStringFromObject.prototype = new CABLES.Op();
CABLES.OPS["6562a543-2147-485d-8fd3-58fe3357684e"]={f:Ops.Json.GetStringFromObject,objName:"Ops.Json.GetStringFromObject"};




// **************************************************************
// 
// Ops.Json.ObjectFilterContentByKey
// 
// **************************************************************

Ops.Json.ObjectFilterContentByKey = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj=op.inObject("Object"),
    inStr=op.inString("name",""),
    inRemoveNull=op.inBool("Remove Null",false),
    outObj=op.outObject("Result");

inObj.onChange=
    inStr.onChange=
    inRemoveNull.onChange=update;

function update()
{
    const obj=JSON.parse(JSON.stringify(inObj.get()));

    filter(obj);

    outObj.set(null);
    outObj.set(obj);
}

function filter(obj)
{
    for(let i in obj)
    {
        if(inStr.get() && i.indexOf(inStr.get())!==0)delete obj[i];
        if(inRemoveNull.get() && obj[i]===null)delete obj[i];

        if(typeof obj[i] =="object") filter(obj[i]);
    }
}

};

Ops.Json.ObjectFilterContentByKey.prototype = new CABLES.Op();
CABLES.OPS["89bddc38-000b-4982-8b37-b6e48f0b001b"]={f:Ops.Json.ObjectFilterContentByKey,objName:"Ops.Json.ObjectFilterContentByKey"};




// **************************************************************
// 
// Ops.Json.ObjectFunnel
// 
// **************************************************************

Ops.Json.ObjectFunnel = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj1 = op.inObject("Object1"),
    inObj2 = op.inObject("Object2"),
    inObj3 = op.inObject("Object3"),
    inObj4 = op.inObject("Object4"),
    inObj5 = op.inObject("Object5");

let outObj = op.outObject("Out Object");

inObj1.onChange = function ()
{
    outObj.set(null);
    outObj.set(inObj1.get());
};

inObj2.onChange = function ()
{
    outObj.set(null);
    outObj.set(inObj2.get());
};

inObj3.onChange = function ()
{
    outObj.set(null);
    outObj.set(inObj3.get());
};

inObj4.onChange = function ()
{
    outObj.set(null);
    outObj.set(inObj4.get());
};

inObj5.onChange = function ()
{
    outObj.set(null);
    outObj.set(inObj5.get());
};


};

Ops.Json.ObjectFunnel.prototype = new CABLES.Op();
CABLES.OPS["ff67d867-098e-4eb1-8b37-00ec0863ce5e"]={f:Ops.Json.ObjectFunnel,objName:"Ops.Json.ObjectFunnel"};




// **************************************************************
// 
// Ops.Json.ObjectGetArrayByPath
// 
// **************************************************************

Ops.Json.ObjectGetArrayByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inObject("Object");
const pathIn = op.inString("Path");
const resultOut = op.outArray("Output");
const foundOut = op.outBool("Found");

objectIn.onChange = update;
pathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    const path = pathIn.get();
    op.setUiError("missing", null);
    if (data && path)
    {
        if (!Array.isArray(data) && !(typeof data === "object"))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input object of type " + (typeof data) + " is not travesable by path");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            op.setUiAttrib({ "extendTitle": parts[parts.length - 1] + "" });
            let result = resolve(path, data);
            if (result === undefined)
            {
                const errorMsg = "could not find element at path " + path;
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else if (!Array.isArray(result))
            {
                const errorMsg = "element at path " + path + " is not an array";
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else
            {
                foundOut.set(true);
            }
            resultOut.set(result);
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ObjectGetArrayByPath.prototype = new CABLES.Op();
CABLES.OPS["a9354531-a42d-4216-ad8c-364df989a9a1"]={f:Ops.Json.ObjectGetArrayByPath,objName:"Ops.Json.ObjectGetArrayByPath"};




// **************************************************************
// 
// Ops.Json.ObjectGetArrayValuesByPath
// 
// **************************************************************

Ops.Json.ObjectGetArrayValuesByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inObject("Object");
const pathIn = op.inString("Path");
const resultOut = op.outArray("Output");
const foundOut = op.outBool("Found");

objectIn.onChange = update;
pathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    let result = [];
    const path = pathIn.get();
    op.setUiError("path", null);

    if (data && path)
    {
        if (typeof data !== "object")
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input object of type " + (typeof data) + " is not travesable by path");
        }
        else if (Array.isArray(data))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input of type " + (typeof data) + " is not an object");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            foundOut.set(false);

            // find first array in path
            let checkPath = "";
            let pathPrefix = "";
            let pathSuffix = "";
            let checkData = null;
            for (let i = 0; i < parts.length; i++)
            {
                checkPath += parts[i];
                checkData = resolve(checkPath, data);
                if (Array.isArray(checkData))
                {
                    pathPrefix = checkPath;
                    pathSuffix = parts.splice(i + 2, parts.length - (i + 2)).join(".");
                    break;
                }
                checkPath += ".";
            }
            if (checkData)
            {
                if (parts.length > 1)
                {
                    for (let i = 0; i < checkData.length; i++)
                    {
                        let resolvePath = pathPrefix + "." + i;
                        if (pathSuffix && pathSuffix !== "")
                        {
                            resolvePath += "." + pathSuffix;
                        }
                        const resolvedData = resolve(resolvePath, data);
                        if (typeof resolvedData !== "undefined")
                        {
                            foundOut.set(true);
                        }
                        result.push(resolvedData);
                    }
                }
                else
                {
                    if (Array.isArray(checkData))
                    {
                        result = checkData;
                    }
                    else
                    {
                        result = [checkData];
                    }
                    foundOut.set(true);
                }

                const titleParts = pathIn.get().split(".");
                const extendTitle = titleParts[titleParts.length - 1] + "";
                op.setUiAttrib({ "extendTitle": extendTitle });
            }
            if (foundOut.get())
            {
                resultOut.set(result);
            }
            else
            {
                op.setUiError("path", "given path seems to be invalid!", 1);
                resultOut.set([]);
            }
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ObjectGetArrayValuesByPath.prototype = new CABLES.Op();
CABLES.OPS["609a645e-5e24-4a5e-a379-804c5b64f5d5"]={f:Ops.Json.ObjectGetArrayValuesByPath,objName:"Ops.Json.ObjectGetArrayValuesByPath"};




// **************************************************************
// 
// Ops.Json.ObjectGetArray_v2
// 
// **************************************************************

Ops.Json.ObjectGetArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    data = op.inObject("data"),
    key = op.inString("key"),
    result = op.outArray("result"),
    arrLength = op.outNumber("Length");

result.ignoreValueSerialize = true;
data.ignoreValueSerialize = true;

data.onChange = update;

key.onChange = function ()
{
    if (!key.isLinked())op.setUiAttrib({ "extendTitle": key.get() });
    update();
};

function update()
{
    result.set(null);
    const dat = data.get();
    const k = key.get();
    if (dat && (dat.hasOwnProperty(k) || dat[k]))
    {
        result.set(dat[k]);
        if (!result.get())
        {
            arrLength.set(0);
        }
        else
        {
            arrLength.set(result.get().length);
        }
    }
    else
    {
        arrLength.set(0);
    }
}


};

Ops.Json.ObjectGetArray_v2.prototype = new CABLES.Op();
CABLES.OPS["7c06a818-9c07-493a-8c4f-04eb2c7796f5"]={f:Ops.Json.ObjectGetArray_v2,objName:"Ops.Json.ObjectGetArray_v2"};




// **************************************************************
// 
// Ops.Json.ObjectGetNumberByPath
// 
// **************************************************************

Ops.Json.ObjectGetNumberByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inObject("Object");
const pathIn = op.inString("Path");
const resultOut = op.outNumber("Output");
const foundOut = op.outBool("Found");

objectIn.onChange = update;
pathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    const path = pathIn.get();
    op.setUiError("missing", null);
    if (data && path)
    {
        if (!Array.isArray(data) && !(typeof data === "object"))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input object of type " + (typeof data) + " is not travesable by path");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            op.setUiAttrib({ "extendTitle": parts[parts.length - 1] + "" });
            let result = resolve(path, data);
            if (result === undefined)
            {
                const errorMsg = "could not find element at path " + path;
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else if (typeof result !== "number")
            {
                const errorMsg = "element at path " + path + " is not a number";
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else
            {
                foundOut.set(true);
            }
            resultOut.set(result);
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ObjectGetNumberByPath.prototype = new CABLES.Op();
CABLES.OPS["ec736baf-feb8-4d8d-b04c-173fc197759c"]={f:Ops.Json.ObjectGetNumberByPath,objName:"Ops.Json.ObjectGetNumberByPath"};




// **************************************************************
// 
// Ops.Json.ObjectGetNumber_v2
// 
// **************************************************************

Ops.Json.ObjectGetNumber_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    data = op.inObject("Data"),
    key = op.inString("Key"),
    result = op.outNumber("Result"),
    outFound = op.outBoolNum("Found");

result.ignoreValueSerialize = true;
data.ignoreValueSerialize = true;

data.onChange = exec;

key.onChange = function ()
{
    if (!key.isLinked())op.setUiAttrib({ "extendTitle": key.get() });
    exec();
};

function exec()
{
    if (data.get())
    {
        const val = data.get()[key.get()];
        result.set(val);
        if (val === undefined) outFound.set(0);
        else outFound.set(1);
    }
    else
    {
        result.set(null);
        outFound.set(0);
    }
}


};

Ops.Json.ObjectGetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["a7335e79-046e-40da-9e9c-db779b0a5e53"]={f:Ops.Json.ObjectGetNumber_v2,objName:"Ops.Json.ObjectGetNumber_v2"};




// **************************************************************
// 
// Ops.Json.ObjectGetObjectByPath
// 
// **************************************************************

Ops.Json.ObjectGetObjectByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inObject("Object");
const pathIn = op.inString("Path");
const resultOut = op.outObject("Output");
const foundOut = op.outBool("Found");

objectIn.onChange = update;
pathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    const path = pathIn.get();
    op.setUiError("missing", null);
    if (data && path)
    {
        if (!Array.isArray(data) && !(typeof data === "object"))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input object of type " + (typeof data) + " is not travesable by path");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            op.setUiAttrib({ "extendTitle": parts[parts.length - 1] + "" });
            let result = resolve(path, data);
            if (result === undefined)
            {
                const errorMsg = "could not find element at path " + path;
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else if (Array.isArray(result) || result === null || typeof result !== "object")
            {
                const errorMsg = "element at path " + path + " is not an object";
                foundOut.set(false);
                result = null;
                op.setUiError("missing", errorMsg, 2);
            }
            else
            {
                foundOut.set(true);
            }
            resultOut.set(result);
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ObjectGetObjectByPath.prototype = new CABLES.Op();
CABLES.OPS["574513c7-472b-433c-bf99-d906d3c737cd"]={f:Ops.Json.ObjectGetObjectByPath,objName:"Ops.Json.ObjectGetObjectByPath"};




// **************************************************************
// 
// Ops.Json.ObjectGetObject_v2
// 
// **************************************************************

Ops.Json.ObjectGetObject_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    data = op.inObject("Object"),
    key = op.inString("Key"),
    result = op.outObject("Result");

result.ignoreValueSerialize = true;
data.ignoreValueSerialize = true;

op.setUiAttrib({ "extendTitlePort": key.name });

key.onChange =
data.onChange = update;

function update()
{
    if (data.get())
    {
        result.set(data.get()[key.get()]);
    }
    else
    {
        result.set(null);
    }
}


};

Ops.Json.ObjectGetObject_v2.prototype = new CABLES.Op();
CABLES.OPS["d1dfa305-89db-4ca1-b0ac-2d6321d76ae8"]={f:Ops.Json.ObjectGetObject_v2,objName:"Ops.Json.ObjectGetObject_v2"};




// **************************************************************
// 
// Ops.Json.ObjectGetString
// 
// **************************************************************

Ops.Json.ObjectGetString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    data = op.inObject("data"),
    key = op.inString("Key"),
    result = op.outString("Result");

result.ignoreValueSerialize = true;
data.ignoreValueSerialize = true;

op.setUiAttrib({ "extendTitlePort": key.name });

key.onChange =
data.onChange = exec;

function exec()
{
    if (data.get())
    {
        result.set(data.get()[key.get()]);
    }
    else
    {
        result.set(null);
    }
}


};

Ops.Json.ObjectGetString.prototype = new CABLES.Op();
CABLES.OPS["7d86cd28-f7d8-44a1-a4da-466c4782aaec"]={f:Ops.Json.ObjectGetString,objName:"Ops.Json.ObjectGetString"};




// **************************************************************
// 
// Ops.Json.ObjectGetStringByPath
// 
// **************************************************************

Ops.Json.ObjectGetStringByPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const objectIn = op.inObject("Object");
const pathIn = op.inString("Path");
const returnPathIn = op.inBool("Output path if missing", false);
const resultOut = op.outString("Output");
const foundOut = op.outBool("Found");

objectIn.ignoreValueSerialize = true;

objectIn.onChange = update;
pathIn.onChange = update;
returnPathIn.onChange = update;

function update()
{
    const data = objectIn.get();
    const path = pathIn.get();
    op.setUiError("missing", null);
    if (data && path)
    {
        if (!Array.isArray(data) && !(typeof data === "object"))
        {
            foundOut.set(false);
            op.setUiError("notiterable", "input object of type " + (typeof data) + " is not travesable by path");
        }
        else
        {
            op.setUiError("notiterable", null);
            const parts = path.split(".");
            op.setUiAttrib({ "extendTitle": parts[parts.length - 1] + "" });
            let result = resolve(path, data);
            if (result === undefined)
            {
                const errorMsg = "could not find element at path " + path;
                let errorLevel = 2;
                result = null;
                foundOut.set(false);
                if (returnPathIn.get())
                {
                    result = path;
                    errorLevel = 1;
                }
                else
                {
                    result = null;
                }
                op.setUiError("missing", errorMsg, errorLevel);
            }
            else
            {
                foundOut.set(true);
                result = String(result);
            }
            resultOut.set(result);
        }
    }
    else
    {
        foundOut.set(false);
    }
}

function resolve(path, obj = self, separator = ".")
{
    const properties = Array.isArray(path) ? path : path.split(separator);
    return properties.reduce((prev, curr) => prev && prev[curr], obj);
}


};

Ops.Json.ObjectGetStringByPath.prototype = new CABLES.Op();
CABLES.OPS["497a6b7c-e33c-45e4-8fb2-a9149d972b5b"]={f:Ops.Json.ObjectGetStringByPath,objName:"Ops.Json.ObjectGetStringByPath"};




// **************************************************************
// 
// Ops.Json.ObjectIsNull
// 
// **************************************************************

Ops.Json.ObjectIsNull = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inObj = op.inObject("Object");
const outResult = op.outBoolNum("Result");

inObj.onChange = function ()
{
    outResult.set(!inObj.get());
};


};

Ops.Json.ObjectIsNull.prototype = new CABLES.Op();
CABLES.OPS["2fd858a8-3dff-43e4-bd85-a62c7d23b5a2"]={f:Ops.Json.ObjectIsNull,objName:"Ops.Json.ObjectIsNull"};




// **************************************************************
// 
// Ops.Json.ObjectIterate
// 
// **************************************************************

Ops.Json.ObjectIterate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj = op.inObject("Object"),
    outKey = op.outNumber("Key");

inObj.onChange = function ()
{
    let obj = inObj.get();

    if (obj)
    {
        for (let i in obj)
        {
            outKey.set(i);
        }
    }
};


};

Ops.Json.ObjectIterate.prototype = new CABLES.Op();
CABLES.OPS["128f5b07-17f9-43fb-ab61-c170a9a9cd8d"]={f:Ops.Json.ObjectIterate,objName:"Ops.Json.ObjectIterate"};




// **************************************************************
// 
// Ops.Json.ObjectKeys
// 
// **************************************************************

Ops.Json.ObjectKeys = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj = op.inObject("Object"),
    outNumKeys = op.outNumber("Num Keys"),
    outKeys = op.outArray("Keys");

inObj.onChange = function ()
{
    let o = inObj.get();
    if (!o)
    {
        outNumKeys.set(0);
        outKeys.set([]);
        return;
    }

    let keys = Object.keys(o);
    outNumKeys.set(keys.length);
    outKeys.set(keys);
};


};

Ops.Json.ObjectKeys.prototype = new CABLES.Op();
CABLES.OPS["83b4d148-8cb3-4a45-8824-957eeaf02e22"]={f:Ops.Json.ObjectKeys,objName:"Ops.Json.ObjectKeys"};




// **************************************************************
// 
// Ops.Json.ObjectOr
// 
// **************************************************************

Ops.Json.ObjectOr = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    object0=op.inObject("Object 1"),
    object1=op.inObject("Object 2"),
    object2=op.inObject("Object 3"),
    object3=op.inObject("Object 4"),
    object4=op.inObject("Object 5"),
    object5=op.inObject("Object 6"),
    object6=op.inObject("Object 7"),
    object7=op.inObject("Object 8"),
    result=op.outObject("Result");

object0.onChange=exec;
object1.onChange=exec;
object2.onChange=exec;
object3.onChange=exec;
object4.onChange=exec;
object5.onChange=exec;
object6.onChange=exec;
object7.onChange=exec;


function exec()
{
    result.set( object0.get() || object1.get()  || object2.get() || object3.get() || object4.get() || object5.get() || object6.get() || object7.get() );
}



};

Ops.Json.ObjectOr.prototype = new CABLES.Op();
CABLES.OPS["98c9a790-c018-466a-9c36-7afd0d2a8826"]={f:Ops.Json.ObjectOr,objName:"Ops.Json.ObjectOr"};




// **************************************************************
// 
// Ops.Json.ObjectRecorder
// 
// **************************************************************

Ops.Json.ObjectRecorder = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTriggerButton("Exec"),
    reset = op.inTriggerButton("reset"),
    download = op.inTriggerButton("download"),
    inObj = op.inObject("Object"),
    numObjects = op.outValue("Num Objects");

let data = [];

reset.onTriggered = function ()
{
    data.length = 0;
    numObjects.set(data.length);
};

exec.onTriggered = function ()
{
    if (inObj.get()) data.push(JSON.parse(JSON.stringify(inObj.get())));
    numObjects.set(data.length);
};
download.onTriggered = function ()
{
    let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
    let downloadAnchorNode = document.createElement("a");
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "jsonexport.json");
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
};


};

Ops.Json.ObjectRecorder.prototype = new CABLES.Op();
CABLES.OPS["5a6c7435-34ee-4897-9fda-548db54aff02"]={f:Ops.Json.ObjectRecorder,objName:"Ops.Json.ObjectRecorder"};




// **************************************************************
// 
// Ops.Json.ObjectSetArray
// 
// **************************************************************

Ops.Json.ObjectSetArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObject = op.inObject("Object"),
    outObject = op.outObject("Result Object"),
    inKey = op.inString("Key"),
    inValue = op.inArray("Value");

inObject.onChange =
    inKey.onChange =
    inValue.onChange = update;

function update()
{
    let obj = inObject.get();
    if (!obj)obj = {};

    if (inKey.get()) obj[inKey.get()] = inValue.get();

    outObject.set(null);
    outObject.set(obj);
}


};

Ops.Json.ObjectSetArray.prototype = new CABLES.Op();
CABLES.OPS["d89cbbe0-5c6e-4b6c-84b3-1fa588f19a79"]={f:Ops.Json.ObjectSetArray,objName:"Ops.Json.ObjectSetArray"};




// **************************************************************
// 
// Ops.Json.ObjectSetNumber
// 
// **************************************************************

Ops.Json.ObjectSetNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObject=op.inObject("Object"),
    outObject=op.outObject("Result Object"),
    inKey=op.inString("Key"),
    inValue=op.inValueFloat("Number");

inObject.onChange=
    inKey.onChange=
    inValue.onChange=update;

function update()
{
    var obj=inObject.get();
    if(!obj)obj={};

    obj[inKey.get()]=inValue.get();

    outObject.set(null);
    outObject.set(obj);
}


};

Ops.Json.ObjectSetNumber.prototype = new CABLES.Op();
CABLES.OPS["e50fd010-5db1-48a7-91dc-94799ae1cb3b"]={f:Ops.Json.ObjectSetNumber,objName:"Ops.Json.ObjectSetNumber"};




// **************************************************************
// 
// Ops.Json.ObjectSetObject
// 
// **************************************************************

Ops.Json.ObjectSetObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inObject = op.inObject("Object");
const inKey = op.inString("Key");
const inValue = op.inObject("Object Value");
const inUpdate = op.inTriggerButton("Set Object");
const outObject = op.outObject("Result Object");

// inObject.onChange=update;
// inKey.onChange=update;
inUpdate.onTriggered = update;

let obj = null;

op.onDelete =
inObject.onChange = () =>
{
    if (obj)
        delete obj[inKey.get()];
};

function update()
{
    obj = inObject.get();
    if (!obj)
    {
        obj = {};
    }
    else
    {
        let changed = false;

        if (inKey.get().indexOf(",") > -1)
        {
            const keys = inKey.get().split(",");

            for (let i in keys)
            {
                if (keys[i] && keys[i].length > 0)
                {
                    if (obj[keys[i]] != inValue.get())changed = true;
                    obj[keys[i]] = inValue.get();
                }
            }
        }
        else
        {
            if (obj[inKey.get()] != inValue.get())changed = true;
            obj[inKey.get()] = inValue.get();
        }

        outObject.set(null);
    }

    outObject.set(obj);
}


};

Ops.Json.ObjectSetObject.prototype = new CABLES.Op();
CABLES.OPS["ba7cad72-f226-4c27-b5e6-b20dabb8a3a4"]={f:Ops.Json.ObjectSetObject,objName:"Ops.Json.ObjectSetObject"};




// **************************************************************
// 
// Ops.Json.ObjectSetObjectSimple
// 
// **************************************************************

Ops.Json.ObjectSetObjectSimple = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inObject = op.inObject("Object");
const inKey = op.inString("Key");
const inValue = op.inObject("Object Value");
const outObject = op.outObject("Result Object");

op.onDelete = removeKey;

inObject.onLinkChanged =
inValue.onChange =
inKey.onChange = () =>
{
    removeKey();
    update();
    op.setUiAttrib({ "extendTitle": inKey.get() });
};

outObject.onLinkChanged =
inObject.onChange = update;

let currentKey = "";

let obj = {};

function removeKey()
{
    delete obj[currentKey];
}

function copyObject()
{

}

function update()
{
    obj = inObject.get() || {};

    let changed = false;

    currentKey = inKey.get();
    if (obj[inKey.get()] != inValue.get())changed = true;
    obj[inKey.get()] = inValue.get();

    outObject.set(null);
    outObject.set(obj);
}


};

Ops.Json.ObjectSetObjectSimple.prototype = new CABLES.Op();
CABLES.OPS["448f0905-dd4c-4909-9ddb-352c7f4467de"]={f:Ops.Json.ObjectSetObjectSimple,objName:"Ops.Json.ObjectSetObjectSimple"};




// **************************************************************
// 
// Ops.Json.ObjectSetString
// 
// **************************************************************

Ops.Json.ObjectSetString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObject=op.inObject("Object"),
    outObject=op.outObject("Result Object"),
    inKey=op.inString("Key"),
    inValue=op.inString("Value");

inObject.onChange=
    inKey.onChange=
    inValue.onChange=update;

function update()
{
    var obj=inObject.get();
    if(!obj)obj={};

    obj[inKey.get()]=inValue.get();

    outObject.set(null);
    outObject.set(obj);
}


};

Ops.Json.ObjectSetString.prototype = new CABLES.Op();
CABLES.OPS["31f19b25-2ed8-4ac6-84d4-a146da9e3a05"]={f:Ops.Json.ObjectSetString,objName:"Ops.Json.ObjectSetString"};




// **************************************************************
// 
// Ops.Json.ObjectStringify_v2
// 
// **************************************************************

Ops.Json.ObjectStringify_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj = op.inObject("Object"),
    inBeautify = op.inValueBool("Beautify"),
    outString = op.outString("Result"),
    outError = op.outBoolNum("Error");

inBeautify.onChange = inObj.onChange = update;

function update()
{
    try
    {
        if (!inBeautify.get())outString.set(JSON.stringify(inObj.get()));
        else outString.set(JSON.stringify(inObj.get(), false, 4));
        outError.set(0);
    }
    catch (e)
    {
        op.error(e);
        outString.set("error");
        outError.set(1);
    }
}


};

Ops.Json.ObjectStringify_v2.prototype = new CABLES.Op();
CABLES.OPS["89fc70ea-2350-4a0e-9a24-4efca10cced6"]={f:Ops.Json.ObjectStringify_v2,objName:"Ops.Json.ObjectStringify_v2"};




// **************************************************************
// 
// Ops.Json.ObjectToArray
// 
// **************************************************************

Ops.Json.ObjectToArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inObj = op.inObject("Object");
const outArray = op.outArray("Array");

inObj.onChange = function ()
{
    outArray.set(inObj.get());
};


};

Ops.Json.ObjectToArray.prototype = new CABLES.Op();
CABLES.OPS["f8ac4574-ffe3-4618-a27f-30d190308e2c"]={f:Ops.Json.ObjectToArray,objName:"Ops.Json.ObjectToArray"};




// **************************************************************
// 
// Ops.Json.ObjectTrigger
// 
// **************************************************************

Ops.Json.ObjectTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrigger=op.inTriggerButton("Trigger"),
    inObj=op.inObject("Object"),
    outTrigger=op.outTrigger("Next"),
    outObj=op.outObject("Result");

inTrigger.onTriggered=function()
{
    outObj.set(null);
    outObj.set(inObj.get());
    outTrigger.trigger();
};


};

Ops.Json.ObjectTrigger.prototype = new CABLES.Op();
CABLES.OPS["e437c074-190f-4adb-8265-3fddea27fe33"]={f:Ops.Json.ObjectTrigger,objName:"Ops.Json.ObjectTrigger"};




// **************************************************************
// 
// Ops.Json.ObjectValues
// 
// **************************************************************

Ops.Json.ObjectValues = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj = op.inObject("Object"),
    outNumValues = op.outNumber("Num values"),
    outValues = op.outArray("Values");

inObj.onChange = () =>
{
    const sourceObj = inObj.get();
    if (!sourceObj)
    {
        outNumValues.set(0);
        outValues.set([]);
        return;
    }

    const values = Object.values(sourceObj);
    outNumValues.set(values.length);
    outValues.set(values);
};


};

Ops.Json.ObjectValues.prototype = new CABLES.Op();
CABLES.OPS["32ff73f5-7947-42b0-83fa-e079af7beb5c"]={f:Ops.Json.ObjectValues,objName:"Ops.Json.ObjectValues"};




// **************************************************************
// 
// Ops.Json.ParseObject_v2
// 
// **************************************************************

Ops.Json.ParseObject_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    str = op.inStringEditor("JSON String", "{}", "json"),
    outObj = op.outObject("Result"),
    isValid = op.outBoolNum("Valid");

str.onChange = parse;
parse();

function parse()
{
    if (!str.get())
    {
        outObj.set(null);
        isValid.set(false);
        return;
    }
    try
    {
        const obj = JSON.parse(str.get());
        outObj.set(null);
        outObj.set(obj);
        isValid.set(true);
        op.setUiError("invalidjson", null);
    }
    catch (ex)
    {
        op.logError(ex);
        isValid.set(false);

        let outStr = "";
        const parts = ex.message.split(" ");
        for (let i = 0; i < parts.length - 1; i++)
        {
            const num = parseFloat(parts[i + 1]);
            if (num && parts[i] == "position")
            {
                const outStrA = str.get().substring(num - 15, num);
                const outStrB = str.get().substring(num, num + 1);
                const outStrC = str.get().substring(num + 1, num + 15);
                outStr = "<span style=\"font-family:monospace;background-color:black;\">" + outStrA + "<span style=\"font-weight:bold;background-color:red;\">" + outStrB + "</span>" + outStrC + " </span>";
            }
        }

        op.setUiError("invalidjson", "INVALID JSON<br/>can not parse string to object:<br/><b> " + ex.message + "</b><br/>" + outStr);
    }
}


};

Ops.Json.ParseObject_v2.prototype = new CABLES.Op();
CABLES.OPS["2ce8a4d3-37d3-4cdc-abd1-a560fbe841ee"]={f:Ops.Json.ParseObject_v2,objName:"Ops.Json.ParseObject_v2"};




// **************************************************************
// 
// Ops.Json.RouteObject
// 
// **************************************************************

Ops.Json.RouteObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

const
    NUM_PORTS = 10,
    DEFAULT_OBJECT = {},
    indexPort = op.inInt('index'),
    objectPort = op.inObject('Object in'),
    defaultObjectPort = op.inObject('default object', DEFAULT_OBJECT),
    objectPorts = createOutPorts(DEFAULT_OBJECT);

indexPort.onChange = objectPort.onChange = defaultObjectPort.onChange = update;

setDefaultValues();
update();

function createOutPorts()
{
    var arrayObjects = [];
    for(var i=0; i<NUM_PORTS; i++)
    {
        var port = op.outObject('Index ' + i + ' Object');
        arrayObjects.push(port);
    }
    defaultObjectPort.set(null);
    return arrayObjects;
};

function setDefaultValues()
{
    var defaultValue = defaultObjectPort.get();

    objectPorts.forEach(port => port.set(null));
    if(defaultObjectPort.get())
    {
        objectPorts.forEach(port => port.set(defaultValue));
    }
};

function update()
{
    setDefaultValues();
    var index = indexPort.get();
    var value = objectPort.get();

    index = Math.floor(index);
    index = clamp(index, 0, NUM_PORTS-1);
    objectPorts[index].set(value);
};

function clamp(value, min, max)
{
  return Math.min(Math.max(value, min), max);
};


};

Ops.Json.RouteObject.prototype = new CABLES.Op();
CABLES.OPS["bc969951-32b5-4226-9944-80a719a65497"]={f:Ops.Json.RouteObject,objName:"Ops.Json.RouteObject"};




// **************************************************************
// 
// Ops.Json.SaveJsonFile
// 
// **************************************************************

Ops.Json.SaveJsonFile = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

const
    download = op.inTriggerButton("download"),
    filename = op.inString("Filename", "jsonexport"),
    inObject = op.inObject("Object");

download.onTriggered = function ()
{
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(inObject.get(), null, 2));
    const downloadAnchorNode = document.createElement("a");
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", filename.get() + ".json");
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
};


};

Ops.Json.SaveJsonFile.prototype = new CABLES.Op();
CABLES.OPS["04596a28-9563-4f42-8756-2d2a831baa60"]={f:Ops.Json.SaveJsonFile,objName:"Ops.Json.SaveJsonFile"};




// **************************************************************
// 
// Ops.Json.SwitchObject
// 
// **************************************************************

Ops.Json.SwitchObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const NUM_PORTS = 8;

const inIndex = op.inValueInt("Object Index", 0);
const objectPorts = [];
const outObject = op.outObject("object out");

op.onLoaded = function () { indexChanged(); };
inIndex.onChange = indexChanged;

for (let i = 0; i < NUM_PORTS; i++)
{
    let port = op.inObject("object port " + i);
    port.inputNum = i;
    port.onChange = onPortChange.bind(port);
    objectPorts[i] = port;
}

function indexChanged()
{
    let index = Math.max(0, Math.floor(inIndex.get()));
    if (index < 0) index = 0;
    else if (index > NUM_PORTS - 1) index = NUM_PORTS - 1;

    outObject.set(null);
    outObject.set(objectPorts[index].get());
}

function onPortChange()
{
    if (this.inputNum != inIndex.get()) return;

    outObject.set(null);
    outObject.set(this.get());
}


};

Ops.Json.SwitchObject.prototype = new CABLES.Op();
CABLES.OPS["345d535e-267d-49fb-98c0-c8a8f9424160"]={f:Ops.Json.SwitchObject,objName:"Ops.Json.SwitchObject"};




// **************************************************************
// 
// Ops.Libs.Lottie.LottieSVGPlayer
// 
// **************************************************************

Ops.Libs.Lottie.LottieSVGPlayer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEle = op.inObject("HTML Element"),
    inData = op.inObject("JSON Data"),
    inPlayMode = op.inSwitch("Play Mode", ["Auto", "Frame"], "Auto"),

    inFrame = op.inFloat("Render Frame", 0),
    inLoop = op.inValueBool("Loop", true),

    inPlay = op.inValueBool("Play", true),

    inDir = op.inBool("Play Backward"),
    inRewind = op.inTriggerButton("Rewind"),

    outComplete = op.outBool("Completed", false),
    outProgress = op.outNumber("Progress"),
    outTotalFrames = op.outNumber("Total Frames");

op.setPortGroup("Timing", [inLoop, inPlayMode, inFrame, inPlay, inRewind, inDir]);

let anim = null;
let playmodeAuto = true;

inPlay.onChange = play;
inRewind.onTriggered = inLoop.onChange = inEle.onChange = inData.onChange = updateData;
inFrame.onChange = gotoFrame;
inDir.onChange = updateDir;
inPlayMode.onChange = updateUi;
updateUi();

function updateUi()
{
    playmodeAuto = inPlayMode.get() === "Auto";

    inPlay.setUiAttribs({ "greyout": !playmodeAuto });
    inDir.setUiAttribs({ "greyout": !playmodeAuto });
    inRewind.setUiAttribs({ "greyout": !playmodeAuto });
    inFrame.setUiAttribs({ "greyout": playmodeAuto });
    if (playmodeAuto) play();
    else gotoFrame();
}

function dispose()
{
    if (anim)
    {
        anim.destroy();
        anim = null;
        outTotalFrames.set(0);
    }
}

function play()
{
    if (!anim) return;
    if (!playmodeAuto) return gotoFrame();

    outComplete.set(false);
    if (!inPlay.get())anim.pause();
    else anim.play();
}

function gotoFrame()
{
    if (playmodeAuto) return;
    if (!anim) return;

    let fr = inFrame.get();
    if (inLoop.get())fr %= anim.totalFrames;

    anim.goToAndStop(fr, true);
}

function updateDir()
{
    if (!anim) return;
    if (!inDir.get()) anim.setDirection(1);
    else anim.setDirection(-1);

    if (inPlay.get() && playmodeAuto) play();
}

function updateData()
{
    if (anim)dispose();
    if (!inEle.get() || !inData.get()) return;
    if (Object.keys(inData.get()).length === 0) return;

    updateUi();

    const params = {
        "container": inEle.get(),
        "renderer": "svg",
        "loop": inLoop.get() == true,
        "autoplay": (inPlay.get() == true && playmodeAuto),
        "animationData": inData.get()
    };

    anim = lottie.loadAnimation(params);

    anim.addEventListener("complete", () =>
    {
        outComplete.set(true);
    });

    anim.addEventListener("enterFrame", (e) =>
    {
        outProgress.set(e.currentTime / (e.totalTime - 1));
    });
    outTotalFrames.set(anim.totalFrames);
    updateDir();
    gotoFrame();
}


};

Ops.Libs.Lottie.LottieSVGPlayer.prototype = new CABLES.Op();
CABLES.OPS["c4ed075b-c897-4788-9cc0-2df638671f67"]={f:Ops.Libs.Lottie.LottieSVGPlayer,objName:"Ops.Libs.Lottie.LottieSVGPlayer"};




// **************************************************************
// 
// Ops.Libs.Lottie.LottieTexturePlayer_v2
// 
// **************************************************************

Ops.Libs.Lottie.LottieTexturePlayer_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("exe"),
    inData = op.inObject("JSON Data"),
    inPlayMode = op.inSwitch("Play Mode", ["Auto", "Frame"], "Auto"),
    inFrame = op.inFloat("frame"),
    inPlay = op.inBool("play"),
    inRewind = op.inTriggerButton("Rewind"),
    speed = op.inFloat("speed", 1),
    width = op.inInt("texture width", 1280),
    height = op.inInt("texture height", 720),
    tfilter = op.inDropDown("Filter", ["nearest", "linear", "mipmap"], "linear"),
    wrap = op.inDropDown("wrap", ["repeat", "mirrored repeat", "clamp to edge"], "repeat"),
    bmScale = op.inSwitch("scale", ["fit", "nofit"], "fit"),
    textureOut = op.outTexture("texture"),
    outTotalFrames = op.outNumber("Total Frames");

const cgl = op.patch.cgl;
const canvasId = "bodymovin_" + CABLES.generateUUID();
let createTexture = false;
let canvasImage = null;
let anim = null;
let ctx = null;
let canvas = null;
let cgl_filter = CGL.Texture.FILTER_LINEAR;
let cgl_wrap = CGL.Texture.WRAP_REPEAT;
let lastFrame = -2;
let playmodeAuto = true;
let updateTexture = true;
let tex = null;

op.setPortGroup("Player Timing", [inPlayMode, inFrame, inPlay, inRewind, speed]);
op.setPortGroup("Texture Settings", [tfilter, wrap, width, height, bmScale]);

inPlayMode.onChange = updateUi;
tfilter.onChange = onLottieFilterChange;
inData.onChange = reload;
bmScale.onChange =
width.onChange =
    height.onChange = reloadForce;

inPlay.onChange = function ()
{
    if (anim)
        if (inPlay.get()) anim.play();
        else anim.pause();
};

inRewind.onTriggered = function ()
{
    if (inPlay.get()) anim.goToAndPlay(0, true);
    else anim.goToAndStop(0, true);
};

speed.onChange = function ()
{
    if (anim) anim.setSpeed(speed.get());
};

wrap.onChange = function ()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    createTexture = true;
};

function onLottieFilterChange()
{
    cgl_filter = CGL.Texture.FILTER_NEAREST;
    if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;

    createTexture = true;
}

exe.onTriggered = function ()
{
    if (!anim) return;

    outTotalFrames.set(anim.totalFrames);

    if (!canvasImage || !canvas) return;

    if (playmodeAuto)
    {
        updateTexture = true;
    }
    else
    {
        if (lastFrame != inFrame.get())
        {
            lastFrame = inFrame.get();

            if (inFrame.get() != -1.0)
            {
                anim.goToAndStop(inFrame.get(), true);
            }
            updateTexture = true;
        }
    }

    if (!textureOut.get() || createTexture)
    {
        const texOpts =
        {
            "wrap": cgl_wrap,
            "filter": cgl_filter,
            "unpackAlpha": false,
        };
        if (tex) tex.delete();
        tex = new CGL.Texture.createFromImage(cgl, canvasImage, texOpts);
        textureOut.set(tex);
        createTexture = false;
    }
    if (updateTexture && tex)
    {
        tex.initTexture(canvasImage);
        updateTexture = false;
    }
};

op.onDelete = function ()
{
    if (anim)anim.stop();
    anim = null;
};

function reloadForce()
{
    createTexture = true;
    reload(true);
}

function updateUi()
{
    playmodeAuto = inPlayMode.get() === "Auto";

    inPlay.setUiAttribs({ "greyout": !playmodeAuto });
    inRewind.setUiAttribs({ "greyout": !playmodeAuto });
    speed.setUiAttribs({ "greyout": !playmodeAuto });
    inFrame.setUiAttribs({ "greyout": playmodeAuto });

    if (anim)
    {
        if (playmodeAuto) if (inPlay.get()) anim.play();
        if (!playmodeAuto) anim.stop();
    }
}

function reload(force)
{
    if (!inData.get() || Object.keys(inData.get()).length === 0)
    {
        if (anim)anim.stop();

        anim = null;
        if (tex)tex.delete();
        tex = null;

        createTexture = true;
        canvasImage = null;
        lastFrame = -2;
        updateTexture = true;

        return;
    }

    updateUi();

    outTotalFrames.set(0);
    if (anim) anim.stop();

    if (!canvasImage || force)
    {
        if (tex)tex = tex.delete();
        if (canvas) canvas.remove();
        canvas = document.createElement("canvas");
        canvas.id = canvasId;

        canvas.width = width.get();
        canvas.height = height.get();
        canvas.style.display = "none";

        const body = document.getElementsByTagName("body")[0];
        body.appendChild(canvas);

        canvasImage = document.getElementById(canvas.id);
        ctx = canvasImage.getContext("2d");
    }

    const animData = {
        "animType": "canvas",
        "loop": false,
        "prerender": true,
        "autoplay": playmodeAuto && inPlay.get(),
        "animationData": inData.get(),
        "rendererSettings":
        {
            "context": ctx,
            "clearCanvas": true,
            "scaleMode": bmScale.get()
        }
    };

    anim = bodymovin.loadAnimation(animData);
    anim.setSpeed(speed.get());

    anim.addEventListener("DOMLoaded", function (e) // sometimes anim loading seems to be async ?
    {
        finishedLoading();
    });

    finishedLoading();
}
function finishedLoading()
{
    if (!playmodeAuto)
    {
        anim.goToAndPlay(0, true);
        lastFrame = -2;
    }
    if (playmodeAuto && inPlay.get()) anim.play();
}


};

Ops.Libs.Lottie.LottieTexturePlayer_v2.prototype = new CABLES.Op();
CABLES.OPS["2fc89999-18bc-4d68-a81e-79d2280051c0"]={f:Ops.Libs.Lottie.LottieTexturePlayer_v2,objName:"Ops.Libs.Lottie.LottieTexturePlayer_v2"};




// **************************************************************
// 
// Ops.Libs.Mediapipe.FaceMesh
// 
// **************************************************************

Ops.Libs.Mediapipe.FaceMesh = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inGeom = op.inObject("Geom"),
    inPoints = op.inArray("Points"),
    outGeom = op.outObject("result geom");

inPoints.onChange = () =>
{
    const points = inPoints.get();

    if (points && g)
    {
        for (let i = 0; i < g.vertices.length; i += 3)
        {
            g.vertices[i + 0] = points[i + 0];
            g.vertices[i + 1] = points[i + 1];
        }

        g.calculateNormals();
        outGeom.set(null);
        outGeom.set(g);
    }
};

const verts = [
    0.000000, -3.406404, 5.979507,
    0.000000, -1.126865, 7.475604,
    0.000000, -2.089024, 6.058267,
    -0.463928, 0.955357, 6.633583,
    0.000000, -0.463170, 7.586580,
    0.000000, 0.365669, 7.242870,
    0.000000, 2.473255, 5.788627,
    -4.253081, 2.577646, 3.279702,
    0.000000, 4.019042, 5.284764,
    0.000000, 4.885979, 5.385258,
    0.000000, 8.261778, 4.481535,
    0.000000, -3.706811, 5.864924,
    0.000000, -3.918301, 5.569430,
    0.000000, -3.994436, 5.219482,
    0.000000, -4.542400, 5.404754,
    0.000000, -4.745577, 5.529457,
    0.000000, -5.019567, 5.601448,
    0.000000, -5.365123, 5.535441,
    0.000000, -6.149624, 5.071372,
    0.000000, -1.501095, 7.112196,
    -0.416106, -1.466449, 6.447657,
    -7.087960, 5.434801, 0.099620,
    -2.628639, 2.035898, 3.848121,
    -3.198363, 1.985815, 3.796952,
    -3.775151, 2.039402, 3.646194,
    -4.465819, 2.422950, 3.155168,
    -2.164289, 2.189867, 3.851822,
    -3.208229, 3.223926, 4.115822,
    -2.673803, 3.205337, 4.092203,
    -3.745193, 3.165286, 3.972409,
    -4.161018, 3.059069, 3.719554,
    -5.062006, 1.934418, 2.776093,
    -2.266659, -7.425768, 4.389812,
    -4.445859, 2.663991, 3.173422,
    -7.214530, 2.263009, 0.073150,
    -5.799793, 2.349546, 2.204059,
    -2.844939, -0.720868, 4.433130,
    -0.711452, -3.329355, 5.877044,
    -0.606033, -3.924562, 5.444923,
    -1.431615, -3.500953, 5.496189,
    -1.914910, -3.803146, 5.028930,
    -1.131043, -3.973937, 5.189648,
    -1.563548, -4.082763, 4.842263,
    -2.650112, -5.003649, 4.188483,
    -0.427049, -1.094134, 7.360529,
    -0.496396, -0.475659, 7.440358,
    -5.253307, 3.881582, 3.363159,
    -1.718698, 0.974609, 4.558359,
    -1.608635, -0.942516, 5.814193,
    -1.651267, -0.610868, 5.581319,
    -4.765501, -0.701554, 3.534632,
    -0.478306, 0.295766, 7.101013,
    -3.734964, 4.508230, 4.550454,
    -4.588603, 4.302037, 4.048484,
    -6.279331, 6.615427, 1.425850,
    -1.220941, 4.142165, 5.106035,
    -2.193489, 3.100317, 4.000575,
    -3.102642, -4.352984, 4.095905,
    -6.719682, -4.788645, -1.745401,
    -1.193824, -1.306795, 5.737747,
    -0.729766, -1.593712, 5.833208,
    -2.456206, -4.342621, 4.283884,
    -2.204823, -4.304508, 4.162499,
    -4.985894, 4.802461, 3.751977,
    -1.592294, -1.257709, 5.456949,
    -2.644548, 4.524654, 4.921559,
    -2.760292, 5.100971, 5.015990,
    -3.523964, 8.005976, 3.729163,
    -5.599763, 5.715470, 2.724259,
    -3.063932, 6.566144, 4.529981,
    -5.720968, 4.254584, 2.830852,
    -6.374393, 4.785590, 1.591691,
    -0.672728, -3.688016, 5.737804,
    -1.262560, -3.787691, 5.417779,
    -1.732553, -3.952767, 5.000579,
    -1.043625, -1.464973, 5.662455,
    -2.321234, -4.329069, 4.258156,
    -2.056846, -4.477671, 4.520883,
    -2.153084, -4.276322, 4.038093,
    -0.946874, -1.035249, 6.512274,
    -1.469132, -4.036351, 4.604908,
    -1.024340, -3.989851, 4.926693,
    -0.533422, -3.993222, 5.138202,
    -0.769720, -6.095394, 4.985883,
    -0.699606, -5.291850, 5.448304,
    -0.669687, -4.949770, 5.509612,
    -0.630947, -4.695101, 5.449371,
    -0.583218, -4.517982, 5.339869,
    -1.537170, -4.423206, 4.745470,
    -1.615600, -4.475942, 4.813632,
    -1.729053, -4.618680, 4.854463,
    -1.838624, -4.828746, 4.823737,
    -2.368250, -3.106237, 4.868096,
    -7.542244, -1.049282, -2.431321,
    0.000000, -1.724003, 6.601390,
    -1.826614, -4.399531, 4.399021,
    -1.929558, -4.411831, 4.497052,
    -0.597442, -2.013686, 5.866456,
    -1.405627, -1.714196, 5.241087,
    -0.662449, -1.819321, 5.863759,
    -2.342340, 0.572222, 4.294303,
    -3.327324, 0.104863, 4.113860,
    -1.726175, -0.919165, 5.273355,
    -5.133204, 7.485602, 2.660442,
    -4.538641, 6.319907, 3.683424,
    -3.986562, 5.109487, 4.466315,
    -2.169681, -5.440433, 4.455874,
    -1.395634, 5.011963, 5.316032,
    -1.619500, 6.599217, 4.921106,
    -1.891399, 8.236377, 4.274997,
    -4.195832, 2.235205, 3.375099,
    -5.733342, 1.411738, 2.431726,
    -1.859887, 2.355757, 3.843181,
    -4.988612, 3.074654, 3.083858,
    -1.303263, 1.416453, 4.831091,
    -1.305757, -0.672779, 6.415959,
    -6.465170, 0.937119, 1.689873,
    -5.258659, 0.945811, 2.974312,
    -4.432338, 0.722096, 3.522615,
    -3.300681, 0.861641, 3.872784,
    -2.430178, 1.131492, 4.039035,
    -1.820731, 1.467954, 4.224124,
    -0.563221, 2.307693, 5.566789,
    -6.338145, -0.529279, 1.881175,
    -5.587698, 3.208071, 2.687839,
    -0.242624, -1.462857, 7.071491,
    -1.611251, 0.339326, 4.895421,
    -7.743095, 2.364999, -2.005167,
    -1.391142, 1.851048, 4.448999,
    -1.785794, -0.978284, 4.850470,
    -4.670959, 2.664461, 3.084075,
    -1.333970, -0.283761, 6.097047,
    -7.270895, -2.890917, -2.252455,
    -1.856432, 2.585245, 3.757904,
    -0.923388, 0.073076, 6.671944,
    -5.000589, -6.135128, 1.892523,
    -5.085276, -7.178590, 0.714711,
    -7.159291, -0.811820, -0.072044,
    -5.843051, -5.248023, 0.924091,
    -6.847258, 3.662916, 0.724695,
    -2.412942, -8.258853, 4.119213,
    -0.179909, -1.689864, 6.573301,
    -2.103655, -0.163946, 4.566119,
    -6.407571, 2.236021, 1.560843,
    -3.670075, 2.360153, 3.635230,
    -3.177186, 2.294265, 3.775704,
    -2.196121, -4.598322, 4.479786,
    -6.234883, -1.944430, 1.663542,
    -1.292924, -9.295920, 4.094063,
    -3.210651, -8.533278, 2.802001,
    -4.068926, -7.993109, 1.925119,
    0.000000, 6.545390, 5.027311,
    0.000000, -9.403378, 4.264492,
    -2.724032, 2.315802, 3.777151,
    -2.288460, 2.398891, 3.697603,
    -1.998311, 2.496547, 3.689148,
    -6.130040, 3.399261, 2.038516,
    -2.288460, 2.886504, 3.775031,
    -2.724032, 2.961810, 3.871767,
    -3.177186, 2.964136, 3.876973,
    -3.670075, 2.927714, 3.724325,
    -4.018389, 2.857357, 3.482983,
    -7.555811, 4.106811, -0.991917,
    -4.018389, 2.483695, 3.440898,
    0.000000, -2.521945, 5.932265,
    -1.776217, -2.683946, 5.213116,
    -1.222237, -1.182444, 5.952465,
    -0.731493, -2.536683, 5.815343,
    0.000000, 3.271027, 5.236015,
    -4.135272, -6.996638, 2.671970,
    -3.311811, -7.660815, 3.382963,
    -1.313701, -8.639995, 4.702456,
    -5.940524, -6.223629, -0.631468,
    -1.998311, 2.743838, 3.744030,
    -0.901447, 1.236992, 5.754256,
    0.000000, -8.765243, 4.891441,
    -2.308977, -8.974196, 3.609070,
    -6.954154, -2.439843, -0.131163,
    -1.098819, -4.458788, 5.120727,
    -1.181124, -4.579996, 5.189564,
    -1.255818, -4.787901, 5.237051,
    -1.325085, -5.106507, 5.205010,
    -1.546388, -5.819392, 4.757893,
    -1.953754, -4.183892, 4.431713,
    -2.117802, -4.137093, 4.555096,
    -2.285339, -4.051196, 4.582438,
    -2.850160, -3.665720, 4.484994,
    -5.278538, -2.238942, 2.861224,
    -0.946709, 1.907628, 5.196779,
    -1.314173, 3.104912, 4.231404,
    -1.780000, 2.860000, 3.881555,
    -1.845110, -4.098880, 4.247264,
    -5.436187, -4.030482, 2.109852,
    -0.766444, 3.182131, 4.861453,
    -1.938616, -6.614410, 4.521085,
    0.000000, 1.059413, 6.774605,
    -0.516573, 1.583572, 6.148363,
    0.000000, 1.728369, 6.316750,
    -1.246815, 0.230297, 5.681036,
    0.000000, -7.942194, 5.181173,
    0.000000, -6.991499, 5.153478,
    -0.997827, -6.930921, 4.979576,
    -3.288807, -5.382514, 3.795752,
    -2.311631, -1.566237, 4.590085,
    -2.680250, -6.111567, 4.096152,
    -3.832928, -1.537326, 4.137731,
    -2.961860, -2.274215, 4.440943,
    -4.386901, -2.683286, 3.643886,
    -1.217295, -7.834465, 4.969286,
    -1.542374, -0.136843, 5.201008,
    -3.878377, -6.041764, 3.311079,
    -3.084037, -6.809842, 3.814195,
    -3.747321, -4.503545, 3.726453,
    -6.094129, -3.205991, 1.473482,
    -4.588995, -4.728726, 2.983221,
    -6.583231, -3.941269, 0.070268,
    -3.492580, -3.195820, 4.130198,
    -1.255543, 0.802341, 5.307551,
    -1.126122, -0.933602, 6.538785,
    -1.443109, -1.142774, 5.905127,
    -0.923043, -0.529042, 7.003423,
    -1.755386, 3.529117, 4.327696,
    -2.632589, 3.713828, 4.364629,
    -3.388062, 3.721976, 4.309028,
    -4.075766, 3.675413, 4.076063,
    -4.622910, 3.474691, 3.646321,
    -5.171755, 2.535753, 2.670867,
    -7.297331, 0.763172, -0.048769,
    -4.706828, 1.651000, 3.109532,
    -4.071712, 1.476821, 3.476944,
    -3.269817, 1.470659, 3.731945,
    -2.527572, 1.617311, 3.865444,
    -1.970894, 1.858505, 3.961782,
    -1.579543, 2.097941, 4.084996,
    -7.664182, 0.673132, -2.435867,
    -1.397041, -1.340139, 5.630378,
    -0.884838, 0.658740, 6.233232,
    -0.767097, -0.968035, 7.077932,
    -0.460213, -1.334106, 6.787447,
    -0.748618, -1.067994, 6.798303,
    -1.236408, -1.585568, 5.480490,
    -0.387306, -1.409990, 6.957705,
    -0.319925, -1.607931, 6.508676,
    -1.639633, 2.556298, 3.863736,
    -1.255645, 2.467144, 4.203800,
    -1.031362, 2.382663, 4.615849,
    -4.253081, 2.772296, 3.315305,
    -4.530000, 2.910000, 3.339685,
    0.463928, 0.955357, 6.633583,
    4.253081, 2.577646, 3.279702,
    0.416106, -1.466449, 6.447657,
    7.087960, 5.434801, 0.099620,
    2.628639, 2.035898, 3.848121,
    3.198363, 1.985815, 3.796952,
    3.775151, 2.039402, 3.646194,
    4.465819, 2.422950, 3.155168,
    2.164289, 2.189867, 3.851822,
    3.208229, 3.223926, 4.115822,
    2.673803, 3.205337, 4.092203,
    3.745193, 3.165286, 3.972409,
    4.161018, 3.059069, 3.719554,
    5.062006, 1.934418, 2.776093,
    2.266659, -7.425768, 4.389812,
    4.445859, 2.663991, 3.173422,
    7.214530, 2.263009, 0.073150,
    5.799793, 2.349546, 2.204059,
    2.844939, -0.720868, 4.433130,
    0.711452, -3.329355, 5.877044,
    0.606033, -3.924562, 5.444923,
    1.431615, -3.500953, 5.496189,
    1.914910, -3.803146, 5.028930,
    1.131043, -3.973937, 5.189648,
    1.563548, -4.082763, 4.842263,
    2.650112, -5.003649, 4.188483,
    0.427049, -1.094134, 7.360529,
    0.496396, -0.475659, 7.440358,
    5.253307, 3.881582, 3.363159,
    1.718698, 0.974609, 4.558359,
    1.608635, -0.942516, 5.814193,
    1.651267, -0.610868, 5.581319,
    4.765501, -0.701554, 3.534632,
    0.478306, 0.295766, 7.101013,
    3.734964, 4.508230, 4.550454,
    4.588603, 4.302037, 4.048484,
    6.279331, 6.615427, 1.425850,
    1.220941, 4.142165, 5.106035,
    2.193489, 3.100317, 4.000575,
    3.102642, -4.352984, 4.095905,
    6.719682, -4.788645, -1.745401,
    1.193824, -1.306795, 5.737747,
    0.729766, -1.593712, 5.833208,
    2.456206, -4.342621, 4.283884,
    2.204823, -4.304508, 4.162499,
    4.985894, 4.802461, 3.751977,
    1.592294, -1.257709, 5.456949,
    2.644548, 4.524654, 4.921559,
    2.760292, 5.100971, 5.015990,
    3.523964, 8.005976, 3.729163,
    5.599763, 5.715470, 2.724259,
    3.063932, 6.566144, 4.529981,
    5.720968, 4.254584, 2.830852,
    6.374393, 4.785590, 1.591691,
    0.672728, -3.688016, 5.737804,
    1.262560, -3.787691, 5.417779,
    1.732553, -3.952767, 5.000579,
    1.043625, -1.464973, 5.662455,
    2.321234, -4.329069, 4.258156,
    2.056846, -4.477671, 4.520883,
    2.153084, -4.276322, 4.038093,
    0.946874, -1.035249, 6.512274,
    1.469132, -4.036351, 4.604908,
    1.024340, -3.989851, 4.926693,
    0.533422, -3.993222, 5.138202,
    0.769720, -6.095394, 4.985883,
    0.699606, -5.291850, 5.448304,
    0.669687, -4.949770, 5.509612,
    0.630947, -4.695101, 5.449371,
    0.583218, -4.517982, 5.339869,
    1.537170, -4.423206, 4.745470,
    1.615600, -4.475942, 4.813632,
    1.729053, -4.618680, 4.854463,
    1.838624, -4.828746, 4.823737,
    2.368250, -3.106237, 4.868096,
    7.542244, -1.049282, -2.431321,
    1.826614, -4.399531, 4.399021,
    1.929558, -4.411831, 4.497052,
    0.597442, -2.013686, 5.866456,
    1.405627, -1.714196, 5.241087,
    0.662449, -1.819321, 5.863759,
    2.342340, 0.572222, 4.294303,
    3.327324, 0.104863, 4.113860,
    1.726175, -0.919165, 5.273355,
    5.133204, 7.485602, 2.660442,
    4.538641, 6.319907, 3.683424,
    3.986562, 5.109487, 4.466315,
    2.169681, -5.440433, 4.455874,
    1.395634, 5.011963, 5.316032,
    1.619500, 6.599217, 4.921106,
    1.891399, 8.236377, 4.274997,
    4.195832, 2.235205, 3.375099,
    5.733342, 1.411738, 2.431726,
    1.859887, 2.355757, 3.843181,
    4.988612, 3.074654, 3.083858,
    1.303263, 1.416453, 4.831091,
    1.305757, -0.672779, 6.415959,
    6.465170, 0.937119, 1.689873,
    5.258659, 0.945811, 2.974312,
    4.432338, 0.722096, 3.522615,
    3.300681, 0.861641, 3.872784,
    2.430178, 1.131492, 4.039035,
    1.820731, 1.467954, 4.224124,
    0.563221, 2.307693, 5.566789,
    6.338145, -0.529279, 1.881175,
    5.587698, 3.208071, 2.687839,
    0.242624, -1.462857, 7.071491,
    1.611251, 0.339326, 4.895421,
    7.743095, 2.364999, -2.005167,
    1.391142, 1.851048, 4.448999,
    1.785794, -0.978284, 4.850470,
    4.670959, 2.664461, 3.084075,
    1.333970, -0.283761, 6.097047,
    7.270895, -2.890917, -2.252455,
    1.856432, 2.585245, 3.757904,
    0.923388, 0.073076, 6.671944,
    5.000589, -6.135128, 1.892523,
    5.085276, -7.178590, 0.714711,
    7.159291, -0.811820, -0.072044,
    5.843051, -5.248023, 0.924091,
    6.847258, 3.662916, 0.724695,
    2.412942, -8.258853, 4.119213,
    0.179909, -1.689864, 6.573301,
    2.103655, -0.163946, 4.566119,
    6.407571, 2.236021, 1.560843,
    3.670075, 2.360153, 3.635230,
    3.177186, 2.294265, 3.775704,
    2.196121, -4.598322, 4.479786,
    6.234883, -1.944430, 1.663542,
    1.292924, -9.295920, 4.094063,
    3.210651, -8.533278, 2.802001,
    4.068926, -7.993109, 1.925119,
    2.724032, 2.315802, 3.777151,
    2.288460, 2.398891, 3.697603,
    1.998311, 2.496547, 3.689148,
    6.130040, 3.399261, 2.038516,
    2.288460, 2.886504, 3.775031,
    2.724032, 2.961810, 3.871767,
    3.177186, 2.964136, 3.876973,
    3.670075, 2.927714, 3.724325,
    4.018389, 2.857357, 3.482983,
    7.555811, 4.106811, -0.991917,
    4.018389, 2.483695, 3.440898,
    1.776217, -2.683946, 5.213116,
    1.222237, -1.182444, 5.952465,
    0.731493, -2.536683, 5.815343,
    4.135272, -6.996638, 2.671970,
    3.311811, -7.660815, 3.382963,
    1.313701, -8.639995, 4.702456,
    5.940524, -6.223629, -0.631468,
    1.998311, 2.743838, 3.744030,
    0.901447, 1.236992, 5.754256,
    2.308977, -8.974196, 3.609070,
    6.954154, -2.439843, -0.131163,
    1.098819, -4.458788, 5.120727,
    1.181124, -4.579996, 5.189564,
    1.255818, -4.787901, 5.237051,
    1.325085, -5.106507, 5.205010,
    1.546388, -5.819392, 4.757893,
    1.953754, -4.183892, 4.431713,
    2.117802, -4.137093, 4.555096,
    2.285339, -4.051196, 4.582438,
    2.850160, -3.665720, 4.484994,
    5.278538, -2.238942, 2.861224,
    0.946709, 1.907628, 5.196779,
    1.314173, 3.104912, 4.231404,
    1.780000, 2.860000, 3.881555,
    1.845110, -4.098880, 4.247264,
    5.436187, -4.030482, 2.109852,
    0.766444, 3.182131, 4.861453,
    1.938616, -6.614410, 4.521085,
    0.516573, 1.583572, 6.148363,
    1.246815, 0.230297, 5.681036,
    0.997827, -6.930921, 4.979576,
    3.288807, -5.382514, 3.795752,
    2.311631, -1.566237, 4.590085,
    2.680250, -6.111567, 4.096152,
    3.832928, -1.537326, 4.137731,
    2.961860, -2.274215, 4.440943,
    4.386901, -2.683286, 3.643886,
    1.217295, -7.834465, 4.969286,
    1.542374, -0.136843, 5.201008,
    3.878377, -6.041764, 3.311079,
    3.084037, -6.809842, 3.814195,
    3.747321, -4.503545, 3.726453,
    6.094129, -3.205991, 1.473482,
    4.588995, -4.728726, 2.983221,
    6.583231, -3.941269, 0.070268,
    3.492580, -3.195820, 4.130198,
    1.255543, 0.802341, 5.307551,
    1.126122, -0.933602, 6.538785,
    1.443109, -1.142774, 5.905127,
    0.923043, -0.529042, 7.003423,
    1.755386, 3.529117, 4.327696,
    2.632589, 3.713828, 4.364629,
    3.388062, 3.721976, 4.309028,
    4.075766, 3.675413, 4.076063,
    4.622910, 3.474691, 3.646321,
    5.171755, 2.535753, 2.670867,
    7.297331, 0.763172, -0.048769,
    4.706828, 1.651000, 3.109532,
    4.071712, 1.476821, 3.476944,
    3.269817, 1.470659, 3.731945,
    2.527572, 1.617311, 3.865444,
    1.970894, 1.858505, 3.961782,
    1.579543, 2.097941, 4.084996,
    7.664182, 0.673132, -2.435867,
    1.397041, -1.340139, 5.630378,
    0.884838, 0.658740, 6.233232,
    0.767097, -0.968035, 7.077932,
    0.460213, -1.334106, 6.787447,
    0.748618, -1.067994, 6.798303,
    1.236408, -1.585568, 5.480490,
    0.387306, -1.409990, 6.957705,
    0.319925, -1.607931, 6.508676,
    1.639633, 2.556298, 3.863736,
    1.255645, 2.467144, 4.203800,
    1.031362, 2.382663, 4.615849,
    4.253081, 2.772296, 3.315305,
    4.530000, 2.910000, 3.339685];
const faces = [
    174, 156, 134,
    247, 34, 8,
    383, 399, 363,
    264, 467, 250,
    309, 416, 325,
    79, 96, 192,
    357, 390, 265,
    128, 35, 163,
    369, 265, 390,
    140, 163, 35,
    268, 1, 303,
    38, 73, 1,
    12, 303, 1,
    12, 1, 73,
    350, 452, 351,
    121, 122, 232,
    453, 351, 452,
    233, 232, 122,
    268, 303, 270,
    38, 40, 73,
    304, 270, 303,
    74, 73, 40,
    358, 344, 351,
    129, 122, 115,
    278, 351, 344,
    48, 115, 122,
    351, 453, 358,
    122, 129, 233,
    454, 358, 453,
    234, 233, 129,
    300, 334, 298,
    70, 68, 105,
    333, 298, 334,
    104, 105, 68,
    176, 153, 397,
    176, 172, 153,
    378, 397, 153,
    149, 153, 172,
    382, 385, 383,
    155, 156, 158,
    399, 383, 385,
    174, 158, 156,
    281, 348, 331,
    51, 102, 119,
    349, 331, 348,
    120, 119, 102,
    270, 304, 271,
    40, 41, 74,
    305, 271, 304,
    75, 74, 41,
    10, 337, 152,
    10, 152, 108,
    338, 152, 337,
    109, 108, 152,
    345, 279, 361,
    116, 132, 49,
    280, 361, 279,
    50, 49, 132,
    263, 432, 419,
    33, 195, 212,
    425, 419, 432,
    205, 212, 195,
    305, 409, 271,
    75, 41, 185,
    410, 271, 409,
    186, 185, 41,
    273, 311, 408,
    43, 184, 81,
    416, 408, 311,
    192, 81, 184,
    323, 271, 411,
    93, 187, 41,
    410, 411, 271,
    186, 41, 187,
    348, 450, 349,
    119, 120, 230,
    451, 349, 450,
    231, 230, 120,
    435, 433, 431,
    215, 211, 213,
    423, 431, 433,
    203, 213, 211,
    314, 315, 19,
    84, 19, 85,
    18, 19, 315,
    18, 85, 19,
    308, 376, 307,
    78, 77, 147,
    292, 307, 376,
    62, 147, 77,
    260, 388, 261,
    30, 31, 161,
    389, 261, 388,
    162, 161, 31,
    287, 415, 385,
    57, 158, 191,
    399, 385, 415,
    174, 191, 158,
    419, 425, 407,
    195, 183, 205,
    336, 407, 425,
    107, 205, 183,
    368, 417, 365,
    139, 136, 193,
    435, 365, 417,
    215, 193, 136,
    392, 424, 328,
    166, 99, 204,
    359, 328, 424,
    130, 204, 99,
    299, 302, 285,
    69, 55, 72,
    252, 285, 302,
    22, 72, 55,
    5, 276, 6,
    5, 6, 46,
    282, 6, 276,
    52, 46, 6,
    255, 374, 254,
    25, 24, 145,
    375, 254, 374,
    146, 145, 24,
    321, 322, 308,
    91, 78, 92,
    376, 308, 322,
    147, 92, 78,
    281, 426, 412,
    51, 188, 206,
    428, 412, 426,
    208, 206, 188,
    422, 314, 201,
    202, 201, 84,
    19, 201, 314,
    19, 84, 201,
    336, 322, 407,
    107, 183, 92,
    406, 407, 322,
    182, 92, 183,
    406, 322, 405,
    182, 181, 92,
    321, 405, 322,
    91, 92, 181,
    18, 315, 17,
    18, 17, 85,
    316, 17, 315,
    86, 85, 17,
    426, 267, 427,
    206, 207, 37,
    424, 427, 267,
    204, 37, 207,
    370, 397, 401,
    141, 177, 172,
    378, 401, 397,
    149, 172, 177,
    392, 270, 323,
    166, 93, 40,
    271, 323, 270,
    41, 40, 93,
    418, 466, 414,
    194, 190, 246,
    465, 414, 466,
    245, 246, 190,
    258, 259, 387,
    28, 160, 29,
    386, 387, 259,
    159, 29, 160,
    261, 389, 468,
    31, 248, 162,
    467, 468, 389,
    247, 162, 248,
    249, 457, 420,
    4, 197, 237,
    400, 420, 457,
    175, 237, 197,
    334, 299, 333,
    105, 104, 69,
    285, 333, 299,
    55, 69, 104,
    286, 9, 418,
    56, 194, 9,
    169, 418, 9,
    169, 9, 194,
    341, 262, 347,
    112, 118, 32,
    449, 347, 262,
    229, 32, 118,
    286, 418, 442,
    56, 222, 194,
    414, 442, 418,
    190, 194, 222,
    328, 461, 327,
    99, 98, 241,
    329, 327, 461,
    100, 241, 98,
    278, 356, 330,
    48, 101, 127,
    372, 330, 356,
    143, 127, 101,
    310, 393, 439,
    80, 219, 167,
    440, 439, 393,
    220, 167, 219,
    382, 383, 257,
    155, 27, 156,
    342, 257, 383,
    113, 156, 27,
    361, 280, 421,
    132, 199, 50,
    430, 421, 280,
    210, 50, 199,
    366, 365, 380,
    137, 151, 136,
    395, 380, 365,
    170, 136, 151,
    356, 278, 438,
    127, 218, 48,
    344, 438, 278,
    115, 48, 218,
    444, 445, 283,
    224, 53, 225,
    284, 283, 445,
    54, 225, 53,
    282, 276, 364,
    52, 135, 46,
    441, 364, 276,
    221, 46, 135,
    432, 263, 396,
    212, 171, 33,
    370, 396, 263,
    141, 33, 171,
    338, 300, 339,
    109, 110, 70,
    298, 339, 300,
    68, 70, 110,
    336, 274, 322,
    107, 92, 44,
    376, 322, 274,
    147, 44, 92,
    349, 451, 350,
    120, 121, 231,
    452, 350, 451,
    232, 231, 121,
    468, 360, 343,
    248, 114, 131,
    447, 343, 360,
    227, 131, 114,
    283, 284, 335,
    53, 106, 54,
    294, 335, 284,
    64, 54, 106,
    251, 459, 463,
    21, 243, 239,
    462, 463, 459,
    242, 239, 243,
    277, 354, 301,
    47, 71, 125,
    384, 301, 354,
    157, 125, 71,
    326, 293, 325,
    97, 96, 63,
    309, 325, 293,
    79, 63, 96,
    284, 277, 294,
    54, 64, 47,
    301, 294, 277,
    71, 47, 64,
    448, 265, 346,
    228, 117, 35,
    373, 346, 265,
    144, 35, 117,
    353, 346, 347,
    124, 118, 117,
    341, 347, 346,
    112, 117, 118,
    2, 20, 275,
    2, 45, 20,
    355, 275, 20,
    126, 20, 45,
    249, 282, 457,
    4, 237, 52,
    364, 457, 282,
    135, 52, 237,
    426, 427, 428,
    206, 208, 207,
    437, 428, 427,
    217, 207, 208,
    381, 382, 253,
    154, 23, 155,
    257, 253, 382,
    27, 155, 23,
    392, 394, 270,
    166, 40, 168,
    268, 270, 394,
    38, 168, 40,
    200, 429, 201,
    200, 201, 209,
    422, 201, 429,
    202, 209, 201,
    331, 330, 267,
    102, 37, 101,
    372, 267, 330,
    143, 101, 37,
    423, 433, 274,
    203, 44, 213,
    288, 274, 433,
    58, 213, 44,
    291, 251, 329,
    61, 100, 21,
    463, 329, 251,
    243, 21, 100,
    259, 287, 386,
    29, 159, 57,
    385, 386, 287,
    158, 57, 159,
    343, 447, 354,
    114, 125, 227,
    266, 354, 447,
    36, 227, 125,
    258, 387, 260,
    28, 30, 160,
    388, 260, 387,
    161, 160, 30,
    431, 423, 432,
    211, 212, 203,
    425, 432, 423,
    205, 203, 212,
    446, 343, 277,
    226, 47, 114,
    354, 277, 343,
    125, 114, 47,
    425, 423, 336,
    205, 107, 203,
    274, 336, 423,
    44, 203, 107,
    307, 293, 308,
    77, 78, 63,
    326, 308, 293,
    97, 63, 78,
    367, 448, 353,
    138, 124, 228,
    346, 353, 448,
    117, 228, 124,
    303, 269, 304,
    73, 74, 39,
    272, 304, 269,
    42, 39, 74,
    372, 359, 267,
    143, 37, 130,
    424, 267, 359,
    204, 130, 37,
    328, 295, 461,
    99, 241, 65,
    456, 461, 295,
    236, 65, 241,
    295, 332, 279,
    65, 49, 103,
    280, 279, 332,
    50, 103, 49,
    304, 272, 305,
    74, 75, 42,
    273, 305, 272,
    43, 42, 75,
    428, 437, 435,
    208, 215, 217,
    433, 435, 437,
    213, 217, 215,
    305, 273, 409,
    75, 185, 43,
    408, 409, 273,
    184, 43, 185,
    395, 431, 396,
    170, 171, 211,
    432, 396, 431,
    212, 211, 171,
    396, 370, 379,
    171, 150, 141,
    401, 379, 370,
    177, 141, 150,
    297, 335, 300,
    67, 70, 106,
    334, 300, 335,
    105, 106, 70,
    418, 169, 352,
    194, 123, 169,
    7, 352, 169,
    7, 169, 123,
    281, 412, 353,
    51, 124, 188,
    377, 353, 412,
    148, 188, 124,
    320, 321, 326,
    90, 97, 91,
    308, 326, 321,
    78, 91, 97,
    286, 296, 337,
    56, 108, 66,
    297, 337, 296,
    67, 66, 108,
    405, 321, 404,
    181, 180, 91,
    320, 404, 321,
    90, 91, 180,
    331, 349, 330,
    102, 101, 120,
    350, 330, 349,
    121, 120, 101,
    335, 294, 334,
    106, 105, 64,
    299, 334, 294,
    69, 64, 105,
    324, 455, 367,
    94, 138, 235,
    448, 367, 455,
    228, 235, 138,
    17, 316, 16,
    17, 16, 86,
    317, 16, 316,
    87, 86, 16,
    430, 280, 359,
    210, 130, 50,
    332, 359, 280,
    103, 50, 130,
    16, 317, 15,
    16, 15, 87,
    318, 15, 317,
    88, 87, 15,
    9, 286, 10,
    9, 10, 56,
    337, 10, 286,
    108, 56, 10,
    330, 350, 278,
    101, 48, 121,
    351, 278, 350,
    122, 121, 48,
    253, 254, 381,
    23, 154, 24,
    375, 381, 254,
    146, 24, 154,
    403, 404, 319,
    179, 89, 180,
    320, 319, 404,
    90, 180, 89,
    352, 7, 420,
    123, 197, 7,
    198, 420, 7,
    198, 7, 197,
    325, 319, 326,
    96, 97, 89,
    320, 326, 319,
    90, 89, 97,
    398, 368, 366,
    173, 137, 139,
    365, 366, 368,
    136, 139, 137,
    289, 436, 398,
    59, 173, 216,
    368, 398, 436,
    139, 216, 173,
    439, 440, 345,
    219, 116, 220,
    279, 345, 440,
    49, 220, 116,
    272, 312, 273,
    42, 43, 82,
    311, 273, 312,
    81, 82, 43,
    6, 282, 196,
    6, 196, 52,
    249, 196, 282,
    4, 52, 196,
    274, 288, 376,
    44, 147, 58,
    292, 376, 288,
    62, 58, 147,
    397, 429, 176,
    172, 176, 209,
    200, 176, 429,
    200, 209, 176,
    269, 313, 272,
    39, 42, 83,
    312, 272, 313,
    82, 83, 42,
    445, 446, 284,
    225, 54, 226,
    277, 284, 446,
    47, 226, 54,
    255, 340, 374,
    25, 145, 111,
    391, 374, 340,
    164, 111, 145,
    296, 283, 297,
    66, 67, 53,
    335, 297, 283,
    106, 53, 67,
    347, 449, 348,
    118, 119, 229,
    450, 348, 449,
    230, 229, 119,
    455, 357, 448,
    235, 228, 128,
    265, 448, 357,
    35, 128, 228,
    337, 297, 338,
    108, 109, 67,
    300, 338, 297,
    70, 67, 109,
    152, 338, 11,
    152, 11, 109,
    339, 11, 338,
    110, 109, 11,
    279, 440, 295,
    49, 65, 220,
    456, 295, 440,
    236, 220, 65,
    408, 416, 293,
    184, 63, 192,
    309, 293, 416,
    79, 192, 63,
    359, 372, 430,
    130, 210, 143,
    356, 430, 372,
    127, 143, 210,
    346, 373, 341,
    117, 112, 144,
    266, 341, 373,
    36, 144, 112,
    389, 391, 467,
    162, 247, 164,
    250, 467, 391,
    8, 164, 247,
    353, 347, 281,
    124, 51, 118,
    348, 281, 347,
    119, 118, 51,
    296, 443, 283,
    66, 53, 223,
    444, 283, 443,
    224, 223, 53,
    20, 95, 355,
    20, 126, 95,
    371, 355, 95,
    142, 95, 126,
    296, 286, 443,
    66, 223, 56,
    442, 443, 286,
    222, 56, 223,
    420, 198, 249,
    197, 4, 198,
    196, 249, 198,
    196, 198, 4,
    360, 264, 256,
    131, 26, 34,
    250, 256, 264,
    8, 34, 26,
    276, 275, 441,
    46, 221, 45,
    458, 441, 275,
    238, 45, 221,
    301, 384, 302,
    71, 72, 157,
    369, 302, 384,
    140, 157, 72,
    418, 352, 466,
    194, 246, 123,
    413, 466, 352,
    189, 123, 246,
    467, 264, 468,
    247, 248, 34,
    360, 468, 264,
    131, 34, 248,
    390, 252, 369,
    163, 140, 22,
    302, 369, 252,
    72, 22, 140,
    375, 387, 381,
    146, 154, 160,
    386, 381, 387,
    159, 160, 154,
    380, 395, 379,
    151, 150, 170,
    396, 379, 395,
    171, 170, 150,
    352, 420, 413,
    123, 189, 197,
    400, 413, 420,
    175, 197, 189,
    427, 323, 437,
    207, 217, 93,
    411, 437, 323,
    187, 93, 217,
    388, 374, 389,
    161, 162, 145,
    391, 389, 374,
    164, 145, 162,
    394, 327, 165,
    168, 165, 98,
    3, 165, 327,
    3, 98, 165,
    355, 371, 462,
    126, 242, 142,
    463, 462, 371,
    243, 142, 242,
    1, 268, 165,
    1, 165, 38,
    394, 165, 268,
    168, 38, 165,
    12, 13, 303,
    12, 73, 13,
    269, 303, 13,
    39, 13, 73,
    387, 375, 388,
    160, 161, 146,
    374, 388, 375,
    145, 146, 161,
    13, 14, 269,
    13, 39, 14,
    313, 269, 14,
    83, 14, 39,
    294, 301, 299,
    64, 69, 71,
    302, 299, 301,
    72, 71, 69,
    341, 266, 262,
    112, 32, 36,
    447, 262, 266,
    227, 36, 32,
    381, 386, 382,
    154, 155, 159,
    385, 382, 386,
    158, 159, 155,
    281, 331, 426,
    51, 206, 102,
    267, 426, 331,
    37, 102, 206,
    424, 392, 427,
    204, 207, 166,
    323, 427, 392,
    93, 166, 207,
    430, 356, 421,
    210, 199, 127,
    438, 421, 356,
    218, 127, 199,
    392, 328, 394,
    166, 168, 99,
    327, 394, 328,
    98, 99, 168,
    458, 439, 441,
    238, 221, 219,
    345, 441, 439,
    116, 219, 221,
    383, 363, 342,
    156, 113, 134,
    464, 342, 363,
    244, 134, 113,
    458, 462, 460,
    238, 240, 242,
    459, 460, 462,
    239, 242, 240,
    435, 431, 365,
    215, 136, 211,
    395, 365, 431,
    170, 211, 136,
    415, 464, 399,
    191, 174, 244,
    363, 399, 464,
    134, 244, 174,
    263, 429, 370,
    33, 141, 209,
    397, 370, 429,
    172, 209, 141,
    458, 275, 462,
    238, 242, 45,
    355, 462, 275,
    126, 45, 242,
    317, 404, 318,
    87, 88, 180,
    403, 318, 404,
    179, 180, 88,
    316, 405, 317,
    86, 87, 181,
    404, 317, 405,
    180, 181, 87,
    315, 406, 316,
    85, 86, 182,
    405, 316, 406,
    181, 182, 86,
    314, 407, 315,
    84, 85, 183,
    406, 315, 407,
    182, 183, 85,
    419, 407, 422,
    195, 202, 183,
    314, 422, 407,
    84, 183, 202,
    367, 402, 324,
    138, 94, 178,
    362, 324, 402,
    133, 178, 94,
    409, 408, 307,
    185, 77, 184,
    293, 307, 408,
    63, 184, 77,
    409, 307, 410,
    185, 186, 77,
    292, 410, 307,
    62, 77, 186,
    411, 410, 288,
    187, 58, 186,
    292, 288, 410,
    62, 186, 58,
    437, 411, 433,
    217, 213, 187,
    288, 433, 411,
    58, 187, 213,
    435, 417, 428,
    215, 208, 193,
    412, 428, 417,
    188, 193, 208,
    265, 369, 373,
    35, 144, 140,
    384, 373, 369,
    157, 140, 144,
    458, 460, 439,
    238, 219, 240,
    310, 439, 460,
    80, 240, 219,
    353, 377, 367,
    124, 138, 148,
    402, 367, 377,
    178, 148, 138,
    5, 2, 276,
    5, 46, 2,
    275, 276, 2,
    45, 2, 46,
    429, 263, 422,
    209, 202, 33,
    419, 422, 263,
    195, 33, 202,
    328, 359, 295,
    99, 65, 130,
    332, 295, 359,
    103, 130, 65,
    368, 436, 417,
    139, 193, 216,
    434, 417, 436,
    214, 216, 193,
    456, 440, 290,
    236, 60, 220,
    393, 290, 440,
    167, 220, 60,
    329, 463, 327,
    100, 98, 243,
    371, 327, 463,
    142, 243, 98,
    327, 371, 3,
    98, 3, 142,
    95, 3, 371,
    95, 142, 3,
    461, 456, 306,
    241, 76, 236,
    290, 306, 456,
    60, 236, 76,
    449, 340, 450,
    229, 230, 111,
    255, 450, 340,
    25, 111, 230,
    262, 447, 256,
    32, 26, 227,
    360, 256, 447,
    131, 227, 26,
    450, 255, 451,
    230, 231, 25,
    254, 451, 255,
    24, 25, 231,
    451, 254, 452,
    231, 232, 24,
    253, 452, 254,
    23, 24, 232,
    452, 253, 453,
    232, 233, 23,
    257, 453, 253,
    27, 23, 233,
    257, 342, 453,
    27, 233, 113,
    454, 453, 342,
    234, 113, 233,
    414, 465, 415,
    190, 191, 245,
    464, 415, 465,
    244, 245, 191,
    442, 414, 287,
    222, 57, 190,
    415, 287, 414,
    191, 190, 57,
    442, 287, 443,
    222, 223, 57,
    259, 443, 287,
    29, 57, 223,
    443, 259, 444,
    223, 224, 29,
    258, 444, 259,
    28, 29, 224,
    445, 444, 260,
    225, 30, 224,
    258, 260, 444,
    28, 224, 30,
    260, 261, 445,
    30, 225, 31,
    446, 445, 261,
    226, 31, 225,
    261, 468, 446,
    31, 226, 248,
    343, 446, 468,
    114, 248, 226,
    251, 310, 459,
    21, 239, 80,
    460, 459, 310,
    240, 80, 239,
    291, 306, 393,
    61, 167, 76,
    290, 393, 306,
    60, 76, 167,
    461, 306, 329,
    241, 100, 76,
    291, 329, 306,
    61, 76, 100,
    377, 434, 402,
    148, 178, 214,
    436, 402, 434,
    216, 214, 178,
    251, 291, 310,
    21, 80, 61,
    393, 310, 291,
    167, 61, 80,
    412, 417, 377,
    188, 148, 193,
    434, 377, 417,
    214, 193, 148,
    342, 464, 454,
    113, 234, 244,
    465, 454, 464,
    245, 244, 234,
    454, 465, 358,
    234, 129, 245,
    466, 358, 465,
    246, 245, 129,
    413, 344, 466,
    189, 246, 115,
    358, 466, 344,
    129, 115, 246,
    438, 344, 400,
    218, 175, 115,
    413, 400, 344,
    189, 115, 175,
    364, 441, 361,
    135, 132, 221,
    345, 361, 441,
    116, 221, 132,
    457, 421, 400,
    237, 175, 199,
    438, 400, 421,
    218, 199, 175,
    457, 364, 421,
    237, 199, 135,
    361, 421, 364,
    132, 135, 199,
    362, 402, 289,
    133, 59, 178,
    436, 289, 402,
    216, 178, 59,
    354, 266, 384,
    125, 157, 36,
    373, 384, 266,
    144, 36, 157,
    256, 250, 340,
    26, 111, 8,
    391, 340, 250,
    164, 8, 111,
    262, 256, 449,
    32, 229, 26,
    340, 449, 256,
    111, 26, 229,
    15, 318, 14,
    15, 14, 88,
    313, 14, 318,
    83, 88, 14,
    318, 403, 313,
    88, 83, 179,
    312, 313, 403,
    82, 179, 83,
    403, 319, 312,
    179, 82, 89,
    311, 312, 319,
    81, 89, 82,
    319, 325, 311,
    89, 81, 96,
    416, 311, 325,
    192, 96, 81];

let tc = [0.499977, 0.652534, 0.500026, 0.5474870000000001, 0.499974, 0.602372, 0.482113, 0.47197900000000004, 0.500151, 0.527156, 0.49991, 0.49825299999999995, 0.499523, 0.40106200000000003, 0.289712, 0.380764, 0.499955, 0.31239799999999995, 0.499987, 0.269919, 0.500023, 0.10704999999999998, 0.500023, 0.666234, 0.500016, 0.679224, 0.500023, 0.692348, 0.499977, 0.6952780000000001, 0.499977, 0.7059340000000001, 0.499977, 0.7193849999999999, 0.499977, 0.737019, 0.499968, 0.781371, 0.499816, 0.562981, 0.473773, 0.5739099999999999, 0.104907, 0.25414099999999995, 0.36593, 0.40957600000000005, 0.338758, 0.413025, 0.31112, 0.40946000000000005, 0.274658, 0.389131, 0.393362, 0.403706, 0.345234, 0.34401099999999996, 0.370094, 0.34607600000000005, 0.319322, 0.34726500000000005, 0.297903, 0.353591, 0.247792, 0.41081, 0.396889, 0.842755, 0.280098, 0.37560000000000004, 0.10631, 0.399956, 0.209925, 0.39135299999999995, 0.355808, 0.5344059999999999, 0.471751, 0.650404, 0.474155, 0.680192, 0.439785, 0.6572290000000001, 0.414617, 0.666541, 0.450374, 0.6808609999999999, 0.428771, 0.6826909999999999, 0.374971, 0.727805, 0.486717, 0.5476289999999999, 0.485301, 0.5273950000000001, 0.257765, 0.31449000000000005, 0.401223, 0.455172, 0.429819, 0.5486150000000001, 0.421352, 0.533741, 0.276896, 0.532057, 0.48337, 0.499587, 0.337212, 0.282883, 0.296392, 0.29324300000000003, 0.169295, 0.19381400000000004, 0.44758, 0.30261000000000005, 0.39239, 0.353888, 0.35449, 0.6967840000000001, 0.067305, 0.730105, 0.442739, 0.5728260000000001, 0.457098, 0.584792, 0.381974, 0.6947110000000001, 0.392389, 0.694203, 0.277076, 0.27193199999999995, 0.422552, 0.563233, 0.385919, 0.28136399999999995, 0.383103, 0.25583999999999996, 0.331431, 0.11971399999999999, 0.229924, 0.23200299999999996, 0.364501, 0.189114, 0.229622, 0.29954099999999995, 0.173287, 0.278748, 0.472879, 0.6661980000000001, 0.446828, 0.668527, 0.422762, 0.67389, 0.445308, 0.580066, 0.388103, 0.693961, 0.403039, 0.70654, 0.403629, 0.693953, 0.460042, 0.557139, 0.431158, 0.692366, 0.452182, 0.692366, 0.475387, 0.692366, 0.465828, 0.77919, 0.472329, 0.736226, 0.473087, 0.717857, 0.473122, 0.704626, 0.473033, 0.6952780000000001, 0.427942, 0.6952780000000001, 0.426479, 0.70354, 0.423162, 0.711846, 0.418309, 0.720063, 0.390095, 0.639573, 0.013954, 0.5600339999999999, 0.499914, 0.580147, 0.4132, 0.6954, 0.409626, 0.701823, 0.46808, 0.6015349999999999, 0.422729, 0.585985, 0.46308, 0.593784, 0.37212, 0.473414, 0.334562, 0.496073, 0.411671, 0.5469649999999999, 0.242176, 0.14767600000000003, 0.290777, 0.20144600000000001, 0.327338, 0.25652699999999995, 0.39951, 0.748921, 0.441728, 0.261676, 0.429765, 0.18783399999999995, 0.412198, 0.10890100000000003, 0.288955, 0.398952, 0.218937, 0.435411, 0.412782, 0.39897000000000005, 0.257135, 0.35544, 0.427685, 0.43796100000000004, 0.44834, 0.5369360000000001, 0.17856, 0.457554, 0.247308, 0.457194, 0.286267, 0.46767499999999995, 0.332828, 0.460712, 0.368756, 0.447207, 0.398964, 0.432655, 0.47641, 0.405806, 0.189241, 0.5239240000000001, 0.228962, 0.348951, 0.490726, 0.5624009999999999, 0.40467, 0.48513300000000004, 0.019469, 0.40156400000000003, 0.426243, 0.420431, 0.396993, 0.548797, 0.26647, 0.376977, 0.439121, 0.518958, 0.032314, 0.6443570000000001, 0.419054, 0.387155, 0.462783, 0.505747, 0.238979, 0.779745, 0.198221, 0.8319380000000001, 0.10755, 0.540755, 0.18361, 0.7402569999999999, 0.13441, 0.33368299999999995, 0.385764, 0.883154, 0.490967, 0.579378, 0.382385, 0.5085729999999999, 0.174399, 0.397671, 0.318785, 0.396235, 0.343364, 0.400597, 0.3961, 0.710217, 0.187885, 0.588538, 0.430987, 0.944065, 0.318993, 0.898285, 0.266248, 0.8697010000000001, 0.500023, 0.19057599999999997, 0.499977, 0.954453, 0.36617, 0.398822, 0.393207, 0.395537, 0.410373, 0.39108, 0.194993, 0.342102, 0.388665, 0.36228400000000005, 0.365962, 0.35597100000000004, 0.343364, 0.35535700000000003, 0.318785, 0.35834, 0.301415, 0.36315600000000003, 0.058133, 0.319076, 0.301415, 0.38744900000000004, 0.499988, 0.6184339999999999, 0.415838, 0.624196, 0.445682, 0.5660769999999999, 0.465844, 0.620641, 0.499923, 0.35152399999999995, 0.288719, 0.8199460000000001, 0.335279, 0.85282, 0.440512, 0.902419, 0.128294, 0.791941, 0.408772, 0.37389399999999995, 0.455607, 0.451801, 0.499877, 0.90899, 0.375437, 0.924192, 0.11421, 0.615022, 0.448662, 0.6952780000000001, 0.44802, 0.7046319999999999, 0.447112, 0.715808, 0.444832, 0.7307939999999999, 0.430012, 0.766809, 0.406787, 0.685673, 0.400738, 0.6810689999999999, 0.3924, 0.6777029999999999, 0.367856, 0.6639189999999999, 0.247923, 0.601333, 0.45277, 0.42084999999999995, 0.436392, 0.35988699999999996, 0.416164, 0.368714, 0.413386, 0.692366, 0.228018, 0.6835720000000001, 0.468268, 0.35267099999999996, 0.411362, 0.804327, 0.499989, 0.46982500000000005, 0.479154, 0.442654, 0.499974, 0.43963699999999994, 0.432112, 0.49358900000000006, 0.499886, 0.8669169999999999, 0.499913, 0.8217289999999999, 0.456549, 0.8192010000000001, 0.344549, 0.745439, 0.378909, 0.57401, 0.374293, 0.780185, 0.319688, 0.570738, 0.357155, 0.60427, 0.295284, 0.6215809999999999, 0.44775, 0.8624769999999999, 0.410986, 0.508723, 0.313951, 0.775308, 0.354128, 0.812553, 0.324548, 0.703993, 0.189096, 0.6463, 0.279777, 0.714658, 0.133823, 0.682701, 0.336768, 0.644733, 0.429884, 0.466522, 0.455528, 0.5486230000000001, 0.437114, 0.5588960000000001, 0.467288, 0.529925, 0.414712, 0.33521999999999996, 0.377046, 0.322778, 0.344108, 0.32015099999999996, 0.312876, 0.32233199999999995, 0.283526, 0.33319, 0.241246, 0.38278599999999996, 0.102986, 0.46876300000000004, 0.267612, 0.42456000000000005, 0.297879, 0.433176, 0.333434, 0.433878, 0.366427, 0.42611600000000005, 0.396012, 0.41669599999999996, 0.420121, 0.41022800000000004, 0.007561, 0.480777, 0.432949, 0.569518, 0.458639, 0.479089, 0.473466, 0.545744, 0.476088, 0.56383, 0.468472, 0.555057, 0.433991, 0.582362, 0.483518, 0.5629839999999999, 0.482483, 0.5778490000000001, 0.42645, 0.389799, 0.438999, 0.39649500000000004, 0.450067, 0.40043399999999996, 0.289712, 0.36825300000000005, 0.27667, 0.36337299999999995, 0.517862, 0.47194800000000003, 0.710288, 0.380764, 0.526227, 0.5739099999999999, 0.895093, 0.25414099999999995, 0.63407, 0.40957600000000005, 0.661242, 0.413025, 0.68888, 0.40946000000000005, 0.725342, 0.389131, 0.60663, 0.403705, 0.654766, 0.34401099999999996, 0.629906, 0.34607600000000005, 0.680678, 0.34726500000000005, 0.702097, 0.353591, 0.752212, 0.410805, 0.602918, 0.842863, 0.719902, 0.37560000000000004, 0.893693, 0.39996, 0.790082, 0.391354, 0.643998, 0.5344880000000001, 0.528249, 0.650404, 0.52585, 0.680191, 0.560215, 0.6572290000000001, 0.585384, 0.666541, 0.549626, 0.6808609999999999, 0.571228, 0.6826920000000001, 0.624852, 0.728099, 0.51305, 0.547282, 0.515097, 0.527252, 0.742247, 0.314507, 0.598631, 0.454979, 0.570338, 0.548575, 0.578632, 0.533623, 0.723087, 0.532054, 0.516446, 0.49963900000000006, 0.662801, 0.282918, 0.703624, 0.29327099999999995, 0.830705, 0.19381400000000004, 0.552386, 0.30256799999999995, 0.60761, 0.353888, 0.645429, 0.696707, 0.932695, 0.730105, 0.557261, 0.5728260000000001, 0.542902, 0.584792, 0.618026, 0.6947110000000001, 0.607591, 0.694203, 0.722943, 0.27196299999999995, 0.577414, 0.563167, 0.614083, 0.28138700000000005, 0.616907, 0.25588599999999995, 0.668509, 0.11991399999999997, 0.770092, 0.23202100000000003, 0.635536, 0.189249, 0.770391, 0.29955600000000004, 0.826722, 0.278755, 0.527121, 0.6661980000000001, 0.553172, 0.668527, 0.577238, 0.67389, 0.554692, 0.580066, 0.611897, 0.693961, 0.596961, 0.70654, 0.596371, 0.693953, 0.539958, 0.557139, 0.568842, 0.692366, 0.547818, 0.692366, 0.524613, 0.692366, 0.53409, 0.779141, 0.527671, 0.736226, 0.526913, 0.717857, 0.526878, 0.704626, 0.526967, 0.6952780000000001, 0.572058, 0.6952780000000001, 0.573521, 0.70354, 0.576838, 0.711846, 0.581691, 0.720063, 0.609945, 0.63991, 0.986046, 0.5600339999999999, 0.5868, 0.6954, 0.590372, 0.701823, 0.531915, 0.601537, 0.577268, 0.585935, 0.536915, 0.5937859999999999, 0.627543, 0.473352, 0.665586, 0.49595100000000003, 0.588354, 0.546862, 0.757824, 0.14767600000000003, 0.70925, 0.20150800000000002, 0.672684, 0.25658099999999995, 0.600409, 0.7490049999999999, 0.558266, 0.261672, 0.570304, 0.187871, 0.588166, 0.10904400000000003, 0.711045, 0.398952, 0.78107, 0.43540500000000004, 0.587247, 0.39893199999999995, 0.74287, 0.35544600000000004, 0.572156, 0.43765200000000004, 0.551868, 0.53657, 0.821442, 0.45755599999999996, 0.752702, 0.457182, 0.713757, 0.467627, 0.667113, 0.460673, 0.631101, 0.44715400000000005, 0.600862, 0.432473, 0.523481, 0.40562699999999996, 0.810748, 0.523926, 0.771046, 0.348959, 0.509127, 0.562718, 0.595293, 0.485024, 0.980531, 0.40156400000000003, 0.5735, 0.42000000000000004, 0.602995, 0.5486880000000001, 0.73353, 0.376977, 0.560611, 0.5190170000000001, 0.967686, 0.6443570000000001, 0.580985, 0.38715999999999995, 0.537728, 0.505385, 0.760966, 0.779753, 0.801779, 0.8319380000000001, 0.892441, 0.540761, 0.816351, 0.7402599999999999, 0.865595, 0.33368699999999996, 0.614074, 0.883246, 0.508953, 0.579438, 0.617942, 0.508316, 0.825608, 0.397675, 0.681215, 0.396235, 0.656636, 0.400597, 0.6039, 0.710217, 0.812086, 0.5885389999999999, 0.568013, 0.944565, 0.681008, 0.898285, 0.733752, 0.8697010000000001, 0.63383, 0.398822, 0.606793, 0.395537, 0.58966, 0.391062, 0.805016, 0.34210799999999997, 0.611335, 0.36228400000000005, 0.634038, 0.35597100000000004, 0.656636, 0.35535700000000003, 0.681215, 0.35834, 0.698585, 0.36315600000000003, 0.941867, 0.319076, 0.698585, 0.38744900000000004, 0.584177, 0.624107, 0.554318, 0.5660769999999999, 0.534154, 0.6206400000000001, 0.711218, 0.819975, 0.66463, 0.8528709999999999, 0.5591, 0.902632, 0.871706, 0.791941, 0.591234, 0.37389399999999995, 0.544341, 0.451584, 0.624563, 0.924192, 0.88577, 0.615029, 0.551338, 0.6952780000000001, 0.55198, 0.7046319999999999, 0.552888, 0.715808, 0.555168, 0.7307939999999999, 0.569944, 0.767035, 0.593203, 0.685676, 0.599262, 0.6810689999999999, 0.6076, 0.6777029999999999, 0.631938, 0.6635, 0.752033, 0.601315, 0.547226, 0.42039499999999996, 0.563544, 0.35982800000000004, 0.583841, 0.368714, 0.586614, 0.692366, 0.771915, 0.683578, 0.531597, 0.352483, 0.588371, 0.804441, 0.520797, 0.442565, 0.567985, 0.493479, 0.543283, 0.8192550000000001, 0.655317, 0.7455149999999999, 0.621009, 0.5740179999999999, 0.62556, 0.780312, 0.680198, 0.570719, 0.642764, 0.604338, 0.704663, 0.62153, 0.552012, 0.862592, 0.589072, 0.508637, 0.685945, 0.775357, 0.645735, 0.81264, 0.675343, 0.703978, 0.810858, 0.646305, 0.720122, 0.7146669999999999, 0.866152, 0.682705, 0.663187, 0.644597, 0.570082, 0.466326, 0.544562, 0.548376, 0.562759, 0.558785, 0.531987, 0.5301400000000001, 0.585271, 0.33517699999999995, 0.622953, 0.32277900000000004, 0.655896, 0.320163, 0.687132, 0.322346, 0.716482, 0.33320099999999997, 0.758757, 0.382787, 0.897013, 0.468769, 0.732392, 0.424547, 0.702114, 0.43316299999999996, 0.666525, 0.433866, 0.633505, 0.426088, 0.603876, 0.41658700000000004, 0.579658, 0.409945, 0.99244, 0.480777, 0.567192, 0.56942, 0.541366, 0.47889899999999996, 0.526564, 0.546118, 0.523913, 0.56383, 0.531529, 0.555057, 0.566036, 0.582329, 0.516311, 0.5630539999999999, 0.517472, 0.577877, 0.573595, 0.389807, 0.560698, 0.395332, 0.549756, 0.39975099999999997, 0.710288, 0.36825300000000005, 0.72333, 0.36337299999999995];

for (let i = 0; i < faces.length; i++)
{
    faces[i]--;
}

const geom = new CGL.Geometry("fratze");
geom.clear();

geom.vertices = new Float32Array(verts);
geom.texCoords = new Float32Array(tc);

geom.vertexNormals = new Float32Array(verts);
geom.verticesIndices = faces;

outGeom.set(null);
outGeom.set(geom);

const g = geom.copy();


};

Ops.Libs.Mediapipe.FaceMesh.prototype = new CABLES.Op();
CABLES.OPS["7e13efda-330f-4c5e-bc84-e14e5af99cd4"]={f:Ops.Libs.Mediapipe.FaceMesh,objName:"Ops.Libs.Mediapipe.FaceMesh"};




// **************************************************************
// 
// Ops.Libs.Mediapipe.MpFaceTracking
// 
// **************************************************************

Ops.Libs.Mediapipe.MpFaceTracking = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inEle = op.inObject("Element"),
    inRefineLand = op.inBool("Refine LandMarks", false),
    outPoints = op.outArray("Points"),
    outFound = op.outNumber("Found"),
    outResult = op.outObject("Result");

// https://google.github.io/mediapipe/solutions/face_mesh.html

let camera = null;

inRefineLand.onChange = setOptions;

inEle.onChange = () =>
{
    const el = inEle.get();
    if (!el) return;

    camera = new Camera(el, {
        "onFrame": async () =>
        {
            await faceMesh.send({ "image": el });
        },
        "width": el.width,
        "height": el.height
    });
    camera.start();
};

const faceMesh = new FaceMesh({ "locateFile": (file) =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });

faceMesh.setOptions({
    "maxNumFaces": 1,
    "minDetectionConfidence": 0.5,
    "minTrackingConfidence": 0.5
});

setOptions();

function setOptions()
{
    faceMesh.setOptions({
        "maxNumFaces": 1,
        "minDetectionConfidence": 0.5,
        "minTrackingConfidence": 0.5,
        "refineLandmarks": inRefineLand.get()
    });
}

faceMesh.onResults((r) =>
{
    let points = [];

    if (r && r.multiFaceLandmarks)
    {
        outFound.set(r.multiFaceLandmarks.length);
        if (r.multiFaceLandmarks[0]) for (let i = 0; i < r.multiFaceLandmarks[0].length; i++)
        {
            points.push(
                (r.multiFaceLandmarks[0][i].x - 0.5) * 2,
                -1 * (r.multiFaceLandmarks[0][i].y - 0.5) * 2, 0);
        }
    }
    else outFound.set(0);

    outPoints.set(points);
    outResult.set(r);
});


};

Ops.Libs.Mediapipe.MpFaceTracking.prototype = new CABLES.Op();
CABLES.OPS["57df26fc-916c-469b-a343-83572c731025"]={f:Ops.Libs.Mediapipe.MpFaceTracking,objName:"Ops.Libs.Mediapipe.MpFaceTracking"};




// **************************************************************
// 
// Ops.Libs.Mediapipe.MpHand
// 
// **************************************************************

Ops.Libs.Mediapipe.MpHand = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inMpResult = op.inObject("Hands Result"),
    inWhichHand = op.inSwitch("Hand", ["Left", "Right"], "Left"),
    inMinScore = op.inFloatSlider("Min Score", 0.2),
    outPoints = op.outArray("Points"),
    outLines = op.outArray("Lines"),
    outResult = op.outObject("Data"),
    outFound = op.outBoolNum("Found Hand"),
    outScore = op.outNumber("Score");

function getLines(points)
{
    const lines = [];
    lines.push(points[0 * 3 + 0], points[0 * 3 + 1], points[0 * 3 + 2]); // thumb
    lines.push(points[1 * 3 + 0], points[1 * 3 + 1], points[1 * 3 + 2]);
    lines.push(points[1 * 3 + 0], points[1 * 3 + 1], points[1 * 3 + 2]);
    lines.push(points[2 * 3 + 0], points[2 * 3 + 1], points[2 * 3 + 2]);
    lines.push(points[2 * 3 + 0], points[2 * 3 + 1], points[2 * 3 + 2]);
    lines.push(points[3 * 3 + 0], points[3 * 3 + 1], points[3 * 3 + 2]);
    lines.push(points[3 * 3 + 0], points[3 * 3 + 1], points[3 * 3 + 2]);
    lines.push(points[4 * 3 + 0], points[4 * 3 + 1], points[4 * 3 + 2]);

    lines.push(points[0 * 3 + 0], points[0 * 3 + 1], points[0 * 3 + 2]); // wrist
    lines.push(points[5 * 3 + 0], points[5 * 3 + 1], points[5 * 3 + 2]);
    lines.push(points[5 * 3 + 0], points[5 * 3 + 1], points[5 * 3 + 2]);
    lines.push(points[9 * 3 + 0], points[9 * 3 + 1], points[9 * 3 + 2]);
    lines.push(points[9 * 3 + 0], points[9 * 3 + 1], points[9 * 3 + 2]);
    lines.push(points[13 * 3 + 0], points[13 * 3 + 1], points[13 * 3 + 2]);
    lines.push(points[13 * 3 + 0], points[13 * 3 + 1], points[13 * 3 + 2]);
    lines.push(points[17 * 3 + 0], points[17 * 3 + 1], points[17 * 3 + 2]);
    lines.push(points[17 * 3 + 0], points[17 * 3 + 1], points[17 * 3 + 2]);
    lines.push(points[0 * 3 + 0], points[0 * 3 + 1], points[0 * 3 + 2]);

    lines.push(points[5 * 3 + 0], points[5 * 3 + 1], points[5 * 3 + 2]); // index finger
    lines.push(points[6 * 3 + 0], points[6 * 3 + 1], points[6 * 3 + 2]);
    lines.push(points[6 * 3 + 0], points[6 * 3 + 1], points[6 * 3 + 2]);
    lines.push(points[7 * 3 + 0], points[7 * 3 + 1], points[7 * 3 + 2]);
    lines.push(points[7 * 3 + 0], points[7 * 3 + 1], points[7 * 3 + 2]);
    lines.push(points[8 * 3 + 0], points[8 * 3 + 1], points[8 * 3 + 2]);

    lines.push(points[9 * 3 + 0], points[9 * 3 + 1], points[9 * 3 + 2]); // middle finger
    lines.push(points[10 * 3 + 0], points[10 * 3 + 1], points[10 * 3 + 2]);
    lines.push(points[10 * 3 + 0], points[10 * 3 + 1], points[10 * 3 + 2]);
    lines.push(points[11 * 3 + 0], points[11 * 3 + 1], points[11 * 3 + 2]);
    lines.push(points[11 * 3 + 0], points[11 * 3 + 1], points[11 * 3 + 2]);
    lines.push(points[12 * 3 + 0], points[12 * 3 + 1], points[12 * 3 + 2]);

    lines.push(points[13 * 3 + 0], points[13 * 3 + 1], points[13 * 3 + 2]); // ring finger
    lines.push(points[14 * 3 + 0], points[14 * 3 + 1], points[14 * 3 + 2]);
    lines.push(points[14 * 3 + 0], points[14 * 3 + 1], points[14 * 3 + 2]);
    lines.push(points[15 * 3 + 0], points[15 * 3 + 1], points[15 * 3 + 2]);
    lines.push(points[15 * 3 + 0], points[15 * 3 + 1], points[15 * 3 + 2]);
    lines.push(points[16 * 3 + 0], points[16 * 3 + 1], points[16 * 3 + 2]);

    lines.push(points[17 * 3 + 0], points[17 * 3 + 1], points[17 * 3 + 2]); // ring finger
    lines.push(points[18 * 3 + 0], points[18 * 3 + 1], points[18 * 3 + 2]);
    lines.push(points[18 * 3 + 0], points[18 * 3 + 1], points[18 * 3 + 2]);
    lines.push(points[19 * 3 + 0], points[19 * 3 + 1], points[19 * 3 + 2]);
    lines.push(points[19 * 3 + 0], points[19 * 3 + 1], points[19 * 3 + 2]);
    lines.push(points[20 * 3 + 0], points[20 * 3 + 1], points[20 * 3 + 2]);

    return lines;
}

inMpResult.onChange = () =>
{
    let points = [];
    let points2 = [];
    let lines = null;
    let lines2 = null;
    let r = inMpResult.get();

    if (r && r.multiHandedness)
    {

    }
    else
    {
        outFound.set(false);
        outScore.set(0);
        return;
    }

    let idx = 0;

    let found = false;

    if (r.multiHandedness)
    {
        for (let i = 0; i < r.multiHandedness.length; i++)
        {
            if (r.multiHandedness[i].label == inWhichHand.get())
            {
                idx = i;
                outScore.set(r.multiHandedness[i].score);
                found = true;
            }
        }
    }

    if (found && outScore.get() > inMinScore.get())
    {
        outFound.set(true);
        if (r && r.multiHandLandmarks && r.multiHandLandmarks[idx])
        {
            for (let i = 0; i < r.multiHandLandmarks[idx].length; i++)
            {
                points[i * 3] = (r.multiHandLandmarks[idx][i].x - 0.5) * 2;
                points[i * 3 + 1] = -1 * (r.multiHandLandmarks[idx][i].y - 0.5) * 2;
                points[i * 3 + 2] = 0;
            }
            lines = getLines(points);

            outPoints.set(points);
            outLines.set(lines);
            outResult.set(r.multiHandLandmarks[idx]);
        }
    }
    else
    {
        outResult.set(null);
        outPoints.set(null);
        outLines.set(null);

        outFound.set(false);
    }
};


};

Ops.Libs.Mediapipe.MpHand.prototype = new CABLES.Op();
CABLES.OPS["935b0d02-1dce-4d5c-87a8-f1fa36c5d25e"]={f:Ops.Libs.Mediapipe.MpHand,objName:"Ops.Libs.Mediapipe.MpHand"};




// **************************************************************
// 
// Ops.Libs.Mediapipe.MpHandCoordinate
// 
// **************************************************************

Ops.Libs.Mediapipe.MpHandCoordinate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

// https://google.github.io/mediapipe/solutions/hands.html

const marks=["WRIST","THUMB_CMC","THUMB_MCP","THUMB_IP","THUMB_TIP","INDEX_FINGER_MCP","INDEX_FINGER_PIP","INDEX_FINGER_DIP","INDEX_FINGER_TIP","MIDDLE_FINGER_MCP","MIDDLE_FINGER_PIP","MIDDLE_FINGER_DIP","MIDDLE_FINGER_TIP","RING_FINGER_MCP","RING_FINGER_PIP","RING_FINGER_DIP","RING_FINGER_TIP","PINKY_MCP","PINKY_PIP","PINKY_DIP","PINKY_TIP"];

const
    inHand=op.inArray("Hand Points"),
    inWhich=op.inDropDown("Joint",marks,"WRIST"),
    outX=op.outNumber("X"),
    outY=op.outNumber("Y"),
    outZ=op.outNumber("Z");

let idx=0;

inWhich.onChange=()=>
{
    idx=marks.indexOf(inWhich.get());
    update();
};

inHand.onChange=update;

function update()
{
    const arr=inHand.get();

    if(arr && arr.length>idx*3)
    {
        outX.set(arr[idx*3+0]);
        outY.set(arr[idx*3+1]);
        outZ.set(arr[idx*3+2]);
    }

}

};

Ops.Libs.Mediapipe.MpHandCoordinate.prototype = new CABLES.Op();
CABLES.OPS["d3adef3d-5c99-48fd-86f0-48ec4a290afb"]={f:Ops.Libs.Mediapipe.MpHandCoordinate,objName:"Ops.Libs.Mediapipe.MpHandCoordinate"};




// **************************************************************
// 
// Ops.Libs.Mediapipe.MpHandTracking
// 
// **************************************************************

Ops.Libs.Mediapipe.MpHandTracking = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// todo: warn if ele not dom object , e..g. texture!

const
    inEle = op.inObject("Element", null, "element"),
    inMinConfDetect = op.inFloatSlider("Min Confidence Detect", 0.5),
    inMinConfTrack = op.inFloatSlider("Min Confidence Tracking", 0.5),

    outResult = op.outObject("Result"),
    outFound = op.outNumber("Found Hands");

const hands = new Hands({ "locateFile": (file) =>
{ return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.1/${file}`; } });

let camera = null;
updateOptions();

inMinConfTrack.onChange =
    inMinConfDetect.onChange = updateOptions;

inEle.onChange = () =>
{
    if (!inEle.get()) return;

    camera = new Camera(inEle.get(), {
        "onFrame": async () =>
        {
            const ele = inEle.get();

            if (ele) await hands.send({ "image": ele });
        },
        "width": inEle.get().width,
        "height": inEle.get().height
    });
    camera.start();
};

function updateOptions()
{
    hands.setOptions({
        "maxNumHands": 2,
        "minDetectionConfidence": inMinConfDetect.get(),
        "minTrackingConfidence": inMinConfTrack.get()
    });
}

hands.onResults((r) =>
{
    if (r && r.multiHandedness)
    {
        outFound.set(r.multiHandedness.length);
    }
    else
    {
        outFound.set(0);
    }

    outResult.set(r);
});


};

Ops.Libs.Mediapipe.MpHandTracking.prototype = new CABLES.Op();
CABLES.OPS["5251e50f-abaf-4ca3-a809-61f8ca58ec35"]={f:Ops.Libs.Mediapipe.MpHandTracking,objName:"Ops.Libs.Mediapipe.MpHandTracking"};




// **************************************************************
// 
// Ops.Libs.Mediapipe.MpPoseGetCoordinate
// 
// **************************************************************

Ops.Libs.Mediapipe.MpPoseGetCoordinate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    marks = ["Nose", "Left eye inner", "Left eye", "Left eye outer", "Right eye inner", "Right eye", "Right eye outer", "Left ear", "Right ear", "Mouth left", "Mouth right", "Left shoulder", "Right shoulder", "Left elbow", "Right elbow", "Left wrist", "Right wrist", "Left pinky #1 knuckle", "Right pinky #1 knuckle", "Left index #1 knuckle", "Right index #1 knuckle", "Left thumb #2 knuckle", "Right thumb #2 knuckle", "Left hip", "Right hip", "Left knee", "Right knee", "Left ankle", "Right ankle", "Left heel", "Right heel", "Left foot index", "Right foot index"],

    inArr = op.inArray("Landmarks"),
    inWhich = op.inDropDown("Landmark", marks, "Nose"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z");

let index = 0;

inWhich.onChange = () =>
{
    index = marks.indexOf(inWhich.get());
};

inArr.onChange = () =>
{
    const arr = inArr.get();

    if (arr && arr[index])
    {
        outX.set((arr[index].x - 0.5) * 2.0);
        outY.set((arr[index].y - 0.5) * -2.0);
        outZ.set(arr[index].z);
    }
};


};

Ops.Libs.Mediapipe.MpPoseGetCoordinate.prototype = new CABLES.Op();
CABLES.OPS["725c90f3-3526-420f-b921-4d214c281e25"]={f:Ops.Libs.Mediapipe.MpPoseGetCoordinate,objName:"Ops.Libs.Mediapipe.MpPoseGetCoordinate"};




// **************************************************************
// 
// Ops.Libs.Mediapipe.MpPoseTracking
// 
// **************************************************************

Ops.Libs.Mediapipe.MpPoseTracking = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"texcopy_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\n\n\nvoid main()\n{\n    vec2 tc=vec2(texCoord.x,texCoord.y);\n\n    #ifdef FLIPX\n        tc.x=1.0-texCoord.x;\n    #endif\n    #ifdef FLIPY\n        tc.y=1.0-texCoord.y;\n    #endif\n    outColor=texture(tex,tc);\n}",};
// todo: warn if ele not dom object , e..g. texture!

const
    inEle = op.inObject("Element", null, "element"),

    inModelComplexity = op.inSwitch("Model Complexity", ["0", "1", "2"], "1"),
    inSmoothLandmarks = op.inBool("Smooth Landmarks", true),

    inMinDetectionConfidence = op.inFloatSlider("Min Detection Confidence", 0.5),
    inMinTrackingConfidence = op.inFloatSlider("Min Tracking Confidence", 0.5),

    inEnableSegmentation = op.inBool("Enable Segmentation", false),
    inUpdateSeg = op.inTrigger("Update Texture"),
    inSmoothSegmentation = op.inBool("Smooth Segmentation", false),
    flipX = op.inValueBool("Flip X", false),
    flipY = op.inValueBool("Flip Y", false),

    outPoints = op.outArray("Points"),
    outTex = op.outTexture("Segmentation Mask"),
    outLandmarks = op.outArray("Landmarks"),
    outLines = op.outArray("Lines"),
    outFound = op.outNumber("Found");

op.setPortGroup("Segmentation", [inEnableSegmentation, inSmoothSegmentation, flipX, flipY, inUpdateSeg]);

const pose = new Pose({ "locateFile": (file) =>
{ return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`; } });

const cgl = op.patch.cgl;
let camera = null;
let lines = [];
let segMaskBitmap = null;
let points = [];
let points2 = [];
let tc = null;
let canvasTexture = null;

updateOptions();

flipX.onChange =
flipY.onChange = initCopyShader;

inSmoothLandmarks.onChange =
    inModelComplexity.onChange =
    inEnableSegmentation.onChange =
    inSmoothSegmentation.onChange =
    inMinDetectionConfidence.onChange =
    inMinTrackingConfidence.onChange = updateOptions;

function updateOptions()
{
    pose.setOptions({
        "modelComplexity": parseInt(inModelComplexity.get()),
        "smoothLandmarks": inSmoothLandmarks.get(),
        "enableSegmentation": inEnableSegmentation.get(),
        "smoothSegmentation": inSmoothSegmentation.get(),
        "minDetectionConfidence": inMinDetectionConfidence.get(),
        "minTrackingConfidence": inMinTrackingConfidence.get()
    });

    inSmoothSegmentation.setUiAttribs({ "greyout": !inEnableSegmentation.get() });
    flipX.setUiAttribs({ "greyout": !inEnableSegmentation.get() });
    flipY.setUiAttribs({ "greyout": !inEnableSegmentation.get() });
}

function initCopyShader()
{
    if (!tc)tc = new CGL.CopyTexture(cgl, "webcamFlippedTexture", { "shader": attachments.texcopy_frag });
    tc.bgShader.toggleDefine("FLIPX", flipX.get());
    tc.bgShader.toggleDefine("FLIPY", !flipY.get());
}

inEle.onChange = () =>
{
    const el = inEle.get();
    if (!el)
    {
        return;
    }
    camera = new Camera(el, {
        "onFrame": async () =>
        {
            await pose.send({ "image": el });
        },
        "width": el.width,
        "height": el.height
    });
    camera.start();
};

inUpdateSeg.onTriggered = () =>
{
    outTex.set(CGL.Texture.getEmptyTexture(cgl));
    if (!segMaskBitmap) return;

    if (!canvasTexture)
    {
        canvasTexture = new CGL.Texture.createFromImage(cgl, segMaskBitmap);
    }
    else
        canvasTexture.initTexture(segMaskBitmap, CGL.Texture.FILTER_LINEAR);

    if (tc)
    {
        outTex.set(tc.copy(canvasTexture));
    }
    else
        outTex.set(canvasTexture);
};

pose.onResults((r) =>
{
    if (r && r.poseLandmarks)
    {
        for (let i = 0; i < r.poseLandmarks.length; i++)
        {
            points[i * 3] = (r.poseLandmarks[i].x - 0.5) * 2.0;
            points[i * 3 + 1] = (r.poseLandmarks[i].y - 0.5) * -2;
            points[i * 3 + 2] = r.poseLandmarks[i].z * 1.0;
        }

        if (r.segmentationMask)
        {
            segMaskBitmap = r.segmentationMask;
        }

        outPoints.set(null);
        outPoints.set(points);

        outLandmarks.set(r.poseLandmarks);

        lines = [];

        // top body
        lines.push(
            points[11 * 3 + 0], points[11 * 3 + 1], points[11 * 3 + 2],
            points[12 * 3 + 0], points[12 * 3 + 1], points[12 * 3 + 2]);
        lines.push(
            points[12 * 3 + 0], points[12 * 3 + 1], points[12 * 3 + 2],
            points[24 * 3 + 0], points[24 * 3 + 1], points[24 * 3 + 2]);
        lines.push(
            points[24 * 3 + 0], points[24 * 3 + 1], points[24 * 3 + 2],
            points[23 * 3 + 0], points[23 * 3 + 1], points[23 * 3 + 2]);
        lines.push(
            points[11 * 3 + 0], points[11 * 3 + 1], points[11 * 3 + 2],
            points[23 * 3 + 0], points[23 * 3 + 1], points[23 * 3 + 2]);

        // left arm
        lines.push(
            points[11 * 3 + 0], points[11 * 3 + 1], points[11 * 3 + 2],
            points[13 * 3 + 0], points[13 * 3 + 1], points[13 * 3 + 2]);
        lines.push(
            points[13 * 3 + 0], points[13 * 3 + 1], points[13 * 3 + 2],
            points[15 * 3 + 0], points[15 * 3 + 1], points[15 * 3 + 2]);

        // right arm
        lines.push(
            points[12 * 3 + 0], points[12 * 3 + 1], points[12 * 3 + 2],
            points[14 * 3 + 0], points[14 * 3 + 1], points[14 * 3 + 2]);
        lines.push(
            points[14 * 3 + 0], points[14 * 3 + 1], points[14 * 3 + 2],
            points[16 * 3 + 0], points[16 * 3 + 1], points[16 * 3 + 2]);

        // left leg
        lines.push(
            points[23 * 3 + 0], points[23 * 3 + 1], points[23 * 3 + 2],
            points[25 * 3 + 0], points[25 * 3 + 1], points[25 * 3 + 2]);
        lines.push(
            points[25 * 3 + 0], points[25 * 3 + 1], points[25 * 3 + 2],
            points[27 * 3 + 0], points[27 * 3 + 1], points[27 * 3 + 2]);
        lines.push(
            points[27 * 3 + 0], points[27 * 3 + 1], points[27 * 3 + 2],
            points[29 * 3 + 0], points[29 * 3 + 1], points[29 * 3 + 2]);

        // right leg
        lines.push(
            points[24 * 3 + 0], points[24 * 3 + 1], points[24 * 3 + 2],
            points[26 * 3 + 0], points[26 * 3 + 1], points[26 * 3 + 2]);
        lines.push(
            points[26 * 3 + 0], points[26 * 3 + 1], points[26 * 3 + 2],
            points[28 * 3 + 0], points[28 * 3 + 1], points[28 * 3 + 2]);
        lines.push(
            points[28 * 3 + 0], points[28 * 3 + 1], points[28 * 3 + 2],
            points[30 * 3 + 0], points[30 * 3 + 1], points[30 * 3 + 2]);

        // left hand
        lines.push(
            points[15 * 3 + 0], points[15 * 3 + 1], points[15 * 3 + 2],
            points[21 * 3 + 0], points[21 * 3 + 1], points[21 * 3 + 2],

            points[15 * 3 + 0], points[15 * 3 + 1], points[15 * 3 + 2],
            points[17 * 3 + 0], points[17 * 3 + 1], points[17 * 3 + 2],

            points[17 * 3 + 0], points[17 * 3 + 1], points[17 * 3 + 2],
            points[19 * 3 + 0], points[19 * 3 + 1], points[19 * 3 + 2],

            points[19 * 3 + 0], points[19 * 3 + 1], points[19 * 3 + 2],
            points[15 * 3 + 0], points[15 * 3 + 1], points[15 * 3 + 2]);

        // right hand
        lines.push(
            points[16 * 3 + 0], points[16 * 3 + 1], points[16 * 3 + 2],
            points[22 * 3 + 0], points[22 * 3 + 1], points[22 * 3 + 2],

            points[16 * 3 + 0], points[16 * 3 + 1], points[16 * 3 + 2],
            points[18 * 3 + 0], points[18 * 3 + 1], points[18 * 3 + 2],

            points[18 * 3 + 0], points[18 * 3 + 1], points[18 * 3 + 2],
            points[20 * 3 + 0], points[20 * 3 + 1], points[20 * 3 + 2],

            points[20 * 3 + 0], points[20 * 3 + 1], points[20 * 3 + 2],
            points[16 * 3 + 0], points[16 * 3 + 1], points[16 * 3 + 2]);

        lines.push(
            points[27 * 3 + 0], points[27 * 3 + 1], points[27 * 3 + 2],
            points[31 * 3 + 0], points[31 * 3 + 1], points[31 * 3 + 2],

            points[31 * 3 + 0], points[31 * 3 + 1], points[31 * 3 + 2],
            points[29 * 3 + 0], points[29 * 3 + 1], points[29 * 3 + 2]);

        lines.push(
            points[28 * 3 + 0], points[28 * 3 + 1], points[28 * 3 + 2],
            points[32 * 3 + 0], points[32 * 3 + 1], points[32 * 3 + 2],

            points[32 * 3 + 0], points[32 * 3 + 1], points[32 * 3 + 2],
            points[30 * 3 + 0], points[30 * 3 + 1], points[30 * 3 + 2]);

        outLines.set(lines);
    }
    else
    {
        outPoints.set(null);
        outLandmarks.set(null);
        outLines.set(null);
    }
});


};

Ops.Libs.Mediapipe.MpPoseTracking.prototype = new CABLES.Op();
CABLES.OPS["279774b0-9897-4f36-840e-5f823cfc988a"]={f:Ops.Libs.Mediapipe.MpPoseTracking,objName:"Ops.Libs.Mediapipe.MpPoseTracking"};




// **************************************************************
// 
// Ops.Libs.OpenType.OpentypeFont
// 
// **************************************************************

Ops.Libs.OpenType.OpentypeFont = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    filename = op.inUrl("Font File", [".otf", ".ttf", ".woff", ".woff2"]),
    outFont = op.outObject("Opentype Font", null, "opentype");

filename.onChange = async function ()
{
    const font = await opentype.load(filename.get());
    outFont.set(font);
};


};

Ops.Libs.OpenType.OpentypeFont.prototype = new CABLES.Op();
CABLES.OPS["f85574bb-3869-4a14-8dcc-70414bd8cfcd"]={f:Ops.Libs.OpenType.OpentypeFont,objName:"Ops.Libs.OpenType.OpentypeFont"};




// **************************************************************
// 
// Ops.Libs.OpenType.OpentypeToSvgPath
// 
// **************************************************************

Ops.Libs.OpenType.OpentypeToSvgPath = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inFont = op.inObject("Opentype Font"),
    inStr = op.inString("Text", "cables"),
    inLs = op.inFloat("Letter Spacing", 0),
    outPathStr = op.outString("Path String");

inStr.onChange =
inLs.onChange =
inFont.onChange = async function ()
{
    const font = inFont.get();
    if (!font || !font.getPath)
    {
        outPathStr.set("");
        return;
    }

    const paths = font.getPaths(inStr.get(), 0, 0, 72);
    let str = "";

    let ls = inLs.get();

    for (let i = 0; i < paths.length; i++)
    {
        for (let j = 0; j < paths[i].commands.length; j++)
        {
            if (paths[i].commands[j].hasOwnProperty("x"))
                paths[i].commands[j].x += i * ls;
            if (paths[i].commands[j].hasOwnProperty("x1"))
                paths[i].commands[j].x1 += i * ls;
        }
        str += paths[i].toPathData();
    }

    outPathStr.set(str);
};


};

Ops.Libs.OpenType.OpentypeToSvgPath.prototype = new CABLES.Op();
CABLES.OPS["4d901c72-b8dc-45dc-ac2e-608e5da40677"]={f:Ops.Libs.OpenType.OpentypeToSvgPath,objName:"Ops.Libs.OpenType.OpentypeToSvgPath"};




// **************************************************************
// 
// Ops.Libs.Trackingjs.TrackWebcamColor
// 
// **************************************************************

Ops.Libs.Trackingjs.TrackWebcamColor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpdate=op.inTrigger("Update"),
    inEle = op.inObject("Video Element"),
    inThresh=op.inFloatSlider("Threshold",0.5),

    inResize=op.inFloatSlider("Resize Video",0.3),

    r = op.inValueSlider("r", Math.random()),
    g = op.inValueSlider("g", Math.random()),
    b = op.inValueSlider("b", Math.random()),

    outArrPos = op.outArray("Positions"),
    outArrSizes = op.outArray("Sizes");

const color={r:0,g:80,b:150};
let started=false;

r.setUiAttribs({ "colorPick": true });
r.onChange=
    g.onChange=
    b.onChange=()=>
    {
        color.r=Math.round(r.get()*255);
        color.g=Math.round(g.get()*255);
        color.b=Math.round(b.get()*255);
    };


let canvas= document.createElement("canvas");
const eleId = "video2canv" + CABLES.uuid();
canvas.setAttribute("id", eleId);


tracking.ColorTracker.registerColor("dynamic", function (r, g, b)
{
    return getColorDistance(color, { "r": r, "g": g, "b": b }) < inThresh.get()*255;
});


let tracker = new tracking.ColorTracker("dynamic");
// let tracker = new tracking.ObjectTracker("face");



tracker.on("track", function (e)
{
    const arrRects = [];
    const arrSizes=[];

    const r=canvas.width/canvas.height;


    if (e.data.length !== 0)
    {

        e.data.forEach(function (rect)
        {
            arrRects.push(r*(rect.x/canvas.width-0.5),1.0-rect.y/canvas.height-0.5,0);
            arrSizes.push(r*(rect.width/canvas.width),rect.height/canvas.height,0);
        });

    }

    outArrPos.set(arrRects);
    outArrSizes.set(arrSizes);
});

inUpdate.onTriggered=() =>
{
    const videoEle=inEle.get();
    if(videoEle)
    {

        if(videoEle.videoWidth && videoEle.videoHeight)
        {

            let w=videoEle.videoWidth;
            let h=videoEle.videoHeight;

            w=Math.round(w*inResize.get());
            h=Math.round(h*inResize.get());

            canvas.setAttribute("width",w);
            canvas.setAttribute("height",h);

            canvas.getContext('2d', { alpha: false }).drawImage(videoEle, 0, 0, w, h);

        }
    }


    // canvas = inCanvas.get();
    if (!started && canvas)
    {
        // started=true;
        tracking.track(canvas, tracker, { "camera": true });
    }
};

function getColorDistance(target, actual)
{
    return Math.sqrt(
        (target.r - actual.r) * (target.r - actual.r) +
        (target.g - actual.g) * (target.g - actual.g) +
        (target.b - actual.b) * (target.b - actual.b)
        );
}



};

Ops.Libs.Trackingjs.TrackWebcamColor.prototype = new CABLES.Op();
CABLES.OPS["546beec8-fcf3-4456-a7f5-8fd81ca717ab"]={f:Ops.Libs.Trackingjs.TrackWebcamColor,objName:"Ops.Libs.Trackingjs.TrackWebcamColor"};




// **************************************************************
// 
// Ops.Math.Abs
// 
// **************************************************************

Ops.Math.Abs = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number = op.inValue("number"),
    result = op.outNumber("result");

number.onChange = function ()
{
    result.set(Math.abs(number.get()));
};


};

Ops.Math.Abs.prototype = new CABLES.Op();
CABLES.OPS["6b5af21d-065f-44d2-9442-8b7a254753f6"]={f:Ops.Math.Abs,objName:"Ops.Math.Abs"};




// **************************************************************
// 
// Ops.Math.Accumulator
// 
// **************************************************************

Ops.Math.Accumulator = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Trigger in"),
    inAddNumber = op.inValueFloat("Add to number", 0.0),
    inMultiplier = op.inValueFloat("Multiplier to add number", 1.0),
    inSetNumber = op.inValueFloat("Default Value", 1.0),
    inSet = op.inTriggerButton("Set Default Value"),
    outNumber = op.outNumber("Current value");

let lastTime = performance.now();
let currentNumber = 0.0;
let firsttime = true;

inSet.onTriggered = resetNumber;

function resetNumber()
{
    currentNumber = inSetNumber.get();
    outNumber.set(currentNumber);
    firsttime = true;
}

exe.onTriggered = function ()
{
    if (!firsttime)
    {
        let diff = (performance.now() - lastTime) / 100;
        currentNumber += inAddNumber.get() * diff * inMultiplier.get();
        outNumber.set(currentNumber);
    }
    lastTime = performance.now();
    firsttime = false;
};


};

Ops.Math.Accumulator.prototype = new CABLES.Op();
CABLES.OPS["460574ca-dca2-4283-8c37-57a8c446a51f"]={f:Ops.Math.Accumulator,objName:"Ops.Math.Accumulator"};




// **************************************************************
// 
// Ops.Math.AddUp
// 
// **************************************************************

Ops.Math.AddUp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number = op.inValue("Number"),
    doAdd = op.inTriggerButton("Add"),
    doReset = op.inTriggerButton("Reset"),
    result = op.outNumber("Result");

let value = 0;

doAdd.onTriggered = function ()
{
    value += number.get();
    result.set(value);
};

doReset.onTriggered = function ()
{
    value = 0;
    result.set(value);
};


};

Ops.Math.AddUp.prototype = new CABLES.Op();
CABLES.OPS["f1c76976-4c8f-43a5-a9c7-6e4c7d21c749"]={f:Ops.Math.AddUp,objName:"Ops.Math.AddUp"};




// **************************************************************
// 
// Ops.Math.AngleBetweenPoints
// 
// **************************************************************

Ops.Math.AngleBetweenPoints = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    p1x = op.inValue("Point 1 X"),
    p1y = op.inValue("Point 1 Y"),
    p2x = op.inValue("Point 2 X"),
    p2y = op.inValue("Point 2 Y"),
    outAngle = op.outNumber("Angle", 0);

p1x.onChange =
    p2x.onChange =
    p1y.onChange =
    p2y.onChange = update;

function update()
{
    let theta = Math.atan2(
        p1y.get() - p2y.get(),
        p1x.get() - p2x.get());

    let angle = theta * 180 / Math.PI * -1;

    outAngle.set(angle);
}


};

Ops.Math.AngleBetweenPoints.prototype = new CABLES.Op();
CABLES.OPS["03e20aba-a22a-40de-9287-a32fc495a643"]={f:Ops.Math.AngleBetweenPoints,objName:"Ops.Math.AngleBetweenPoints"};




// **************************************************************
// 
// Ops.Math.Array3MultiplyMatrix
// 
// **************************************************************

Ops.Math.Array3MultiplyMatrix = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Update"),
    inArr = op.inArray("Array", null, 3),
    inMat = op.inArray("Matrix", null, 16),
    outArr = op.outArray("Result", null, 3);

let theArr = [];
exec.onTriggered = function ()
{
    let arr = inArr.get();
    if (!arr)
    {
        outArr.set(null);
        return;
    }
    theArr.length = arr.length;
    let mMat = inMat.get();
    let vec = vec4.create();
    vec[3] = 1;

    for (let i = 0; i < arr.length / 3; i++)
    {
        vec[0] = arr[i * 3 + 0];
        vec[1] = arr[i * 3 + 1];
        vec[2] = arr[i * 3 + 2];

        vec3.transformMat4(vec, vec, mMat);

        theArr[i * 3 + 0] = vec[0];
        theArr[i * 3 + 1] = vec[1];
        theArr[i * 3 + 2] = vec[2];
    }

    outArr.set(null);
    outArr.set(theArr);
};


};

Ops.Math.Array3MultiplyMatrix.prototype = new CABLES.Op();
CABLES.OPS["a83aca4c-48ab-41ad-9943-3f4d03777ae8"]={f:Ops.Math.Array3MultiplyMatrix,objName:"Ops.Math.Array3MultiplyMatrix"};




// **************************************************************
// 
// Ops.Math.Array3To2dProjection
// 
// **************************************************************

Ops.Math.Array3To2dProjection = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Exec"),
    inArr = op.inArray("Array3x"),
    fov = op.inValueFloat("fov", 45),
    w = op.inValueFloat("w", 1),
    h = op.inValueFloat("h", 1),
    px = op.inValueFloat("Pos X", -0.5),
    py = op.inValueFloat("Pos Y", -0.5),
    coordmul = op.inValueFloat("mul"),
    next = op.outTrigger("Next"),
    outArr = op.outArray("Array2x");

exe.onTriggered = function ()
{
    // if (needsUpdate)
    update();
};

exe.onChange =
    inArr.onChange =
    fov.onChange =
    w.onChange =
    h.onChange =
    px.onChange =
    py.onChange =
    coordmul.onChange = update;

const cgl = op.patch.cgl;

let needsUpdate = false;

let minX = 9999999;
let maxX = -9999999;
let minY = 9999999;
let maxY = -9999999;

let pos = vec3.create();
let m = mat4.create();
let trans = vec3.create();
let pm = mat4.create();

function proj(p)
{
    pm = mat4.perspective(pm, fov.get() * CGL.DEG2RAD, 1, 0.0001, 100);

    mat4.multiply(m, cgl.vMatrix, cgl.mMatrix);
    vec3.transformMat4(pos, [px.get(), py.get(), 0], m);
    vec3.add(pos, pos, p);

    vec3.transformMat4(trans, pos, pm);

    let height = h.get();
    let width = w.get();
    let x = trans[0] * width;
    let y = trans[1] * height;

    return [x, y, 0];
}

inArr.onChange = function ()
{
    needsUpdate = true;
};

function update()
{
    let points3d = inArr.get();
    if (!points3d) return;

    let ind = 0;
    let laserArr = [];
    let point = vec3.create();

    for (let i = 0; i < points3d.length / 3; i++)
    {
        vec3.set(point,
            points3d[i * 3 + 0],
            points3d[i * 3 + 1],
            points3d[i * 3 + 2]
        );

        let vv = proj(point);

        let x = vv[0];
        let y = vv[1];
        if (x == null)x = 0;
        if (y == null)y = 0;

        x += w.get() / 2;
        y += h.get() / 2;

        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);

        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);

        laserArr[ind++] = x;
        laserArr[ind++] = y;
        laserArr[ind++] = 0;
    }

    outArr.set(null);
    outArr.set(laserArr);
    needsUpdate = false;

    next.trigger();
}


};

Ops.Math.Array3To2dProjection.prototype = new CABLES.Op();
CABLES.OPS["8ac0bd90-ba6f-40f7-8429-21bff899cb14"]={f:Ops.Math.Array3To2dProjection,objName:"Ops.Math.Array3To2dProjection"};




// **************************************************************
// 
// Ops.Math.Atan2
// 
// **************************************************************

Ops.Math.Atan2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    x = op.inValue("X"),
    y = op.inValue("Y"),
    phase = op.inValue("Phase", 0.0),
    mul = op.inValue("Frequency", 1.0),
    result = op.outNumber("Result");

x.onChange =
    y.onChange = update;

function update()
{
    result.set(
        mul.get() * Math.atan2(x.get(), y.get()) + phase.get()
    );
}


};

Ops.Math.Atan2.prototype = new CABLES.Op();
CABLES.OPS["93ebaebf-0ebf-4aae-b0d8-2996ae44f1ed"]={f:Ops.Math.Atan2,objName:"Ops.Math.Atan2"};




// **************************************************************
// 
// Ops.Math.Average
// 
// **************************************************************

Ops.Math.Average = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number = op.inValue("number"),
    infl = op.inValueSlider("Influence", 0.2),
    result = op.outNumber("result");

number.onChange = function ()
{
    let influence = infl.get();
    result.set((result.get() * (1.0 - influence) + number.get()) * influence);
};

number.set(1);


};

Ops.Math.Average.prototype = new CABLES.Op();
CABLES.OPS["12a93cd3-348b-460a-aa02-f66690062322"]={f:Ops.Math.Average,objName:"Ops.Math.Average"};




// **************************************************************
// 
// Ops.Math.ButterflyCurve
// 
// **************************************************************

Ops.Math.ButterflyCurve = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inVal = op.inValue("Value"),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y");

inVal.onChange = update;

function update()
{
    let t = inVal.get();

    let x = Math.cos(t) * Math.pow(Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) - Math.sin(t / 12), 2);
    let y = Math.sin(t) * Math.pow(Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) - Math.sin(t / 12), 2);

    outX.set(x);
    outY.set(y);
}


};

Ops.Math.ButterflyCurve.prototype = new CABLES.Op();
CABLES.OPS["d9023bba-8122-4eed-8d61-32461cad8aba"]={f:Ops.Math.ButterflyCurve,objName:"Ops.Math.ButterflyCurve"};




// **************************************************************
// 
// Ops.Math.Ceil
// 
// **************************************************************

Ops.Math.Ceil = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const number1 = op.inValue("Number");
const result = op.outNumber("Result");

function exec()
{
    result.set(Math.ceil(number1.get()));
}

number1.onChange = exec;


};

Ops.Math.Ceil.prototype = new CABLES.Op();
CABLES.OPS["15ba7aa9-b1c3-4b20-b6bf-b52a3ba8c8c5"]={f:Ops.Math.Ceil,objName:"Ops.Math.Ceil"};




// **************************************************************
// 
// Ops.Math.CircleCoordinates
// 
// **************************************************************

Ops.Math.CircleCoordinates = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inPos = op.inFloat("Position"),
    inRadius = op.inFloat("Radius", 1),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y");

inPos.onChange =
    inRadius.onChange = calc;

function calc()
{
    const r = inRadius.get();
    const degInRad = (360 * inPos.get()) * CGL.DEG2RAD;

    outX.set(Math.sin(degInRad) * r);
    outY.set(Math.cos(degInRad) * r);
}


};

Ops.Math.CircleCoordinates.prototype = new CABLES.Op();
CABLES.OPS["76fdea4d-1653-46d6-80f3-af34018f043d"]={f:Ops.Math.CircleCoordinates,objName:"Ops.Math.CircleCoordinates"};




// **************************************************************
// 
// Ops.Math.Clamp
// 
// **************************************************************

Ops.Math.Clamp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inValueFloat("val", 0.5),
    min = op.inValueFloat("min", 0),
    max = op.inValueFloat("max", 1),
    ignore = op.inValueBool("ignore outside values"),
    result = op.outNumber("result");

val.onChange = min.onChange = max.onChange = clamp;

function clamp()
{
    if (ignore.get())
    {
        if (val.get() > max.get()) return;
        if (val.get() < min.get()) return;
    }
    result.set(Math.min(Math.max(val.get(), min.get()), max.get()));
}


};

Ops.Math.Clamp.prototype = new CABLES.Op();
CABLES.OPS["cda1a98e-5e16-40bd-9b18-a67e9eaad5a1"]={f:Ops.Math.Clamp,objName:"Ops.Math.Clamp"};




// **************************************************************
// 
// Ops.Math.Compare.Between
// 
// **************************************************************

Ops.Math.Compare.Between = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number = op.inValue("value", 2),
    number1 = op.inValue("number1", 1),
    number2 = op.inValue("number2", 3),
    result = op.outNumber("result");

number1.onChange = exec;
number2.onChange = exec;
number.onChange = exec;
exec();

function exec()
{
    result.set(
        number.get() > Math.min(number1.get(), number2.get()) &&
            number.get() < Math.max(number1.get(), number2.get())
    );
}


};

Ops.Math.Compare.Between.prototype = new CABLES.Op();
CABLES.OPS["d629959e-838d-4541-b12f-15e2d6ff5131"]={f:Ops.Math.Compare.Between,objName:"Ops.Math.Compare.Between"};




// **************************************************************
// 
// Ops.Math.Compare.BetweenEquals
// 
// **************************************************************

Ops.Math.Compare.BetweenEquals = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number = op.inValueFloat("Value", 2),
    range1 = op.inValueFloat("Range 1", 1),
    range2 = op.inValueFloat("Range 2", 3),
    result = op.outNumber("Result");

number.onChange = range1.onChange = range2.onChange = exec;
exec();

function exec()
{
    result.set(
        number.get() >= Math.min(range1.get(), range2.get()) &&
      number.get() <= Math.max(range1.get(), range2.get())
    );
}


};

Ops.Math.Compare.BetweenEquals.prototype = new CABLES.Op();
CABLES.OPS["e2d6d6c4-84c7-42d7-a1b2-e9c5d4c5c13e"]={f:Ops.Math.Compare.BetweenEquals,objName:"Ops.Math.Compare.BetweenEquals"};




// **************************************************************
// 
// Ops.Math.Compare.CompareNumbers
// 
// **************************************************************

Ops.Math.Compare.CompareNumbers = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    logicSelectMode = op.inValueSelect("Comparison mode", [">", "<", ">=", "<=", "==", "!=", "><", ">=<"], ">"),
    numberIn_1 = op.inFloat("Value in", 0),
    numberIn_2 = op.inFloat("Condition value", 1),
    numberIn_3 = op.inFloat("Max", 1),
    resultNumberOut = op.outNumber("Result");

let logicFunc;

logicSelectMode.onChange = onFilterChange;

numberIn_1.onChange = numberIn_2.onChange = numberIn_3.onChange = update;

onFilterChange();

function onFilterChange()
{
    let logicSelectValue = logicSelectMode.get();
    if (logicSelectValue === ">") logicFunc = function (a, b, c) { if (a > b) return 1; return 0; };
    else if (logicSelectValue === "<") logicFunc = function (a, b, c) { if (a < b) return 1; return 0; };
    else if (logicSelectValue === ">=") logicFunc = function (a, b, c) { if (a >= b) return 1; return 0; };
    else if (logicSelectValue === "<=") logicFunc = function (a, b, c) { if (a <= b) return 1; return 0; };
    else if (logicSelectValue === "==") logicFunc = function (a, b, c) { if (a === b) return 1; return 0; };
    else if (logicSelectValue === "!=") logicFunc = function (a, b, c) { if (a !== b) return 1; return 0; };
    else if (logicSelectValue === "><") logicFunc = function (a, b, c) { if (a > Math.min(b, c) && a < Math.max(b, c)) return 1; return 0; };
    else if (logicSelectValue === ">=<") logicFunc = function (a, b, c) { if (a >= Math.min(b, c) && a <= Math.max(b, c)) return 1; return 0; };

    if (logicSelectValue === "><" || logicSelectValue === ">=<")
    {
        numberIn_3.setUiAttribs({ "greyout": false });
        numberIn_2.setUiAttribs({ "title": "Min" });
    }
    else
    {
        numberIn_3.setUiAttribs({ "greyout": true });
        numberIn_2.setUiAttribs({ "title": "Condition value" });
    }
    update();
    op.setUiAttrib({ "extendTitle": logicSelectValue });
}

function update()
{
    let n1 = numberIn_1.get();
    let n2 = numberIn_2.get();
    let n3 = numberIn_3.get();

    let resultNumber = logicFunc(n1, n2, n3);

    resultNumberOut.set(resultNumber);
}


};

Ops.Math.Compare.CompareNumbers.prototype = new CABLES.Op();
CABLES.OPS["169137db-9853-4384-ac5b-d10a0bbda5c2"]={f:Ops.Math.Compare.CompareNumbers,objName:"Ops.Math.Compare.CompareNumbers"};




// **************************************************************
// 
// Ops.Math.Compare.Equals
// 
// **************************************************************

Ops.Math.Compare.Equals = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number1 = op.inValue("number1", 1),
    number2 = op.inValue("number2", 1),
    result = op.outBoolNum("result");

number1.onChange =
    number2.onChange = exec;
exec();

function exec()
{
    result.set(number1.get() == number2.get());
}


};

Ops.Math.Compare.Equals.prototype = new CABLES.Op();
CABLES.OPS["4dd3cc55-eebc-4187-9d4e-2e053a956fab"]={f:Ops.Math.Compare.Equals,objName:"Ops.Math.Compare.Equals"};




// **************************************************************
// 
// Ops.Math.Compare.GreaterOrEquals
// 
// **************************************************************

Ops.Math.Compare.GreaterOrEquals = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    result = op.outBoolNum("result"),
    number1 = op.inValueFloat("number1"),
    number2 = op.inValueFloat("number2");

number1.onLinkChanged =
    number2.onLinkChanged =
    number1.onChange =
    number2.onChange = exec;

function exec()
{
    result.set(number1.get() >= number2.get());
}


};

Ops.Math.Compare.GreaterOrEquals.prototype = new CABLES.Op();
CABLES.OPS["5f9ce320-1e8d-49cb-9927-337e0b3f4d45"]={f:Ops.Math.Compare.GreaterOrEquals,objName:"Ops.Math.Compare.GreaterOrEquals"};




// **************************************************************
// 
// Ops.Math.Compare.GreaterThan
// 
// **************************************************************

Ops.Math.Compare.GreaterThan = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number1 = op.inValueFloat("number1"),
    number2 = op.inValueFloat("number2"),
    result = op.outBoolNum("result");

op.setTitle(">");

number1.onChange = number2.onChange = exec;

function exec()
{
    result.set(number1.get() > number2.get());
}


};

Ops.Math.Compare.GreaterThan.prototype = new CABLES.Op();
CABLES.OPS["b250d606-f7f8-44d3-b099-c29efff2608a"]={f:Ops.Math.Compare.GreaterThan,objName:"Ops.Math.Compare.GreaterThan"};




// **************************************************************
// 
// Ops.Math.Compare.IfBetweenThen
// 
// **************************************************************

Ops.Math.Compare.IfBetweenThen = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    number = op.inValue("number", 0),
    min = op.inValue("min", 0),
    max = op.inValue("max", 1),
    triggerThen = op.outTrigger("then"),
    triggerElse = op.outTrigger("else"),
    outBetween = op.outBoolNum("bs between");

exe.onTriggered = function ()
{
    if (number.get() >= min.get() && number.get() < max.get())
    {
        outBetween.set(true);
        triggerThen.trigger();
    }
    else
    {
        outBetween.set(false);
        triggerElse.trigger();
    }
};


};

Ops.Math.Compare.IfBetweenThen.prototype = new CABLES.Op();
CABLES.OPS["c80437f0-f0e1-465c-9cea-8a044aa2feaa"]={f:Ops.Math.Compare.IfBetweenThen,objName:"Ops.Math.Compare.IfBetweenThen"};




// **************************************************************
// 
// Ops.Math.Compare.IsEven
// 
// **************************************************************

Ops.Math.Compare.IsEven = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number = op.inValueFloat("number1"),
    result = op.outBoolNum("result");

number.onChange = exec;
exec();

function exec()
{
    result.set(!(number.get() & 1));
}


};

Ops.Math.Compare.IsEven.prototype = new CABLES.Op();
CABLES.OPS["f462c64a-3e17-4de8-a77d-6735725fc9cc"]={f:Ops.Math.Compare.IsEven,objName:"Ops.Math.Compare.IsEven"};




// **************************************************************
// 
// Ops.Math.Compare.LessThan
// 
// **************************************************************

Ops.Math.Compare.LessThan = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const number1 = op.inValue("number1");
const number2 = op.inValue("number2");
const result = op.outBoolNum("result");

op.setTitle("<");

number1.onChange = exec;
number2.onChange = exec;
exec();

function exec()
{
    result.set(number1.get() < number2.get());
}


};

Ops.Math.Compare.LessThan.prototype = new CABLES.Op();
CABLES.OPS["04fd113f-ade1-43fb-99fa-f8825f8814c0"]={f:Ops.Math.Compare.LessThan,objName:"Ops.Math.Compare.LessThan"};




// **************************************************************
// 
// Ops.Math.Cosine
// 
// **************************************************************

Ops.Math.Cosine = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inValue("Value"),
    phase = op.inValue("Phase", 0.0),
    mul = op.inValue("Frequency", 1.0),
    amplitude = op.inValue("Amplitude", 1.0),
    invert = op.inValueBool("asine", false),
    result = op.outNumber("Result");

let calculate = Math.cos;

value.onChange = function ()
{
    result.set(
        amplitude.get() * calculate((value.get() * mul.get()) + phase.get())
    );
};

invert.onChange = function ()
{
    if (invert.get()) calculate = Math.acos;
    else calculate = Math.cos;
};


};

Ops.Math.Cosine.prototype = new CABLES.Op();
CABLES.OPS["b51166c4-e0a8-441a-b724-1531effdc52f"]={f:Ops.Math.Cosine,objName:"Ops.Math.Cosine"};




// **************************************************************
// 
// Ops.Math.Crossfade
// 
// **************************************************************

Ops.Math.Crossfade = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inFade = op.inFloatSlider("Crossfade",0.5);
const inMinOut = op.inFloat("Out Min", 0);
const inMaxOut = op.inFloat("Out Max", 1);
op.setPortGroup("Range",[inMinOut, inMaxOut]);

const anim = new CABLES.Anim();
const inDropdownAnim = anim.createPort(op,"Easing", function() {
    anim.keys[0].setEasing(anim.defaultEasing);
});

anim.setValue(0,0);
anim.setValue(1,1);
op.setPortGroup("Easing",[inDropdownAnim]);

const outA = op.outNumber("A");
const outB = op.outNumber("B");


function handleMinMaxChange() {
    anim.keys[0].time= anim.keys[0].value = Math.min(inMinOut.get(),inMaxOut.get());
    anim.keys[1].time= anim.keys[1].value = Math.max(inMinOut.get(),inMaxOut.get());
    handleValueChange();
}
function handleValueChange() {
    const val = inFade.get();

    const realMin = Math.min(inMaxOut.get(), inMinOut.get());
    const realMax = Math.max(inMaxOut.get(), inMinOut.get());

    // Y = (X-A)/(B-A) * (D-C) + C
    const resultA = anim.getValue((1-val) * (realMax - realMin) + realMin);
    const resultB = anim.getValue(val * (realMax - realMin) + realMin);

    outA.set(resultA);
    outB.set(resultB);
}

function updateMinMax() {
    anim.keys[0].time = anim.keys[0].value = Math.min(inMinOut.get(), inMaxOut.get());
    anim.keys[1].time = anim.keys[1].value = Math.max(inMinOut.get(), inMaxOut.get());
}

handleValueChange();

inMinOut.onChange = inMaxOut.onChange = handleMinMaxChange;
inFade.onChange = handleValueChange;


};

Ops.Math.Crossfade.prototype = new CABLES.Op();
CABLES.OPS["6c8d01a2-dc8c-43c3-a569-c2ab0ba42747"]={f:Ops.Math.Crossfade,objName:"Ops.Math.Crossfade"};




// **************************************************************
// 
// Ops.Math.DegreeToVector
// 
// **************************************************************

Ops.Math.DegreeToVector = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    deg = op.inValueFloat("degree", 0),
    x = op.outNumber("x"),
    y = op.outNumber("y");

deg.onChange = update;

function update()
{
    let rad = deg.get() * CGL.DEG2RAD;
    x.set(-1 * Math.sin(rad));
    y.set(Math.cos(rad));
}


};

Ops.Math.DegreeToVector.prototype = new CABLES.Op();
CABLES.OPS["56b1618b-4eed-41a8-87a2-57397ffc9029"]={f:Ops.Math.DegreeToVector,objName:"Ops.Math.DegreeToVector"};




// **************************************************************
// 
// Ops.Math.Degrees
// 
// **************************************************************

Ops.Math.Degrees = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inValue("Radians"),
    result = op.outNumber("Result");

// convert radians into degrees
value.onChange = function ()
{
    result.set(
        value.get() * 180 / Math.PI
    );
};


};

Ops.Math.Degrees.prototype = new CABLES.Op();
CABLES.OPS["53385f87-13eb-4c19-8b04-6632a72e967c"]={f:Ops.Math.Degrees,objName:"Ops.Math.Degrees"};




// **************************************************************
// 
// Ops.Math.Delta
// 
// **************************************************************

Ops.Math.Delta = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inValue("Value"),
    changeAlwaysPort = op.inValueBool("Change Always", false),
    inReset = op.inTrigger("Reset"),
    result = op.outNumber("Delta");

val.changeAlways = false;

let oldVal = 0;
let firstTime = true;

changeAlwaysPort.onChange = function ()
{
    val.changeAlways = changeAlwaysPort.get();
};

inReset.onTriggered = function ()
{
    firstTime = true;
};

val.onChange = function ()
{
    let change = oldVal - val.get();
    oldVal = val.get();
    if (firstTime)
    {
        firstTime = false;
        return;
    }
    result.set(change);
};


};

Ops.Math.Delta.prototype = new CABLES.Op();
CABLES.OPS["0f203337-e13c-47ec-a09f-b309212540b0"]={f:Ops.Math.Delta,objName:"Ops.Math.Delta"};




// **************************************************************
// 
// Ops.Math.DeltaSum
// 
// **************************************************************

Ops.Math.DeltaSum = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inVal = op.inValue("Delta Value"),
    defVal = op.inValue("Default Value", 0),
    inMul = op.inValue("Multiply", 1),
    inReset = op.inTriggerButton("Reset"),
    inLimit = op.inValueBool("Limit", false),
    inMin = op.inValue("Min", 0),
    inMax = op.inValue("Max", 100),
    inRubber = op.inValue("Rubberband", 0),
    outVal = op.outNumber("Absolute Value");

inVal.changeAlways = true;

op.setPortGroup("Limit", [inLimit, inMin, inMax, inRubber]);

let value = 0;
let lastEvent = CABLES.now();
let rubTimeout = null;

inLimit.onChange = updateLimit;
defVal.onChange =
    inReset.onTriggered = resetValue;

inMax.onChange =
    inMin.onChange = updateValue;

updateLimit();

function resetValue()
{
    let v = defVal.get();

    if (inLimit.get())
    {
        v = Math.max(inMin.get(), v);
        v = Math.min(inMax.get(), v);
    }

    value = v;
    outVal.set(value);
}

function updateLimit()
{
    inMin.setUiAttribs({ "greyout": !inLimit.get() });
    inMax.setUiAttribs({ "greyout": !inLimit.get() });
    inRubber.setUiAttribs({ "greyout": !inLimit.get() });

    updateValue();
}

function releaseRubberband()
{
    const min = inMin.get();
    const max = inMax.get();

    if (value < min) value = min;
    if (value > max) value = max;

    outVal.set(value);
}

function updateValue()
{
    if (inLimit.get())
    {
        const min = inMin.get();
        const max = inMax.get();
        const rubber = inRubber.get();
        const minr = inMin.get() - rubber;
        const maxr = inMax.get() + rubber;

        if (value < minr) value = minr;
        if (value > maxr) value = maxr;

        if (rubber !== 0.0)
        {
            clearTimeout(rubTimeout);
            rubTimeout = setTimeout(releaseRubberband.bind(this), 300);
        }
    }

    outVal.set(value);
}

inVal.onChange = function ()
{
    let v = inVal.get();

    const rubber = inRubber.get();

    if (rubber !== 0.0)
    {
        const min = inMin.get();
        const max = inMax.get();
        const minr = inMin.get() - rubber;
        const maxr = inMax.get() + rubber;

        if (value < min)
        {
            const aa = Math.abs(value - minr) / rubber;
            v *= (aa * aa);
        }
        if (value > max)
        {
            const aa = Math.abs(maxr - value) / rubber;
            v *= (aa * aa);
        }
    }

    lastEvent = CABLES.now();
    value += v * inMul.get();
    updateValue();
};


};

Ops.Math.DeltaSum.prototype = new CABLES.Op();
CABLES.OPS["d9d4b3db-c24b-48da-b798-9e6230d861f7"]={f:Ops.Math.DeltaSum,objName:"Ops.Math.DeltaSum"};




// **************************************************************
// 
// Ops.Math.Difference
// 
// **************************************************************

Ops.Math.Difference = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    num1 = op.inValue("Number A"),
    num2 = op.inValue("Number B"),
    result = op.outNumber("Result");

num1.onChange =
    num2.onChange = update;

function update()
{
    let r = num1.get() - num2.get();
    r = Math.abs(r);
    result.set(r);
}


};

Ops.Math.Difference.prototype = new CABLES.Op();
CABLES.OPS["5431b943-18aa-46e4-bd32-a7eee30d4e51"]={f:Ops.Math.Difference,objName:"Ops.Math.Difference"};




// **************************************************************
// 
// Ops.Math.Distance2d
// 
// **************************************************************

Ops.Math.Distance2d = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    x1 = op.inValue("x1"),
    y1 = op.inValue("y1"),
    x2 = op.inValue("x2"),
    y2 = op.inValue("y2"),
    dist = op.outNumber("distance");

x1.onChange =
y1.onChange =
x2.onChange =
y2.onChange = calc;

function calc()
{
    const xd = x2.get() - x1.get();
    const yd = y2.get() - y1.get();
    dist.set(Math.sqrt(xd * xd + yd * yd));
}


};

Ops.Math.Distance2d.prototype = new CABLES.Op();
CABLES.OPS["d181cc7c-adbb-467b-842b-e6a854c58bfc"]={f:Ops.Math.Distance2d,objName:"Ops.Math.Distance2d"};




// **************************************************************
// 
// Ops.Math.Distance3d
// 
// **************************************************************

Ops.Math.Distance3d = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let x1 = op.inValueFloat("x1");
let y1 = op.inValueFloat("y1");
let z1 = op.inValueFloat("z1");

let x2 = op.inValueFloat("x2");
let y2 = op.inValueFloat("y2");
let z2 = op.inValueFloat("z2");

let dist = op.addOutPort(new CABLES.Port(op, "distance"));
op.setPortGroup("Point 1", [x1, y1, z1]);
op.setPortGroup("Point 2", [x2, y2, z2]);

x1.onChange = calc;
y1.onChange = calc;
z1.onChange = calc;
x2.onChange = calc;
y2.onChange = calc;
z2.onChange = calc;

function calc()
{
    let xd = x2.get() - x1.get();
    let yd = y2.get() - y1.get();
    let zd = z2.get() - z1.get();
    dist.set(Math.sqrt(xd * xd + yd * yd + zd * zd));
}


};

Ops.Math.Distance3d.prototype = new CABLES.Op();
CABLES.OPS["6c5772d8-c6f4-4cad-a8e7-f669c0186964"]={f:Ops.Math.Distance3d,objName:"Ops.Math.Distance3d"};




// **************************************************************
// 
// Ops.Math.Distance3dNew
// 
// **************************************************************

Ops.Math.Distance3dNew = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    calc = op.inTriggerButton("Calc"),

    x1 = op.inValueFloat("x1"),
    y1 = op.inValueFloat("y1"),
    z1 = op.inValueFloat("z1"),

    x2 = op.inValueFloat("x2"),
    y2 = op.inValueFloat("y2"),
    z2 = op.inValueFloat("z2"),

    inMin = op.inValue("Min", 0);

op.setPortGroup("Point 1", [x1, y1, z1]);
op.setPortGroup("Point 2", [x2, y2, z2]);

const next = op.outTrigger("Next");
const dist = op.addOutPort(new CABLES.Port(op, "distance"));

let min = inMin.get();

inMin.onChange = function ()
{
    min = inMin.get();
};

calc.onTriggered = function ()
{
    const xd = x2.get() - x1.get();
    if (Math.abs(xd) > min) return;

    const yd = y2.get() - y1.get();
    if (Math.abs(yd) > min) return;

    const zd = z2.get() - z1.get();
    if (Math.abs(zd) > min) return;

    dist.set(Math.sqrt(xd * xd + yd * yd + zd * zd));

    next.trigger();
};


};

Ops.Math.Distance3dNew.prototype = new CABLES.Op();
CABLES.OPS["6b344add-6c4d-4365-858f-a365e4adb183"]={f:Ops.Math.Distance3dNew,objName:"Ops.Math.Distance3dNew"};




// **************************************************************
// 
// Ops.Math.Divide
// 
// **************************************************************

Ops.Math.Divide = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number1 = op.inValueFloat("number1", 1),
    number2 = op.inValueFloat("number2", 2),
    result = op.outNumber("result");

op.setTitle("/");

number1.onChange = number2.onChange = exec;
exec();

function exec()
{
    result.set(number1.get() / number2.get());
}


};

Ops.Math.Divide.prototype = new CABLES.Op();
CABLES.OPS["86fcfd8c-038d-4b91-9820-a08114f6b7eb"]={f:Ops.Math.Divide,objName:"Ops.Math.Divide"};




// **************************************************************
// 
// Ops.Math.Ease
// 
// **************************************************************

Ops.Math.Ease = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inVal = op.inValue("Value"),
    inMin = op.inValue("Min", 0),
    inMax = op.inValue("Max", 1),
    result = op.outNumber("Result"),
    anim = new CABLES.Anim();

anim.createPort(op, "Easing", updateAnimEasing);
anim.setValue(0, 0);
anim.setValue(1, 1);

op.onLoaded = inMin.onChange = inMax.onChange = updateMinMax;

function updateMinMax()
{
    anim.keys[0].time = anim.keys[0].value = Math.min(inMin.get(), inMax.get());
    anim.keys[1].time = anim.keys[1].value = Math.max(inMin.get(), inMax.get());
}

function updateAnimEasing()
{
    anim.keys[0].setEasing(anim.defaultEasing);
}

inVal.onChange = function ()
{
    const r = anim.getValue(inVal.get());
    result.set(r);
};


};

Ops.Math.Ease.prototype = new CABLES.Op();
CABLES.OPS["8f6e4a08-33e6-408f-ac4a-198bd03b417b"]={f:Ops.Math.Ease,objName:"Ops.Math.Ease"};




// **************************************************************
// 
// Ops.Math.Exp
// 
// **************************************************************

Ops.Math.Exp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const number = op.inValueFloat("number");
const result = op.outNumber("result");

number.onChange = function ()
{
    let r = Math.exp(number.get());
    if (isNaN(r))r = 0;
    result.set(r);
};


};

Ops.Math.Exp.prototype = new CABLES.Op();
CABLES.OPS["612727c2-b2e5-446c-99bb-7e30132f2ff6"]={f:Ops.Math.Exp,objName:"Ops.Math.Exp"};




// **************************************************************
// 
// Ops.Math.FlipSign
// 
// **************************************************************

Ops.Math.FlipSign = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inval = op.inValueFloat("Value", 1),
    result = op.outNumber("Result");

inval.onChange = update;
update();

function update()
{
    result.set(inval.get() * -1);
}


};

Ops.Math.FlipSign.prototype = new CABLES.Op();
CABLES.OPS["f5c858a2-2654-4108-86fe-319efa70ecec"]={f:Ops.Math.FlipSign,objName:"Ops.Math.FlipSign"};




// **************************************************************
// 
// Ops.Math.Floor
// 
// **************************************************************

Ops.Math.Floor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const number1 = op.inValue("Number");
const result = op.outNumber("Result");
number1.onChange = exec;

function exec()
{
    result.set(Math.floor(number1.get()));
}


};

Ops.Math.Floor.prototype = new CABLES.Op();
CABLES.OPS["0c77617c-b688-4b55-addf-2cbcaabf98af"]={f:Ops.Math.Floor,objName:"Ops.Math.Floor"};




// **************************************************************
// 
// Ops.Math.Fract
// 
// **************************************************************

Ops.Math.Fract = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inValue("Value"),
    result = op.outNumber("Result");

value.onChange = function ()
{
    const v = value.get();
    result.set(v - Math.floor(v));
};


};

Ops.Math.Fract.prototype = new CABLES.Op();
CABLES.OPS["12573ba7-866d-40c4-9ddd-14d9331ffe6f"]={f:Ops.Math.Fract,objName:"Ops.Math.Fract"};




// **************************************************************
// 
// Ops.Math.GaussianRandomArray
// 
// **************************************************************

Ops.Math.GaussianRandomArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNum = op.inValueInt("Num", 100),
    outArr = op.outArray("Array"),
    inDev = op.inValue("Deviation", 1),
    seed = op.inValueFloat("Random Seed");

let arr = [];
let stdDev = 1;
let previous = false;
let nextGaussian = null;
let y2;

seed.onChange = inDev.onChange = inNum.onChange = update;
update();

// from https://github.com/processing/p5.js/blob/master/src/math/random.js

function randomGaussian(mean, sd)
{
    let y1, x1, x2, w;
    if (previous)
    {
        y1 = y2;
        previous = false;
    }
    else
    {
        do
        {
            x1 = Math.seededRandom() * 2 - 1;
            x2 = Math.seededRandom() * 2 - 1;
            w = x1 * x1 + x2 * x2;
        } while (w >= 1);
        w = Math.sqrt((-2 * Math.log(w)) / w);
        y1 = x1 * w;
        y2 = x2 * w;
        previous = true;
    }

    let m = mean || 0;
    let s = sd || 1;
    return y1 * s + m;
}

function update()
{
    stdDev = inDev.get();
    Math.randomSeed = seed.get();

    arr.length = Math.floor(inNum.get()) || 0;
    for (let i = 0; i < arr.length; i++)
    {
        arr[i] = randomGaussian(0, stdDev);
    }

    outArr.set(null);
    outArr.set(arr);
}


};

Ops.Math.GaussianRandomArray.prototype = new CABLES.Op();
CABLES.OPS["1a8c3535-6fce-4cba-8601-ddb7a5dd7656"]={f:Ops.Math.GaussianRandomArray,objName:"Ops.Math.GaussianRandomArray"};




// **************************************************************
// 
// Ops.Math.Incrementor
// 
// **************************************************************

Ops.Math.Incrementor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    increment = op.inTriggerButton("Increment"),
    decrement = op.inTriggerButton("Decrement"),
    inLength = op.inValueInt("Length"),
    inLimit = op.inBool("Limit", true),
    reset = op.inTriggerButton("Reset"),
    inMode = op.inSwitch("Mode", ["Rewind", "Stop at Max"], "Rewind"),
    inDefault = op.inValueInt("Default", 0),
    outChanged = op.outTrigger("Changed"),
    value = op.outNumber("Value"),
    outRestarted = op.outTrigger("Restarted");

value.ignoreValueSerialize = true;
inLength.set(10);
let val = 0;
value.set(0);

inLength.onTriggered = reset;
inDefault.onChange = doReset;
reset.onTriggered = doReset;

const MODE_REWIND = 0;
const MODE_STOP = 1;

let mode = MODE_REWIND;

inMode.onChange = function ()
{
    if (inMode.get() == "Rewind")
    {
        mode = MODE_REWIND;
    }
    if (inMode.get() == "Stop at Max")
    {
        mode = MODE_STOP;
    }
};

inLimit.onChange = () =>
{
    inLength.setUiAttribs({ "greyout": !inLimit.get() });
};

function doReset()
{
    value.set(null);
    val = inDefault.get();
    value.set(val);
    outRestarted.trigger();
}

decrement.onTriggered = function ()
{
    val--;
    if (inLimit.get())
    {
        if (mode == MODE_REWIND && val < 0)val = inLength.get() - 1;
        if (mode == MODE_STOP && val < 0)val = 0;
    }
    value.set(val);

    outChanged.trigger();
};

increment.onTriggered = function ()
{
    val++;
    if (inLimit.get())
    {
        if (mode == MODE_REWIND && val >= inLength.get())
        {
            val = 0;
            outRestarted.trigger();
        }
        if (mode == MODE_STOP && val >= inLength.get())val = inLength.get() - 1;
    }

    value.set(val);

    outChanged.trigger();
};


};

Ops.Math.Incrementor.prototype = new CABLES.Op();
CABLES.OPS["45cc0011-ada8-4423-8f5b-39a3810b8389"]={f:Ops.Math.Incrementor,objName:"Ops.Math.Incrementor"};




// **************************************************************
// 
// Ops.Math.IndexFraction
// 
// **************************************************************

Ops.Math.IndexFraction = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inValue=op.inFloat("Number",0.5),
    inIdx=op.inInt("Index",0),
    outValue=op.outNumber("Result");

 inIdx.onChange=inValue.onChange = update;

function update()
{
    const idx=inIdx.get();
    const val=inValue.get();

    if(idx<Math.floor(val)) outValue.set(1.0);
    else if(idx>Math.ceil(val)) outValue.set(0.0);
    else outValue.set(val-Math.floor(val));
}

};

Ops.Math.IndexFraction.prototype = new CABLES.Op();
CABLES.OPS["924f3516-7d1c-4829-a24d-515bf3e7f43f"]={f:Ops.Math.IndexFraction,objName:"Ops.Math.IndexFraction"};




// **************************************************************
// 
// Ops.Math.Interpolate
// 
// **************************************************************

Ops.Math.Interpolate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val1 = op.inFloat("Value 1"),
    val2 = op.inFloat("Value 2"),
    perc = op.inFloatSlider("Percentage"),
    result = op.outNumber("Result");

val1.onChange =
val2.onChange =
perc.onChange = update;

function update()
{
    result.set((val2.get() - val1.get()) * perc.get() + val1.get());
}


};

Ops.Math.Interpolate.prototype = new CABLES.Op();
CABLES.OPS["d126e2c8-221e-428f-8ff4-8b8c5f6b8905"]={f:Ops.Math.Interpolate,objName:"Ops.Math.Interpolate"};




// **************************************************************
// 
// Ops.Math.IsNumberRising
// 
// **************************************************************

Ops.Math.IsNumberRising = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNum = op.inFloat("Number", 0),
    outRising = op.outNumber("Rising");

let last = 0;

inNum.onChange = () =>
{
    outRising.set(inNum.get() > last);
    last = inNum.get();
};


};

Ops.Math.IsNumberRising.prototype = new CABLES.Op();
CABLES.OPS["1598fbdf-eab9-41a1-98de-794795255359"]={f:Ops.Math.IsNumberRising,objName:"Ops.Math.IsNumberRising"};




// **************************************************************
// 
// Ops.Math.Log
// 
// **************************************************************

Ops.Math.Log = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const number = op.inValueFloat("number");
const result = op.outNumber("result");

number.onChange = function ()
{
    let r = Math.log(number.get());
    if (isNaN(r))r = 0;
    result.set(r);
};


};

Ops.Math.Log.prototype = new CABLES.Op();
CABLES.OPS["7440b1ca-71d9-42a3-a927-d7b45b8857f9"]={f:Ops.Math.Log,objName:"Ops.Math.Log"};




// **************************************************************
// 
// Ops.Math.MapGeoCoordsSpherical
// 
// **************************************************************

Ops.Math.MapGeoCoordsSpherical = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Coordinates"),
    inRad = op.inFloat("Radius", 1),
    outArr = op.outArray("Result");

let arr = [];
inRad.onChange =
    inArr.onChange = update;

function update()
{
    outArr.set(null);
    let iarr = inArr.get();

    if (!iarr) return;

    let l = iarr.length / 2 * 3;
    arr.length = l;
    const radius = inRad.get();

    for (let i = 0; i < iarr.length; i += 2)
    {
        const
            lat = iarr[i + 0],
            lon = iarr[i + 1],
            phi = (90 - lat) * (Math.PI / 180),
            theta = (lon + 180) * (Math.PI / 180);

        const x = -((radius) * Math.sin(phi) * Math.cos(theta)),
            z = ((radius) * Math.sin(phi) * Math.sin(theta)),
            y = ((radius) * Math.cos(phi));

        arr[i / 2 * 3 + 0] = x;
        arr[i / 2 * 3 + 1] = y;
        arr[i / 2 * 3 + 2] = z;
    }

    outArr.set(arr);
}


};

Ops.Math.MapGeoCoordsSpherical.prototype = new CABLES.Op();
CABLES.OPS["e4c6786b-abf6-4762-b8f9-ed89dd532e23"]={f:Ops.Math.MapGeoCoordsSpherical,objName:"Ops.Math.MapGeoCoordsSpherical"};




// **************************************************************
// 
// Ops.Math.MapRange
// 
// **************************************************************

Ops.Math.MapRange = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    v = op.inValueFloat("value", 0),
    old_min = op.inValueFloat("old min", 0),
    old_max = op.inValueFloat("old max", 1),
    new_min = op.inValueFloat("new min", -1),
    new_max = op.inValueFloat("new max", 1),
    easing = op.inValueSelect("Easing", ["Linear", "Smoothstep", "Smootherstep"], "Linear"),
    result = op.outNumber("result", 0);

op.setPortGroup("Input Range", [old_min, old_max]);
op.setPortGroup("Output Range", [new_min, new_max]);

let ease = 0;
let r = 0;

v.onChange =
    old_min.onChange =
    old_max.onChange =
    new_min.onChange =
    new_max.onChange = exec;

exec();

easing.onChange = function ()
{
    if (easing.get() == "Smoothstep") ease = 1;
    else if (easing.get() == "Smootherstep") ease = 2;
    else ease = 0;
};

function exec()
{
    const nMin = new_min.get();
    const nMax = new_max.get();
    const oMin = old_min.get();
    const oMax = old_max.get();
    let x = v.get();

    if (x >= Math.max(oMax, oMin))
    {
        result.set(nMax);
        return;
    }
    else
    if (x <= Math.min(oMax, oMin))
    {
        result.set(nMin);
        return;
    }

    let reverseInput = false;
    const oldMin = Math.min(oMin, oMax);
    const oldMax = Math.max(oMin, oMax);
    if (oldMin != oMin) reverseInput = true;

    let reverseOutput = false;
    const newMin = Math.min(nMin, nMax);
    const newMax = Math.max(nMin, nMax);
    if (newMin != nMin) reverseOutput = true;

    let portion = 0;

    if (reverseInput) portion = (oldMax - x) * (newMax - newMin) / (oldMax - oldMin);
    else portion = (x - oldMin) * (newMax - newMin) / (oldMax - oldMin);

    if (reverseOutput) r = newMax - portion;
    else r = portion + newMin;

    if (ease === 0)
    {
        result.set(r);
    }
    else
    if (ease == 1)
    {
        x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
        result.set(nMin + x * x * (3 - 2 * x) * (nMax - nMin)); // smoothstep
    }
    else
    if (ease == 2)
    {
        x = Math.max(0, Math.min(1, (r - nMin) / (nMax - nMin)));
        result.set(nMin + x * x * x * (x * (x * 6 - 15) + 10) * (nMax - nMin)); // smootherstep
    }
}


};

Ops.Math.MapRange.prototype = new CABLES.Op();
CABLES.OPS["2617b407-60a0-4ff6-b4a7-18136cfa7817"]={f:Ops.Math.MapRange,objName:"Ops.Math.MapRange"};




// **************************************************************
// 
// Ops.Math.Math
// 
// **************************************************************

Ops.Math.Math = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const num0 = op.inFloat("number 0", 0),
    num1 = op.inFloat("number 1", 0),
    mathDropDown = op.inSwitch("math mode", ["+", "-", "*", "/", "%", "min", "max"], "+"),
    result = op.outNumber("result");

let mathFunc;

num0.onChange = num1.onChange = update;
mathDropDown.onChange = onFilterChange;

let n0 = 0;
let n1 = 0;

const mathFuncAdd = function (a, b) { return a + b; };
const mathFuncSub = function (a, b) { return a - b; };
const mathFuncMul = function (a, b) { return a * b; };
const mathFuncDiv = function (a, b) { return a / b; };
const mathFuncMod = function (a, b) { return a % b; };
const mathFuncMin = function (a, b) { return Math.min(a, b); };
const mathFuncMax = function (a, b) { return Math.max(a, b); };

function onFilterChange()
{
    let mathSelectValue = mathDropDown.get();

    if (mathSelectValue == "+") mathFunc = mathFuncAdd;
    else if (mathSelectValue == "-") mathFunc = mathFuncSub;
    else if (mathSelectValue == "*") mathFunc = mathFuncMul;
    else if (mathSelectValue == "/") mathFunc = mathFuncDiv;
    else if (mathSelectValue == "%") mathFunc = mathFuncMod;
    else if (mathSelectValue == "min") mathFunc = mathFuncMin;
    else if (mathSelectValue == "max") mathFunc = mathFuncMax;
    update();
    op.setUiAttrib({ "extendTitle": mathSelectValue });
}

function update()
{
    n0 = num0.get();
    n1 = num1.get();

    result.set(mathFunc(n0, n1));
}

onFilterChange();


};

Ops.Math.Math.prototype = new CABLES.Op();
CABLES.OPS["e9fdcaca-a007-4563-8a4d-e94e08506e0f"]={f:Ops.Math.Math,objName:"Ops.Math.Math"};




// **************************************************************
// 
// Ops.Math.MathExpression
// 
// **************************************************************

Ops.Math.MathExpression = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inA = op.inFloat("A", 0);
const inB = op.inFloat("B", 1);
const inC = op.inFloat("C", 2);
const inD = op.inFloat("D", 3);
op.setPortGroup("Parameters", [inA, inB, inC, inD]);
const inExpression = op.inString("Expression", "a*(b+c+d)");
op.setPortGroup("Expression", [inExpression]);
const outResult = op.outNumber("Result");
const outExpressionIsValid = op.outBool("Expression Valid");

let currentFunction = inExpression.get();
let functionValid = false;

const createFunction = () =>
{
    try
    {
        currentFunction = new Function("m", "a", "b", "c", "d", `with(m) { return ${inExpression.get()} }`);
        functionValid = true;
        evaluateFunction();
        outExpressionIsValid.set(functionValid);
    }
    catch (e)
    {
        functionValid = false;
        outExpressionIsValid.set(functionValid);
        if (e instanceof ReferenceError || e instanceof SyntaxError) return;
    }
};

const evaluateFunction = () =>
{
    if (functionValid)
    {
        outResult.set(currentFunction(Math, inA.get(), inB.get(), inC.get(), inD.get()));
        if (!inExpression.get()) outResult.set(0);
    }

    outExpressionIsValid.set(functionValid);
};


inA.onChange = inB.onChange = inC.onChange = inD.onChange = evaluateFunction;
inExpression.onChange = createFunction;
createFunction();


};

Ops.Math.MathExpression.prototype = new CABLES.Op();
CABLES.OPS["d2343a1e-64ea-45b2-99ed-46e167bbdcd3"]={f:Ops.Math.MathExpression,objName:"Ops.Math.MathExpression"};




// **************************************************************
// 
// Ops.Math.Max
// 
// **************************************************************

Ops.Math.Max = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inValueFloat("value", 1),
    max = op.inValueFloat("Maximum", 1),
    result = op.outNumber("result");

max.onChange =
    value.onChange = exec;

exec();

function exec()
{
    let v = Math.max(value.get(), max.get());
    if (v == v) result.set(v);
}


};

Ops.Math.Max.prototype = new CABLES.Op();
CABLES.OPS["07f0be49-c226-4029-8039-3b620145dc2a"]={f:Ops.Math.Max,objName:"Ops.Math.Max"};




// **************************************************************
// 
// Ops.Math.MaxSinceReset
// 
// **************************************************************

Ops.Math.MaxSinceReset = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const valuePort = op.inValue("Value");
const resetPort = op.inTriggerButton("Reset");
const maxPort = op.outNumber("Maximum");

let first;
let lastMax;

// change listeners
resetPort.onTriggered = reset;
valuePort.onChange = update;

// init
reset();

/**
 * On Value change
 */
function update()
{
    let value = valuePort.get();
    if (first)
    {
        maxPort.set(value);
        lastMax = value;
    }
    else
    {
        lastMax = Math.max(lastMax, value);
        maxPort.set(lastMax);
    }
    first = false;
}

/**
 * On Reset
 */
function reset()
{
    first = true;
}


};

Ops.Math.MaxSinceReset.prototype = new CABLES.Op();
CABLES.OPS["d3fdb4e1-199d-487a-a719-1315aa49fcfb"]={f:Ops.Math.MaxSinceReset,objName:"Ops.Math.MaxSinceReset"};




// **************************************************************
// 
// Ops.Math.MercatorCoord
// 
// **************************************************************

Ops.Math.MercatorCoord = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inLat = op.inValue("Latitude"),
    inLon = op.inValue("Longitude"),
    inMapWidth = op.inValue("MapWidth", 1),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y");

inLat.onChange =
    inLon.onChange =
    inMapWidth.onChange = update;


function update()
{
    let mapWidth = inMapWidth.get();// 1.289672544080605;
    let mapHeight = 1;

    let latitude = inLat.get();
    let longitude = inLon.get();
    // get x value
    let x = (longitude + 180) * (mapWidth / 360);

    // convert from degrees to radians
    let latRad = latitude * Math.PI / 180;

    // get y value
    let mercN = Math.log(Math.tan((Math.PI / 4) + (latRad / 2)));
    let y = (mapHeight / 2) - (mapWidth * mercN / (2 * Math.PI));

    // x-=mapWidth/2;

    outX.set(x);
    outY.set(0 - y);
}


};

Ops.Math.MercatorCoord.prototype = new CABLES.Op();
CABLES.OPS["d95c5ba8-ed6e-4147-bf5f-8e44be3ef6cf"]={f:Ops.Math.MercatorCoord,objName:"Ops.Math.MercatorCoord"};




// **************************************************************
// 
// Ops.Math.MercatorCoordsArray
// 
// **************************************************************

Ops.Math.MercatorCoordsArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("LatLon Array"),
    inMapWidth = op.inValue("MapWidth", 100),
    inCenterLat = op.inValue("Center Lat", 0),
    inCenterLon = op.inValue("Center Lon", 0),
    outArr = op.outArray("Result");

inArr.onChange =
    inMapWidth.onChange =
    // inMapHeight.onChange=
    inCenterLat.onChange =
    inCenterLon.onChange = update;

function calcLon(lon, mapWidth)
{
    const x = (lon + 180) * (mapWidth / 360);
    return x;
}

function calcLat(lat, mapWidth, mapHeight)
{
    const latRad = lat * Math.PI / 180;

    // get y value
    const mercN = Math.log(Math.tan((Math.PI / 4) + (latRad / 2)));
    const y = (mapHeight / 2) - (mapWidth * mercN / (2 * Math.PI));
    return y;
}

function update()
{
    const mapWidth = inMapWidth.get();// 1.289672544080605;
    const mapHeight = 1;// inMapHeight.get();// 1;

    const centerLon = calcLon(inCenterLon.get(), mapWidth, mapHeight);
    const centerLat = calcLat(inCenterLat.get(), mapWidth, mapHeight);

    const arr = inArr.get();

    if (!arr)
    {
        outArr.set(null);
        return;
    }

    const newArray = [];

    for (let i = 0; i < arr.length; i += 2)
    {
        const latitude = arr[i];// inLat.get();
        const longitude = arr[i + 1];// inLon.get();

        let lon = calcLon(longitude, mapWidth, mapHeight);
        let lat = calcLat(latitude, mapWidth, mapHeight);

        // convert from degrees to radians
        // x-=mapWidth/2;

        lon -= centerLon;
        lat -= centerLat;

        newArray.push(lon, 0 - lat);
    }

    outArr.set(null);
    outArr.set(newArray);
}


};

Ops.Math.MercatorCoordsArray.prototype = new CABLES.Op();
CABLES.OPS["96e77c88-58b8-4948-bd61-c95d604a2607"]={f:Ops.Math.MercatorCoordsArray,objName:"Ops.Math.MercatorCoordsArray"};




// **************************************************************
// 
// Ops.Math.MinSinceReset
// 
// **************************************************************

Ops.Math.MinSinceReset = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let valuePort = op.inValue("Value");
let resetPort = op.inTriggerButton("Reset");
let minPort = op.outNumber("Minimum");

let first;
let lastMin;

resetPort.onTriggered = reset;
valuePort.onChange = update;

reset();

function update()
{
    let value = valuePort.get();
    if (first)
    {
        minPort.set(value);
        lastMin = value;
    }
    else
    {
        lastMin = Math.min(lastMin, value);
        minPort.set(lastMin);
    }
    first = false;
}

function reset()
{
    first = true;
}


};

Ops.Math.MinSinceReset.prototype = new CABLES.Op();
CABLES.OPS["30da693f-70bd-46bf-97d5-9f31e7f76bba"]={f:Ops.Math.MinSinceReset,objName:"Ops.Math.MinSinceReset"};




// **************************************************************
// 
// Ops.Math.Min_v3
// 
// **************************************************************

Ops.Math.Min_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val1 = op.inValue("Value 1", 1),
    val2 = op.inValue("Value 2", 2),
    result = op.outNumber("result");

val1.onChange =
    val2.onChange = exec;

exec();

function exec()
{
    let v = Math.min(val1.get(), val2.get());
    result.set(v);
}


};

Ops.Math.Min_v3.prototype = new CABLES.Op();
CABLES.OPS["24a9062d-380c-4690-8fe7-6703787fa94c"]={f:Ops.Math.Min_v3,objName:"Ops.Math.Min_v3"};




// **************************************************************
// 
// Ops.Math.Modulo
// 
// **************************************************************

Ops.Math.Modulo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number1 = op.inValueFloat("number1", 1),
    number2 = op.inValueFloat("number2", 2),
    pingpong = op.inValueBool("pingpong"),
    result = op.outNumber("result");

let calculateFunction = calculateModule;

number1.onChange =
number2.onChange = exec;

pingpong.onChange = updatePingPong;

exec();

function exec()
{
    let n2 = number2.get();
    let n1 = number1.get();

    result.set(calculateFunction(n1, n2));
}

function calculateModule(n1, n2)
{
    let re = ((n1 % n2) + n2) % n2;
    if (re != re) re = 0;
    return re;
}

function calculatePingPong(i, n)
{
    let cycle = 2 * n;
    i %= cycle;
    if (i >= n) return cycle - i;
    else return i;
}

function updatePingPong()
{
    if (pingpong.get()) calculateFunction = calculatePingPong;
    else calculateFunction = calculateModule;
}


};

Ops.Math.Modulo.prototype = new CABLES.Op();
CABLES.OPS["ebc13b25-3705-4265-8f06-5f985b6a7bb1"]={f:Ops.Math.Modulo,objName:"Ops.Math.Modulo"};




// **************************************************************
// 
// Ops.Math.MulMatrixXyz
// 
// **************************************************************

Ops.Math.MulMatrixXyz = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Update"),
    inX = op.inFloat("X", 0),
    inY = op.inFloat("Y", 0),
    inZ = op.inFloat("Z", 0),
    inMat = op.inArray("Matrix"),
    outNext = op.outTrigger("Next"),
    outX = op.outNumber("Result X"),
    outY = op.outNumber("Result Y"),
    outZ = op.outNumber("Result Z");

let theArr = [];
let vec = vec4.create();

exec.onTriggered = function ()
{
    const mMat = inMat.get();

    if (!mMat) return;

    vec4.set(vec, inX.get(), inY.get(), inZ.get(), 1);

    vec3.transformMat4(vec, vec, mMat);

    outX.set(vec[0]);
    outY.set(vec[1]);
    outZ.set(vec[2]);

    outNext.trigger();
};


};

Ops.Math.MulMatrixXyz.prototype = new CABLES.Op();
CABLES.OPS["69cc5915-fd7f-4c6c-9a8c-8553c6bab0c5"]={f:Ops.Math.MulMatrixXyz,objName:"Ops.Math.MulMatrixXyz"};




// **************************************************************
// 
// Ops.Math.Multiply
// 
// **************************************************************

Ops.Math.Multiply = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number1 = op.inValueFloat("number1", 1),
    number2 = op.inValueFloat("number2", 2),
    result = op.outNumber("result");

op.setTitle("*");

number1.onChange = number2.onChange = update;
update();

function update()
{
    const n1 = number1.get();
    const n2 = number2.get();

    result.set(n1 * n2);
}


};

Ops.Math.Multiply.prototype = new CABLES.Op();
CABLES.OPS["1bbdae06-fbb2-489b-9bcc-36c9d65bd441"]={f:Ops.Math.Multiply,objName:"Ops.Math.Multiply"};




// **************************************************************
// 
// Ops.Math.NumberDivisible
// 
// **************************************************************

Ops.Math.NumberDivisible = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    num = op.inValue("Number"),
    divisor = op.inValue("Divisor"),
    result = op.outBoolNum("Result");

num.onChange = divisor.onChange = function ()
{
    result.set(num.get() % divisor.get() === 0);
};


};

Ops.Math.NumberDivisible.prototype = new CABLES.Op();
CABLES.OPS["4059e4ee-da93-490a-a00c-6fe0f0ee8efc"]={f:Ops.Math.NumberDivisible,objName:"Ops.Math.NumberDivisible"};




// **************************************************************
// 
// Ops.Math.OneMinus
// 
// **************************************************************

Ops.Math.OneMinus = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inValue = op.inValue("Value"),
    result = op.outNumber("Result");

inValue.onChange = update;
update();

function update()
{
    result.set(1 - inValue.get());
}


};

Ops.Math.OneMinus.prototype = new CABLES.Op();
CABLES.OPS["f34d019d-59ae-40d6-a55d-a7691bbc40e0"]={f:Ops.Math.OneMinus,objName:"Ops.Math.OneMinus"};




// **************************************************************
// 
// Ops.Math.PerlinNoise_v2
// 
// **************************************************************

Ops.Math.PerlinNoise_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inX = op.inFloat("X", 0),
    inY = op.inFloat("Y", 0),
    inZ = op.inFloat("Z", 0),
    inScale = op.inFloat("Scale", 4),
    inSeed = op.inFloat("Seed", 1),

    result = op.outNumber("Result");

const PERLIN_YWRAPB = 4;
const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
const PERLIN_ZWRAPB = 8;
const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
const PERLIN_SIZE = 4095;

let perlin_octaves = 4; // default to medium smooth
let perlin_amp_falloff = 0.5; // 50% reduction/octave

const scaled_cosine = (i) => 0.5 * (1.0 - Math.cos(i * Math.PI));

let perlin = null;

inX.onChange =
    inY.onChange =
    inZ.onChange = update;

function update()
{
    let s = inScale.get();
    let r = noise(inX.get() * s, inY.get() * s, inZ.get() * s);
    result.set(r);
}

function noise(x, y = 0, z = 0)
{
    if (perlin == null)
    {
        perlin = new Array(PERLIN_SIZE + 1);
        for (let i = 0; i < PERLIN_SIZE + 1; i++)
        {
            perlin[i] = Math.random();
        }
    }

    if (x < 0)
    {
        x = -x;
    }
    if (y < 0)
    {
        y = -y;
    }
    if (z < 0)
    {
        z = -z;
    }

    let xi = Math.floor(x),
        yi = Math.floor(y),
        zi = Math.floor(z);
    let xf = x - xi;
    let yf = y - yi;
    let zf = z - zi;
    let rxf, ryf;

    let r = 0;
    let ampl = 0.5;

    let n1, n2, n3;

    for (let o = 0; o < perlin_octaves; o++)
    {
        let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);

        rxf = scaled_cosine(xf);
        ryf = scaled_cosine(yf);

        n1 = perlin[of & PERLIN_SIZE];
        n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);
        n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
        n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);
        n1 += ryf * (n2 - n1);

        of += PERLIN_ZWRAP;
        n2 = perlin[of & PERLIN_SIZE];
        n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);
        n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
        n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);
        n2 += ryf * (n3 - n2);

        n1 += scaled_cosine(zf) * (n2 - n1);

        r += n1 * ampl;
        ampl *= perlin_amp_falloff;
        xi <<= 1;
        xf *= 2;
        yi <<= 1;
        yf *= 2;
        zi <<= 1;
        zf *= 2;

        if (xf >= 1.0)
        {
            xi++;
            xf--;
        }
        if (yf >= 1.0)
        {
            yi++;
            yf--;
        }
        if (zf >= 1.0)
        {
            zi++;
            zf--;
        }
    }
    return r;
}

inSeed.onChange = () =>
{
    Math.randomSeed = inSeed.get();
    perlin = new Array(PERLIN_SIZE + 1);
    for (let i = 0; i < PERLIN_SIZE + 1; i++)
    {
        perlin[i] = Math.seededRandom();
    }
};


};

Ops.Math.PerlinNoise_v2.prototype = new CABLES.Op();
CABLES.OPS["b1a19b32-4ccd-4bce-a37d-e386e53dfc1c"]={f:Ops.Math.PerlinNoise_v2,objName:"Ops.Math.PerlinNoise_v2"};




// **************************************************************
// 
// Ops.Math.Pi
// 
// **************************************************************

Ops.Math.Pi = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    multiply = op.inValueFloat("Multiply amount", 1.0),
    p = op.outNumber("Pi", Math.PI);

multiply.onChange = function ()
{
    p.setValue(Math.PI * multiply.get());
};


};

Ops.Math.Pi.prototype = new CABLES.Op();
CABLES.OPS["311e8179-9a7c-43de-9eb2-84577d702974"]={f:Ops.Math.Pi,objName:"Ops.Math.Pi"};




// **************************************************************
// 
// Ops.Math.PointInRectangle2d
// 
// **************************************************************

Ops.Math.PointInRectangle2d = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    x = op.inValue("x"),
    y = op.inValue("y"),

    rtop = op.inValue("rect top"),
    rleft = op.inValue("rect left"),
    rright = op.inValue("rect right"),
    rbottom = op.inValue("rect bottom"),

    result = op.outBoolNum("Result"),
    outX = op.outNumber("Pos x"),
    outY = op.outNumber("Pos y");

x.onChange = y.onChange = function ()
{
    let isIn = (x.get() > rleft.get() && x.get() < rright.get() && y.get() > rtop.get() && y.get() < rbottom.get());

    outX.set(Math.max(0, Math.min(1.0, (x.get() - rleft.get()) / (rright.get() - rleft.get()))));
    outY.set(Math.max(0, Math.min(1.0, (y.get() - rtop.get()) / (rbottom.get() - rtop.get()))));

    result.set(isIn == true);
};


};

Ops.Math.PointInRectangle2d.prototype = new CABLES.Op();
CABLES.OPS["6d722288-0fec-43da-bf41-0372426fb685"]={f:Ops.Math.PointInRectangle2d,objName:"Ops.Math.PointInRectangle2d"};




// **************************************************************
// 
// Ops.Math.Pow
// 
// **************************************************************

Ops.Math.Pow = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    base = op.inValueFloat("Base"),
    exponent = op.inValueFloat("Exponent"),
    result = op.outNumber("Result");

exponent.set(2);

base.onChange = update;
exponent.onChange = update;

function update()
{
    let r = Math.pow(base.get(), exponent.get());
    if (isNaN(r))r = 0;
    result.set(r);
}


};

Ops.Math.Pow.prototype = new CABLES.Op();
CABLES.OPS["3bb3f98f-27d6-44c4-b4e5-186e10f0809d"]={f:Ops.Math.Pow,objName:"Ops.Math.Pow"};




// **************************************************************
// 
// Ops.Math.PowerOfTwoSize
// 
// **************************************************************

Ops.Math.PowerOfTwoSize = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inW = op.inValueInt("Width"),
    inH = op.inValueInt("Height"),
    inStrat = op.inValueSelect("Strategy", ["floor", "floor/2", "ceil"], "floor"),
    outW = op.outNumber("Width Result"),
    outH = op.outNumber("Height Result");
inStrat.onChange = updateStrategy;
inW.onChange = inH.onChange = update;
let getPOT = null;
updateStrategy();

function isPOT(x)
{
    return (x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384);
}

function updateStrategy()
{
    let s = inStrat.get();

    if (s == "floor")getPOT = getPotNextfloor;
    if (s == "floor/2")getPOT = getPotNextfloorx2;
    if (s == "ceil")getPOT = getPotNextBigger;
    if (s == "nearest")getPOT = getPotNearest;

    update();
}

function getPotNextBigger(x)
{
    // if(x>8192)return 16384;
    // if(x>4096)return 8129;
    if (x > 2048) return 4096;
    if (x > 1024) return 2048;
    if (x > 512) return 1024;
    if (x > 256) return 512;
    if (x > 128) return 256;
    if (x > 64) return 128;
    if (x > 32) return 64;
    if (x > 16) return 32;
    if (x > 8) return 16;
    if (x > 4) return 8;
    if (x > 2) return 4;
}

function getPotNextfloorx2(x)
{
    return Math.ceil(getPotNextfloor(x) / 2);
}

function getPotNextfloor(x)
{
    if (x < 2) return 1;
    if (x < 4) return 2;
    if (x < 8) return 4;
    if (x < 16) return 8;
    if (x < 32) return 16;
    if (x < 64) return 32;
    if (x < 128) return 64;
    if (x < 256) return 128;
    if (x < 512) return 256;
    if (x < 1024) return 512;
    if (x < 2048) return 1024;
    if (x < 4096) return 2048;
    if (x < 8192) return 4096;
    // if(x<16384)return 8192;
}

function getPotNearest(x)
{
    if (x > 3072) return 4096;
    if (x > 1536) return 2048;
    if (x > 768) return 1024;
    if (x > 320) return 512;
    if (x > 191) return 256;
    if (x > 95) return 128;
    if (x > 47) return 64;
    if (x > 23) return 32;
    if (x > 11) return 16;
    if (x > 5) return 8;
    if (x > 3) return 4;
    return 2;
}

function update()
{
    let w = inW.get();
    let h = inH.get();

    if (!isPOT(w)) w = getPOT(w);
    if (!isPOT(h)) h = getPOT(h);

    outW.set(w);
    outH.set(h);
}


};

Ops.Math.PowerOfTwoSize.prototype = new CABLES.Op();
CABLES.OPS["58e01e34-0f42-4861-ad9a-ed96e08f8565"]={f:Ops.Math.PowerOfTwoSize,objName:"Ops.Math.PowerOfTwoSize"};




// **************************************************************
// 
// Ops.Math.Radians
// 
// **************************************************************

Ops.Math.Radians = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inValue("Degrees"),
    result = op.outNumber("Result"),
    calculate = Math.cos;

// convert degrees into radians
value.onChange = function ()
{
    result.set(
        value.get() * Math.PI / 180
    );
};


};

Ops.Math.Radians.prototype = new CABLES.Op();
CABLES.OPS["d6daab6e-791e-4c4c-ac01-d887447de4f9"]={f:Ops.Math.Radians,objName:"Ops.Math.Radians"};




// **************************************************************
// 
// Ops.Math.RandomCounter
// 
// **************************************************************

Ops.Math.RandomCounter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inCount=op.inTriggerButton("Count"),
    inMin=op.inFloat("Step Min",0.5),
    inMax=op.inFloat("Step Max",1),
    outNum=op.outNumber("Result");

inCount.onTriggered=count;

let v=0;


function count()
{

    let r=Math.seededRandom() * (inMax.get() - inMin.get()) + inMin.get();

    if(Math.seededRandom()>0.5) v+=r;
    else v-=r;

    outNum.set(v);

}

};

Ops.Math.RandomCounter.prototype = new CABLES.Op();
CABLES.OPS["48c712f0-bb8e-4a0b-9b97-26da68a68223"]={f:Ops.Math.RandomCounter,objName:"Ops.Math.RandomCounter"};




// **************************************************************
// 
// Ops.Math.RandomNumbers_v3
// 
// **************************************************************

Ops.Math.RandomNumbers_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inSeed = op.inValueFloat("Seed", 1),
    min = op.inValueFloat("Min", 0),
    max = op.inValueFloat("Max", 1),
    outX = op.outNumber("X"),
    outY = op.outNumber("Y"),
    outZ = op.outNumber("Z"),
    outW = op.outNumber("W");

inSeed.onChange =
    min.onChange =
    max.onChange = update;
update();

function update()
{
    const inMin = min.get();
    const inMax = max.get();
    Math.randomSeed = Math.abs(inSeed.get() || 0) * 571.1 + 1.0;
    outX.set(Math.seededRandom() * (inMax - inMin) + inMin);
    outY.set(Math.seededRandom() * (inMax - inMin) + inMin);
    outZ.set(Math.seededRandom() * (inMax - inMin) + inMin);
    outW.set(Math.seededRandom() * (inMax - inMin) + inMin);
}


};

Ops.Math.RandomNumbers_v3.prototype = new CABLES.Op();
CABLES.OPS["d2b970e1-9406-4459-995c-5a594acd88e3"]={f:Ops.Math.RandomNumbers_v3,objName:"Ops.Math.RandomNumbers_v3"};




// **************************************************************
// 
// Ops.Math.RotationFromNormal
// 
// **************************************************************

Ops.Math.RotationFromNormal = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inNormalX = op.inValue("Normal X");
const inNormalY = op.inValue("Normal Y");
const inNormalZ = op.inValue("Normal Z");
const inRecalculate = op.inTriggerButton("recalculate");

const outRotation = op.outArray("RotationMatrix");

const identMat = mat4.create();
const outMat = mat4.create();
const upVec = vec3.fromValues(0, 1, 0);
const tmpVec = vec3.create();
const tmpQuat = quat.create();

outRotation.set(identMat);

inRecalculate.onTriggered = function ()
{
    vec3.set(
        tmpVec,
        inNormalX.get(),
        inNormalY.get(),
        inNormalZ.get()
    );

    vec3.normalize(tmpVec, tmpVec);
    quat.identity(tmpQuat);
    quat.rotationTo(tmpQuat, upVec, tmpVec);
    mat4.fromQuat(outMat, tmpQuat);
    outRotation.set(identMat);
    outRotation.set(outMat);
};


};

Ops.Math.RotationFromNormal.prototype = new CABLES.Op();
CABLES.OPS["9b39dd02-9558-4297-ba8a-8f21f690d128"]={f:Ops.Math.RotationFromNormal,objName:"Ops.Math.RotationFromNormal"};




// **************************************************************
// 
// Ops.Math.Round
// 
// **************************************************************

Ops.Math.Round = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number1 = op.inValueFloat("number"),
    decPlaces = op.inInt("Decimal Places", 0),
    result = op.outNumber("result");

let decm = 0;

number1.onChange = exec;
decPlaces.onChange = updateDecm;

updateDecm();

function updateDecm()
{
    decm = Math.pow(10, decPlaces.get());
    exec();
}

function exec()
{
    result.set(Math.round(number1.get() * decm) / decm);
}


};

Ops.Math.Round.prototype = new CABLES.Op();
CABLES.OPS["1a1ef636-6d02-42ba-ae1e-627b917d0d2b"]={f:Ops.Math.Round,objName:"Ops.Math.Round"};




// **************************************************************
// 
// Ops.Math.RoundEven
// 
// **************************************************************

Ops.Math.RoundEven = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNum = op.inValueFloat("Number"),
    inMode = op.inSwitch("Mode", ["Ceil", "Floor"], "Ceil"),
    result = op.outNumber("Result");

inMode.onChange = inNum.onChange = function ()
{
    let value = 0;
    switch (inMode.get())
    {
    case "Floor":
        value = 2 * (Math.floor(inNum.get() / 2.0));
        break;
    default:
    case "Ceil":
        value = 2 * (Math.round(inNum.get() / 2.0));
        break;
    }
    result.set(value);
};


};

Ops.Math.RoundEven.prototype = new CABLES.Op();
CABLES.OPS["b4c116ba-ab64-4903-80bb-35c8d65819a1"]={f:Ops.Math.RoundEven,objName:"Ops.Math.RoundEven"};




// **************************************************************
// 
// Ops.Math.SchlickBias
// 
// **************************************************************

Ops.Math.SchlickBias = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inX=op.inFloat("Value",0),
    inGain=op.inFloatSlider("Gain",0.5),
    inBias=op.inFloatSlider("Bias",0.5),
    result=op.outNumber("Result");

inX.onChange=
inBias.onChange=
inGain.onChange=getGain;

function getBias(x,bias)
{
    const r= x / ((1 / bias - 2) * (1 - x) + 1);
    return r;
}

function getGain()
{
    const gain=inGain.get();
    const x=inX.get();
    let r= x < 0.5 ? getBias(x * 2.0, gain)/2.0 : getBias(x * 2.0 - 1.0,1.0 - gain)/2.0 + 0.5;

    r=getBias(r,inBias.get());


    result.set(r);

}




};

Ops.Math.SchlickBias.prototype = new CABLES.Op();
CABLES.OPS["ea957aae-c9c7-4d2a-a227-c2a10042f554"]={f:Ops.Math.SchlickBias,objName:"Ops.Math.SchlickBias"};




// **************************************************************
// 
// Ops.Math.Sign
// 
// **************************************************************

Ops.Math.Sign = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inValue("Value"),
    noZeroIn = op.inBool("Remove zero", false),
    result = op.outNumber("Result");

value.onChange = function ()
{
    let direction = 0;
    let val = value.get() * 999;
    let noZero = noZeroIn.get();

    if (!noZero)
    {
        direction = Math.round(Math.max(Math.min(val, 1), -1));
    }
    else
    {
        direction = (val < 0) ? -1 : 1;
    }
    result.set(direction);
};


};

Ops.Math.Sign.prototype = new CABLES.Op();
CABLES.OPS["a0d6ed0e-9b6b-4d84-a599-882feeadd769"]={f:Ops.Math.Sign,objName:"Ops.Math.Sign"};




// **************************************************************
// 
// Ops.Math.SimpleMovingAverage
// 
// **************************************************************

Ops.Math.SimpleMovingAverage = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inValue("Value"),
    num = op.inValueInt("Number of Values", 10),
    result = op.outNumber("Result");

val.changeAlways = true;
let buffer = [];
let index = 0;

num.onChange = init;
init();

function init()
{
    let n = Math.abs(Math.floor(num.get()));
    buffer.length = n;

    for (let i = 0; i < buffer.length; i++)buffer[i] = null;
    index = 0;
}

val.onChange = function ()
{
    index++;
    if (index >= buffer.length)index = 0;
    buffer[index] = val.get();

    let avg = 0;
    let divide = 0;
    for (let i = 0; i < buffer.length; i++)
    {
        if (buffer[i] !== null) // ignore zeroes
        {
            avg += buffer[i];
            divide++;
        }
    }

    result.set(avg / divide || 1);
};


};

Ops.Math.SimpleMovingAverage.prototype = new CABLES.Op();
CABLES.OPS["b28c1e66-1c88-4394-bf73-327c0e82ea34"]={f:Ops.Math.SimpleMovingAverage,objName:"Ops.Math.SimpleMovingAverage"};




// **************************************************************
// 
// Ops.Math.Sine
// 
// **************************************************************

Ops.Math.Sine = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inValue("value"),
    phase = op.inValue("phase", 0.0),
    mul = op.inValue("frequency", 1.0),
    amplitude = op.inValue("amplitude", 1.0),
    invert = op.inValueBool("asine", false),
    result = op.outNumber("result");

let calculate = Math.sin;

mul.onChange =
amplitude.onChange =
phase.onChange =
value.onChange = function ()
{
    result.set(
        amplitude.get() * calculate((value.get() * mul.get()) + phase.get())
    );
};

invert.onChange = function ()
{
    if (invert.get()) calculate = Math.asin;
    else calculate = Math.sin;
};


};

Ops.Math.Sine.prototype = new CABLES.Op();
CABLES.OPS["d24da018-9f3d-428b-85c9-6ff14d77548b"]={f:Ops.Math.Sine,objName:"Ops.Math.Sine"};




// **************************************************************
// 
// Ops.Math.SmoothStep_v2
// 
// **************************************************************

Ops.Math.SmoothStep_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    result = op.outNumber("result"),
    number = op.inValueFloat("number", 0),
    min = op.inValueFloat("min", 0),
    max = op.inValueFloat("max", 1);

number.onChange = max.onChange = min.onChange = exec;
exec();

function exec()
{
    let x = Math.max(0, Math.min(1, (number.get() - min.get()) / (max.get() - min.get())));
    result.set(x * x * (3 - 2) * (max.get() - min.get())); // smoothstep
}


};

Ops.Math.SmoothStep_v2.prototype = new CABLES.Op();
CABLES.OPS["b5c41eea-ac30-4ac7-9481-eefe42e8199c"]={f:Ops.Math.SmoothStep_v2,objName:"Ops.Math.SmoothStep_v2"};




// **************************************************************
// 
// Ops.Math.SmootherStep
// 
// **************************************************************

Ops.Math.SmootherStep = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inValueFloat("val", 0),
    min = op.inValueFloat("min", 0),
    max = op.inValueFloat("max", 1),
    result = op.outNumber("result");

val.onChange = max.onChange = min.onChange = exec;
exec();

function exec()
{
    let x = Math.max(0, Math.min(1, (val.get() - min.get()) / (max.get() - min.get())));
    result.set(x * x * x * (x * (x * 6 - 15) + 10) * (max.get() - min.get())); // smootherstep
}


};

Ops.Math.SmootherStep.prototype = new CABLES.Op();
CABLES.OPS["c66da84f-ff2f-45de-b3c2-557bdf1cb946"]={f:Ops.Math.SmootherStep,objName:"Ops.Math.SmootherStep"};




// **************************************************************
// 
// Ops.Math.Speed
// 
// **************************************************************

Ops.Math.Speed = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExe = op.inTrigger("Update"),
    inVal = op.inValue("Value"),
    result = op.outNumber("Speed");

inVal.alwaysChange = true;

let lastVal = 0;
let lastTime = CABLES.now();
inExe.onTriggered = update;

function update()
{
    let diff = Math.abs(inVal.get() - lastVal);
    let diffTime = CABLES.now() - lastTime;

    let speed = diff * (1000 / diffTime);

    result.set(speed);

    lastVal = inVal.get();
    lastTime = CABLES.now();
}


};

Ops.Math.Speed.prototype = new CABLES.Op();
CABLES.OPS["ff6b8c7b-00c6-48f2-9b43-d059e52143fe"]={f:Ops.Math.Speed,objName:"Ops.Math.Speed"};




// **************************************************************
// 
// Ops.Math.Sqrt
// 
// **************************************************************

Ops.Math.Sqrt = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number = op.inValue("number"),
    result = op.outNumber("result");

number.onChange = function ()
{
    let r = Math.sqrt(number.get());
    if (isNaN(r))r = 0;
    result.set(r);
};


};

Ops.Math.Sqrt.prototype = new CABLES.Op();
CABLES.OPS["dec567c3-231d-4146-964d-891fde8924f1"]={f:Ops.Math.Sqrt,objName:"Ops.Math.Sqrt"};




// **************************************************************
// 
// Ops.Math.Subtract
// 
// **************************************************************

Ops.Math.Subtract = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number1 = op.inValue("number1", 1),
    number2 = op.inValue("number2", 1),
    result = op.outNumber("result");

op.setTitle("-");

number1.onChange =
    number2.onChange = exec;
exec();

function exec()
{
    let v = number1.get() - number2.get();
    if (!isNaN(v)) result.set(v);
}


};

Ops.Math.Subtract.prototype = new CABLES.Op();
CABLES.OPS["a4ffe852-d200-4b96-9347-68feb01122ca"]={f:Ops.Math.Subtract,objName:"Ops.Math.Subtract"};




// **************************************************************
// 
// Ops.Math.Sum
// 
// **************************************************************

Ops.Math.Sum = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    number1 = op.inValueFloat("number1", 1),
    number2 = op.inValueFloat("number2", 1),
    result = op.outNumber("result");

op.setTitle("+");

number1.onChange =
number2.onChange = exec;
exec();

function exec()
{
    const v = number1.get() + number2.get();
    if (!isNaN(v))
        result.set(v);
}


};

Ops.Math.Sum.prototype = new CABLES.Op();
CABLES.OPS["c8fb181e-0b03-4b41-9e55-06b6267bc634"]={f:Ops.Math.Sum,objName:"Ops.Math.Sum"};




// **************************************************************
// 
// Ops.Math.Tangent
// 
// **************************************************************

Ops.Math.Tangent = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inValue("Value"),
    phase = op.inValue("Phase", 0.0),
    mul = op.inValue("Frequency", 1.0),
    amplitude = op.inValue("Amplitude", 1.0),
    invert = op.inValueBool("asine", false),
    result = op.outNumber("Result");

let calculate = Math.tan;

value.onChange = function ()
{
    result.set(
        amplitude.get() * calculate((value.get() * mul.get()) + phase.get())
    );
};

invert.onChange = function ()
{
    if (invert.get()) calculate = Math.atan;
    else calculate = Math.tan;
};


};

Ops.Math.Tangent.prototype = new CABLES.Op();
CABLES.OPS["be52d1f0-1004-4161-9ba9-7921c38955c0"]={f:Ops.Math.Tangent,objName:"Ops.Math.Tangent"};




// **************************************************************
// 
// Ops.Math.TriggerMathExpression
// 
// **************************************************************

Ops.Math.TriggerMathExpression = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inExec = op.inTrigger("Calculate"),
    inExpression = op.inString("Expression", "x*(y+z)"),

    inX = op.inFloat("X", 0),
    inY = op.inFloat("Y", 0),
    inZ = op.inFloat("Z", 0),
    inW = op.inFloat("W", 0),

    inA = op.inFloat("A", 0),
    inB = op.inFloat("B", 0),
    inC = op.inFloat("C", 0),
    inD = op.inFloat("D", 0),

    inI = op.inFloat("I", 0),

    next = op.outTrigger("Next"),
    outResult = op.outNumber("Result"),
    outExpressionIsValid = op.outBool("Expression Valid");

op.setPortGroup("Parameters", [inA, inB, inC, inD, inX, inY, inZ, inW, inI]);

let currentFunction = inExpression.get();
let functionValid = false;

inExec.onTriggered = evaluateFunction;
inExpression.onChange = createFunction;

createFunction();

function createFunction()
{
    try
    {
        currentFunction = new Function("m", "a", "b", "c", "d", "x", "y", "z", "w", "i", "with(m) { return " + inExpression.get() + " }");

        functionValid = true;
        evaluateFunction();
        outExpressionIsValid.set(functionValid);
    }
    catch (e)
    {
        functionValid = false;
        outExpressionIsValid.set(functionValid);
        if (e instanceof ReferenceError || e instanceof SyntaxError) return;
    }
}

function evaluateFunction()
{
    if (functionValid)
    {
        outResult.set(currentFunction(Math, inA.get(), inB.get(), inC.get(), inD.get(), inX.get(), inY.get(), inZ.get(), inW.get(), inI.get()));
        if (!inExpression.get()) outResult.set(0);
    }

    outExpressionIsValid.set(functionValid);
    next.trigger();
}


};

Ops.Math.TriggerMathExpression.prototype = new CABLES.Op();
CABLES.OPS["7ba04c59-5b31-44f9-bd15-865a6db67c81"]={f:Ops.Math.TriggerMathExpression,objName:"Ops.Math.TriggerMathExpression"};




// **************************************************************
// 
// Ops.Math.TriggerRandomNumber_v2
// 
// **************************************************************

Ops.Math.TriggerRandomNumber_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTriggerButton("Generate"),
    min = op.inValue("min", 0),
    max = op.inValue("max", 1),
    outTrig = op.outTrigger("next"),
    result = op.outNumber("result"),
    inInteger = op.inValueBool("Integer", false),
    noDupe = op.inValueBool("No consecutive duplicates", false);

op.setPortGroup("Value Range", [min, max]);

exe.onTriggered =
    max.onChange =
    min.onChange =
    inInteger.onChange = genRandom;

genRandom();

function genRandom()
{
    let r = (Math.random() * (max.get() - min.get())) + min.get();

    if (inInteger.get())r = randInt();

    if (min.get() != max.get() && max.get() > min.get())
        while (noDupe.get() && r == result.get()) r = randInt();

    result.set(r);
    outTrig.trigger();
}

function randInt()
{
    return Math.floor((Math.random() * ((max.get() - min.get() + 1))) + min.get());
}


};

Ops.Math.TriggerRandomNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["26f446cc-9107-4164-8209-5254487fa132"]={f:Ops.Math.TriggerRandomNumber_v2,objName:"Ops.Math.TriggerRandomNumber_v2"};




// **************************************************************
// 
// Ops.Math.VectorLength
// 
// **************************************************************

Ops.Math.VectorLength = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    x = op.inValue("X"),
    y = op.inValue("Y"),
    z = op.inValue("Z"),
    l = op.outNumber("Length");

x.onChange =
    y.onChange =
    z.onChange = update;

let vec = vec3.create();

function update()
{
    vec3.set(vec, x.get(), y.get(), z.get());
    l.set(vec3.len(vec));
}


};

Ops.Math.VectorLength.prototype = new CABLES.Op();
CABLES.OPS["a9e7bda2-7f57-4df2-83e3-74cdf63371d7"]={f:Ops.Math.VectorLength,objName:"Ops.Math.VectorLength"};




// **************************************************************
// 
// Ops.Net.CorsProxy_v2
// 
// **************************************************************

Ops.Net.CorsProxy_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let a = op.inString("URL", "");
let result = op.outString("CORS URL");
let CORS_CABLES_PROXY = "https://cors.cables.gl/";

a.onChange = update;

update();

function update()
{
    result.set(CORS_CABLES_PROXY + a.get());
}


};

Ops.Net.CorsProxy_v2.prototype = new CABLES.Op();
CABLES.OPS["0cac2fb2-cac2-4b50-82c1-f7047ef96e0a"]={f:Ops.Net.CorsProxy_v2,objName:"Ops.Net.CorsProxy_v2"};




// **************************************************************
// 
// Ops.Net.WebSocket.WebSocketSend
// 
// **************************************************************

Ops.Net.WebSocket.WebSocketSend = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inConnection = op.inObject("Connection", null, "Websocket"),
    inObject = op.inObject("Object"),
    inSend = op.inTriggerButton("Send"),
    inStringify = op.inBool("Send String", true),
    outSent = op.outBoolNum("Sent");

let connection = null;

inConnection.onChange = function ()
{
    connection = inConnection.get();
};

inSend.onTriggered = function ()
{
    if (connection && inObject.get())
    {
        if (inStringify.get())connection.send(JSON.stringify(inObject.get()));
        else connection.send(inObject.get());

        outSent.set(true);
    }
    else
    {
        outSent.set(false);
    }
};


};

Ops.Net.WebSocket.WebSocketSend.prototype = new CABLES.Op();
CABLES.OPS["071149e8-5ac5-43dd-a052-e32dbd80cae2"]={f:Ops.Net.WebSocket.WebSocketSend,objName:"Ops.Net.WebSocket.WebSocketSend"};




// **************************************************************
// 
// Ops.Net.WebSocket.WebSocket_v2
// 
// **************************************************************

Ops.Net.WebSocket.WebSocket_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUrl = op.inString("URL"),
    outConnection = op.outObject("Connection", null, "Websocket"),
    outResult = op.outObject("Result"),
    outConnected = op.outBoolNum("Connected"),
    outValidJson = op.outBoolNum("Valid JSON"),
    outReceived = op.outTrigger("Received Data"),
    outRaw = op.outString("Raw Data");

let connection = null;
let timeout = null;
let connectedTo = "";

inUrl.onChange = connect;
timeout = setTimeout(checkConnection, 2000);

inUrl.set();

let connecting = false;

function checkConnection()
{
    if (!outConnected.get() && !connecting)
    {
        op.log("reconnect websocket...");
        connect();
    }

    timeout = setTimeout(checkConnection, 2000);
}

op.onDelete = function ()
{
    if (outConnected.get())connection.close();
    connecting = false;
    clearTimeout(timeout);
};

function connect()
{
    op.setUiError("connection", null);
    op.setUiError("jsonvalid", null);

    if (outConnected.get() && connectedTo == inUrl.get()) return;

    if (!inUrl.get() || inUrl.get() === "")
    {
        op.log("websocket: invalid url ");
        outConnected.set(false);
        return;
    }

    window.WebSocket = window.WebSocket || window.MozWebSocket;

    if (!window.WebSocket)
        op.logError("Sorry, but your browser doesn't support WebSockets.");

    try
    {
        connecting = true;
        if (connection !== null)connection.close();
        connection = new WebSocket(inUrl.get());
    }
    catch (e)
    {
        op.log("could not connect to", inUrl.get());
        connecting = false;
        op.log(e);
    }

    if (connection)
    {
        connection.onerror = function (message)
        {
            connecting = false;
            op.log("ws error");
            outConnected.set(false);
            outConnection.set(null);
            op.setUiError("connection", "Error connecting to websocket server", 2);
        };

        connection.onclose = function (message)
        {
            connecting = false;
            op.log("ws close");
            outConnected.set(false);
            outConnection.set(null);
        };

        connection.onopen = function (message)
        {
            connecting = false;
            outConnected.set(true);
            connectedTo = inUrl.get();
            outConnection.set(connection);
        };

        connection.onmessage = function (message)
        {
            op.setUiError("jsonvalid", null);
            outRaw.set(message.data);
            try
            {
                const json = JSON.parse(message.data);
                outResult.set(null);
                outResult.set(json);
                outValidJson.set(true);
            }
            catch (e)
            {
                op.log(e);
                op.log("This doesn't look like a valid JSON: ", message.data);
                op.setUiError("jsonvalid", "Received message was not valid JSON", 0);
                outValidJson.set(false);
            }
            outReceived.trigger();
        };
    }
}


};

Ops.Net.WebSocket.WebSocket_v2.prototype = new CABLES.Op();
CABLES.OPS["e747dc72-8214-41ca-9aae-9041f20dd6ac"]={f:Ops.Net.WebSocket.WebSocket_v2,objName:"Ops.Net.WebSocket.WebSocket_v2"};




// **************************************************************
// 
// Ops.Patch.CallBack_v2
// 
// **************************************************************

Ops.Patch.CallBack_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTriggerButton("exe");
const callbackname = op.inString("Callback Name", "myFunction");
const val0 = op.inString("Parameter 1", "");
const val1 = op.inString("Parameter 2", "");
const val2 = op.inString("Parameter 3", "");

let values = [0, 0, 0];

val0.onChange = function () { values[0] = val0.get(); };
val1.onChange = function () { values[1] = val1.get(); };
val2.onChange = function () { values[2] = val2.get(); };

exe.onTriggered = function ()
{
    if (op.patch.config.hasOwnProperty(callbackname.get()))
    {
        op.patch.config[callbackname.get()](values);
    }
    else
    {
        op.log("callback ", callbackname.get(), " not found! Parameters: ", values);
    }
};


};

Ops.Patch.CallBack_v2.prototype = new CABLES.Op();
CABLES.OPS["cfc87cb1-a74b-482f-9fad-e1777cb7ffd4"]={f:Ops.Patch.CallBack_v2,objName:"Ops.Patch.CallBack_v2"};




// **************************************************************
// 
// Ops.Patch.Function_v2
// 
// **************************************************************

Ops.Patch.Function_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    funcName = op.inString("Function Name", "default"),
    triggerButton = op.inTriggerButton("Trigger"),
    inString1 = op.inString("Default Parameter 1"),
    inString2 = op.inString("Default Parameter 2"),
    inString3 = op.inString("Default Parameter 3"),
    outTrigger = op.outTrigger("Next"),
    outString1 = op.outString("Parameter 1"),
    outString2 = op.outString("Parameter 2"),
    outString3 = op.outString("Parameter 3");

triggerButton.onTriggered = triggered;

funcName.onChange = function ()
{
    op.patch.config[funcName.get()] = triggered;
};

function triggered()
{
    const arg1 = arguments.hasOwnProperty(0) ? arguments[0] : inString1.get();
    const arg2 = arguments.hasOwnProperty(1) ? arguments[1] : inString2.get();
    const arg3 = arguments.hasOwnProperty(2) ? arguments[2] : inString3.get();
    outString1.set(arg1);
    outString2.set(arg2);
    outString3.set(arg3);
    outTrigger.trigger();
}


};

Ops.Patch.Function_v2.prototype = new CABLES.Op();
CABLES.OPS["39043a11-1ae0-4568-93a7-ec1493df2662"]={f:Ops.Patch.Function_v2,objName:"Ops.Patch.Function_v2"};




// **************************************************************
// 
// Ops.Patch.LoadingStatusTask
// 
// **************************************************************

Ops.Patch.LoadingStatusTask = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// vars
let stack = [];
let uuid = CABLES.uuid();

// inputs
let startPort = op.inTriggerButton("Start Task");
let stopPort = op.inTriggerButton("End Task");

// listeners
startPort.onTriggered = startTask;
stopPort.onTriggered = stopTask;

function startTask()
{
    let id = uuid + " (" + (stack.length + 1) + ")";
    let loadingId = op.patch.loading.start("task", id);
    if (CABLES.UI)
    {
        gui.jobs().start({ "id": loadingId, "title": "loading task " + id });
    }

    stack.push(loadingId);
}

function stopTask()
{
    let loadingId = stack.pop();
    op.patch.loading.finished(loadingId);
    if (CABLES.UI)
    {
        gui.jobs().finish(loadingId);
    }
}


};

Ops.Patch.LoadingStatusTask.prototype = new CABLES.Op();
CABLES.OPS["38d0f6ba-a4d8-4093-9cab-17e1b5dd52ae"]={f:Ops.Patch.LoadingStatusTask,objName:"Ops.Patch.LoadingStatusTask"};




// **************************************************************
// 
// Ops.Patch.LoadingStatus_v2
// 
// **************************************************************

Ops.Patch.LoadingStatus_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    preRenderOps = op.inValueBool("PreRender Ops"),
    startTimeLine = op.inBool("Play Timeline", true),

    next = op.outTrigger("Next"),
    outInitialFinished = op.outBool("Finished Initial Loading", false),
    outLoading = op.outBool("Loading"),
    outProgress = op.outNumber("Progress"),
    outList = op.outArray("Jobs"),
    loadingFinished = op.outTrigger("Trigger Loading Finished ");

const cgl = op.patch.cgl;
const patch = op.patch;

let finishedOnce = false;
const preRenderTimes = [];
let firstTime = true;

document.body.classList.add("cables-loading");

let loadingId = cgl.patch.loading.start("loadingStatusInit", "loadingStatusInit");

exe.onTriggered = () =>
{
    const jobs = op.patch.loading.getListJobs();
    outProgress.set(patch.loading.getProgress());

    let hasFinished = jobs.length === 0;
    const notFinished = !hasFinished;
    // outLoading.set(!hasFinished);

    if (notFinished)
    {
        outList.set(op.patch.loading.getListJobs());
    }

    if (notFinished)
    {
        if (firstTime)
        {
            if (preRenderOps.get()) op.patch.preRenderOps();
            op.patch.timer.setTime(0);
            if (startTimeLine.get())
            {
                op.patch.timer.play();
            }
            else
            {
                op.patch.timer.pause();
            }
        }
        firstTime = false;

        document.body.classList.remove("cables-loading");
        document.body.classList.add("cables-loaded");
    }
    else
    {
        finishedOnce = true;
        outList.set(op.patch.loading.getListJobs());

        if (patch.loading.getProgress() < 1.0)
        {
            op.patch.timer.setTime(0);
            op.patch.timer.pause();
        }
    }

    outInitialFinished.set(finishedOnce);

    if (outLoading.get() && hasFinished) loadingFinished.trigger();

    outLoading.set(notFinished);

    next.trigger();

    if (loadingId)
    {
        cgl.patch.loading.finished(loadingId);
        loadingId = null;
    }
};


};

Ops.Patch.LoadingStatus_v2.prototype = new CABLES.Op();
CABLES.OPS["e62f7f4c-7436-437e-8451-6bc3c28545f7"]={f:Ops.Patch.LoadingStatus_v2,objName:"Ops.Patch.LoadingStatus_v2"};




// **************************************************************
// 
// Ops.Patch.PlayButton
// 
// **************************************************************

Ops.Patch.PlayButton = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"inner_css":"\nborder-style:solid;\nborder-color:transparent transparent transparent #ccc;\nbox-sizing:border-box;\nwidth:50px;\nheight:50px;\nmargin-top:25px;\nmargin-left:36px;\nborder-width:25px 0px 25px 40px;\npointer-events:none;\n","outer_css":"width:100px;\nheight:100px;\nleft:50%;\ntop:50%;\nborder-radius:100%;\nposition:absolute;\ncursor:pointer;\nopacity:0.7;\ntransform:translate(-50%,-50%);\nz-index:999999;\nbackground-color:#333;\nborder:5px solid #333;",};
const
    inExec = op.inTrigger("Trigger"),
    inIfSuspended = op.inValueBool("Only if Audio Suspended"),
    inReset = op.inTriggerButton("Reset"),
    inStyleOuter = op.inStringEditor("Style Outer", attachments.outer_css),
    inStyleInner = op.inStringEditor("Style Inner", attachments.inner_css),
    inActive = op.inBool("Active", true),
    outNext = op.outTrigger("Next"),
    notClickedNext = op.outTrigger("Not Clicked"),
    outState = op.outString("Audiocontext State"),
    outEle = op.outObject("Element"),
    outClicked = op.outBoolNum("Clicked", false),
    outClickedTrigger = op.outTrigger("Clicked Trigger");

op.toWorkPortsNeedToBeLinked(inExec);
let audioCtx = CABLES.WEBAUDIO.createAudioContext(op);

const canvas = op.patch.cgl.canvas.parentElement;
let wasClicked = false;
let ele = null;
let elePlay = null;
createElements();

inStyleOuter.onChange =
    inStyleInner.onChange = createElements;

audioCtx.addEventListener("statechange", updateState);

inActive.onChange = () =>
{
    if (!inActive.get())ele.style.display = "none";
    else ele.style.display = "block";
};

function createElements()
{
    if (elePlay) elePlay.remove();
    if (ele) ele.remove();

    ele = document.createElement("div");
    ele.style = inStyleOuter.get();
    outEle.set(ele);

    canvas.appendChild(ele);

    elePlay = document.createElement("div");
    elePlay.style = inStyleInner.get();

    ele.appendChild(elePlay);
    ele.classList.add("playButton");

    ele.addEventListener("mouseenter", hover);
    ele.addEventListener("mouseleave", hoverOut);
    ele.addEventListener("click", clicked);
    ele.addEventListener("touchStart", clicked);
    op.onDelete = removeElements;
}

inReset.onTriggered = function ()
{
    createElements();
    wasClicked = false;
    outClicked.set(wasClicked);
};

function updateState()
{
    outState.set(audioCtx.state);
    if (inIfSuspended.get() && audioCtx.state == "running") clicked();
}

inExec.onTriggered = function ()
{
    if (wasClicked) outNext.trigger();
    else notClickedNext.trigger();
};

function clicked()
{
    removeElements();
    if (audioCtx && audioCtx.state == "suspended")audioCtx.resume();
    wasClicked = true;
    outClicked.set(wasClicked);
    outClickedTrigger.trigger();
}

function removeElements()
{
    if (elePlay) elePlay.remove();
    if (ele) ele.remove();
}

function hoverOut()
{
    if (ele) ele.style.opacity = 0.7;
}

function hover()
{
    if (ele) ele.style.opacity = 1.0;
}


};

Ops.Patch.PlayButton.prototype = new CABLES.Op();
CABLES.OPS["32e53fa2-4545-4c53-a94d-2204aa079246"]={f:Ops.Patch.PlayButton,objName:"Ops.Patch.PlayButton"};




// **************************************************************
// 
// Ops.Physics.Ammo.AmmoBody
// 
// **************************************************************

Ops.Physics.Ammo.AmmoBody = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// https://github.com/enable3d/enable3d/blob/master/packages/ammoPhysics/src/three-to-ammo.js

const
    inExec = op.inTrigger("Update"),
    inName = op.inString("Name", ""),
    inMass = op.inFloat("Mass", 0),
    inFriction = op.inFloat("Friction", 0.5),
    inRollingFriction = op.inFloat("Rolling Friction", 0.5),
    inRestitution = op.inFloat("Restitution", 0.5),

    inShape = op.inDropDown("Shape", ["Box", "Sphere", "Cylinder", "Capsule", "Cone", "Geom Convex Hull", "Triangle Shape"], "Box"),
    inGeom = op.inObject("Geometry", null, "geometry"),
    inGeomSimplify = op.inInt("Simplify Max Triangles", 50),
    inRadius = op.inFloat("Radius", 0.5),
    inSizeX = op.inFloat("Size X", 1),
    inSizeY = op.inFloat("Size Y", 1),
    inSizeZ = op.inFloat("Size Z", 1),

    inPositions = op.inArray("Positions", null, 3),
    inPosIndex = op.inBool("Append Index to name", true),

    inNeverDeactivate = op.inBool("Never Deactivate"),
    inGhostObject = op.inBool("Ghost Object"),
    inActive = op.inBool("Active", true),
    inReset = op.inTriggerButton("Reset"),
    inActivate = op.inTriggerButton("Activate"),

    next = op.outTrigger("next"),
    outRayHit = op.outBoolNum("Ray Hit"),
    transformed = op.outTrigger("Transformed");

op.setPortGroup("Array", [inPositions, inPosIndex]);

inExec.onTriggered = update;

const cgl = op.patch.cgl;
let bodies = [];
let world = null;
let tmpTrans = null;

const tmpOrigin = vec3.create();
const tmpQuat = quat.create();
const tmpScale = vec3.create();
let transMat = mat4.create();

let btOrigin = null;
let btQuat = null;
let doResetPos = false;
let colShape = null;

let doScale = true;
let needsRemove = false;
inName.onChange = updateBodyMeta;

op.setPortGroup("Parameters", [inRestitution, inFriction, inRollingFriction, inMass]);
op.setPortGroup("Shape", [inShape, inGeom, inGeomSimplify, inRadius, inSizeY, inSizeX, inSizeZ]);
op.setPortGroup("Flags", [inNeverDeactivate, inActive, inGhostObject]);

inExec.onLinkChanged =
    inFriction.onChange =
    inRestitution.onChange =
    inRollingFriction.onChange =
    inGeomSimplify.onChange =
    inGhostObject.onChange =
    inGeom.onChange =
    inShape.onChange =
    inMass.onChange =
    inRadius.onChange =
    inSizeY.onChange =
    inSizeZ.onChange =
    inPositions.onChange =
    inSizeX.onChange = () =>
    {
        needsRemove = true;
    };

inPosIndex.onChange = updateBodyMeta;
op.onDelete = removeBody;

inActive.onChange = () =>
{
    if (!inActive.get()) removeBody();
};

inActivate.onTriggered = () =>
{
    for (let i = 0; i < bodies.length; i++)
        bodies[i].activate();
};

function removeBody()
{
    if (world)
    {
        for (let i = 0; i < bodies.length; i++)
            world.removeRigidBody(bodies[i]);
    }

    bodies.length = 0;
}

inReset.onTriggered = () =>
{
    needsRemove = true;
};

function updateBodyMeta()
{
    const n = inName.get();
    const appendIndex = inPosIndex.get();
    const posArr = inPositions.get();

    if (world)
        for (let i = 0; i < bodies.length; i++)
        {
            let name = n;
            if (appendIndex && posArr)name = n + "." + i;

            world.setBodyMeta(bodies[i],
                {
                    "name": name,
                    "mass": inMass.get(),
                });
        }

    op.setUiAttribs({ "extendTitle": inName.get() });
}

function setup()
{
    if (!inActive.get()) return;
    doScale = true;

    removeBody();

    if (!tmpTrans)tmpTrans = new Ammo.btTransform();
    // if (!transform)transform = new Ammo.btTransform();

    if (colShape)Ammo.destroy(colShape);
    colShape = null;
    // transform.setIdentity();
    // CABLES.AmmoWorld.copyCglTransform(cgl, transform);

    op.setUiError("nogeom", null);
    if (inShape.get() == "Box") colShape = new Ammo.btBoxShape(new Ammo.btVector3(inSizeX.get() / 2, inSizeY.get() / 2, inSizeZ.get() / 2));
    else if (inShape.get() == "Sphere") colShape = new Ammo.btSphereShape(inRadius.get());
    else if (inShape.get() == "Cylinder") colShape = new Ammo.btCylinderShape(new Ammo.btVector3(inSizeX.get() / 2, inSizeY.get() / 2, inSizeZ.get() / 2));
    else if (inShape.get() == "Capsule") colShape = new Ammo.btCapsuleShape(inRadius.get(), inSizeY.get());
    else if (inShape.get() == "Cone") colShape = new Ammo.btConeShape(inRadius.get(), inSizeY.get());
    else if (inShape.get() == "Triangle Shape")
    {
        const geom = inGeom.get();
        if (!geom || !inGeom.isLinked())
        {
            op.setUiError("nogeom", "Shape needs geometry connected");
            return;
        }
        else op.setUiError("nogeom", null);
        if (!geom) return;

        let mesh = new Ammo.btTriangleMesh(true, true);

        for (let i = 0; i < geom.verticesIndices.length / 3; i++)
        {
            mesh.addTriangle(
                new Ammo.btVector3(
                    geom.vertices[geom.verticesIndices[i * 3] * 3 + 0],
                    geom.vertices[geom.verticesIndices[i * 3] * 3 + 1],
                    geom.vertices[geom.verticesIndices[i * 3] * 3 + 2]
                ),
                new Ammo.btVector3(
                    geom.vertices[geom.verticesIndices[i * 3 + 1] * 3 + 0],
                    geom.vertices[geom.verticesIndices[i * 3 + 1] * 3 + 1],
                    geom.vertices[geom.verticesIndices[i * 3 + 1] * 3 + 2]
                ),
                new Ammo.btVector3(
                    geom.vertices[geom.verticesIndices[i * 3 + 2] * 3 + 0],
                    geom.vertices[geom.verticesIndices[i * 3 + 2] * 3 + 1],
                    geom.vertices[geom.verticesIndices[i * 3 + 2] * 3 + 2]
                ),
                false);
        }

        colShape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
    }
    else if (inShape.get() == "Geom Convex Hull")
    {
        const geom = inGeom.get();
        if (!geom || !inGeom.isLinked())
        {
            op.setUiError("nogeom", "Shape needs geometry connected");
            return;
        }
        else op.setUiError("nogeom", null);
        if (!geom) return;

        colShape = CABLES.AmmoWorld.createConvexHullFromGeom(geom, inGeomSimplify.get());

        doScale = false;
    }
    else
    {
        inGeomSimplify.setUiAttribs({ "greyout": true });
        op.log("unknown shape type", inShape.get());
        return;
    }

    if (inShape.get() == "Geom Convex Hull")
    {
        inRadius.setUiAttribs({ "greyout": true });
        inSizeX.setUiAttribs({ "greyout": true });
        inSizeY.setUiAttribs({ "greyout": true });
        inSizeZ.setUiAttribs({ "greyout": true });
        inGeomSimplify.setUiAttribs({ "greyout": false });
    }
    else
    {
        inSizeX.setUiAttribs({ "greyout": inShape.get() == "Sphere" || inShape.get() == "Capsule" || inShape.get() == "Cone" });
        inSizeY.setUiAttribs({ "greyout": inShape.get() == "Sphere" });
        inSizeZ.setUiAttribs({ "greyout": inShape.get() == "Sphere" || inShape.get() == "Capsule" || inShape.get() == "Cone" });
        inRadius.setUiAttribs({ "greyout": inShape.get() == "Box" });
    }

    colShape.setMargin(0.05);

    let mass = inMass.get();
    let localInertia = new Ammo.btVector3(0, 0, 0);
    colShape.calculateLocalInertia(mass, localInertia);

    let num = 1;
    let posArr = null;
    if (inPositions.isLinked())
    {
        num = 0;
        posArr = inPositions.get();

        if (posArr && posArr.length)
        {
            num = Math.max(num, posArr.length / 3);
        }
    }

    for (let i = 0; i < num; i++)
    {
        let transform = new Ammo.btTransform();

        const motionState = new Ammo.btDefaultMotionState(transform);

        let rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, colShape, localInertia);
        const body = new Ammo.btRigidBody(rbInfo);
        world.addRigidBody(body);

        // 		CF_STATIC_OBJECT= 1,
        // 		CF_KINEMATIC_OBJECT= 2,
        // 		CF_NO_CONTACT_RESPONSE = 4,
        // 		CF_CUSTOM_MATERIAL_CALLBACK = 8,//this allows per-triangle material (friction/restitution)
        // 		CF_CHARACTER_OBJECT = 16,
        // 		CF_DISABLE_VISUALIZE_OBJECT = 32, //disable debug drawing
        // 		CF_DISABLE_SPU_COLLISION_PROCESSING = 64//disable parallel/SPU processing
        if (inGhostObject.get())
            body.setCollisionFlags(body.getCollisionFlags() | 4);

        bodies.push(body);
        // motionStates.push(motionState);
    }
    setPositions();

    world.on("rayCastHit", (name) =>
    {
        outRayHit.set(name == inName.get());
    });

    updateParams();
    updateBodyMeta();
}

function setPositions()
{
    let posArr = inPositions.get();

    for (let i = 0; i < bodies.length; i++)
    {
        bodies[i].getMotionState().getWorldTransform(tmpTrans);

        if (posArr)
        {
            cgl.pushModelMatrix();

            mat4.translate(cgl.mMatrix, cgl.mMatrix, [
                posArr[i * 3 + 0], posArr[i * 3 + 1], posArr[i * 3 + 2]]);
        }
        CABLES.AmmoWorld.copyCglTransform(cgl, tmpTrans);
        if (posArr)cgl.popModelMatrix();

        bodies[i].getMotionState().setWorldTransform(tmpTrans);
        bodies[i].setWorldTransform(tmpTrans);
    }
}

function updateParams()
{
    if (!world || bodies.length == 0) return;
    for (let i = 0; i < bodies.length; i++)
    {
        bodies[i].setFriction(inFriction.get());
        bodies[i].setRollingFriction(inRollingFriction.get());
        bodies[i].setRestitution(inRestitution.get());
    }
}

function renderTransformed()
{
    if (!bodies.length) return;
    if (!inActive.get()) return;

    ping();

    if (transformed.isLinked())
        for (let i = 0; i < bodies.length; i++)
        {
            const body = bodies[i];
            let ms = body.getMotionState();
            if (ms)
            {
                ms.getWorldTransform(tmpTrans);
                let p = tmpTrans.getOrigin();
                let q = tmpTrans.getRotation();

                cgl.pushModelMatrix();

                mat4.identity(cgl.mMatrix);

                let scale = [inSizeX.get(), inSizeY.get(), inSizeZ.get()];

                if (inShape.get() == "Sphere") scale = [inRadius.get() * 2, inRadius.get() * 2, inRadius.get() * 2];
                if (inShape.get() == "Cone") scale = [inRadius.get() * 2, inSizeY.get(), inRadius.get() * 2];
                // if (inShape.get() == "Cylinder") scale = [inRadius.get() * 2, inSizeY.get(), inRadius.get() * 2];
                if (inShape.get() == "Capsule") scale = [inRadius.get() * 2, inSizeY.get() * 2, inRadius.get() * 2];

                mat4.fromRotationTranslationScale(transMat, [q.x(), q.y(), q.z(), q.w()], [p.x(), p.y(), p.z()], scale);
                mat4.mul(cgl.mMatrix, cgl.mMatrix, transMat);

                transformed.trigger();

                cgl.popModelMatrix();
            }
        }
}

function ping()
{
    if (world)
        for (let i = 0; i < bodies.length; i++)
            world.pingBody(bodies[i]);
}

function update()
{
    if (world && bodies.length && bodies[0] && world.getBodyMeta(bodies[0]) == undefined)removeBody();
    if (needsRemove)
    {
        removeBody();
        needsRemove = false;
    }
    if (world != cgl.frameStore.ammoWorld) removeBody();

    world = cgl.frameStore.ammoWorld;
    if (!world)
    {
        outRayHit.set(false);
        return;
    }
    if (!bodies.length) setup(world);
    if (!bodies.length) return;
    if (bodies[0] && inNeverDeactivate.get()) bodies[0].activate(); // body.setActivationState(Ammo.DISABLE_DEACTIVATION); did not work.....

    if (inMass.get() == 0 || doResetPos)
    {
        setPositions();
        doResetPos = false;
    }

    renderTransformed();

    next.trigger();
}


};

Ops.Physics.Ammo.AmmoBody.prototype = new CABLES.Op();
CABLES.OPS["d9c57405-9cc0-475f-b81d-21401a7ab326"]={f:Ops.Physics.Ammo.AmmoBody,objName:"Ops.Physics.Ammo.AmmoBody"};




// **************************************************************
// 
// Ops.Physics.Ammo.AmmoBodyCollision
// 
// **************************************************************

Ops.Physics.Ammo.AmmoBodyCollision = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("update"),
    inName0 = op.inString("Name 1", ""),
    inName0Match = op.inSwitch("Match Name 1", ["exact", "start", "contain"], "exact"),
    inName1 = op.inString("Name 2", ""),
    inName1Match = op.inSwitch("Match Name 2", ["exact", "start", "contain"], "exact"),
    next = op.outTrigger("Next"),
    outColliding = op.outBoolNum("Colliding"),
    outNumCollisions = op.outNumber("Num Collisions"),
    outCollisions = op.outArray("Collisions");

let oldWorld = null;

exec.onTriggered = () =>
{
    const ammoWorld = op.patch.cgl.frameStore.ammoWorld;
    if (!ammoWorld) return;

    if (oldWorld != ammoWorld)
    {
        oldWorld = ammoWorld;
    }
    const match0 = inName0Match.get();
    const match1 = inName1Match.get();
    const name0 = inName0.get();
    const name1 = inName1.get();

    let filterFunc = (col) =>
    {
        let isColliding = false;
        let found = false;
        let otherName = "name1";
        if (match0 === "exact")
        {
            if (col.name0 === name0)
            {
                found = true;
            }
            else if (col.name1 === name0)
            {
                found = true;
                otherName = "name0";
            }
        }
        else if (match0 === "start")
        {
            if (col.name0.startsWith(name0))
            {
                found = true;
            }
            else if (col.name1.startsWith(name0))
            {
                found = true;
                otherName = "name0";
            }
        }
        else if (match0 === "contain")
        {
            if (col.name0.includes(inName0.get()))
            {
                found = true;
            }
            else if (col.name1.includes(inName0.get()))
            {
                found = true;
                otherName = "name0";
            }
        }
        if (found)
        {
            if (name1)
            {
                if (match1 === "exact")
                {
                    if (col[otherName] === name1) isColliding = true;
                }
                else if (match1 === "start")
                {
                    if (col[otherName].startsWith(name1)) isColliding = true;
                }
                else if (match1 === "contain")
                {
                    if (col[otherName].includes(name1)) isColliding = true;
                }
            }
            else
            {
                isColliding = true;
            }
        }
        return isColliding;
    };

    const allCols = ammoWorld.getCollisions();
    const cols = allCols.filter(filterFunc);
    outCollisions.set(cols);
    outNumCollisions.set(cols.length);
    outColliding.set(cols.length > 0);

    next.trigger();
};


};

Ops.Physics.Ammo.AmmoBodyCollision.prototype = new CABLES.Op();
CABLES.OPS["6fd02be3-0c73-4fbd-88a1-d60313ad5622"]={f:Ops.Physics.Ammo.AmmoBodyCollision,objName:"Ops.Physics.Ammo.AmmoBodyCollision"};




// **************************************************************
// 
// Ops.Physics.Ammo.AmmoCharacter
// 
// **************************************************************

Ops.Physics.Ammo.AmmoCharacter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Update"),
    inRadius = op.inFloat("Radius", 1),
    inStyle = op.inSwitch("View", ["3rd Person", "1st Person"], "3rd Person"),
    // inSizeX = op.inFloat("Size X", 1),
    inSizeY = op.inFloat("Height", 2.04),
    // inSizeZ = op.inFloat("Size Z", 1),
    inMass = op.inFloat("Mass", 0),
    inName = op.inString("Name", ""),
    inActivate = op.inTriggerButton("Activate"),

    inMoveXP = op.inBool("Move X+", false),
    inMoveXM = op.inBool("Move X-", false),
    inMoveYP = op.inBool("Move Y+", false),
    inMoveYM = op.inBool("Move Y-", false),
    inMoveZP = op.inBool("Move Z+", false),
    inMoveZM = op.inBool("Move Z-", false),

    inDirX = op.inFloat("Dir X"),
    inDirY = op.inFloat("Dir Y"),
    inDirZ = op.inFloat("Dir Z"),

    inResetX = op.inFloat("Set Pos X"),
    inResetY = op.inFloat("Set Pos Y"),
    inResetZ = op.inFloat("Set Pos Z"),
    // inSetPos = op.inTriggerButton("Set Pos"),
    inReset = op.inTriggerButton("Reset"),

    inSpeed = op.inFloat("Speed", 1),
    inFallVelocity = op.inFloat("Add Velocity Y", 0.5),

    next = op.outTrigger("next"),
    outX = op.outNumber("Position X"),
    outY = op.outNumber("Position Y"),
    outZ = op.outNumber("Position Z"),
    transformed = op.outTrigger("Transformed");

inExec.onTriggered = update;

op.setPortGroup("Reset", [inResetX, inResetY, inResetZ, inReset]);

const cgl = op.patch.cgl;
let body = null;
let world = null;
let tmpTrans = null;
let transform = null;
let motionState = null;
const tmpOrigin = vec3.create();
const tmpQuat = quat.create();
const tmpScale = vec3.create();
let transMat = mat4.create();

let forceQuat = null;
let initX = 0, initY = 0, initZ = 0;

let btOrigin = null;
let btQuat = null;
let doResetPos = false;

inName.onChange = updateBodyMeta;

op.onDelete =
    inMass.onChange =
    inRadius.onChange =
    inSizeY.onChange = () =>
    {
        removeBody();
    };

inActivate.onTriggered = () =>
{
    if (body)body.activate();
};

function removeBody()
{
    if (world && body) world.removeRigidBody(body);
    body = null;
}

inReset.onTriggered = () =>
{
    initX = inResetX.get();
    initY = inResetY.get();
    initZ = inResetZ.get();

    removeBody();
};

let btVelocity = null;

function updateBodyMeta()
{
    if (world)
        world.setBodyMeta(body,
            {
                "name": inName.get(),
                "mass": inMass.get(),
            });

    op.setUiAttribs({ "extendTitle": inName.get() });
}

function setup()
{
    if (world && body) world.removeRigidBody(body);

    tmpTrans = new Ammo.btTransform();
    transform = new Ammo.btTransform();

    transform.setIdentity();

    copyCglTransform(transform);

    motionState = new Ammo.btDefaultMotionState(transform);

    let colShape = new Ammo.btCapsuleShape(inRadius.get(), inSizeY.get() - inRadius.get());

    colShape.setMargin(0.05);

    let localInertia = new Ammo.btVector3(0, 0, 0);
    colShape.calculateLocalInertia(inMass.get(), localInertia);

    let rbInfo = new Ammo.btRigidBodyConstructionInfo(inMass.get(), motionState, colShape, localInertia);
    body = new Ammo.btRigidBody(rbInfo);
    // body.setDamping(0.7, 0.01);

    world.addRigidBody(body);

    updateBodyMeta();
}

function renderTransformed()
{
    let ms = body.getMotionState();
    if (ms)
    {
        ms.getWorldTransform(tmpTrans);
        let p = tmpTrans.getOrigin();
        let q = tmpTrans.getRotation();

        if (inStyle.get() == "3rd Person")
            q.setValue(tmpQuat[0], tmpQuat[1], tmpQuat[2], tmpQuat[3]);

        cgl.pushModelMatrix();

        mat4.identity(cgl.mMatrix);

        let scale = [inRadius.get(), inRadius.get(), inRadius.get()];

        mat4.fromRotationTranslationScale(transMat, [q.x(), q.y(), q.z(), q.w()], [
            p.x(), p.y(), p.z()], scale);
        mat4.mul(cgl.mMatrix, cgl.mMatrix, transMat);

        transformed.trigger();

        cgl.popModelMatrix();
    }
}

function copyCglTransform(transform)
{
    if (!btOrigin)
    {
        btOrigin = new Ammo.btVector3(0, 0, 0);
        btQuat = new Ammo.btQuaternion(0, 0, 0, 0);
    }
    mat4.getTranslation(tmpOrigin, cgl.mMatrix);
    mat4.getRotation(tmpQuat, cgl.mMatrix);

    let changed = false;

    btOrigin.setValue(tmpOrigin[0], tmpOrigin[1], tmpOrigin[2]);
    btOrigin = new Ammo.btVector3(initX, initY, initZ);
    btQuat.setValue(tmpQuat[0], tmpQuat[1], tmpQuat[2], tmpQuat[3]);

    transform.setOrigin(btOrigin);
    transform.setRotation(btQuat);
}

function update()
{
    if (world != cgl.frameStore.ammoWorld) removeBody();

    world = cgl.frameStore.ammoWorld;
    if (!world) return;
    if (!body) setup(world);
    if (!body) return;
    body.activate(); // body.setActivationState(Ammo.DISABLE_DEACTIVATION); did not work.....

    if (!btVelocity)
    {
        btVelocity = new Ammo.btVector3(0, 0, 0);
    }

    let vx = 0, vy = 0, vz = 0.0;
    let speed = inSpeed.get();

    let doMove = false;
    if (inMoveZP.get())
    {
        vx = inDirX.get() * speed;
        vy = inDirY.get() * speed;
        vz = inDirZ.get() * speed;
        doMove = true;
    }
    if (inMoveZM.get())
    {
        vx = -inDirX.get() * speed;
        vy = -inDirY.get() * speed;
        vz = -inDirZ.get() * speed;
        doMove = true;
    }

    if (inMoveXP.get())
    {
        vx = -inDirZ.get() * speed;
        vy = inDirY.get() * speed;
        vz = inDirX.get() * speed;
        doMove = true;
    }
    if (inMoveXM.get())
    {
        vx = inDirZ.get() * speed;
        vy = inDirY.get() * speed;
        vz = -inDirX.get() * speed;
        doMove = true;
    }

    if (inMoveYP.get()) vy = 3;
    else vy = 0;

    doMove = true;

    if (doMove)
    {
        btVelocity.setValue(vx, vy - inFallVelocity.get(), vz);
        body.setLinearVelocity(btVelocity);
    }

    if (inMass.get() == 0 || doResetPos)
    {
        copyCglTransform(transform);
        motionState.setWorldTransform(transform);

        body.setWorldTransform(transform);

        doResetPos = false;
    }

    motionState.getWorldTransform(transform);

    // force upright position
    if (!forceQuat) forceQuat = new Ammo.btQuaternion();
    forceQuat.setEulerZYX(0, 90, 0);
    transform.setRotation(forceQuat);
    body.setWorldTransform(transform);
    let p = tmpTrans.getOrigin();

    outX.set(p.x());
    outY.set(p.y());
    outZ.set(p.z());

    renderTransformed();

    next.trigger();
}


};

Ops.Physics.Ammo.AmmoCharacter.prototype = new CABLES.Op();
CABLES.OPS["5f6c2a84-8de9-41e5-948a-d9c5ed49022f"]={f:Ops.Physics.Ammo.AmmoCharacter,objName:"Ops.Physics.Ammo.AmmoCharacter"};




// **************************************************************
// 
// Ops.Physics.Ammo.AmmoCharacterFpsCamera
// 
// **************************************************************

Ops.Physics.Ammo.AmmoCharacterFpsCamera = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    render = op.inTrigger("render"),
    enablePointerLock = op.inBool("Enable pointer lock", true),
    trigger = op.outTrigger("trigger"),
    isLocked = op.outBoolNum("isLocked", false),
    inHeight = op.inFloat("Height", 2),
    inName = op.inString("Character Name", "player1"),
    mouseSpeed = op.inFloat("Mouse Speed", 1),
    inActive = op.inBool("Active", true),
    outMouseDown = op.outTrigger("Mouse Left"),
    outMouseDownRight = op.outTrigger("Mouse Right"),
    outDirX = op.outNumber("Dir X"),
    outDirY = op.outNumber("Dir Y"),
    outDirZ = op.outNumber("Dir Z"),
    outRotX = op.outNumber("Rot X"),
    outRotY = op.outNumber("Rot Y");

op.toWorkPortsNeedToBeLinked(render);

const cgl = op.patch.cgl;
const viewMatrix = mat4.create();
const vPos = vec3.create();
let speedx = 0, speedy = 0, speedz = 0;
const movementSpeedFactor = 0.5;
const canvas = document.getElementById("glcanvas");
const DEG2RAD = 3.14159 / 180.0;
let rotX = 0;
let rotY = 0;
let lastMove = 0;
let mouseNoPL = { "firstMove": true,
    "deltaX": 0,
    "deltaY": 0,
};

initListener();

enablePointerLock.onChange = initListener;

inActive.onChange = () =>
{
    document.exitPointerLock();
    removeListener();

    lockChangeCallback();

    if (inActive.get()) initListener();
};

let tmpTrans = null;

render.onTriggered = function ()
{
    if (!Ammo) return;
    if (!inActive.get()) return trigger.trigger();
    if (!tmpTrans) tmpTrans = new Ammo.btTransform();

    if (cgl.frameStore.shadowPass) return trigger.trigger();

    cgl.pushViewMatrix();

    const ammoWorld = cgl.frameStore.ammoWorld;

    if (!ammoWorld)
    {
        op.log("char no ammoworld");
        return;
    }

    const body = ammoWorld.getBodyByName(inName.get());

    if (body)
    {
        let ms = body.getMotionState();
        ms.getWorldTransform(tmpTrans);
        let p = tmpTrans.getOrigin();
        vec3.set(vPos, -p.x(), -p.y() - inHeight.get(), -p.z());
    }
    else
    {
        op.log("char body not found!");
    }

    if (rotX < -90)rotX = -90;
    if (rotX > 90)rotX = 90;

    mat4.identity(cgl.vMatrix);

    mat4.rotateX(cgl.vMatrix, cgl.vMatrix, DEG2RAD * rotX);
    mat4.rotateY(cgl.vMatrix, cgl.vMatrix, DEG2RAD * rotY);

    mat4.translate(cgl.vMatrix, cgl.vMatrix, vPos);

    trigger.trigger();
    cgl.popViewMatrix();

    outRotX.set(rotX);
    outRotY.set(rotY);

    // for dir vec
    mat4.identity(viewMatrix);
    mat4.rotateX(viewMatrix, viewMatrix, DEG2RAD * rotX);
    mat4.rotateY(viewMatrix, viewMatrix, DEG2RAD * rotY);
    mat4.transpose(viewMatrix, viewMatrix);

    const dir = vec4.create();
    vec4.transformMat4(dir, [0, 0, 1, 1], viewMatrix);

    vec4.normalize(dir, dir);
    outDirX.set(-dir[0]);
    outDirY.set(-dir[1]);
    outDirZ.set(-dir[2]);
};

function moveCallback(e)
{
    const mouseSensitivity = 0.1;
    rotX += e.movementY * mouseSensitivity * mouseSpeed.get();
    rotY += e.movementX * mouseSensitivity * mouseSpeed.get();

    if (rotX < -90.0) rotX = -90.0;
    if (rotX > 90.0) rotX = 90.0;
    if (rotY < -180.0) rotY += 360.0;
    if (rotY > 180.0) rotY -= 360.0;
}

function mouseDown(e)
{
    if (e.which == 3) outMouseDownRight.trigger();
    else outMouseDown.trigger();
}

function lockChangeCallback(e)
{
    if (document.pointerLockElement === canvas ||
            document.mozPointerLockElement === canvas ||
            document.webkitPointerLockElement === canvas)
    {
        document.addEventListener("pointerdown", mouseDown, false);
        document.addEventListener("pointermove", moveCallback, false);
        isLocked.set(true);
    }
    else
    {
        document.removeEventListener("pointerdown", mouseDown, false);
        document.removeEventListener("pointermove", moveCallback, false);
        isLocked.set(false);
    }
}

function startPointerLock(e)
{
    const test = false;

    if (render.isLinked() && enablePointerLock.get() && e.buttons == 1)
    {
        document.addEventListener("pointermove", moveCallback, false);
        canvas.requestPointerLock = canvas.requestPointerLock ||
                                    canvas.mozRequestPointerLock ||
                                    canvas.webkitRequestPointerLock;
        canvas.requestPointerLock();
    }
}

function removeListener()
{
    cgl.canvas.removeEventListener("pointermove", moveCallbackNoPL, false);
    cgl.canvas.removeEventListener("pointerup", upCallbackNoPL, false);

    document.removeEventListener("pointerlockchange", lockChangeCallback, false);
    document.removeEventListener("mozpointerlockchange", lockChangeCallback, false);
    document.removeEventListener("webkitpointerlockchange", lockChangeCallback, false);
    document.getElementById("glcanvas").removeEventListener("mousedown", startPointerLock);
}

function initListener()
{
    if (enablePointerLock.get())
    {
        document.addEventListener("pointerlockchange", lockChangeCallback, false);
        document.addEventListener("mozpointerlockchange", lockChangeCallback, false);
        document.addEventListener("webkitpointerlockchange", lockChangeCallback, false);
        document.getElementById("glcanvas").addEventListener("mousedown", startPointerLock);

        cgl.canvas.removeEventListener("pointermove", moveCallbackNoPL, false);
        cgl.canvas.removeEventListener("pointerup", upCallbackNoPL, false);
    }
    else
    {
        cgl.canvas.addEventListener("pointermove", moveCallbackNoPL, false);
        cgl.canvas.addEventListener("pointerup", upCallbackNoPL, false);
    }
}

function upCallbackNoPL(e)
{
    try { cgl.canvas.releasePointerCapture(e.pointerId); }
    catch (e) {}
    mouseNoPL.firstMove = true;
}

function moveCallbackNoPL(e)
{
    if (e && e.buttons == 1)
    {
        try { cgl.canvas.setPointerCapture(e.pointerId); }
        catch (_e) {}

        if (!mouseNoPL.firstMove)
        {
            const deltaX = (e.clientX - mouseNoPL.lastX) * mouseSpeed.get() * 0.5;
            const deltaY = (e.clientY - mouseNoPL.lastY) * mouseSpeed.get() * 0.5;

            rotX += deltaY;
            rotY += deltaX;
        }

        mouseNoPL.firstMove = false;
        mouseNoPL.lastX = e.clientX;
        mouseNoPL.lastY = e.clientY;
    }
}


};

Ops.Physics.Ammo.AmmoCharacterFpsCamera.prototype = new CABLES.Op();
CABLES.OPS["0dca47aa-09e4-4b5d-b0d8-22390a950293"]={f:Ops.Physics.Ammo.AmmoCharacterFpsCamera,objName:"Ops.Physics.Ammo.AmmoCharacterFpsCamera"};




// **************************************************************
// 
// Ops.Physics.Ammo.AmmoDebugRenderer
// 
// **************************************************************

Ops.Physics.Ammo.AmmoDebugRenderer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inRender = op.inTrigger("Render"),
    inDrawWireframe = op.inBool("Draw Wireframe", true),
    inDrawAABB = op.inBool("Draw AABB", false),
    inDrawContacts = op.inBool("Draw Contact Points", true),
    inIgnClear = op.inBool("Depth", true),

    inActive = op.inBool("Active", true),

    outNext = op.outTrigger("Next");

op.setPortGroup("Options", [inDrawContacts, inDrawWireframe, inDrawAABB, inIgnClear]);

const cgl = op.patch.cgl;

let debugDrawer = null;
let oldWorld = null;

inRender.onTriggered = () =>
{
    if (cgl.frameStore.shadowPass) return outNext.trigger();

    const ammoWorld = cgl.frameStore.ammoWorld;
    if (!ammoWorld) return;

    if (!debugDrawer || oldWorld != ammoWorld.world)
    {
        debugDrawer = new CABLES.AmmoDebugDrawer(ammoWorld.world, { });
        debugDrawer.enable();
        oldWorld = ammoWorld.world;
    }

    if (!inActive.get())
    {
        outNext.trigger();
        return;
    }

    if (!ammoWorld) return;

    let debugmode = 0;
    if (inDrawWireframe.get())debugmode |= 1;
    if (inDrawAABB.get())debugmode |= 2;
    if (inDrawContacts.get())debugmode |= 8;

    outNext.trigger();

    debugmode |= 16384;

    if (debugmode)
    {
        cgl.pushModelMatrix();
        cgl.pushDepthTest(inIgnClear.get());
        cgl.pushDepthWrite(inIgnClear.get());

        mat4.identity(cgl.mMatrix);

        debugDrawer.setDebugMode(debugmode);
        debugDrawer.update();
        debugDrawer.render(cgl);
        // outPoints.set(debugDrawer.verts);

        cgl.popDepthTest();
        cgl.popDepthWrite();
        cgl.popModelMatrix();
    }
};


};

Ops.Physics.Ammo.AmmoDebugRenderer.prototype = new CABLES.Op();
CABLES.OPS["e4b4f6c9-483b-486e-abbc-fbc4254a65d1"]={f:Ops.Physics.Ammo.AmmoDebugRenderer,objName:"Ops.Physics.Ammo.AmmoDebugRenderer"};




// **************************************************************
// 
// Ops.Physics.Ammo.AmmoEmitter
// 
// **************************************************************

Ops.Physics.Ammo.AmmoEmitter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Exec"),
    inLimit = op.inInt("Limit Bodies", 10),

    inRadius = op.inFloat("Radius", 1),
    inMass = op.inFloat("Mass", 1),
    inNameIndex = op.inBool("Add index to name", true),

    inName = op.inString("Name", "emitterBody"),

    inFriction = op.inFloat("Friction", 0.5),
    inRollingFriction = op.inFloat("Rolling Friction", 0.5),
    inRestitution = op.inFloat("Restitution", 0.5),

    inDirX = op.inFloat("Dir X"),
    inDirY = op.inFloat("Dir Y"),
    inDirZ = op.inFloat("Dir Z"),
    inSpeed = op.inFloat("Speed"),

    inSpawn = op.inTriggerButton("Spawn One"),
    inRemove = op.inTriggerButton("Remove All"),
    inActivate = op.inTriggerButton("Activate All"),
    inRemoveFalling = op.inBool("Remove Y<-100", true),
    // inLifeTime=op.inFloat("Lifetime",0),

    next = op.outTrigger("Next"),
    outNum = op.outNumber("Total Bodies"),
    outPos = op.outArray("Positions", 3),
    outRot = op.outArray("Rotations Quats", 4);

let shouldspawnOne = false;
inSpawn.onTriggered = () => { shouldspawnOne = true; };

const bodies = [];
const cgl = op.patch.cgl;

let countAll = 0;
let world = null;
let tmpTrans = null;
let btVelocity = null;

inRemove.onTriggered = removeAll;

inExec.onLinkChanged =
inNameIndex.onChange =
    op.onDelete = removeAll;

inName.onChange = () => { op.setUiAttribs({ "extendTitle": inName.get() }); };

function removeAll()
{
    for (let i = 0; i < bodies.length; i++)
    {
        world.removeRigidBody(bodies[i].body);
    }

    outPos.set(null);
    outRot.set(null);

    bodies.length = 0;
}

inActivate.onTriggered = () =>
{
    for (let i = 0; i < bodies.length; i++) bodies[i].body.activate();
};

function setArrayTransformed(body, i, arrPos)
{
    if (!body) return;
    let ms = body.ms;
    if (ms)
    {
        ms.getWorldTransform(tmpTrans);
        let p = tmpTrans.getOrigin();
        let q = tmpTrans.getRotation();

        // cgl.pushModelMatrix();

        // mat4.identity(cgl.mMatrix);

        // let scale = [inSizeX.get(), inSizeY.get(), inSizeZ.get()];

        // if (inShape.get() == "Sphere") scale = [inRadius.get() * 2, inRadius.get() * 2, inRadius.get() * 2];
        // if (inShape.get() == "Cone") scale = [inRadius.get() * 2, inSizeY.get(), inRadius.get() * 2];
        // if (inShape.get() == "Cylinder") scale = [inRadius.get() * 2, inSizeY.get(), inRadius.get() * 2];
        // if (inShape.get() == "Capsule") scale = [inRadius.get() * 2, inSizeY.get() * 2, inRadius.get() * 2];

        arrPos[i * 3] = p.x();
        arrPos[i * 3 + 1] = p.y();
        arrPos[i * 3 + 2] = p.z();

        arrRot[i * 4] = q.x();
        arrRot[i * 4 + 1] = q.y();
        arrRot[i * 4 + 2] = q.z();
        arrRot[i * 4 + 3] = q.w();

        // mat4.fromRotationTranslationScale(transMat, [q.x(), q.y(), q.z(), q.w()], [p.x(), p.y(), p.z()], scale);
        // mat4.mul(cgl.mMatrix, cgl.mMatrix, transMat);

        // transformed.trigger();

        // cgl.popModelMatrix();
    }
}

function spawn()
{
    if (!world) return;
    if (!tmpTrans) tmpTrans = new Ammo.btTransform();

    let transform = null;
    let colShape = new Ammo.btSphereShape(inRadius.get());

    colShape.setMargin(0.05);

    let localInertia = new Ammo.btVector3(0, 0, 0);
    colShape.calculateLocalInertia(inMass.get(), localInertia);

    transform = new Ammo.btTransform();
    transform.setIdentity();

    CABLES.AmmoWorld.copyCglTransform(cgl, transform);

    let motionState = new Ammo.btDefaultMotionState(transform);

    let rbInfo = new Ammo.btRigidBodyConstructionInfo(inMass.get(), motionState, colShape, localInertia);
    let body = new Ammo.btRigidBody(rbInfo);

    body.setFriction(inFriction.get());
    body.setRollingFriction(inRollingFriction.get());
    body.setRestitution(inRestitution.get());

    let speed = inSpeed.get();
    let vx = inDirX.get() * speed;
    let vy = inDirY.get() * speed;
    let vz = inDirZ.get() * speed;

    if (!btVelocity) btVelocity = new Ammo.btVector3(0, 0, 0);

    btVelocity.setValue(vx, vy, vz);
    body.setLinearVelocity(btVelocity);

    world.addRigidBody(body);

    let name = inName.get() + "_" + countAll;
    if (!inNameIndex.get())name = inName.get();

    world.setBodyMeta(body,
        {
            "name": name
        });

    motionState.setWorldTransform(transform);
    body.setWorldTransform(transform);

    if (bodies.length >= inLimit.get())
    {
        world.removeRigidBody(bodies[0].body);
        bodies.shift();
    }

    bodies.push({ "body": body, "ms": motionState });

    countAll++;

    outNum.set(bodies.length);

    shouldspawnOne = false;
}

function dispose()
{
    for (let i = 0; i < bodies.length; i++)
    {
        world.removeRigidBody(bodies[i].body);
    }

    bodies.length = 0;
}

let arrPos = [];
let arrRot = [];

inExec.onTriggered = () =>
{
    if (shouldspawnOne) spawn();
    if (world != cgl.frameStore.ammoWorld)
    {
        world = cgl.frameStore.ammoWorld;
        world.on("dispose", dispose);
    }

    if (inRemoveFalling.get())
    {
        for (let i = 0; i < bodies.length; i++)
            if (bodies[i])
            {
                bodies[i].ms.getWorldTransform(tmpTrans);
                let p = tmpTrans.getOrigin();
                if (p.y() < -100)bodies.splice(i, 1);
            }
    }

    arrPos.length = bodies.length * 3;
    arrRot.length = bodies.length * 4;
    for (let i = 0; i < bodies.length; i++)
    {
        if (!bodies[i]) continue;
        setArrayTransformed(bodies[i], i, arrPos);
    }
    outPos.set(null);
    outPos.set(arrPos);
    outRot.set(null);
    outRot.set(arrRot);

    next.trigger();
};


};

Ops.Physics.Ammo.AmmoEmitter.prototype = new CABLES.Op();
CABLES.OPS["0c568898-f2e0-47b3-b44f-5d0e7c2cda57"]={f:Ops.Physics.Ammo.AmmoEmitter,objName:"Ops.Physics.Ammo.AmmoEmitter"};




// **************************************************************
// 
// Ops.Physics.Ammo.AmmoRaycast
// 
// **************************************************************

Ops.Physics.Ammo.AmmoRaycast = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Update"),
    inCoords = op.inSwitch("Ray Coordinates", ["Screen XY", "Points 3d"], "Screen XY"),
    inX = op.inValueFloat("Screen X"),
    inY = op.inValueFloat("Screen Y"),
    inRayPoints = op.inArray("Ray Points"),
    active = op.inBool("Active", true),
    inCursor = op.inBool("Change Cursor", true),
    next = op.outTrigger("next"),

    outHasHit = op.outBoolNum("Has Hit", false),
    outName = op.outString("Hit Body Name", ""),
    outX = op.outNumber("Hit X"),
    outY = op.outNumber("Hit Y"),
    outZ = op.outNumber("Hit Z");

inExec.onTriggered = update;

const cgl = op.patch.cgl;
let world = null;
let didsetCursor = false;
let mat = mat4.create();
let isScreenCoords = true;

inCoords.onChange = updateCoordsType;
updateCoordsType();

function updateCoordsType()
{
    isScreenCoords = inCoords.get() == "Screen XY";
    inX.setUiAttribs({ "greyout": !isScreenCoords });
    inY.setUiAttribs({ "greyout": !isScreenCoords });
    inRayPoints.setUiAttribs({ "greyout": isScreenCoords });
}

function update()
{
    world = cgl.frameStore.ammoWorld;

    // for(let i=0;i<world.bodies.length;i++)
    // console.log(world.bodies[i]);

    if (!world) return;

    if (active.get())
    {
        let afrom;
        let ato;

        if (isScreenCoords)
        {
            const x = inX.get();
            const y = inY.get();

            const origin = vec3.fromValues(x, y, -1);
            mat4.mul(mat, cgl.pMatrix, cgl.vMatrix);
            mat4.invert(mat, mat);

            vec3.transformMat4(origin, origin, mat);

            // -----------

            const to = vec3.fromValues(x, y, 1);
            mat4.mul(mat, cgl.pMatrix, cgl.vMatrix);
            mat4.invert(mat, mat);

            vec3.transformMat4(to, to, mat);

            afrom = new Ammo.btVector3(origin[0], origin[1], origin[2]);
            ato = new Ammo.btVector3(to[0], to[1], to[2]);
        }
        else
        {
            const arr = inRayPoints.get() || [0, 0, 0, 0, 0, 0];

            afrom = new Ammo.btVector3(arr[0], arr[1], arr[2]);
            ato = new Ammo.btVector3(arr[3], arr[4], arr[5]);
        }

        const rayCallback = new Ammo.ClosestRayResultCallback(afrom, ato);
        world.world.rayTest(afrom, ato, rayCallback);

        if (rayCallback.hasHit())
        {
            const meta = world.getBodyMeta(rayCallback.get_m_collisionObject());

            if (meta)
            {
                world.emitEvent("rayCastHit", meta.name);
                outName.set(meta.name);
            }

            outX.set(rayCallback.m_hitPointWorld.x());
            outY.set(rayCallback.m_hitPointWorld.y());
            outZ.set(rayCallback.m_hitPointWorld.z());
        }
        else
        {
            outX.set(0);
            outX.set(0);
            outX.set(0);

            world.emitEvent("rayCastHit", null);

            outName.set("");
        }
        outHasHit.set(rayCallback.hasHit());

        if (rayCallback.hasHit() && inCursor.get())
        {
            op.patch.cgl.setCursor("pointer");
            didsetCursor = true;
        }
        else if (didsetCursor)
        {
            op.patch.cgl.setCursor("auto");
            didsetCursor = false;
        }

        Ammo.destroy(rayCallback);
        if (afrom)Ammo.destroy(afrom);
        if (ato)Ammo.destroy(ato);
    }

    next.trigger();
}


};

Ops.Physics.Ammo.AmmoRaycast.prototype = new CABLES.Op();
CABLES.OPS["fa0418ee-ea51-446b-9be0-141f88d75e94"]={f:Ops.Physics.Ammo.AmmoRaycast,objName:"Ops.Physics.Ammo.AmmoRaycast"};




// **************************************************************
// 
// Ops.Physics.Ammo.AmmoWorld
// 
// **************************************************************

Ops.Physics.Ammo.AmmoWorld = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Update"),
    inSim = op.inBool("Simulate", true),
    inAutoRemove = op.inBool("Auto Remove Inactive", true),

    inGravX = op.inFloat("Gravity X", 0),
    inGravY = op.inFloat("Gravity Y", -9.81),
    inGravZ = op.inFloat("Gravity Z", 0),

    inActivateAll = op.inTriggerButton("Activate All"),
    inReset = op.inTriggerButton("Reset"),

    next = op.outTrigger("next"),
    outNumBodies = op.outNumber("Total Bodies"),
    outPoints = op.outArray("debug points"),
    outBodiesMeta = op.outArray("Bodies Meta"),
    outCollisions = op.outArray("Collisions");

op.setPortGroup("Gravity", [inGravX, inGravZ, inGravY]);

inExec.onTriggered = update;

const cgl = op.patch.cgl;
let deltaTime, lastTime;
let ammoWorld = null;// new CABLES.AmmoWorld();
let loadingId = null;
let needsReset = true;
inReset.onTriggered = () =>
{
    needsReset = true;
};

inActivateAll.onTriggered = () =>
{
    if (ammoWorld) ammoWorld.activateAllBodies();
};

inGravX.onChange = inGravZ.onChange = inGravY.onChange = updateGravity;

function updateGravity()
{
    if (ammoWorld && ammoWorld.world)
        ammoWorld.world.setGravity(new Ammo.btVector3(inGravX.get(), inGravY.get(), inGravZ.get()));
}

function update()
{
    if (needsReset)
    {
        if (ammoWorld)ammoWorld.dispose();
        ammoWorld = null;
        needsReset = false;
    }

    if (!ammoWorld)
    {
        if (Ammo.cablesSetupDone)
        {
            ammoWorld = new CABLES.AmmoWorld();
            updateGravity();
            cgl.patch.loading.finished(loadingId);
            loadingId = null;
        }
        else
        {
            if (!loadingId) loadingId = cgl.patch.loading.start("ammoWorld", "ammoWASM");
            return;
        }
    }
    if (!ammoWorld.world) return;

    deltaTime = performance.now() - lastTime;

    if (inSim.get()) ammoWorld.frame();

    const old = cgl.frameStore.ammoWorld;
    cgl.frameStore.ammoWorld = ammoWorld;

    outNumBodies.set(ammoWorld.numBodies());
    outBodiesMeta.set(ammoWorld.getListBodies());
    outCollisions.set(ammoWorld.getCollisions());

    ammoWorld.autoRemove = inAutoRemove.get();

    next.trigger();

    lastTime = performance.now();
    cgl.frameStore.ammoWorld = old;
}


};

Ops.Physics.Ammo.AmmoWorld.prototype = new CABLES.Op();
CABLES.OPS["1005fcd0-5f40-49c5-8d46-45e95fcecf37"]={f:Ops.Physics.Ammo.AmmoWorld,objName:"Ops.Physics.Ammo.AmmoWorld"};




// **************************************************************
// 
// Ops.Physics.Ammo.GltfAmmoBodies
// 
// **************************************************************

Ops.Physics.Ammo.GltfAmmoBodies = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExec = op.inTrigger("Exec"),
    inShape = op.inSwitch("Shape", ["Convex Hull", "Triangle Shape"], "Convex Hull"),
    inNames = op.inString("Filter Meshes", ""),
    inMass = op.inFloat("Mass kg", 0),

    inActive = op.inBool("Active", true),
    outNum = op.outNumber("Meshes", 0);

const cgl = op.patch.cgl;
const bodies = [];
const vec = vec3.create();
const empty = vec3.create();
const trMat = mat4.create();
const size = 1.0;

let world = null;
let scene = null;
let added = false;
let currentSceneLoaded = 0;

inExec.onTriggered = update;

const SHAPE_BOX = 0;
const SHAPE_SPHERE = 1;
const shape = SHAPE_BOX;
const sizeVec = vec3.create();

const meshCube = new CGL.WireCube(cgl);

let tmpTrans = null;

inMass.onChange =
inShape.onChange =
inNames.onChange =
inExec.onLinkChanged = () =>
{
    removeFromWorld();
    added = false;
};

inActive.onChange = () =>
{
    if (!inActive.get())removeFromWorld();
    update();
};

function update()
{
    if (!inActive.get()) return;
    if (!added || world != cgl.frameStore.ammoWorld) addToWorld();

    if (world && bodies.length && bodies[0] && world.getBodyMeta(bodies[0].body) == undefined)removeFromWorld();

    ping();
    for (let i = 0; i < bodies.length; i++)
    {
        cgl.pushModelMatrix();

        mat4.identity(cgl.mMatrix);

        mat4.mul(cgl.mMatrix, cgl.mMatrix, bodies[i].node.modelMatAbs());

        if (!tmpTrans)tmpTrans = new Ammo.btTransform();

        CABLES.AmmoWorld.copyCglTransform(cgl, tmpTrans);

        bodies[i].motionState.setWorldTransform(tmpTrans);
        bodies[i].body.setWorldTransform(tmpTrans);

        cgl.popModelMatrix();
    }
}

function removeFromWorld()
{
    if (world)
    {
        for (let i = 0; i < bodies.length; i++)
        {
            world.removeRigidBody(bodies[i].body);
        }
    }
    bodies.length = 0;
    outNum.set(bodies.length);
    world = null;
    added = false;
}

function ping()
{
    if (world)
        for (let i = 0; i < bodies.length; i++)
            world.pingBody(bodies[i].body);
}

function addToWorld()
{
    scene = cgl.frameStore.currentScene;
    if (!scene || !cgl.frameStore.ammoWorld) return;

    if (world != cgl.frameStore.ammoWorld || currentSceneLoaded != scene.loaded) removeFromWorld();

    world = cgl.frameStore.ammoWorld;

    if (!world)
    {
        op.logError("no physics world!?");
        outNum.set(0);
        return;
    }
    if (!scene) return;

    currentSceneLoaded = scene.loaded;
    for (let i = 0; i < scene.nodes.length; i++)
    {
        if (!scene.nodes[i].mesh) continue;
        if (scene.nodes[i].name.indexOf(inNames.get()) == -1) continue;

        let colShape = null;

        scene.nodes[i].transform(cgl, 0);
        scene.nodes[i].updateMatrix();

        const sc = scene.nodes[i]._scale || [1, 1, 1];
        const geom = scene.nodes[i].mesh.meshes[0].geom;

        if (inShape.get() == "Convex Hull")
        {
            colShape = CABLES.AmmoWorld.createConvexHullFromGeom(geom, 100, sc);
        }
        else
        {
            let mesh = new Ammo.btTriangleMesh(true, true);

            for (let i = 0; i < geom.verticesIndices.length / 3; i++)
            {
                mesh.addTriangle(
                    new Ammo.btVector3(
                        sc[0] * geom.vertices[geom.verticesIndices[i * 3] * 3 + 0],
                        sc[0] * geom.vertices[geom.verticesIndices[i * 3] * 3 + 1],
                        sc[0] * geom.vertices[geom.verticesIndices[i * 3] * 3 + 2]
                    ),
                    new Ammo.btVector3(
                        sc[0] * geom.vertices[geom.verticesIndices[i * 3 + 1] * 3 + 0],
                        sc[0] * geom.vertices[geom.verticesIndices[i * 3 + 1] * 3 + 1],
                        sc[0] * geom.vertices[geom.verticesIndices[i * 3 + 1] * 3 + 2]
                    ),
                    new Ammo.btVector3(
                        sc[0] * geom.vertices[geom.verticesIndices[i * 3 + 2] * 3 + 0],
                        sc[0] * geom.vertices[geom.verticesIndices[i * 3 + 2] * 3 + 1],
                        sc[0] * geom.vertices[geom.verticesIndices[i * 3 + 2] * 3 + 2]
                    ),
                    false);
            }

            colShape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
        }

        colShape.setMargin(0.05);

        let localInertia = new Ammo.btVector3(0, 0, 0);
        colShape.calculateLocalInertia(inMass.get(), localInertia);

        let transform = new Ammo.btTransform();
        let motionState = new Ammo.btDefaultMotionState(transform);

        let rbInfo = new Ammo.btRigidBodyConstructionInfo(inMass.get(), motionState, colShape, localInertia);
        let body = new Ammo.btRigidBody(rbInfo);
        world.addRigidBody(body);

        world.setBodyMeta(body,
            {
                "name": scene.nodes[i].name,
                "mass": inMass.get(),

            });

        bodies.push(
            {
                "node": scene.nodes[i],
                "motionState": motionState,
                "body": body
            });
    }

    outNum.set(bodies.length);

    added = true;
}


};

Ops.Physics.Ammo.GltfAmmoBodies.prototype = new CABLES.Op();
CABLES.OPS["ea7553aa-0836-4512-9253-34b86d62accc"]={f:Ops.Physics.Ammo.GltfAmmoBodies,objName:"Ops.Physics.Ammo.GltfAmmoBodies"};




// **************************************************************
// 
// Ops.Points.PointsCircle
// 
// **************************************************************

Ops.Points.PointsCircle = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    outArr = op.outArray("Points", 3),
    percent = op.inValueSlider("percent", 1),
    segments = op.inValue("segments", 40),
    radius = op.inValue("radius", 1),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array lengths");

radius.onChange =
    percent.onChange =
    segments.onChange = calcArray;

function calcArray()
{
    const segs = Math.max(3, Math.floor(segments.get()));
    const points = [];

    let count = 0;
    for (let i = 0; i < segs * percent.get(); i++)
    {
        let degInRad = (360 / segs) * i * CGL.DEG2RAD;
        let posx = Math.cos(degInRad) * radius.get();
        let posy = Math.sin(degInRad) * radius.get();

        points.push(posx);
        points.push(posy);
        points.push(0);
    }

    outArr.set(null);
    outArr.set(points);
    outTotalPoints.set(points.length / 3);
    outArrayLength.set(points.length);
}

calcArray();


};

Ops.Points.PointsCircle.prototype = new CABLES.Op();
CABLES.OPS["ef54ba67-8b1d-41b0-8140-bb97061eaa97"]={f:Ops.Points.PointsCircle,objName:"Ops.Points.PointsCircle"};




// **************************************************************
// 
// Ops.Points.PointsCube
// 
// **************************************************************

Ops.Points.PointsCube = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const numx = op.inValueInt("num x", 5),
    numy = op.inValueInt("num y", 5),
    numz = op.inValueInt("num z", 5),
    mul = op.inValue("mul", 1),
    center = op.inValueBool("center", true),
    outArray = op.outArray("Array out"),
    idx = op.outNumber("Total points"),
    arrayLengthOut = op.outNumber("Array length");

let newArr = [];
outArray.set(newArr);

numx.onChange =
numy.onChange =
numz.onChange =
mul.onChange =
center.onChange = update;

function update()
{
    newArr.length = 0;

    let subX = 0;
    let subY = 0;
    let subZ = 0;

    if (center.get())
    {
        subX = ((numx.get() - 1) * mul.get()) / 2.0;
        subY = ((numy.get() - 1) * mul.get()) / 2.0;
        subZ = ((numz.get() - 1) * mul.get()) / 2.0;
    }

    let xTemp = 0;
    let yTemp = 0;
    let zTemp = 0;

    let m = mul.get();

    for (var z = 0; z < numz.get(); z++)
    {
        zTemp = (z * m) - subZ;

        for (var y = 0; y < numy.get(); y++)
        {
            yTemp = (y * m) - subY;

            for (var x = 0; x < numx.get(); x++)
            {
                xTemp = (x * m) - subX;

                newArr.push(xTemp);
                newArr.push(yTemp);
                newArr.push(zTemp);
            }
        }
    }
    idx.set(x * y * z);
    outArray.set(null);
    outArray.set(newArr);
    arrayLengthOut.set(newArr.length);
}

update();


};

Ops.Points.PointsCube.prototype = new CABLES.Op();
CABLES.OPS["6030193b-089c-4565-a7b8-d837501ded52"]={f:Ops.Points.PointsCube,objName:"Ops.Points.PointsCube"};




// **************************************************************
// 
// Ops.Points.PointsHexagonGrid
// 
// **************************************************************

Ops.Points.PointsHexagonGrid = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const numxIn = op.inInt("Rows", 5),
    numyIn = op.inInt("Colums", 5),
    pointyOrTopped = op.inSwitch("Hex facing", ["Pointy", "Topped"], "Topped"),
    flipCorners = op.inBool("Flip corners", false),
    tileXOffsetIn = op.inFloat("Tile X offset", 1),
    tileYOffsetIn = op.inFloat("Tile Y offset", 1),
    multiplierIn = op.inFloat("Multiplier", 1),
    arrayOut = op.outArray("Array out");

tileXOffsetIn.onChange = tileYOffsetIn.onChange = numxIn.onChange = numyIn.onChange = multiplierIn.onChange = flipCorners.onChange = pointyOrTopped.onChange = update;

op.setPortGroup("Dimensions", [numxIn, numyIn]);
op.setPortGroup("Orientation", [flipCorners, pointyOrTopped]);
op.setPortGroup("Spacing", [tileXOffsetIn, tileYOffsetIn, multiplierIn]);

update();

function update()
{
    const arr = [];

    let offsetX = 0;
    let offsetY = 0;

    let w = 0;
    let h = 0;

    const multiplier = multiplierIn.get();

    if (pointyOrTopped.get() === "Pointy")
    {
        w = numyIn.get();
        h = numxIn.get();

        offsetX = tileXOffsetIn.get() * 1.7;
        offsetY = tileYOffsetIn.get() * 1.432;

        for (let x = 0; x < w; x++)
        {
            for (let y = 0; y < h; y++)
            {
                let yFlipped = y;
                if (flipCorners.get()) yFlipped = y + 1;

                if (yFlipped % 2 == 0)
                {
                    arr.push((x - w / 2) * offsetX * multiplier);
                    arr.push((y - h / 2) * offsetY * multiplier);
                    arr.push(0);
                }
                else
                {
                    arr.push(
                        ((x - w / 2) * offsetX + offsetX / 2) * multiplier
                    );
                    arr.push((y - h / 2) * offsetY * multiplier);
                    arr.push(0);
                }
            }
        }
    }
    else
    {
        w = numxIn.get();
        h = numyIn.get();

        offsetX = tileYOffsetIn.get() * 1.7;
        offsetY = tileXOffsetIn.get() * 1.432;

        for (let x = 0; x < w; x++)
        {
            for (let y = 0; y < h; y++)
            {
                let yFlipped = y;
                if (flipCorners.get()) yFlipped = y + 1;

                if (yFlipped % 2 == 0)
                {
                    arr.push((y - h / 2) * offsetY * multiplier);
                    arr.push((x - w / 2) * offsetX * multiplier);
                    arr.push(0);
                }
                else
                {
                    arr.push((y - h / 2) * offsetY * multiplier);
                    arr.push(
                        ((x - w / 2) * offsetX + offsetX / 2) * multiplier
                    );
                    arr.push(0);
                }
            }
        }
    }
    arrayOut.set(arr);
}


};

Ops.Points.PointsHexagonGrid.prototype = new CABLES.Op();
CABLES.OPS["989c4d70-8567-47f2-8df3-85c68d422107"]={f:Ops.Points.PointsHexagonGrid,objName:"Ops.Points.PointsHexagonGrid"};




// **************************************************************
// 
// Ops.Points.PointsPlane_v2
// 
// **************************************************************

Ops.Points.PointsPlane_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNumX = op.inValueInt("Rows", 32),
    inNumY = op.inValueInt("Columns", 32),
    inHeight = op.inFloat("Width", 2),
    inWidth = op.inFloat("Height", 2),
    inRowOffset = op.inFloat("Row Offset", 0),
    inCenter = op.inValueBool("Center", true),
    outArr = op.outArray("Result", [], 3),
    outTotalPoints = op.outNumber("Total points"),
    outArrayLength = op.outNumber("Array length"),
    outRowNums = op.outArray("Row Numbers", [], 1),
    outColNums = op.outArray("Column Numbers", [], 1);

inNumX.onChange =
inNumY.onChange =
inCenter.onChange =
inWidth.onChange =
inRowOffset.onChange =
inHeight.onChange = generate;

const arr = [];
const arrRowNums = [];
const arrColNums = [];
outArr.set(arr);
generate();

function generate()
{
    arr.length = 0;
    const numX = Math.max(0, inNumX.get());
    const numY = Math.max(0, inNumY.get());

    let stepX = 0;
    let stepY = 0;

    // to avoid divide by zero
    if (numX == 1)
    {
        stepX = inWidth.get() / (numX);
    }
    else
    {
        stepX = inWidth.get() / (numX - 1);
    }
    if (numY == 1)
    {
        stepY = inHeight.get() / (numY);
    }
    else
    {
        stepY = inHeight.get() / (numY - 1);
    }

    let i = 0;

    let centerX = 0;
    let centerY = 0;

    if (inCenter.get())
    {
        centerX = inWidth.get() / 2;
        centerY = inHeight.get() / 2;
    }

    const l = Math.floor(numX) * Math.floor(numY) * 3;

    arr.length = l;
    arrColNums.length = l / 3;
    arrRowNums.length = l / 3;

    let offRow = inRowOffset.get();
    let off = 0;
    for (let y = 0; y < numY; y++)
    {
        for (let x = 0; x < numX; x++)
        {
            off = 0;
            if (x % 2 == 0 && offRow)off = offRow;

            arrColNums[i / 3] = y;
            arrRowNums[i / 3] = x;

            arr[i++] = stepY * y - centerY + off;
            arr[i++] = stepX * x - centerX;

            arr[i++] = 0;
        }
    }

    outRowNums.set(null);
    outRowNums.set(arrRowNums);

    outColNums.set(null);
    outColNums.set(arrColNums);

    outArr.set(null);
    outArr.set(arr);
    outTotalPoints.set(arr.length / 3);
    outArrayLength.set(arr.length);
}


};

Ops.Points.PointsPlane_v2.prototype = new CABLES.Op();
CABLES.OPS["d453f898-17d4-4e2c-b8c7-7b7b34c0ff68"]={f:Ops.Points.PointsPlane_v2,objName:"Ops.Points.PointsPlane_v2"};




// **************************************************************
// 
// Ops.Points.PointsSphereRandom
// 
// **************************************************************

Ops.Points.PointsSphereRandom = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    num = op.inValueInt("Amount of points", 100),
    size = op.inValue("Sphere size", 1),
    seed = op.inValue("Random seed", 0),
    distRand = op.inValueSlider("Random distance from sphere", 0),
    distrib = op.inValueSelect("Distribution", ["Uniform", "Poles", "Half"], "Uniform"),
    outArray = op.outArray("Array out", 3),
    totalPointsOut = op.outNumber("Total points"),
    arrayLengthOut = op.outNumber("Array length");

let newArr = [];
outArray.set(newArr);

seed.onChange =
    num.onChange =
    size.onChange =
    distrib.onChange =
    distRand.onChange =
    outArray.onLinkChanged = generate;

generate();

function generate()
{
    const verts = [];
    verts.length = Math.max(0, Math.round(num.get()) * 3);

    Math.randomSeed = seed.get();

    let rndq = quat.create();
    let tempv = vec3.create();

    let dist = 0;
    if (distrib.get() == "Poles")dist = 1;
    if (distrib.get() == "Half")dist = 2;

    let dRand = distRand.get();

    for (let i = 0; i < num.get(); i++)
    {
        if (dist == 1 || dist == 2)
        {
            rndq[0] = Math.seededRandom();
            rndq[1] = Math.seededRandom();
            rndq[2] = Math.seededRandom();
            rndq[3] = Math.seededRandom();
        }
        else
        {
            rndq[0] = Math.seededRandom() * 2.0 - 1.0;
            rndq[1] = Math.seededRandom() * 2.0 - 1.0;
            rndq[2] = Math.seededRandom() * 2.0 - 1.0;
            rndq[3] = Math.seededRandom() * 2.0 - 1.0;
        }

        quat.normalize(rndq, rndq);

        if (dist == 2)
        {
            tempv[0] = size.get();
        }
        else
        {
            if (i % 2 === 0) tempv[0] = -size.get();
            else tempv[0] = size.get();
        }

        tempv[1] = 0;
        tempv[2] = 0;

        if (dRand !== 0) tempv[0] -= Math.random() * dRand;

        vec3.transformQuat(tempv, tempv, rndq);
        verts[i * 3] = tempv[0];
        verts[i * 3 + 1] = tempv[1];
        verts[i * 3 + 2] = tempv[2];
    }

    outArray.set(null);
    outArray.set(verts);
    totalPointsOut.set(verts.length / 3);
    arrayLengthOut.set(verts.length);
}


};

Ops.Points.PointsSphereRandom.prototype = new CABLES.Op();
CABLES.OPS["1ea17de7-adad-4053-943a-4874bccf54e9"]={f:Ops.Points.PointsSphereRandom,objName:"Ops.Points.PointsSphereRandom"};




// **************************************************************
// 
// Ops.Sequence
// 
// **************************************************************

Ops.Sequence = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    cleanup = op.inTriggerButton("Clean up connections");

const
    exes = [],
    triggers = [],
    num = 16;

let updateTimeout = null;

exe.onTriggered = triggerAll;
cleanup.onTriggered = clean;
cleanup.setUiAttribs({ "hidePort": true });
cleanup.setUiAttribs({ "hideParam": true });

for (let i = 0; i < num; i++)
{
    const p = op.outTrigger("trigger " + i);
    triggers.push(p);
    p.onLinkChanged = updateButton;

    if (i < num - 1)
    {
        let newExe = op.inTrigger("exe " + i);
        newExe.onTriggered = triggerAll;
        exes.push(newExe);
    }
}

function updateButton()
{
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() =>
    {
        let show = false;
        for (let i = 0; i < triggers.length; i++)
            if (triggers[i].links.length > 1) show = true;

        cleanup.setUiAttribs({ "hideParam": !show });

        if (op.isCurrentUiOp()) op.refreshParams();
    }, 60);
}

function triggerAll()
{
    for (let i = 0; i < triggers.length; i++) triggers[i].trigger();
}

function clean()
{
    let count = 0;
    for (let i = 0; i < triggers.length; i++)
    {
        let removeLinks = [];

        if (triggers[i].links.length > 1)
            for (let j = 1; j < triggers[i].links.length; j++)
            {
                while (triggers[count].links.length > 0) count++;

                removeLinks.push(triggers[i].links[j]);
                const otherPort = triggers[i].links[j].getOtherPort(triggers[i]);
                op.patch.link(op, "trigger " + count, otherPort.parent, otherPort.name);
                count++;
            }

        for (let j = 0; j < removeLinks.length; j++) removeLinks[j].remove();
    }
    updateButton();
}


};

Ops.Sequence.prototype = new CABLES.Op();
CABLES.OPS["a466bc1f-06e9-4595-8849-bffb9fe22f99"]={f:Ops.Sequence,objName:"Ops.Sequence"};




// **************************************************************
// 
// Ops.Sidebar.Button_v2
// 
// **************************************************************

Ops.Sidebar.Button_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
const parentPort = op.inObject("link");
const buttonTextPort = op.inString("Text", "Button");

// outputs
const siblingsPort = op.outObject("childs");
const buttonPressedPort = op.outTrigger("Pressed Trigger");

const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar--button");
const input = document.createElement("div");
input.classList.add("sidebar__button-input");
el.appendChild(input);
input.addEventListener("click", onButtonClick);
const inputText = document.createTextNode(buttonTextPort.get());
input.appendChild(inputText);
op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

// events
parentPort.onChange = onParentChanged;
buttonTextPort.onChange = onButtonTextChanged;
op.onDelete = onDelete;

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

function onButtonClick()
{
    buttonPressedPort.trigger();
}

function onButtonTextChanged()
{
    const buttonText = buttonTextPort.get();
    input.textContent = buttonText;
    if (CABLES.UI)
    {
        op.setTitle("Button: " + buttonText);
    }
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.Button_v2.prototype = new CABLES.Op();
CABLES.OPS["5e9c6933-0605-4bf7-8671-a016d917f327"]={f:Ops.Sidebar.Button_v2,objName:"Ops.Sidebar.Button_v2"};




// **************************************************************
// 
// Ops.Sidebar.ColorPicker_v3
// 
// **************************************************************

Ops.Sidebar.ColorPicker_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"colorrick_css":".colorRick_dialog\n{\n    --width:256px;\n    --height:256px;\n    --width-hue:20px;\n    --pad:10px;\n    --colorblock-height:20px;\n    --inputcontainer-height:120px;\n\n    background-color: #333;\n    width:calc(var(--width) + 3*var(--pad) + var(--width-hue));\n    height:calc(var(--height) + var(--colorblock-height) + 30px + var(--inputcontainer-height));\n    position: absolute;\n    border-radius: 10px;\n    overflow: hidden;\n    z-index: 999999;\n\n}\n\n.colorRick_dialog *\n{\n    font-size: 13px;\n}\n\n.colorRick_area\n{\n    width:var(--width);\n    height:var(--height);\n    left:var(--pad);\n    top:var(--pad);\n    background: linear-gradient(to right, rgb(255, 255, 255), rgb(0, 255, 11));\n    position: absolute;\n    cursor:pointer;\n}\n\n.colorRick_brightness\n{\n    background: linear-gradient(hsla(0,0%,100%,0),#000);\n    width:100%;\n    height:100%;\n    pointer-events: none;\n}\n\n.colorRick_hue\n{\n    cursor:pointer;\n    top:var(--pad);\n    background:linear-gradient(red,#f0f 17%,#00f 34%,#0ff 50%,#0f0 67%,#ff0 84%,red);\n    height:var(--height);\n\n    width:var(--width-hue);\n    position: absolute;\n    left:calc(var(--width) + var(--pad) + var(--pad));\n}\n\n.colorRick_preview\n{\n    position: absolute;\n    width:calc(var(--width) / 10 * 9);\n    height:var(--colorblock-height);\n    top:calc(var(--height) + 20px);\n    margin-left:10px;\n}\n\n.colorRick_preview_orig\n{\n    margin-left:calc(calc(var(--width) / 10 * 9) + 10px);\n    width:calc(var(--width) / 10);\n    cursor:pointer;\n}\n\n.colorRick_cursor\n{\n    width:4px;\n    height:4px;\n    border:1px solid transparent;\n    background-color: white;\n    position: absolute;\n    pointer-events: none;\n    border-radius: 100%;\n}\n\n.colorRick_cursor_hue\n{\n    position: absolute;\n    width:24px;\n    margin-left: -2px;\n    height:0px;\n    border-top:1px solid white;\n    border-bottom:1px solid white;\n    position: absolute;\n    pointer-events: none;\n}\n\n.colorRick_inputcontainer\n{\n    position: absolute;\n\n    height:var(--inputcontainer-height);\n    /* top:250px; */\n    top:calc(var(--height) + 20px + 20px + 10px);\n    left:0px;\n    width:100%;\n    background-color: #000;\n    padding:10px;\n}\n\n.colorRick_inputcontainer table\n{\n    width:var(--width);\n}\n\n.colorRick_inputcontainer, .colorRick_inputcontainer table\n{\n    color:#999;\n}\n\n.colorRick_input\n{\n    background-color: #444;\n    border:0px solid transparent;\n    opacity: 1;\n    color:#ddd;\n}\n\n.colorRick_input_small\n{\n    width:60px;\n    margin-left:10px;\n}\n\n.colorRick_input_hex\n{\n    width:100px;\n}\n\n.colorRick_invalid\n{\n    opacity: 0.5;\n}\n\n.colorRick_inputcontainer table\n{\n    /* width:90%; */\n}\n\n.colorRick_inputcontainer table,.colorRick_inputcontainer table td, .colorRick_inputcontainer table tr\n{\n    /* pointer-events: none; */\n    user-select: none;\n\n    vertical-align: top;\n}\n\n.colorRick_inputcontainer table td.right\n{\n    text-align: right;\n    height: 30px;\n}\n",};
// constants
const DEFAULT_COLOR_HEX = "#07F78C";

// inputs
const parentPort = op.inObject("Link");
const labelPort = op.inString("Text", "Hex Color");
const defaultColorArr = hexToRgbNorm(DEFAULT_COLOR_HEX);
const inputRedPort = op.inValueSlider("Input Red", defaultColorArr[0]);
const inputGreenPort = op.inValueSlider("Input Green", defaultColorArr[1]);
const inputBluePort = op.inValueSlider("Input Blue", defaultColorArr[2]);
// const inputValuePort = op.inValueString('Input', DEFAULT_COLOR_HEX);
const setDefaultValueButtonPort = op.inTriggerButton("Set Default");
const defaultValuePort = op.inValueString("Default", DEFAULT_COLOR_HEX);
defaultValuePort.setUiAttribs({ "hidePort": true, "greyout": true });

// outputs
const siblingsPort = op.outObject("Children");
const redPort = op.outNumber("Red", 0.0);
const greenPort = op.outNumber("Green", 0.0);
const bluePort = op.outNumber("Blue", 0.0);

const outHex = op.outString("Hex", DEFAULT_COLOR_HEX);

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.addEventListener("dblclick", function ()
{
    let defaultValue = defaultValuePort.get();
    input.setAttribute("value", defaultValue);
    if (defaultValue)
    {
        if (defaultValue.length === 6 && defaultValue.charAt(0) !== "#")
        {
            defaultValue = "#" + defaultValue;
        }
        if (defaultValue.length === 7)
        {
            input.value = defaultValue;
            colorInput.value = defaultValue;
            setColorOutPorts(defaultValue);
        }
    }
});

el.classList.add("sidebar__item");
el.classList.add("sidebar__color-picker");
el.classList.add("sidebar__reloadable");

const styleEle = document.createElement("style");
styleEle.type = "text/css";
styleEle.textContent = attachments.colorrick_css;

const head = document.getElementsByTagName("body")[0];
head.appendChild(styleEle);

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelTextNode = document.createTextNode(labelPort.get());
label.appendChild(labelTextNode);
el.appendChild(label);
// var inputWrapper = document.createElement('div');
// inputWrapper.classList.add('sidebar__text-input-input-wrapper');
// el.appendChild(inputWrapper);
const input = document.createElement("input");
input.classList.add("sidebar__color-picker-input");
/* input.classList.add('jscolor'); */ /* color picker library */
input.setAttribute("type", "text");
input.setAttribute("value", defaultValuePort.get());
// inputWrapper.appendChild(input);
el.appendChild(input);
input.addEventListener("input", onInput);
const colorInput = document.createElement("div");
colorInput.classList.add("sidebar__color-picker-color-input");
// colorInput.setAttribute("type", "color");
colorInput.style.backgroundColor = defaultValuePort.get();
// colorInput.addEventListener("change", onColorPickerChange, false);

colorInput.addEventListener("click", function ()
{
    new ColorRick(
        {
            "ele": this,
            "color": this.style.backgroundColor || "#ff0000",
            "onChange": (col) =>
            {
                const hex = col.hex();
                this.style.backgroundColor = hex;
                setColorOutPorts(hex);
                input.value = hex;
                outHex.set(hex);
                setInputsByHex(hex);

                op.refreshParams();
            }
        });
});

el.appendChild(colorInput);
input.addEventListener("input", onInput);

onDefaultValueChanged(); /* initialize once */

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
defaultValuePort.onChange = onDefaultValueChanged;
op.onDelete = onDelete;
setDefaultValueButtonPort.onTriggered = setDefaultColor;
inputRedPort.onChange = inputColorChanged;
inputGreenPort.onChange = inputColorChanged;
inputBluePort.onChange = inputColorChanged;

// functions

function inputColorChanged()
{
    const hex = getInputColorHex();
    colorInput.style.backgroundColor = hex;
    input.value = hex;
    setColorOutPorts(hex);
}

/**
 * Returns the color of the op params ("input red", "input green", "input blue") as hex
 */
function getInputColorHex()
{
    const r = CABLES.clamp(inputRedPort.get(), 0, 1);
    const g = CABLES.clamp(inputGreenPort.get(), 0, 1);
    const b = CABLES.clamp(inputBluePort.get(), 0, 1);
    const hex = rgbNormToHex(r, g, b);
    return hex;
}

function setDefaultColor()
{
    // let hexCol = inputValuePort.get().trim();
    const hex = getInputColorHex();
    defaultValuePort.set(hex);
    outHex.set(hex);
    op.refreshParams();
}

/*
function onInputValuePortChange() {
    let hexCol = inputValuePort.get().trim();
    if(hexCol.length === 6 && hexCol.charAt(0) !== '#') {
        hexCol = '#' + hexCol;
    }
    if(hexCol.length === 7) {
        colorInput.value = hexCol;
        input.value = hexCol;
        setColorOutPorts(hexCol);
    }
}
*/

function hexToRgbNorm(hexColor)
{
    if (!hexColor || hexColor.length !== 7) { return; }
    return hexColor
        .match(/[A-Za-z0-9]{2}/g)
        .map(function (v)
        {
            return parseInt(v, 16) / 255;
        });
}

/**
 * Helper for rgbNormToHex / rgbToHex
 * Converts a number in range [0..255] to hex [00..FF] (with left padding)
 */
function componentToHex(c)
{
    const hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}

/**
 * r, g, b in range [0..1]
 * @returns {string} e.g. "#ff0000"
 */
function rgbNormToHex(r, g, b)
{
    return "#" + componentToHex(Math.floor(255 * r)) + componentToHex(Math.floor(255 * g)) + componentToHex(Math.floor(255 * b));
}

/**
 * Sets the op param color input ports by hex value (e.g. "#FF0000")
 * Does NOT update the gui
 */
function setInputsByHex(hex)
{
    const colorArr = hexToRgbNorm(hex);
    inputRedPort.set(colorArr[0]);
    inputGreenPort.set(colorArr[1]);
    inputBluePort.set(colorArr[2]);
    outHex.set(hex);
}

function onInput(ev)
{
    let newValue = ev.target.value;
    if (newValue.length === 6 && newValue.charAt(0) !== "#")
    {
        newValue = "#" + newValue;
    }
    if (newValue.length === 7)
    {
        colorInput.value = newValue;
        setColorOutPorts(newValue);
        // inputValuePort.set(newValue)
        setInputsByHex(newValue);
        outHex.set(newValue);
        op.refreshParams();
    }
}

// hex must be 7 digits
function setColorOutPorts(hex)
{
    const colorArr = hexToRgbNorm(hex);
    outHex.set(hex);
    redPort.set(colorArr[0]);
    greenPort.set(colorArr[1]);
    bluePort.set(colorArr[2]);
}

function onDefaultValueChanged()
{
    let defaultValue = defaultValuePort.get();
    input.setAttribute("value", defaultValue);
    if (defaultValue)
    {
        if (defaultValue.length === 6 && defaultValue.charAt(0) !== "#")
        {
            defaultValue = "#" + defaultValue;
        }
        if (defaultValue.length === 7)
        {
            input.value = defaultValue;
            colorInput.value = defaultValue;
            setColorOutPorts(defaultValue);
        }
    }
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;

    if (CABLES.UI) op.setTitle("Color Picker: " + labelText);
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.ColorPicker_v3.prototype = new CABLES.Op();
CABLES.OPS["52dc1ef8-deb0-4664-a924-4c5548aa8a55"]={f:Ops.Sidebar.ColorPicker_v3,objName:"Ops.Sidebar.ColorPicker_v3"};




// **************************************************************
// 
// Ops.Sidebar.DisplayValue_v2
// 
// **************************************************************

Ops.Sidebar.DisplayValue_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Value");
const valuePort = op.inString("Value", "");

// outputs
const siblingsPort = op.outObject("childs");

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__value-display");
const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelTextNode = document.createTextNode(labelPort.get());
label.appendChild(labelTextNode);
el.appendChild(label);
const value = document.createElement("div");
value.textContent = valuePort.get();
value.classList.add("sidebar__item-value-label");
el.appendChild(value);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
valuePort.onChange = onValueChanged;
op.onDelete = onDelete;

// functions

function onValueChanged()
{
    value.textContent = valuePort.get();
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;
    if (CABLES.UI)
    {
        op.setTitle("Value: " + labelText);
    }
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(element)
{
    if (element)
    {
        element.style.display = "block";
    }
}

function hideElement(element)
{
    if (element)
    {
        element.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(element)
{
    if (element && element.parentNode && element.parentNode.removeChild)
    {
        element.parentNode.removeChild(element);
    }
}


};

Ops.Sidebar.DisplayValue_v2.prototype = new CABLES.Op();
CABLES.OPS["3dd9927e-0d34-4442-8a8a-0ab843aee6e3"]={f:Ops.Sidebar.DisplayValue_v2,objName:"Ops.Sidebar.DisplayValue_v2"};




// **************************************************************
// 
// Ops.Sidebar.DropDown_v2
// 
// **************************************************************

Ops.Sidebar.DropDown_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
const parentPort = op.inObject("Link");
const labelPort = op.inString("Text", "Value");
const valuesPort = op.inArray("Values");
const defaultValuePort = op.inString("Default", "");
const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);
const inSize = op.inInt("Lines", 1);
const setDefaultValueButtonPort = op.inTriggerButton("Set Default");
setDefaultValueButtonPort.onTriggered = setDefault;

// outputs
const siblingsPort = op.outObject("Children");
const valuePort = op.outString("Result", defaultValuePort.get());
const outIndex = op.outNumber("Index");

defaultValuePort.setUiAttribs({ "title": "Input" });

// vars
const el = document.createElement("div");
el.addEventListener("dblclick", function ()
{
    valuePort.set(defaultValuePort.get());
    const optionElements = input.querySelectorAll("option");
    optionElements.forEach(function (optionElement, index)
    {
        if (optionElement.value.trim() === defaultValuePort.get())
        {
            optionElement.selected = true;
            outIndex.set(index);
        }
        else
        {
            optionElement.removeAttribute("selected");
        }
    });
});

el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__select");
el.classList.add("sidebar__reloadable");

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);
const input = document.createElement("select");

input.classList.add("sidebar__select-select");
el.appendChild(input);
input.addEventListener("input", onInput);

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
defaultValuePort.onChange = onDefaultValueChanged;
op.onDelete = onDelete;
valuesPort.onChange = onValuesPortChange;

let options = [];
// functions

inSize.onChange = () =>
{
    input.setAttribute("size", inSize.get());
};

op.onLoaded = function ()
{
    valuePort.set(defaultValuePort.get());
};

function onValuesPortChange()
{
    // remove all children
    while (input.lastChild)
    {
        input.removeChild(input.lastChild);
    }
    options = valuesPort.get();
    const defaultValue = defaultValuePort.get();
    if (options)
    {
        options.forEach(function (option)
        {
            const optionEl = document.createElement("option");

            optionEl.setAttribute("value", option);
            if (option === defaultValue || option === valuePort.get())
            {
                optionEl.setAttribute("selected", "");
            }
            const textEl = document.createTextNode(option);
            optionEl.appendChild(textEl);
            input.appendChild(optionEl);
        });
    }
    else
    {
        valuePort.set("");
    }

    outIndex.set(0);
    setSelectedProperty(); /* set the selected property for the default value */
}

let finalIndex = 0;
function setSelectedProperty(defaultinput)
{
    const optionElements = input.querySelectorAll("option");

    let finalEle = null;

    optionElements.forEach(function (optionElement, index)
    {
        if (optionElement.value.trim() === valuePort.get())
        {
            finalEle = optionElement;
            finalIndex = index;
        }
        optionElement.removeAttribute("selected");
    });

    if (defaultinput)
    {
        const defaultItem = defaultValuePort.get() + "".trim();

        optionElements.forEach(function (optionElement, index)
        {
            if (optionElement.value.trim() === defaultItem)
            {
                finalEle = optionElement;
                finalIndex = index;
            }

            optionElement.removeAttribute("selected");
        });
    }

    if (finalEle) finalEle.setAttribute("selected", "");
    outIndex.set(finalIndex);
}

function onInput(ev)
{
    valuePort.set(ev.target.value);
    outIndex.set(options.indexOf(ev.target.value));
    setSelectedProperty();
}

function onDefaultValueChanged()
{
    const defaultValue = defaultValuePort.get();
    valuePort.set(defaultValue);
    input.value = defaultValue;
    setSelectedProperty();
}

function onLabelTextChanged()
{
    const lblText = labelPort.get();
    label.textContent = lblText;
    if (CABLES.UI)
    {
        op.setTitle("Dropdown: " + lblText);
    }
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(ele)
{
    if (ele)
    {
        ele.style.display = "block";
    }
    setSelectedProperty();
}

function hideElement(ele)
{
    if (ele)
    {
        ele.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(ele)
{
    if (ele && ele.parentNode && ele.parentNode.removeChild)
    {
        ele.parentNode.removeChild(ele);
    }
}

function setDefault()
{
    defaultValuePort.set(input.value);
    op.refreshParams();
}


};

Ops.Sidebar.DropDown_v2.prototype = new CABLES.Op();
CABLES.OPS["7b3f93d6-4de1-41fd-aa26-e74c8285c662"]={f:Ops.Sidebar.DropDown_v2,objName:"Ops.Sidebar.DropDown_v2"};




// **************************************************************
// 
// Ops.Sidebar.Group
// 
// **************************************************************

Ops.Sidebar.Group = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
let parentPort = op.inObject("link");
let labelPort = op.inString("Text", "Group");
const inShowTitle = op.inBool("Show Title", true);
let defaultMinimizedPort = op.inValueBool("Default Minimized");
const inVisible = op.inBool("Visible", true);

// outputs
let nextPort = op.outObject("next");
let childrenPort = op.outObject("childs");

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

// vars
let el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("sidebar__group");
onDefaultMinimizedPortChanged();
let header = document.createElement("div");
header.classList.add("sidebar__group-header");
header.classList.add("cablesEle");
el.appendChild(header);
header.addEventListener("click", onClick);
let headerTitle = document.createElement("div");
headerTitle.classList.add("sidebar__group-header-title");
// headerTitle.textContent = labelPort.get();
header.appendChild(headerTitle);
let headerTitleText = document.createElement("span");
headerTitleText.textContent = labelPort.get();
headerTitleText.classList.add("sidebar__group-header-title-text");
headerTitle.appendChild(headerTitleText);
let icon = document.createElement("span");
icon.classList.add("sidebar__group-header-icon");
icon.classList.add("iconsidebar-chevron-up");
headerTitle.appendChild(icon);
let groupItems = document.createElement("div");
groupItems.classList.add("sidebar__group-items");
el.appendChild(groupItems);
op.toWorkPortsNeedToBeLinked(parentPort);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
defaultMinimizedPort.onChange = onDefaultMinimizedPortChanged;
op.onDelete = onDelete;

// functions

inShowTitle.onChange = () =>
{
    if (inShowTitle.get())header.style.display = "block";
    else header.style.display = "none";
};

function onDefaultMinimizedPortChanged()
{
    if (defaultMinimizedPort.get())
    {
        el.classList.add("sidebar__group--closed");
    }
    else
    {
        el.classList.remove("sidebar__group--closed");
    }
}

function onClick(ev)
{
    ev.stopPropagation();
    el.classList.toggle("sidebar__group--closed");
}

function onLabelTextChanged()
{
    let labelText = labelPort.get();
    headerTitleText.textContent = labelText;
    if (CABLES.UI)
    {
        op.setTitle("Group: " + labelText);
    }
}

function onParentChanged()
{
    childrenPort.set(null);
    let parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        childrenPort.set({
            "parentElement": groupItems,
            "parentOp": op,
        });
        nextPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.Group.prototype = new CABLES.Op();
CABLES.OPS["86ea2333-b51c-48ed-94c2-8b7b6e9ff34c"]={f:Ops.Sidebar.Group,objName:"Ops.Sidebar.Group"};




// **************************************************************
// 
// Ops.Sidebar.Incrementor_v2
// 
// **************************************************************

Ops.Sidebar.Incrementor_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Label", "Incrementor");
const inMin = op.inValue("min", 0);
const inMax = op.inValue("max", 10);
const inStepsize = op.inValue("stepsize", 1);
const inDefault = op.inValue("Default", 0);
const inValues = op.inArray("Values");
const inSetDefault = op.inTriggerButton("Set Default");
inSetDefault.onTriggered = setDefaultValue;

// outputs
const siblingsPort = op.outObject("childs");
const outValue = op.outNumber("value");

// vars
let currentPosition = 0;

const containerEl = document.createElement("div");
containerEl.dataset.op = op.id;
containerEl.classList.add("cablesEle");
containerEl.classList.add("sidebar__item");
const label = document.createElement("div");
label.classList.add("sidebar__item-label");
label.addEventListener("dblclick", function ()
{
    outValue.set(inDefault.get());
});
const labelTextEl = document.createTextNode(labelPort.get());
label.appendChild(labelTextEl);
containerEl.appendChild(label);

const innerContainer = document.createElement("span");
innerContainer.classList.add("sidebar__item__right");

// value
const valueEl = document.createElement("span");
valueEl.style.marginRight = "10px";

let valueText = document.createTextNode(inMin.get());
if (Array.isArray(inValues.get()))
{
    valueText = document.createTextNode(inValues.get()[currentPosition]);
}

valueEl.appendChild(valueText);
innerContainer.appendChild(valueEl);

// previous
const prevEl = document.createElement("span");
prevEl.classList.add("sidebar--button");
prevEl.style.marginRight = "3px";
const prevInput = document.createElement("div");
prevInput.classList.add("sidebar__button-input");
prevInput.classList.add("minus");
prevEl.appendChild(prevInput);
prevInput.addEventListener("click", onPrev);
const prevText = document.createTextNode("-");
prevInput.appendChild(prevText);
innerContainer.appendChild(prevEl);

// next
const nextEl = document.createElement("span");
nextEl.classList.add("sidebar--button");
const nextInput = document.createElement("div");
nextInput.classList.add("sidebar__button-input");
nextInput.classList.add("plus");
nextEl.appendChild(nextInput);
nextInput.addEventListener("click", onNext);
const nextText = document.createTextNode("+");
nextInput.appendChild(nextText);

innerContainer.appendChild(nextEl);
containerEl.appendChild(innerContainer);

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

function setDefaultValue()
{
    inDefault.set(outValue.get());
    op.refreshParams();
}

// events
parentPort.onChange = onParentChanged;
inValues.onChange = onValueChange;
labelPort.onChange = onLabelTextChanged;
op.onDelete = onDelete;

op.onLoaded = op.onInit = function ()
{
    if (Array.isArray(inValues.get()))
    {
        inDefault.setUiAttribs({ "greyout": true });
    }
    else
    {
        outValue.set(inDefault.get());
        valueText.textContent = inDefault.get();
    }
};

function onValueChange()
{
    const values = inValues.get();
    let value = inMin.get();
    if (Array.isArray(values))
    {
        value = values[currentPosition];
        inMin.setUiAttribs({ "greyout": true });
        inMax.set(values.length - 1);
        inMax.setUiAttribs({ "greyout": true });
        inStepsize.setUiAttribs({ "greyout": true });
        inStepsize.set(1);
        inDefault.setUiAttribs({ "greyout": true });
        inDefault.set(0);
    }
    else
    {
        inMin.setUiAttribs({ "greyout": false });
        inMax.setUiAttribs({ "greyout": false });
        inStepsize.setUiAttribs({ "greyout": false });
        inDefault.setUiAttribs({ "greyout": false });
    }
    outValue.set(value);
    valueText.textContent = value;
}

function onNext()
{
    const values = inValues.get();
    let value = 0;
    if (!Array.isArray(values))
    {
        // no array given, increment/decrement according to params
        const currentValue = outValue.get();
        value = Math.min(currentValue + inStepsize.get(), inMax.get());
    }
    else
    {
        // user inputs an array, iterate fields, ignore min/max/stepsize
        if (currentPosition < values.length - 1)
        {
            currentPosition += Math.ceil(inStepsize.get());
        }
        value = values[currentPosition];
    }
    valueText.textContent = value;
    outValue.set(value);
}

function onPrev()
{
    const values = inValues.get();
    let value = 0;
    if (!Array.isArray(values))
    {
        // no array given, increment/decrement according to params
        const currentValue = outValue.get();
        value = Math.max(currentValue - inStepsize.get(), inMin.get());
    }
    else
    {
        // user inputs an array, iterate fields, ignore min/max/stepsize
        if (currentPosition > 0)
        {
            currentPosition -= Math.ceil(inStepsize.get());
        }
        value = values[currentPosition];
    }
    valueText.textContent = value;
    outValue.set(value);
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(containerEl);
        siblingsPort.set(parent);
    }
    else if (containerEl.parentElement)
    {
        // detach
        containerEl.parentElement.removeChild(containerEl);
    }
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;

    if (CABLES.UI)
    {
        op.setTitle(labelText);
    }
}

function onDelete()
{
    removeElementFromDOM(containerEl);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.Incrementor_v2.prototype = new CABLES.Op();
CABLES.OPS["13932cbc-2bd4-4b2a-b6e0-cda6df4cec54"]={f:Ops.Sidebar.Incrementor_v2,objName:"Ops.Sidebar.Incrementor_v2"};




// **************************************************************
// 
// Ops.Sidebar.LocalFileToDataUrl
// 
// **************************************************************

Ops.Sidebar.LocalFileToDataUrl = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Select File:");
const inId = op.inValueString("Id", "");
const inVisible = op.inBool("Visible", true);
const inGreyOut = op.inBool("Grey Out", false);
const inOpenDialog = op.inTriggerButton("Show Dialog");
const reset = op.inTriggerButton("Reset");

// outputs

const siblingsPort = op.outObject("childs");
const outDataURL = op.outString("Data URL");
outDataURL.ignoreValueSerialize = true;

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__text");
const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

const fileInputEle = document.createElement("input");
fileInputEle.type = "file";
fileInputEle.id = "file";
fileInputEle.name = "file";

fileInputEle.style["background-color"] = "transparent";
fileInputEle.style.width = "90%";
fileInputEle.style.display = "none";
// fileInputEle.style.float = "left";

const elReset = document.createElement("div");
elReset.style.cursor = "pointer";
elReset.style.position = "absolute";
elReset.style.right = "10px";
elReset.style["margin-top"] = "15px";
elReset.innerHTML = "&nbsp;&nbsp;✕";

const fileInputButton = document.createElement("div");
fileInputButton.classList.add("sidebar__button-input");
fileInputButton.innerHTML = "Choose File";
fileInputButton.onclick = () => { fileInputEle.click(); };
inOpenDialog.onTriggered = () => { fileInputButton.click(); };
fileInputButton.style["margin-top"] = "10px";
fileInputButton.style.width = "80%";

el.appendChild(elReset);
el.appendChild(fileInputButton);
el.appendChild(fileInputEle);

const imgEl = document.createElement("img");

fileInputEle.addEventListener("change", handleFileSelect, false);

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

function onReset()
{
    fileInputEle.value = "";
    outDataURL.set("");
}

reset.onTriggered = onReset;
elReset.addEventListener("click", onReset);

function handleFileSelect(evt)
{
    const reader = new FileReader();

    reader.onabort = function (e)
    {
        op.log("File read cancelled");
    };

    reader.onload = function (e)
    {
        outDataURL.set(e.target.result);
    };

    if (evt.target.files[0]) reader.readAsDataURL(evt.target.files[0]);
    else outDataURL.set("");
}

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inId.onChange = onIdChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

// functions

function onIdChanged()
{
    el.id = inId.get();
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.LocalFileToDataUrl.prototype = new CABLES.Op();
CABLES.OPS["c99d271e-aa5e-4a9d-a4d3-4c5137c189e8"]={f:Ops.Sidebar.LocalFileToDataUrl,objName:"Ops.Sidebar.LocalFileToDataUrl"};




// **************************************************************
// 
// Ops.Sidebar.LocalTextureFile
// 
// **************************************************************

Ops.Sidebar.LocalTextureFile = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
let parentPort = op.inObject("link"),
    labelPort = op.inString("Text", "Select File:"),
    inId = op.inValueString("Id", ""),

    tfilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"], "linear"),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge");

// outputs
let siblingsPort = op.outObject("childs");
const outTex = op.outTexture("Texture");

// vars
let el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__text");
let label = document.createElement("div");
label.classList.add("sidebar__item-label");
let labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

const fileInputEle = document.createElement("input");
fileInputEle.type = "file";
fileInputEle.id = "file";
fileInputEle.name = "file";
fileInputEle.style.width = "95%";
el.appendChild(fileInputEle);

outTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));

const imgEl = document.createElement("img");

tfilter.onChange = wrap.onChange = () =>
{
    fileInputEle.dispatchEvent(new Event("change"));
};
fileInputEle.addEventListener("change", handleFileSelect, false);

function handleFileSelect(evt)
{
    const reader = new FileReader();

    reader.onabort = function (e)
    {
        op.log("File read cancelled");
    };

    reader.onload = function (e)
    {
        let image = new Image();
        image.onerror = function (e)
        {
            outTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
            op.log("image error", e);
        };
        image.onload = function (e)
        {
            let cgl_filter = CGL.Texture.FILTER_LINEAR;
            let cgl_wrap = CGL.Texture.WRAP_REPEAT;
            if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
            else if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
            else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;
            else if (tfilter.get() == "Anisotropic") cgl_filter = CGL.Texture.FILTER_ANISOTROPIC;

            if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
            if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
            if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

            let tex = CGL.Texture.createFromImage(op.patch.cgl, image, { "filter": cgl_filter, "wrap": cgl_wrap });
            outTex.set(tex);
        };
        image.src = e.target.result;
    };

    if (evt && evt.target && evt.target.files[0])
        reader.readAsDataURL(evt.target.files[0]);
}

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inId.onChange = onIdChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

// functions

function onIdChanged()
{
    el.id = inId.get();
}

function onLabelTextChanged()
{
    let labelText = labelPort.get();
    label.textContent = labelText;
}

function onParentChanged()
{
    siblingsPort.set(null);
    let parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el) el.style.display = "block";
}

function hideElement(el)
{
    if (el) el.style.display = "none";
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.LocalTextureFile.prototype = new CABLES.Op();
CABLES.OPS["6e8600c4-fb7d-4315-88d4-4f10009538a7"]={f:Ops.Sidebar.LocalTextureFile,objName:"Ops.Sidebar.LocalTextureFile"};




// **************************************************************
// 
// Ops.Sidebar.NumberInput_v2
// 
// **************************************************************

Ops.Sidebar.NumberInput_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
const parentPort = op.inObject("Link");
const labelPort = op.inString("Text", "Number");
const inputValuePort = op.inValue("Input", 0);
const setDefaultValueButtonPort = op.inTriggerButton("Set Default");
const defaultValuePort = op.inValue("Default", 0);
defaultValuePort.setUiAttribs({ "hidePort": true, "greyout": true });

// outputs
const siblingsPort = op.outObject("Children");
const valuePort = op.outNumber("Result", defaultValuePort.get());

// vars
const el = document.createElement("div");
el.addEventListener("dblclick", function ()
{
    valuePort.set(parseFloat(defaultValuePort.get()));
    inputValuePort.set(parseFloat(defaultValuePort.get()));
});
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__text-input");
el.classList.add("sidebar__reloadable");

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelTextNode = document.createTextNode(labelPort.get());
label.appendChild(labelTextNode);
el.appendChild(label);
// var inputWrapper = document.createElement('div');
// inputWrapper.classList.add('sidebar__text-input-input-wrapper');
// el.appendChild(inputWrapper);
const input = document.createElement("input");
input.classList.add("sidebar__text-input-input");
input.setAttribute("type", "text");
input.setAttribute("value", defaultValuePort.get());
// inputWrapper.appendChild(input);
el.appendChild(input);
input.addEventListener("input", onInput);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
defaultValuePort.onChange = onDefaultValueChanged;
op.onDelete = onDelete;
inputValuePort.onChange = onInputValuePortChanged;
setDefaultValueButtonPort.onTriggered = setDefaultValue;

// functions

function setDefaultValue()
{
    defaultValuePort.set(parseFloat(inputValuePort.get()));
    op.refreshParams();
}

function onInputValuePortChanged()
{
    let val = parseFloat(inputValuePort.get());
    if (isNaN(val)) { val = 0; }
    input.value = val;
    valuePort.set(val);
}

function onInput(ev)
{
    let newVal = parseFloat(ev.target.value);
    if (isNaN(newVal)) { newVal = 0; }
    valuePort.set(newVal);
    inputValuePort.set(newVal);
    op.refreshParams();
}

function onDefaultValueChanged()
{
    /*
    var defaultValue = defaultValuePort.get();
    valuePort.set(defaultValue);
    input.value = defaultValue;
    */
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;
    if (CABLES.UI)
    {
        op.setTitle("Number Input: " + labelText);
    }
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(element)
{
    if (element)
    {
        element.style.display = "block";
    }
}

function hideElement(element)
{
    if (element)
    {
        element.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(element)
{
    if (element && element.parentNode && element.parentNode.removeChild)
    {
        element.parentNode.removeChild(element);
    }
}


};

Ops.Sidebar.NumberInput_v2.prototype = new CABLES.Op();
CABLES.OPS["c4f3f1d7-de07-4c06-921e-32baeef4fc68"]={f:Ops.Sidebar.NumberInput_v2,objName:"Ops.Sidebar.NumberInput_v2"};




// **************************************************************
// 
// Ops.Sidebar.Presets_v2
// 
// **************************************************************

Ops.Sidebar.Presets_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Presets");
const siblingsPort = op.outObject("Children");

const inAddPreset = op.inTriggerButton("Add Preset");
const inUpdatePreset = op.inTriggerButton("Update current Preset");
const outIndex = op.outNumber("Index");

inAddPreset.onTriggered = addPreset;
inUpdatePreset.onTriggered = updatePreset;
parentPort.onChange = onParentChanged;

const presetPorts = [];
const presetTitlePorts = [];

const el = document.createElement("div");
el.classList.add("sidebar__item");
el.classList.add("sidebar__select");
const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);
const selectList = document.createElement("select");
selectList.classList.add("sidebar__select-select");
el.appendChild(selectList);

const MAX_PRESETS = 8;

for (let i = 0; i < MAX_PRESETS; i++)
{
    const inpTitle = op.inString("Preset Title " + i);
    const inp = op.inObject("Preset " + i);
    presetPorts.push(inp);
    presetTitlePorts.push(inpTitle);

    inpTitle.onLinkChanged = inp.onLinkChanged = updateSelect;
}

selectList.onchange = function ()
{
    outIndex.set(selectList.selectedIndex);
    setSidebar(selectList.options[selectList.selectedIndex].value);
};

op.patch.addEventListener("patchLoadEnd", initialize);
op.init = initialize;

function initialize()
{
    setTimeout(() =>
    {
        for (let i = 0; i < MAX_PRESETS; i++)
            if (presetPorts[i].isLinked())
                setSidebar(i);
        setSidebar(0);
    }, 1000);
}

function updateSelect()
{
    while (selectList.firstChild) selectList.removeChild(selectList.firstChild);

    for (let i = 0; i < MAX_PRESETS; i++)
    {
        if (presetPorts[i].isLinked())
        {
            const option = document.createElement("option");
            option.value = i;

            const other = presetPorts[i].links[0].getOtherPort(presetPorts[i]);

            // other.parent.removeListener("onTitleChange",updateSelect);

            // if (!other.parent.hasEventListener(other.parent.onTitlechangeevent))
            // other.parent.onTitlechangeevent = other.parent.addEventListener("onTitleChange", updateSelect);

            option.text = "" + presetTitlePorts[i].get();
            selectList.appendChild(option);
        }
    }
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function deSerializeSidebar(obj)
{
    if (!obj) return;
    if (!obj.ops) return;

    for (let i = 0; i < obj.ops.length; i++)
    {
        const theOp = op.patch.getOpById(obj.ops[i].id);
        if (theOp)
        {
            for (const portName in obj.ops[i].ports)
            {
                const p = theOp.getPortByName(portName);
                if (p)
                {
                    if (typeof obj.ops[i].ports[portName] !== "object")
                    {
                        p.set(obj.ops[i].ports[portName]);
                    }
                    else
                    {
                        p.set(obj.ops[i].ports[portName].value);
                    }
                }
                else
                {
                    op.warn("unknown preset");
                }

                const def = theOp.getPortByName("Input");
                if (def)
                {
                    def.set(obj.ops[i].ports[portName]);
                }
                const namedInPort = theOp.getPortByName("Input " + p.name);
                if (namedInPort)
                {
                    namedInPort.set(obj.ops[i].ports[portName]);
                }
            }
        }
    }
}

function setSidebar(idx)
{
    const obj = presetPorts[idx].get();
    deSerializeSidebar(obj);
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(element)
{
    if (element && element.parentNode && element.parentNode.removeChild)
    {
        element.parentNode.removeChild(element);
    }
}

function updatePreset()
{
    const r = serializeSidebar();
    const idx = selectList.options[selectList.selectedIndex].value;

    const valueOp = presetPorts[idx].links[0].getOtherPort(presetPorts[idx]).parent;
    valueOp.getPortByName("JSON String").set(JSON.stringify(r));
}

function serializeSidebar()
{
    const values = [];
    for (let i = 0; i < op.patch.ops.length; i++)
    {
        if (
            op.patch.ops[i].objName.indexOf("Ops.Sidebar.Sidebar") == -1 &&
            op.patch.ops[i].objName.indexOf("AsObject") == -1 &&
            op.patch.ops[i].objName.indexOf("Group") == -1 &&
            op.patch.ops[i].objName.indexOf("Preset") == -1 &&
            op.patch.ops[i].objName.indexOf("Ops.Sidebar") === 0
        )
        {
            let foundPort = false;

            const theOp = op.patch.ops[i];
            const p = {};
            p.id = theOp.id;
            p.objName = theOp.objName;
            p.ports = {};

            for (let j = 0; j < op.patch.ops[i].portsOut.length; j++)
            {
                if (theOp.portsOut[j].type == CABLES.OP_PORT_TYPE_VALUE)
                {
                    p.ports[theOp.portsOut[j].name] = theOp.portsOut[j].get();
                    foundPort = true;
                }
            }

            if (foundPort)values.push(p);
        }
    }

    const r = { "ops": values };

    if (CABLES.UI && gui) gui.setStateUnsaved();
    return r;
}

function addPreset()
{
    let freePort = 0;
    let i = 0;
    for (i = 0; i < MAX_PRESETS; i++)
    {
        if (!presetPorts[i].isLinked())
        {
            freePort = presetPorts[i];
            break;
        }
    }

    const r = serializeSidebar();

    const newOp = op.patch.addOp("Ops.Json.ParseObject_v2");

    newOp.getPortByName("JSON String").set(JSON.stringify(r));

    if (CABLES.UI) gui.patchView.centerSelectOp(newOp.id);

    op.patch.link(op, freePort.name, newOp, "Result");
}

op.serializeSidebar = serializeSidebar;
op.deSerializeSidebar = deSerializeSidebar;


};

Ops.Sidebar.Presets_v2.prototype = new CABLES.Op();
CABLES.OPS["9ef53cbc-f47b-4631-92f1-470bd40c2866"]={f:Ops.Sidebar.Presets_v2,objName:"Ops.Sidebar.Presets_v2"};




// **************************************************************
// 
// Ops.Sidebar.SideBarStyle
// 
// **************************************************************

Ops.Sidebar.SideBarStyle = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const parentPort = op.inObject("link"),
    inWidth = op.inInt("Width", 220),
    inBorderRadius = op.inFloat("Round Corners", 10),
    inColorSpecial = op.inString("Special Color", "#07f78c"),

    siblingsPort = op.outObject("childs");

inColorSpecial.onChange =
inBorderRadius.onChange =
inWidth.onChange = setStyle;

parentPort.onChange = onParentChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

let sideBarEle = null;

function setStyle()
{
    if (!sideBarEle) return;

    sideBarEle.style.setProperty("--sidebar-width", inWidth.get() + "px");

    sideBarEle.style.setProperty("--sidebar-color", inColorSpecial.get());

    sideBarEle.style.setProperty("--sidebar-border-radius", Math.round(inBorderRadius.get()) + "px");

    op.patch.emitEvent("sidebarStylesChanged");
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        siblingsPort.set(parent);
        sideBarEle = parent.parentElement.parentElement;
        setStyle();
    }
    else
    {
        sideBarEle = null;
    }
}

function showElement(el)
{
    if (!el) return;
    el.style.display = "block";
}

function hideElement(el)
{
    if (!el) return;
    el.style.display = "none";
}

function onDelete()
{
}


};

Ops.Sidebar.SideBarStyle.prototype = new CABLES.Op();
CABLES.OPS["87d78a59-c8d4-4269-a3f8-af273741aae4"]={f:Ops.Sidebar.SideBarStyle,objName:"Ops.Sidebar.SideBarStyle"};




// **************************************************************
// 
// Ops.Sidebar.SideBarSwitch
// 
// **************************************************************

Ops.Sidebar.SideBarSwitch = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const parentPort = op.inObject("link"),
    inArr = op.inArray("Names"),
    inStyle = op.inSwitch("Style", ["Tabs", "Switch"], "Switch"),
    labelPort = op.inString("Text", "Switch"),

    inInput = op.inInt("Input", 0),

    setDefaultValueButtonPort = op.inTriggerButton("Set Default"),
    inGreyOut = op.inBool("Grey Out", false),

    inDefault = op.inValue("Default", 0),

    siblingsPort = op.outObject("childs"),
    outIndex = op.outNumber("Index", -1),
    outStr = op.outString("String");

let elTabActive = null;
const el = document.createElement("div");
el.classList.add("sidebar__item");
el.dataset.op = op.id;
el.classList.add("cablesEle");
inDefault.setUiAttribs({ "greyout": true });

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

const switchGroup = document.createElement("div");
el.appendChild(switchGroup);

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

parentPort.onChange = onParentChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");
op.setPortGroup("Default Item", [inDefault, setDefaultValueButtonPort]);
const tabEles = [];

inArr.onChange = rebuildHtml;
inStyle.onChange = updateStyle;
updateStyle();

labelPort.onChange = () =>
{
    label.innerHTML = labelPort.get();
};

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

function rebuildHtml()
{
    tabEles.length = 0;
    switchGroup.innerHTML = "";
    elTabActive = null;

    const arr = inArr.get();
    if (!arr) return;

    for (let i = 0; i < arr.length; i++)
    {
        const el = addTab(String(arr[i]));
        if (i == inDefault.get())setActiveTab(el);
    }
}

setDefaultValueButtonPort.onTriggered = () =>
{
    inDefault.set(outIndex.get());
    op.refreshParams();
};

function updateStyle()
{
    if (inStyle.get() == "Tabs")
    {
        el.classList.add("sidebar_tabs");
        switchGroup.classList.remove("sidebar_switchs");
        label.style.display = "none";
    }
    else
    {
        el.classList.remove("sidebar_tabs");
        switchGroup.classList.add("sidebar_switchs");
        label.style.display = "inline-block";
    }

    labelPort.setUiAttribs({ "greyout": inStyle.get() == "Tabs" });

    rebuildHtml();
}

function addTab(title)
{
    const tabEle = document.createElement("div");

    if (inStyle.get() == "Tabs") tabEle.classList.add("sidebar_tab");
    else tabEle.classList.add("sidebar_switch");

    tabEle.id = "tabEle" + tabEles.length;
    tabEle.innerHTML = title;
    tabEle.dataset.index = tabEles.length;
    tabEle.dataset.txt = title;

    tabEle.addEventListener("click", tabClicked);

    switchGroup.appendChild(tabEle);

    tabEles.push(tabEle);

    return tabEle;
}

inInput.onChange = () =>
{
    if (tabEles.length > inInput.get())
        tabClicked({ "target": tabEles[inInput.get()] });
    // setActiveTab(tabEles[inInput.get()]);
};

function setActiveTab(el)
{
    if (el)
    {
        elTabActive = el;
        op.log(el.dataset.index);
        outIndex.set(parseInt(el.dataset.index));
        outStr.set(el.dataset.txt);

        if (inStyle.get() == "Tabs") el.classList.add("sidebar_tab_active");
        else el.classList.add("sidebar_switch_active");
    }
}

function tabClicked(e)
{
    if (elTabActive)
        if (inStyle.get() == "Tabs") elTabActive.classList.remove("sidebar_tab_active");
        else elTabActive.classList.remove("sidebar_switch_active");
    setActiveTab(e.target);
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    {
        if (el.parentElement)
            el.parentElement.removeChild(el);
    }
}

function showElement(el)
{
    if (!el) return;
    el.style.display = "block";
}

function hideElement(el)
{
    if (!el) return;
    el.style.display = "none";
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.SideBarSwitch.prototype = new CABLES.Op();
CABLES.OPS["ebc8c92c-5fa6-4598-a9c6-b8e12f22f7c2"]={f:Ops.Sidebar.SideBarSwitch,objName:"Ops.Sidebar.SideBarSwitch"};




// **************************************************************
// 
// Ops.Sidebar.Sidebar
// 
// **************************************************************

Ops.Sidebar.Sidebar = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"style_css":" /*\n * SIDEBAR\n  http://danielstern.ca/range.css/#/\n  https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-progress-value\n */\n\n.sidebar-icon-undo\n{\n    width:10px;\n    height:10px;\n    background-image: url(\"data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='grey' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 7v6h6'/%3E%3Cpath d='M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13'/%3E%3C/svg%3E\");\n    background-size: 19px;\n    background-repeat: no-repeat;\n    top: -19px;\n    margin-top: -7px;\n}\n\n.icon-chevron-down {\n    top: 2px;\n    right: 9px;\n}\n\n.iconsidebar-chevron-up,.sidebar__close-button {\n\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n}\n\n.iconsidebar-minimizebutton {\n    background-position: 98% center;\n    background-repeat: no-repeat;\n}\n\n.sidebar-cables-right\n{\n    right: 15px;\n    left: initial !important;\n}\n\n.sidebar-cables {\n    --sidebar-color: #07f78c;\n    --sidebar-width: 220px;\n    --sidebar-border-radius: 10px;\n    --sidebar-monospace-font-stack: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n    --sidebar-hover-transition-time: .2s;\n\n    position: absolute;\n    top: 15px;\n    left: 15px;\n    border-radius: var(--sidebar-border-radius);\n    z-index: 100000;\n    color: #BBBBBB;\n    width: var(  --sidebar-width);\n    max-height: 100%;\n    box-sizing: border-box;\n    overflow-y: auto;\n    overflow-x: hidden;\n    font-size: 13px;\n    font-family: Arial;\n    line-height: 1em; /* prevent emojis from breaking height of the title */\n}\n\n.sidebar-cables::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar-cables::-webkit-scrollbar {\n    background-color: transparent;\n    --cables-scrollbar-width: 8px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-track {\n    background-color: transparent;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables::-webkit-scrollbar-thumb {\n    background-color: #333333;\n    border-radius: 4px;\n    width: var(--cables-scrollbar-width);\n}\n\n.sidebar-cables--closed {\n    width: auto;\n}\n\n.sidebar__close-button {\n    background-color: #222;\n    /*-webkit-user-select: none;  */\n    /*-moz-user-select: none;     */\n    /*-ms-user-select: none;      */\n    /*user-select: none;          */\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    /*color: #CCCCCC;*/\n    height: 2px;\n    /*border-bottom:20px solid #222;*/\n\n    /*box-sizing: border-box;*/\n    /*padding-top: 2px;*/\n    /*text-align: center;*/\n    /*cursor: pointer;*/\n    /*border-radius: 0 0 var(--sidebar-border-radius) var(--sidebar-border-radius);*/\n    /*opacity: 1.0;*/\n    /*transition: opacity 0.3s;*/\n    /*overflow: hidden;*/\n}\n\n.sidebar__close-button-icon {\n    display: inline-block;\n    /*opacity: 0;*/\n    width: 20px;\n    height: 20px;\n    /*position: relative;*/\n    /*top: -1px;*/\n\n\n}\n\n.sidebar--closed {\n    width: auto;\n    margin-right: 20px;\n}\n\n.sidebar--closed .sidebar__close-button {\n    margin-top: 8px;\n    margin-left: 8px;\n    padding:10px;\n\n    height: 25px;\n    width:25px;\n    border-radius: 50%;\n    cursor: pointer;\n    opacity: 0.3;\n    background-repeat: no-repeat;\n    background-position: center center;\n    transform:rotate(180deg);\n}\n\n.sidebar--closed .sidebar__group\n{\n    display:none;\n\n}\n.sidebar--closed .sidebar__close-button-icon {\n    background-position: 0px 0px;\n}\n\n.sidebar__close-button:hover {\n    background-color: #111111;\n    opacity: 1.0 !important;\n}\n\n/*\n * SIDEBAR ITEMS\n */\n\n.sidebar__items {\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5;*/\n    background-color: #222;\n    padding-bottom: 20px;\n}\n\n.sidebar--closed .sidebar__items {\n    /* max-height: 0; */\n    height: 0;\n    display: none;\n    pointer-interactions: none;\n}\n\n.sidebar__item__right {\n    float: right;\n}\n\n/*\n * SIDEBAR GROUP\n */\n\n.sidebar__group {\n    /*background-color: #1A1A1A;*/\n    overflow: hidden;\n    box-sizing: border-box;\n    animate: height;\n    /*background-color: #151515;*/\n    /* max-height: 1000px; */\n    /* transition: max-height 0.5s; */\n--sidebar-group-header-height: 33px;\n}\n\n.sidebar__group-items\n{\n    padding-top: 15px;\n    padding-bottom: 15px;\n}\n\n.sidebar__group--closed {\n    /* max-height: 13px; */\n    height: var(--sidebar-group-header-height);\n}\n\n.sidebar__group-header {\n    box-sizing: border-box;\n    color: #EEEEEE;\n    background-color: #151515;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n\n    /*height: 100%;//var(--sidebar-group-header-height);*/\n\n    padding-top: 7px;\n    text-transform: uppercase;\n    letter-spacing: 0.08em;\n    cursor: pointer;\n    /*transition: background-color var(--sidebar-hover-transition-time);*/\n    position: relative;\n}\n\n.sidebar__group-header:hover {\n  background-color: #111111;\n}\n\n.sidebar__group-header-title {\n  /*float: left;*/\n  overflow: hidden;\n  padding: 0 15px;\n  padding-top:5px;\n  padding-bottom:10px;\n  font-weight:bold;\n}\n\n.sidebar__group-header-undo {\n    float: right;\n    overflow: hidden;\n    padding-right: 15px;\n    padding-top:5px;\n    font-weight:bold;\n  }\n\n.sidebar__group-header-icon {\n    width: 17px;\n    height: 14px;\n    background-repeat: no-repeat;\n    display: inline-block;\n    position: absolute;\n    background-size: cover;\n\n    /* icon open */\n    /* feather icon: chevron up */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tdXAiPjxwb2x5bGluZSBwb2ludHM9IjE4IDE1IDEyIDkgNiAxNSI+PC9wb2x5bGluZT48L3N2Zz4=);\n    top: 4px;\n    right: 5px;\n    opacity: 0.0;\n    transition: opacity 0.3;\n}\n\n.sidebar__group-header:hover .sidebar__group-header-icon {\n    opacity: 1.0;\n}\n\n/* icon closed */\n.sidebar__group--closed .sidebar__group-header-icon {\n    /* feather icon: chevron down */\n    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);\n    top: 4px;\n    right: 5px;\n}\n\n/*\n * SIDEBAR ITEM\n */\n\n.sidebar__item\n{\n    box-sizing: border-box;\n    padding: 7px;\n    padding-left:15px;\n    padding-right:15px;\n\n    overflow: hidden;\n    position: relative;\n}\n\n.sidebar__item-label {\n    display: inline-block;\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    width: calc(50% - 7px);\n    margin-right: 7px;\n    margin-top: 2px;\n    text-overflow: ellipsis;\n    /* overflow: hidden; */\n}\n\n.sidebar__item-value-label {\n    font-family: var(--sidebar-monospace-font-stack);\n    display: inline-block;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    max-width: 60%;\n}\n\n.sidebar__item-value-label::selection {\n    background-color: var(--sidebar-color);\n    color: #EEEEEE;\n}\n\n.sidebar__item + .sidebar__item,\n.sidebar__item + .sidebar__group,\n.sidebar__group + .sidebar__item,\n.sidebar__group + .sidebar__group {\n    /*border-top: 1px solid #272727;*/\n}\n\n/*\n * SIDEBAR ITEM TOGGLE\n */\n\n/*.sidebar__toggle */\n.icon_toggle{\n    cursor: pointer;\n}\n\n.sidebar__toggle-input {\n    --sidebar-toggle-input-color: #CCCCCC;\n    --sidebar-toggle-input-color-hover: #EEEEEE;\n    --sidebar-toggle-input-border-size: 2px;\n    display: inline;\n    float: right;\n    box-sizing: border-box;\n    border-radius: 50%;\n    cursor: pointer;\n    --toggle-size: 11px;\n    margin-top: 2px;\n    background-color: transparent !important;\n    border: var(--sidebar-toggle-input-border-size) solid var(--sidebar-toggle-input-color);\n    width: var(--toggle-size);\n    height: var(--toggle-size);\n    transition: background-color var(--sidebar-hover-transition-time);\n    transition: border-color var(--sidebar-hover-transition-time);\n}\n.sidebar__toggle:hover .sidebar__toggle-input {\n    border-color: var(--sidebar-toggle-input-color-hover);\n}\n\n.sidebar__toggle .sidebar__item-value-label {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    max-width: calc(50% - 12px);\n}\n.sidebar__toggle-input::after { clear: both; }\n\n.sidebar__toggle--active .icon_toggle\n{\n\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjMDZmNzhiIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iIzA2Zjc4YiIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjMDZmNzhiIiBzdHJva2U9IiMwNmY3OGIiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiMwNmY3OGIiIHN0cm9rZT0iIzA2Zjc4YiIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    opacity: 1;\n    transform: rotate(0deg);\n}\n\n\n.icon_toggle\n{\n    float: right;\n    width:40px;\n    height:18px;\n    background-image: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE1cHgiIHdpZHRoPSIzMHB4IiBmaWxsPSIjYWFhYWFhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTAwIDEwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZmlsbD0iI2FhYWFhYSIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCBjMTIuNjUsMCwyMy0xMC4zNSwyMy0yM2wwLDBjMC0xMi42NS0xMC4zNS0yMy0yMy0yM0gzMHogTTcwLDY3Yy05LjM4OSwwLTE3LTcuNjEtMTctMTdzNy42MTEtMTcsMTctMTdzMTcsNy42MSwxNywxNyAgICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PC9nPjwvZz48Zz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwLDI3QzE3LjM1LDI3LDcsMzcuMzUsNyw1MGwwLDBjMCwxMi42NSwxMC4zNSwyMywyMywyM2g0MCAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMweiBNNzAsNjdjLTkuMzg5LDAtMTctNy42MS0xNy0xN3M3LjYxMS0xNywxNy0xN3MxNyw3LjYxLDE3LDE3ICAgUzc5LjM4OSw2Nyw3MCw2N3oiPjwvcGF0aD48L2c+PGcgZGlzcGxheT0ibm9uZSI+PGcgZGlzcGxheT0iaW5saW5lIj48cGF0aCBmaWxsPSIjYWFhYWFhIiBzdHJva2U9IiNhYWFhYWEiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNNyw1MGMwLDEyLjY1LDEwLjM1LDIzLDIzLDIzaDQwICAgIGMxMi42NSwwLDIzLTEwLjM1LDIzLTIzbDAsMGMwLTEyLjY1LTEwLjM1LTIzLTIzLTIzSDMwQzE3LjM1LDI3LDcsMzcuMzUsNyw1MEw3LDUweiI+PC9wYXRoPjwvZz48Y2lyY2xlIGRpc3BsYXk9ImlubGluZSIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGw9IiNhYWFhYWEiIHN0cm9rZT0iI2FhYWFhYSIgc3Ryb2tlLXdpZHRoPSI0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGN4PSI3MCIgY3k9IjUwIiByPSIxNyI+PC9jaXJjbGU+PC9nPjxnIGRpc3BsYXk9Im5vbmUiPjxwYXRoIGRpc3BsYXk9ImlubGluZSIgZD0iTTcwLDI1SDMwQzE2LjIxNSwyNSw1LDM2LjIxNSw1LDUwczExLjIxNSwyNSwyNSwyNWg0MGMxMy43ODUsMCwyNS0xMS4yMTUsMjUtMjVTODMuNzg1LDI1LDcwLDI1eiBNNzAsNzEgICBIMzBDMTguNDIxLDcxLDksNjEuNTc5LDksNTBzOS40MjEtMjEsMjEtMjFoNDBjMTEuNTc5LDAsMjEsOS40MjEsMjEsMjFTODEuNTc5LDcxLDcwLDcxeiBNNzAsMzFjLTEwLjQ3NywwLTE5LDguNTIzLTE5LDE5ICAgczguNTIzLDE5LDE5LDE5czE5LTguNTIzLDE5LTE5UzgwLjQ3NywzMSw3MCwzMXogTTcwLDY1Yy04LjI3MSwwLTE1LTYuNzI5LTE1LTE1czYuNzI5LTE1LDE1LTE1czE1LDYuNzI5LDE1LDE1Uzc4LjI3MSw2NSw3MCw2NXoiPjwvcGF0aD48L2c+PC9zdmc+);\n    background-size: 50px 37px;\n    background-position: -6px -10px;\n    transform: rotate(180deg);\n    opacity: 0.4;\n}\n\n\n\n/*.sidebar__toggle--active .sidebar__toggle-input {*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    background-color: var(--sidebar-toggle-input-color);*/\n/*}*/\n/*.sidebar__toggle--active .sidebar__toggle-input:hover*/\n/*{*/\n/*    background-color: var(--sidebar-toggle-input-color-hover);*/\n/*    border-color: var(--sidebar-toggle-input-color-hover);*/\n/*    transition: background-color var(--sidebar-hover-transition-time);*/\n/*    transition: border-color var(--sidebar-hover-transition-time);*/\n/*}*/\n\n/*\n * SIDEBAR ITEM BUTTON\n */\n\n.sidebar__button {}\n\n.sidebar__button-input {\n    -webkit-user-select: none;  /* Chrome all / Safari all */\n    -moz-user-select: none;     /* Firefox all */\n    -ms-user-select: none;      /* IE 10+ */\n    user-select: none;          /* Likely future */\n    min-height: 24px;\n    background-color: transparent;\n    color: #CCCCCC;\n    box-sizing: border-box;\n    padding-top: 3px;\n    text-align: center;\n    border-radius: 125px;\n    border:2px solid #555;\n    cursor: pointer;\n    padding-bottom: 3px;\n}\n\n.sidebar__button-input.plus, .sidebar__button-input.minus {\n    display: inline-block;\n    min-width: 20px;\n}\n\n.sidebar__button-input:hover {\n  background-color: #333;\n  border:2px solid var(--sidebar-color);\n}\n\n/*\n * VALUE DISPLAY (shows a value)\n */\n\n.sidebar__value-display {}\n\n/*\n * SLIDER\n */\n\n.sidebar__slider {\n    --sidebar-slider-input-height: 3px;\n}\n\n.sidebar__slider-input-wrapper {\n    width: 100%;\n\n    margin-top: 8px;\n    position: relative;\n}\n\n.sidebar__slider-input {\n    -webkit-appearance: none;\n    appearance: none;\n    margin: 0;\n    width: 100%;\n    height: var(--sidebar-slider-input-height);\n    background: #555;\n    cursor: pointer;\n    outline: 0;\n\n    -webkit-transition: .2s;\n    transition: background-color .2s;\n    border: none;\n}\n\n.sidebar__slider-input:focus, .sidebar__slider-input:hover {\n    border: none;\n}\n\n.sidebar__slider-input-active-track {\n    user-select: none;\n    position: absolute;\n    z-index: 11;\n    top: 0;\n    left: 0;\n    background-color: var(--sidebar-color);\n    pointer-events: none;\n    height: var(--sidebar-slider-input-height);\n    max-width: 100%;\n}\n\n/* Mouse-over effects */\n.sidebar__slider-input:hover {\n    /*background-color: #444444;*/\n}\n\n/*.sidebar__slider-input::-webkit-progress-value {*/\n/*    background-color: green;*/\n/*    color:green;*/\n\n/*    }*/\n\n/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */\n\n.sidebar__slider-input::-moz-range-thumb\n{\n    position: absolute;\n    height: 15px;\n    width: 15px;\n    z-index: 900 !important;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: var(--sidebar-color) !important;\n    user-select: none;\n\n}\n\n.sidebar__slider-input::-webkit-slider-thumb\n{\n    position: relative;\n    appearance: none;\n    -webkit-appearance: none;\n    user-select: none;\n    height: 15px;\n    width: 15px;\n    display: block;\n    z-index: 900 !important;\n    border: 0;\n    border-radius: 20px !important;\n    cursor: pointer;\n    background: #777 !important;\n}\n\n.sidebar__slider-input:hover ::-webkit-slider-thumb {\n    background-color: #EEEEEE !important;\n}\n\n/*.sidebar__slider-input::-moz-range-thumb {*/\n\n/*    width: 0 !important;*/\n/*    height: var(--sidebar-slider-input-height);*/\n/*    background: #EEEEEE;*/\n/*    cursor: pointer;*/\n/*    border-radius: 0 !important;*/\n/*    border: none;*/\n/*    outline: 0;*/\n/*    z-index: 100 !important;*/\n/*}*/\n\n.sidebar__slider-input::-moz-range-track {\n    background-color: transparent;\n    z-index: 11;\n}\n\n/*.sidebar__slider-input::-moz-range-thumb:hover {*/\n  /* background-color: #EEEEEE; */\n/*}*/\n\n\n/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input-active-track {*/\n/*    background-color: #EEEEEE;*/\n/*}*/\n\n/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input::-moz-range-thumb {*/\n/*    background-color: #fff !important;*/\n/*}*/\n\n/*.sidebar__slider-input-wrapper:hover .sidebar__slider-input::-webkit-slider-thumb {*/\n/*    background-color: #EEEEEE;*/\n/*}*/\n\n.sidebar__slider input[type=text],\n.sidebar__slider input[type=paddword]\n{\n    box-sizing: border-box;\n    /*background-color: #333333;*/\n    text-align: right;\n    color: #BBBBBB;\n    display: inline-block;\n    background-color: transparent !important;\n\n    width: 40%;\n    height: 18px;\n    outline: none;\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n}\n\n.sidebar__slider input[type=text]:active,\n.sidebar__slider input[type=text]:focus,\n.sidebar__slider input[type=text]:hover\n.sidebar__slider input[type=password]:active,\n.sidebar__slider input[type=password]:focus,\n.sidebar__slider input[type=password]:hover\n{\n\n    color: #EEEEEE;\n}\n\n/*\n * TEXT / DESCRIPTION\n */\n\n.sidebar__text .sidebar__item-label {\n    width: auto;\n    display: block;\n    max-height: none;\n    margin-right: 0;\n    line-height: 1.1em;\n}\n\n/*\n * SIDEBAR INPUT\n */\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=text],\n.sidebar__text-input input[type=password] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: 50%;\n    height: 18px;\n    outline: none;\n    border: none;\n    border-radius: 0;\n    border:1px solid #666;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n}\n\n.sidebar__text-input textarea:focus::placeholder {\n  color: transparent;\n}\n\n.sidebar__color-picker .sidebar__item-label\n{\n    width:45%;\n}\n\n.sidebar__text-input textarea,\n.sidebar__text-input input[type=text]:active,\n.sidebar__text-input input[type=text]:focus,\n.sidebar__text-input input[type=text]:hover,\n.sidebar__text-input input[type=password]:active,\n.sidebar__text-input input[type=password]:focus,\n.sidebar__text-input input[type=password]:hover {\n    background-color: transparent;\n    color: #EEEEEE;\n}\n\n.sidebar__text-input textarea\n{\n    margin-top:10px;\n    height:60px;\n    width:100%;\n}\n\n/*\n * SIDEBAR SELECT\n */\n\n\n\n .sidebar__select {}\n .sidebar__select-select {\n    color: #BBBBBB;\n    /*-webkit-appearance: none;*/\n    /*-moz-appearance: none;*/\n    appearance: none;\n    /*box-sizing: border-box;*/\n    width: 50%;\n    /*height: 20px;*/\n    background-color: #333333;\n    /*background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODg4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0iZmVhdGhlciBmZWF0aGVyLWNoZXZyb24tZG93biI+PHBvbHlsaW5lIHBvaW50cz0iNiA5IDEyIDE1IDE4IDkiPjwvcG9seWxpbmU+PC9zdmc+);*/\n    background-repeat: no-repeat;\n    background-position: right center;\n    background-size: 16px 16px;\n    margin: 0;\n    /*padding: 0 2 2 6px;*/\n    border-radius: 5px;\n    border: 1px solid #777;\n    background-color: #444;\n    cursor: pointer;\n    outline: none;\n    padding-left: 5px;\n\n }\n\n.sidebar__select-select:hover,\n.sidebar__select-select:active,\n.sidebar__select-select:active {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\n/*\n * COLOR PICKER\n */\n\n\n .sidebar__color-picker input[type=text] {\n    box-sizing: border-box;\n    background-color: #333333;\n    color: #BBBBBB;\n    display: inline-block;\n    width: calc(50% - 21px); /* 50% minus space of picker circle */\n    height: 18px;\n    outline: none;\n    border: none;\n    border-radius: 0;\n    padding: 0 0 0 4px !important;\n    margin: 0;\n    margin-right: 7px;\n}\n\n.sidebar__color-picker input[type=text]:active,\n.sidebar__color-picker input[type=text]:focus,\n.sidebar__color-picker input[type=text]:hover {\n    background-color: #444444;\n    color: #EEEEEE;\n}\n\ndiv.sidebar__color-picker-color-input,\n.sidebar__color-picker input[type=color],\n.sidebar__palette-picker input[type=color] {\n    display: inline-block;\n    border-radius: 100%;\n    height: 14px;\n    width: 14px;\n\n    padding: 0;\n    border: none;\n    /*border:2px solid red;*/\n    border-color: transparent;\n    outline: none;\n    background: none;\n    appearance: none;\n    -moz-appearance: none;\n    -webkit-appearance: none;\n    cursor: pointer;\n    position: relative;\n    top: 3px;\n}\n.sidebar__color-picker input[type=color]:focus,\n.sidebar__palette-picker input[type=color]:focus {\n    outline: none;\n}\n.sidebar__color-picker input[type=color]::-moz-color-swatch,\n.sidebar__palette-picker input[type=color]::-moz-color-swatch {\n    border: none;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch-wrapper,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch-wrapper {\n    padding: 0;\n}\n.sidebar__color-picker input[type=color]::-webkit-color-swatch,\n.sidebar__palette-picker input[type=color]::-webkit-color-swatch {\n    border: none;\n    border-radius: 100%;\n}\n\n/*\n * Palette Picker\n */\n.sidebar__palette-picker .sidebar__palette-picker-color-input.first {\n    margin-left: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input.last {\n    margin-right: 0;\n}\n.sidebar__palette-picker .sidebar__palette-picker-color-input {\n    margin: 0 4px;\n}\n\n.sidebar__palette-picker .circlebutton {\n    width: 14px;\n    height: 14px;\n    border-radius: 1em;\n    display: inline-block;\n    top: 3px;\n    position: relative;\n}\n\n/*\n * Preset\n */\n.sidebar__item-presets-preset\n{\n    padding:4px;\n    cursor:pointer;\n    padding-left:8px;\n    padding-right:8px;\n    margin-right:4px;\n    background-color:#444;\n}\n\n.sidebar__item-presets-preset:hover\n{\n    background-color:#666;\n}\n\n.sidebar__greyout\n{\n    background: #222;\n    opacity: 0.8;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 1000;\n    right: 0;\n    top: 0;\n}\n\n.sidebar_tabs\n{\n    background-color: #151515;\n    padding-bottom: 0px;\n}\n\n.sidebar_switchs\n{\n    float: right;\n}\n\n.sidebar_tab\n{\n    float:left;\n    background-color: #151515;\n    border-bottom:1px solid transparent;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_tab_active\n{\n    background-color: #272727;\n    color:white;\n}\n\n.sidebar_tab:hover\n{\n    border-bottom:1px solid #777;\n    color:white;\n}\n\n\n.sidebar_switch\n{\n    float:left;\n    background-color: #444;\n    padding-right:7px;\n    padding-left:7px;\n    padding-bottom: 5px;\n    padding-top: 5px;\n    cursor:pointer;\n}\n\n.sidebar_switch:last-child\n{\n    border-top-right-radius: 7px;\n    border-bottom-right-radius: 7px;\n}\n\n.sidebar_switch:first-child\n{\n    border-top-left-radius: 7px;\n    border-bottom-left-radius: 7px;\n}\n\n\n.sidebar_switch_active\n{\n    background-color: #999;\n    color:white;\n}\n\n.sidebar_switch:hover\n{\n    color:white;\n}\n",};
// vars
const CSS_ELEMENT_CLASS = "cables-sidebar-style"; /* class for the style element to be generated */
const CSS_ELEMENT_DYNAMIC_CLASS = "cables-sidebar-dynamic-style"; /* things which can be set via op-port, but not attached to the elements themselves, e.g. minimized opacity */
const SIDEBAR_CLASS = "sidebar-cables";
const SIDEBAR_ID = "sidebar" + CABLES.uuid();
const SIDEBAR_ITEMS_CLASS = "sidebar__items";
const SIDEBAR_OPEN_CLOSE_BTN_CLASS = "sidebar__close-button";

const BTN_TEXT_OPEN = ""; // 'Close';
const BTN_TEXT_CLOSED = ""; // 'Show Controls';

let openCloseBtn = null;
let openCloseBtnIcon = null;
let headerTitleText = null;

// inputs
const visiblePort = op.inValueBool("Visible", true);
const opacityPort = op.inValueSlider("Opacity", 1);
const defaultMinimizedPort = op.inValueBool("Default Minimized");
const minimizedOpacityPort = op.inValueSlider("Minimized Opacity", 0.5);
const undoButtonPort = op.inValueBool("Show undo button", false);
const inMinimize = op.inValueBool("Show Minimize", false);

const inTitle = op.inString("Title", "Sidebar");
const side = op.inValueBool("Side");

// outputs
const childrenPort = op.outObject("childs");
childrenPort.setUiAttribs({ "title": "Children" });

const isOpenOut = op.outBool("Opfened");
isOpenOut.setUiAttribs({ "title": "Opened" });

let sidebarEl = document.querySelector("." + SIDEBAR_ID);
if (!sidebarEl)
{
    sidebarEl = initSidebarElement();
}
// if(!sidebarEl) return;
const sidebarItemsEl = sidebarEl.querySelector("." + SIDEBAR_ITEMS_CLASS);
childrenPort.set({
    "parentElement": sidebarItemsEl,
    "parentOp": op,
});
onDefaultMinimizedPortChanged();
initSidebarCss();
updateDynamicStyles();

// change listeners
visiblePort.onChange = onVisiblePortChange;
opacityPort.onChange = onOpacityPortChange;
defaultMinimizedPort.onChange = onDefaultMinimizedPortChanged;
minimizedOpacityPort.onChange = onMinimizedOpacityPortChanged;
undoButtonPort.onChange = onUndoButtonChange;
op.onDelete = onDelete;

// functions

function onMinimizedOpacityPortChanged()
{
    updateDynamicStyles();
}

inMinimize.onChange = updateMinimize;

function updateMinimize(header)
{
    if (!header || header.uiAttribs) header = document.querySelector(".sidebar-cables .sidebar__group-header");
    if (!header) return;

    const undoButton = document.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");

    if (inMinimize.get())
    {
        header.classList.add("iconsidebar-chevron-up");
        header.classList.add("iconsidebar-minimizebutton");

        if (undoButton)undoButton.style.marginRight = "20px";
    }
    else
    {
        header.classList.remove("iconsidebar-chevron-up");
        header.classList.remove("iconsidebar-minimizebutton");

        if (undoButton)undoButton.style.marginRight = "initial";
    }
}

side.onChange = function ()
{
    if (side.get()) sidebarEl.classList.add("sidebar-cables-right");
    else sidebarEl.classList.remove("sidebar-cables-right");
};

function onUndoButtonChange()
{
    const header = document.querySelector(".sidebar-cables .sidebar__group-header");
    if (header)
    {
        initUndoButton(header);
    }
}

function initUndoButton(header)
{
    if (header)
    {
        const undoButton = document.querySelector(".sidebar-cables .sidebar__group-header .sidebar__group-header-undo");
        if (undoButton)
        {
            if (!undoButtonPort.get())
            {
                // header.removeChild(undoButton);
                undoButton.remove();
            }
        }
        else
        {
            if (undoButtonPort.get())
            {
                const headerUndo = document.createElement("span");
                headerUndo.classList.add("sidebar__group-header-undo");
                headerUndo.classList.add("sidebar-icon-undo");

                headerUndo.addEventListener("click", function (event)
                {
                    event.stopPropagation();
                    const reloadables = document.querySelectorAll(".sidebar-cables .sidebar__reloadable");
                    const doubleClickEvent = document.createEvent("MouseEvents");
                    doubleClickEvent.initEvent("dblclick", true, true);
                    reloadables.forEach((reloadable) =>
                    {
                        reloadable.dispatchEvent(doubleClickEvent);
                    });
                });
                header.appendChild(headerUndo);
            }
        }
    }
    updateMinimize(header);
}

function onDefaultMinimizedPortChanged()
{
    if (!openCloseBtn) { return; }
    if (defaultMinimizedPort.get())
    {
        sidebarEl.classList.add("sidebar--closed");
        if (visiblePort.get())
        {
            isOpenOut.set(false);
        }
        // openCloseBtn.textContent = BTN_TEXT_CLOSED;
    }
    else
    {
        sidebarEl.classList.remove("sidebar--closed");
        if (visiblePort.get())
        {
            isOpenOut.set(true);
        }
        // openCloseBtn.textContent = BTN_TEXT_OPEN;
    }
}

function onOpacityPortChange()
{
    const opacity = opacityPort.get();
    sidebarEl.style.opacity = opacity;
}

function onVisiblePortChange()
{
    if (visiblePort.get())
    {
        sidebarEl.style.display = "block";
        if (!sidebarEl.classList.contains("sidebar--closed"))
        {
            isOpenOut.set(true);
        }
    }
    else
    {
        sidebarEl.style.display = "none";
        isOpenOut.set(false);
    }
}

side.onChanged = function ()
{

};

/**
 * Some styles cannot be set directly inline, so a dynamic stylesheet is needed.
 * Here hover states can be set later on e.g.
 */
function updateDynamicStyles()
{
    const dynamicStyles = document.querySelectorAll("." + CSS_ELEMENT_DYNAMIC_CLASS);
    if (dynamicStyles)
    {
        dynamicStyles.forEach(function (e)
        {
            e.parentNode.removeChild(e);
        });
    }
    const newDynamicStyle = document.createElement("style");
    newDynamicStyle.classList.add(CSS_ELEMENT_DYNAMIC_CLASS);
    let cssText = ".sidebar--closed .sidebar__close-button { ";
    cssText += "opacity: " + minimizedOpacityPort.get();
    cssText += "}";
    const cssTextEl = document.createTextNode(cssText);
    newDynamicStyle.appendChild(cssTextEl);
    document.body.appendChild(newDynamicStyle);
}

function initSidebarElement()
{
    const element = document.createElement("div");
    element.classList.add(SIDEBAR_CLASS);
    element.classList.add(SIDEBAR_ID);
    const canvasWrapper = op.patch.cgl.canvas.parentElement; /* maybe this is bad outside cables!? */

    // header...
    const headerGroup = document.createElement("div");
    headerGroup.classList.add("sidebar__group");

    element.appendChild(headerGroup);
    const header = document.createElement("div");
    header.classList.add("sidebar__group-header");

    element.appendChild(header);
    const headerTitle = document.createElement("span");
    headerTitle.classList.add("sidebar__group-header-title");
    headerTitleText = document.createElement("span");
    headerTitleText.classList.add("sidebar__group-header-title-text");
    headerTitleText.innerHTML = inTitle.get();
    headerTitle.appendChild(headerTitleText);
    header.appendChild(headerTitle);

    initUndoButton(header);
    updateMinimize(header);

    headerGroup.appendChild(header);
    element.appendChild(headerGroup);
    headerGroup.addEventListener("click", onOpenCloseBtnClick);

    if (!canvasWrapper)
    {
        op.warn("[sidebar] no canvas parentelement found...");
        return;
    }
    canvasWrapper.appendChild(element);
    const items = document.createElement("div");
    items.classList.add(SIDEBAR_ITEMS_CLASS);
    element.appendChild(items);
    openCloseBtn = document.createElement("div");
    openCloseBtn.classList.add(SIDEBAR_OPEN_CLOSE_BTN_CLASS);
    openCloseBtn.addEventListener("click", onOpenCloseBtnClick);
    // openCloseBtn.textContent = BTN_TEXT_OPEN;
    element.appendChild(openCloseBtn);
    // openCloseBtnIcon = document.createElement("span");

    // openCloseBtnIcon.classList.add("sidebar__close-button-icon");
    // openCloseBtnIcon.classList.add("iconsidebar-chevron-up");

    // openCloseBtn.appendChild(openCloseBtnIcon);

    return element;
}

inTitle.onChange = function ()
{
    if (headerTitleText)headerTitleText.innerHTML = inTitle.get();
};

function setClosed(b)
{

}

function onOpenCloseBtnClick(ev)
{
    ev.stopPropagation();
    if (!sidebarEl) { op.logError("Sidebar could not be closed..."); return; }
    sidebarEl.classList.toggle("sidebar--closed");
    const btn = ev.target;
    let btnText = BTN_TEXT_OPEN;
    if (sidebarEl.classList.contains("sidebar--closed"))
    {
        btnText = BTN_TEXT_CLOSED;
        isOpenOut.set(false);
    }
    else
    {
        isOpenOut.set(true);
    }
}

function initSidebarCss()
{
    // var cssEl = document.getElementById(CSS_ELEMENT_ID);
    const cssElements = document.querySelectorAll("." + CSS_ELEMENT_CLASS);
    // remove old script tag
    if (cssElements)
    {
        cssElements.forEach(function (e)
        {
            e.parentNode.removeChild(e);
        });
    }
    const newStyle = document.createElement("style");
    newStyle.innerHTML = attachments.style_css;
    newStyle.classList.add(CSS_ELEMENT_CLASS);
    document.body.appendChild(newStyle);
}

function onDelete()
{
    removeElementFromDOM(sidebarEl);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild) el.parentNode.removeChild(el);
}


};

Ops.Sidebar.Sidebar.prototype = new CABLES.Op();
CABLES.OPS["5a681c35-78ce-4cb3-9858-bc79c34c6819"]={f:Ops.Sidebar.Sidebar,objName:"Ops.Sidebar.Sidebar"};




// **************************************************************
// 
// Ops.Sidebar.SidebarText_v2
// 
// **************************************************************

Ops.Sidebar.SidebarText_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Value");
const inId = op.inValueString("Id", "");

// outputs
const siblingsPort = op.outObject("childs");

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__text");
const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createElement("div");// document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inId.onChange = onIdChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

// functions

function onIdChanged()
{
    el.id = inId.get();
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.innerHTML = labelText;
    if (CABLES.UI)
    {
        if (labelText && typeof labelText === "string")
        {
            op.setTitle("Text: " + labelText.substring(0, 10)); // display first 10 characters of text in op title
        }
        else
        {
            op.setTitle("Text");
        }
    }
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.SidebarText_v2.prototype = new CABLES.Op();
CABLES.OPS["cc591cc3-ff23-4817-907c-e5be7d5c059d"]={f:Ops.Sidebar.SidebarText_v2,objName:"Ops.Sidebar.SidebarText_v2"};




// **************************************************************
// 
// Ops.Sidebar.SidebarVariables
// 
// **************************************************************

Ops.Sidebar.SidebarVariables = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// inputs
let parentPort = op.inObject("link");
let inId = op.inValueString("Id", "");
let inUpdate = op.inTriggerButton("update");

// outputs
let siblingsPort = op.outObject("childs");

// vars
let el = document.createElement("div");
el.classList.add("sidebar__item");
el.classList.add("sidebar__text");
let label = document.createElement("div");
// label.classList.add('sidebar__item-label');

el.appendChild(label);

// events
parentPort.onChange = onParentChanged;
inUpdate.onTriggered = update;

inId.onChange = onIdChanged;
op.onDelete = onDelete;

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");

update();

// functions

function onIdChanged()
{
    el.id = inId.get();
}

function update()
{
    // var labelText = labelPort.get();
    // label.textContent = labelText;
    // if(CABLES.UI) {
    //     if(labelText && typeof labelText === 'string') {
    //         op.setTitle('Text: ' + labelText.substring(0, 10)); // display first 10 characters of text in op title
    //     } else {
    //         op.setTitle('Text');
    //     }
    // }

    let vars = op.patch.getVars();
    let html = "<table style=\"font-size:13px;\">";
    for (let ki in vars)
    {
        let v = vars[ki].getValue();

        if (typeof v == "object") v = "[object]";
        html += "<tr><td>" + ki + "</td><td><b>" + v + "</b></td></tr>";
    }
    html += "</table>";

    label.innerHTML = html;
}

function onParentChanged()
{
    siblingsPort.set(null);
    let parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.SidebarVariables.prototype = new CABLES.Op();
CABLES.OPS["55e502d6-0360-41aa-9c84-deb9f9e0be24"]={f:Ops.Sidebar.SidebarVariables,objName:"Ops.Sidebar.SidebarVariables"};




// **************************************************************
// 
// Ops.Sidebar.Slider_v3
// 
// **************************************************************

Ops.Sidebar.Slider_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// constants
const STEP_DEFAULT = 0.00001;

// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Slider");
const minPort = op.inValue("Min", 0);
const maxPort = op.inValue("Max", 1);
const stepPort = op.inValue("Step", STEP_DEFAULT);
const labelSuffix = op.inString("Suffix", "");

const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);

const inputValuePort = op.inValue("Input", 0.5);
const setDefaultValueButtonPort = op.inTriggerButton("Set Default");
const reset = op.inTriggerButton("Reset");

let parent = null;

const defaultValuePort = op.inValue("Default", 0.5);
defaultValuePort.setUiAttribs({ "hidePort": true, "greyout": true });

// outputs
const siblingsPort = op.outObject("childs");
const valuePort = op.outNumber("Result", defaultValuePort.get());

op.toWorkNeedsParent("Ops.Sidebar.Sidebar");
op.setPortGroup("Range", [minPort, maxPort, stepPort]);
op.setPortGroup("Display", [inGreyOut, inVisible]);

// vars
const el = document.createElement("div");
el.addEventListener("dblclick", function ()
{
    valuePort.set(parseFloat(defaultValuePort.get()));
    inputValuePort.set(parseFloat(defaultValuePort.get()));
});

el.dataset.op = op.id;
el.classList.add("cablesEle");

el.classList.add("sidebar__item");
el.classList.add("sidebar__slider");
el.classList.add("sidebar__reloadable");

op.patch.on("sidebarStylesChanged", () => { updateActiveTrack(); });

const label = document.createElement("div");
label.classList.add("sidebar__item-label");

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

const value = document.createElement("input");
value.value = defaultValuePort.get();
value.classList.add("sidebar__text-input-input");
value.setAttribute("type", "text");
value.oninput = onTextInputChanged;
el.appendChild(value);

const suffixEle = document.createElement("span");
// setValueFieldValue(defaultValuePort).get();
// value.setAttribute("type", "text");
// value.oninput = onTextInputChanged;

el.appendChild(suffixEle);

labelSuffix.onChange = () =>
{
    suffixEle.innerHTML = labelSuffix.get();
};

const inputWrapper = document.createElement("div");
inputWrapper.classList.add("sidebar__slider-input-wrapper");
el.appendChild(inputWrapper);

const activeTrack = document.createElement("div");
activeTrack.classList.add("sidebar__slider-input-active-track");
inputWrapper.appendChild(activeTrack);
const input = document.createElement("input");
input.classList.add("sidebar__slider-input");
input.setAttribute("min", minPort.get());
input.setAttribute("max", maxPort.get());
input.setAttribute("type", "range");
input.setAttribute("step", stepPort.get());
input.setAttribute("value", defaultValuePort.get());
input.style.display = "block"; /* needed because offsetWidth returns 0 otherwise */
inputWrapper.appendChild(input);

updateActiveTrack();
input.addEventListener("input", onSliderInput);

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inputValuePort.onChange = onInputValuePortChanged;
defaultValuePort.onChange = onDefaultValueChanged;
setDefaultValueButtonPort.onTriggered = onSetDefaultValueButtonPress;
minPort.onChange = onMinPortChange;
maxPort.onChange = onMaxPortChange;
stepPort.onChange = stepPortChanged;
op.onDelete = onDelete;

// op.onLoadedValueSet=function()
op.onLoaded = op.onInit = function ()
{
    if (op.patch.config.sidebar)
    {
        op.patch.config.sidebar[labelPort.get()];
        valuePort.set(op.patch.config.sidebar[labelPort.get()]);
    }
    else
    {
        valuePort.set(parseFloat(defaultValuePort.get()));
        inputValuePort.set(parseFloat(defaultValuePort.get()));
        // onInputValuePortChanged();
    }
};

reset.onTriggered = function ()
{
    const newValue = parseFloat(defaultValuePort.get());
    valuePort.set(newValue);
    setValueFieldValue(newValue);
    setInputFieldValue(newValue);
    inputValuePort.set(newValue);
    updateActiveTrack();
};

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

function onTextInputChanged(ev)
{
    let newValue = parseFloat(ev.target.value);
    if (isNaN(newValue)) newValue = 0;
    const min = minPort.get();
    const max = maxPort.get();
    if (newValue < min) { newValue = min; }
    else if (newValue > max) { newValue = max; }
    // setInputFieldValue(newValue);
    valuePort.set(newValue);
    updateActiveTrack();
    inputValuePort.set(newValue);
    op.refreshParams();
}

function onInputValuePortChanged()
{
    let newValue = parseFloat(inputValuePort.get());
    const minValue = minPort.get();
    const maxValue = maxPort.get();
    if (newValue > maxValue) { newValue = maxValue; }
    else if (newValue < minValue) { newValue = minValue; }
    setValueFieldValue(newValue);
    setInputFieldValue(newValue);
    valuePort.set(newValue);
    updateActiveTrack();
}

function onSetDefaultValueButtonPress()
{
    let newValue = parseFloat(inputValuePort.get());
    const minValue = minPort.get();
    const maxValue = maxPort.get();
    if (newValue > maxValue) { newValue = maxValue; }
    else if (newValue < minValue) { newValue = minValue; }
    setValueFieldValue(newValue);
    setInputFieldValue(newValue);
    valuePort.set(newValue);
    defaultValuePort.set(newValue);
    op.refreshParams();

    updateActiveTrack();
}

function onSliderInput(ev)
{
    ev.preventDefault();
    ev.stopPropagation();
    setValueFieldValue(ev.target.value);
    const inputFloat = parseFloat(ev.target.value);
    valuePort.set(inputFloat);
    inputValuePort.set(inputFloat);
    op.refreshParams();

    updateActiveTrack();
    return false;
}

function stepPortChanged()
{
    const step = stepPort.get();
    input.setAttribute("step", step);
    updateActiveTrack();
}

function updateActiveTrack(val)
{
    let valueToUse = parseFloat(input.value);
    if (typeof val !== "undefined") valueToUse = val;
    let availableWidth = activeTrack.parentElement.getBoundingClientRect().width || 220;
    if (parent) availableWidth = parseInt(getComputedStyle(parent.parentElement).getPropertyValue("--sidebar-width")) - 20;

    const trackWidth = CABLES.map(
        valueToUse,
        parseFloat(input.min),
        parseFloat(input.max),
        0,
        availableWidth - 16 /* subtract slider thumb width */
    );
    activeTrack.style.width = trackWidth + "px";
}

function onMinPortChange()
{
    const min = minPort.get();
    input.setAttribute("min", min);
    updateActiveTrack();
}

function onMaxPortChange()
{
    const max = maxPort.get();
    input.setAttribute("max", max);
    updateActiveTrack();
}

function onDefaultValueChanged()
{
    const defaultValue = defaultValuePort.get();
    valuePort.set(parseFloat(defaultValue));
    onMinPortChange();
    onMaxPortChange();
    setInputFieldValue(defaultValue);
    setValueFieldValue(defaultValue);

    updateActiveTrack(defaultValue); // needs to be passed as argument, is this async?
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;
    if (CABLES.UI) op.setTitle("Slider: " + labelText);
}

function onParentChanged()
{
    siblingsPort.set(null);
    parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else if (el.parentElement) el.parentElement.removeChild(el);

    updateActiveTrack();
}

function setValueFieldValue(v)
{
    value.value = v;
}

function setInputFieldValue(v)
{
    input.value = v;
}

function showElement(el)
{
    if (el)el.style.display = "block";
}

function hideElement(el)
{
    if (el)el.style.display = "none";
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild) el.parentNode.removeChild(el);
}


};

Ops.Sidebar.Slider_v3.prototype = new CABLES.Op();
CABLES.OPS["74730122-5cba-4d0d-b610-df334ec6220a"]={f:Ops.Sidebar.Slider_v3,objName:"Ops.Sidebar.Slider_v3"};




// **************************************************************
// 
// Ops.Sidebar.TextInput_v2
// 
// **************************************************************

Ops.Sidebar.TextInput_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    parentPort = op.inObject("Link"),
    labelPort = op.inString("Text", "Text"),
    defaultValuePort = op.inString("Default", ""),
    inPlaceholder = op.inString("Placeholder", ""),
    inType = op.inSwitch("Type", ["text", "password"], "text"),
    inTextArea = op.inBool("TextArea", false),
    inGreyOut = op.inBool("Grey Out", false),
    inVisible = op.inBool("Visible", true),
    inClear = op.inTriggerButton("Clear"),
    siblingsPort = op.outObject("Children"),
    valuePort = op.outString("Result", defaultValuePort.get()),
    outFocus = op.outBool("Focus");

const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__text-input");
el.classList.add("sidebar__reloadable");

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

label.addEventListener("dblclick", function ()
{
    valuePort.set(defaultValuePort.get());
    input.value = defaultValuePort.get();
});

let input = null;
creatElement();

op.toWorkPortsNeedToBeLinked(parentPort);

inTextArea.onChange = creatElement;
inType.onChange = setAttribs;

function setAttribs()
{
    input.setAttribute("type", inType.get());
    input.setAttribute("value", defaultValuePort.get());
    input.setAttribute("placeholder", inPlaceholder.get());
}

function creatElement()
{
    if (input)input.remove();
    if (!inTextArea.get())
    {
        input = document.createElement("input");
    }
    else
    {
        input = document.createElement("textarea");
        onDefaultValueChanged();
    }

    input.classList.add("sidebar__text-input-input");

    setAttribs();

    el.appendChild(input);
    input.addEventListener("input", onInput);
    input.addEventListener("focus", onFocus);
    input.addEventListener("blur", onBlur);
}

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

inClear.onTriggered = () =>
{
    input.value = "";
};

function onFocus()
{
    outFocus.set(true);
}

function onBlur()
{
    outFocus.set(false);
}

inPlaceholder.onChange = () =>
{
    input.setAttribute("placeholder", inPlaceholder.get());
};

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
defaultValuePort.onChange = onDefaultValueChanged;
op.onDelete = onDelete;

// functions

function onInput(ev)
{
    valuePort.set(ev.target.value);
}

function onDefaultValueChanged()
{
    const defaultValue = defaultValuePort.get();
    valuePort.set(defaultValue);
    input.value = defaultValue;
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;
    if (CABLES.UI)
    {
        op.setTitle("Text Input: " + labelText);
    }
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else
    { // detach
        if (el.parentElement)
        {
            el.parentElement.removeChild(el);
        }
    }
}

function showElement(el)
{
    if (el)
    {
        el.style.display = "block";
    }
}

function hideElement(el)
{
    if (el)
    {
        el.style.display = "none";
    }
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.TextInput_v2.prototype = new CABLES.Op();
CABLES.OPS["6538a190-e73c-451b-964e-d010ee267aa9"]={f:Ops.Sidebar.TextInput_v2,objName:"Ops.Sidebar.TextInput_v2"};




// **************************************************************
// 
// Ops.Sidebar.Toggle_v3
// 
// **************************************************************

Ops.Sidebar.Toggle_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const DEFAULT_VALUE_DEFAULT = true;

// inputs
const parentPort = op.inObject("link");
const labelPort = op.inString("Text", "Toggle");
const inputValuePort = op.inValueBool("Input", DEFAULT_VALUE_DEFAULT);
const setDefaultValueButtonPort = op.inTriggerButton("Set Default");
const defaultValuePort = op.inValueBool("Default", DEFAULT_VALUE_DEFAULT);
defaultValuePort.setUiAttribs({ "hidePort": true, "greyout": true });
const inGreyOut = op.inBool("Grey Out", false);
const inVisible = op.inBool("Visible", true);

// outputs
const siblingsPort = op.outObject("childs");
const valuePort = op.outNumber("Value", defaultValuePort.get());

// vars
const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.classList.add("sidebar__item");
el.classList.add("sidebar__toggle");
el.classList.add("sidebar__reloadable");

if (DEFAULT_VALUE_DEFAULT) el.classList.add("sidebar__toggle--active");

el.addEventListener("dblclick", function ()
{
    valuePort.set(defaultValuePort.get());
    inputValuePort.set(defaultValuePort.get());
});

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelText = document.createTextNode(labelPort.get());
label.appendChild(labelText);
el.appendChild(label);

const icon = document.createElement("div");
icon.classList.add("icon_toggle");
icon.addEventListener("click", onInputClick);
el.appendChild(icon);

const greyOut = document.createElement("div");
greyOut.classList.add("sidebar__greyout");
el.appendChild(greyOut);
greyOut.style.display = "none";

// events
parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
inputValuePort.onChange = onInputValuePortChanged;
op.onDelete = onDelete;
setDefaultValueButtonPort.onTriggered = setDefaultValue;

function setDefaultValue()
{
    const defaultValue = inputValuePort.get();

    defaultValuePort.set(defaultValue);
    valuePort.set(defaultValue);
    op.refreshParams();
}

function onInputClick()
{
    el.classList.toggle("sidebar__toggle--active");
    if (el.classList.contains("sidebar__toggle--active"))
    {
        valuePort.set(true);
        inputValuePort.set(true);
        icon.classList.add("icon_toggle_true");
        icon.classList.remove("icon_toggle_false");
    }
    else
    {
        icon.classList.remove("icon_toggle_true");
        icon.classList.add("icon_toggle_false");

        valuePort.set(false);
        inputValuePort.set(false);
    }
    op.refreshParams();
}

function onInputValuePortChanged()
{
    const inputValue = inputValuePort.get();
    if (inputValue)
    {
        el.classList.add("sidebar__toggle--active");
        valuePort.set(true);
    }
    else
    {
        el.classList.remove("sidebar__toggle--active");
        valuePort.set(false);
    }
}

function onLabelTextChanged()
{
    const text = labelPort.get();
    label.textContent = text;
    if (CABLES.UI) op.setTitle("Toggle: " + text);
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else if (el.parentElement) el.parentElement.removeChild(el);
}

function showElement(element)
{
    if (element) element.style.display = "block";
}

function hideElement(element)
{
    if (element) element.style.display = "none";
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(element)
{
    if (element && element.parentNode && element.parentNode.removeChild) element.parentNode.removeChild(el);
}

inGreyOut.onChange = function ()
{
    greyOut.style.display = inGreyOut.get() ? "block" : "none";
};

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};


};

Ops.Sidebar.Toggle_v3.prototype = new CABLES.Op();
CABLES.OPS["fb60ab7d-f2f2-4fc5-bcd0-88c6ed481908"]={f:Ops.Sidebar.Toggle_v3,objName:"Ops.Sidebar.Toggle_v3"};




// **************************************************************
// 
// Ops.Sidebar.XYPad
// 
// **************************************************************

Ops.Sidebar.XYPad = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    parentPort = op.inObject("Link"),
    labelPort = op.inString("Text", "XY Pad"),
    inRange = op.inSwitch("Range", ["0-1", "-1-1"], "0-1"),
    inputX = op.inValueSlider("Input X", 0),
    inputY = op.inValueSlider("Input Y", 0),

    flipX = op.inBool("Flip X", false),
    flipY = op.inBool("Flip Y", false),

    setDefaultValueButtonPort = op.inTriggerButton("Set Default"),
    defaultValuePortX = op.inValueString("Default X", 0.5),
    defaultValuePortY = op.inValueString("Default Y", 0.5),

    inVisible = op.inBool("Visible", true);

const siblingsPort = op.outObject("Children");

defaultValuePortX.setUiAttribs({ "hidePort": true, "greyout": true });
defaultValuePortY.setUiAttribs({ "hidePort": true, "greyout": true });

const outX = op.outNumber("X", 0.0);
const outY = op.outNumber("Y", 0.0);

const el = document.createElement("div");
el.dataset.op = op.id;
el.classList.add("cablesEle");
el.addEventListener("dblclick", function ()
{
    setOutValue(defaultValuePortX.get(), defaultValuePortY.get());
    redraw();
});

el.classList.add("sidebar__item");
el.classList.add("sidebar__color-picker");
el.classList.add("sidebar__reloadable");

const label = document.createElement("div");
label.classList.add("sidebar__item-label");
const labelTextNode = document.createTextNode(labelPort.get());
label.appendChild(labelTextNode);
el.appendChild(label);

const valueX = document.createElement("input");
valueX.classList.add("sidebar__text-input-input");
valueX.setAttribute("type", "text");
valueX.style.width = "40px";
valueX.style.backgroundColor = "transparent";
el.appendChild(valueX);

const valueY = document.createElement("input");
valueY.classList.add("sidebar__text-input-input");
valueY.setAttribute("type", "text");
valueY.style.width = "40px";
valueY.style.backgroundColor = "transparent";
el.appendChild(valueY);

valueX.addEventListener("input", valueInputChanged);
valueY.addEventListener("input", valueInputChanged);
setDefaultValueButtonPort.onTriggered = setDefaultValues;

inVisible.onChange = function ()
{
    el.style.display = inVisible.get() ? "block" : "none";
};

function valueInputChanged()
{
    let x = parseFloat(valueX.value);
    let y = parseFloat(valueY.value);

    if (x != x || y != y) return;

    let minX = 0;
    let maxX = 1;
    let minY = 0;
    let maxY = 1;

    x = Math.max(Math.min(x, maxX), minX);
    y = Math.max(Math.min(y, maxY), minY);

    if (inRange.get() == "-1-1")
    {
        minY = minX = -1;
        maxY = maxX = 1;
    }

    setOutValue(
        CABLES.map(x, minX, maxX, 0, 1),
        CABLES.map(y, minY, maxY, 0, 1)
    );
}

const size = 190;

const canv = document.createElement("canvas");
canv.width = canv.height = size;
canv.style.width = size + "px";
canv.style.height = size + "px";
canv.style.marginTop = "6px";
canv.style.position = "initial";
el.appendChild(canv);

const ctx = canv.getContext("2d");

parentPort.onChange = onParentChanged;
labelPort.onChange = onLabelTextChanged;
op.onDelete = onDelete;

inRange.onChange = () =>
{
    setOutValue(defaultValuePortX.get(), defaultValuePortY.get());

    redraw();
};

redraw();

flipX.onChange = flipY.onChange = () =>
{
    setOutValue(inputX.get(), inputY.get());
};

canv.addEventListener("pointerdown", (e) =>
{
    try { canv.setPointerCapture(e.pointerId); }
    catch (e) {}
});

canv.addEventListener("pointerup", (e) =>
{
    try { canv.releasePointerCapture(e.pointerId); }
    catch (e) {}
});

inputX.onChange = () =>
{
    // outX.set(Math.min(1, Math.max(inputX.get(), 0)));
    setOutValue(inputX.get(), inputY.get());
    // redraw();
};

inputY.onChange = () =>
{
    // outY.set(Math.min(1, Math.max(inputY.get(), 0)));
    setOutValue(inputX.get(), inputY.get());
    // redraw();
};

function move(e)
{
    if (e.buttons == 1)
    {
        let x = Math.min(size, Math.max(e.offsetX, 0));
        let y = Math.min(size, Math.max(e.offsetY, 0));

        if (e.shiftKey)
        {
            const s = size / 10;
            x = Math.round(x / s) * s;
            y = Math.round(y / s) * s;
        }

        setOutValue(x / size, y / size);
        inputX.set(x / size);
        inputY.set(y / size);
        op.refreshParams();
    }
}

canv.addEventListener("pointermove", move, false);
canv.addEventListener("pointerdown", move, false);

function setOutValue(x, y)
{
    inputX.set(x);
    inputY.set(y);

    if (flipX.get())x = 1 - x;
    if (flipY.get())y = 1 - y;

    let ox = x;
    let oy = y;

    if (inRange.get() == "0-1")
    {
        outX.set(ox);
        outY.set(oy);
    }
    else
    {
        outX.set(((ox) - 0.5) * 2.0);
        outY.set(((oy) - 0.5) * 2.0);
    }

    if (valueX.value != "" + outX.get()) valueX.value = "" + outX.get();
    if (valueY.value != "" + outY.get()) valueY.value = "" + outY.get();

    redraw();
}

function redraw()
{
    ctx.lineWidth = 1;
    ctx.strokeWidth = 1;

    ctx.clearRect(0, 0, size, size);
    ctx.fillStyle = "#333";
    ctx.fillRect(0, 0, size, size);

    ctx.strokeStyle = "#555";
    ctx.strokeRect(0, size / 2, size, 0);
    ctx.strokeRect(size / 2, 0, 0, size);
    ctx.strokeRect(0, 0, size, size);

    ctx.strokeStyle = "#fff";
    ctx.beginPath();
    ctx.arc(inputX.get() * size, inputY.get() * size, 5, 0, Math.PI * 2, true);
    ctx.stroke();
}

function setDefaultValues()
{
    // const hex = getInputColorHex();
    defaultValuePortY.set(inputY.get());
    defaultValuePortX.set(inputX.get());

    setOutValue(defaultValuePortX.get(), defaultValuePortY.get());

    // defaultValuePort.set(hex);
    // outHex.set(hex);

    redraw();
    op.refreshParams();
}

function inputColorChanged()
{
    redraw();
}

function onLabelTextChanged()
{
    const labelText = labelPort.get();
    label.textContent = labelText;

    op.setUiAttrib({ "extendTitle": labelText });
}

function onParentChanged()
{
    siblingsPort.set(null);
    const parent = parentPort.get();
    if (parent && parent.parentElement)
    {
        parent.parentElement.appendChild(el);
        siblingsPort.set(parent);
    }
    else if (el.parentElement) el.parentElement.removeChild(el);
}

function showElement(el)
{
    if (el) el.style.display = "block";
}

function hideElement(el)
{
    if (el) el.style.display = "none";
}

function onDelete()
{
    removeElementFromDOM(el);
}

function removeElementFromDOM(el)
{
    if (el && el.parentNode && el.parentNode.removeChild)
    {
        el.parentNode.removeChild(el);
    }
}


};

Ops.Sidebar.XYPad.prototype = new CABLES.Op();
CABLES.OPS["84f3d05f-0991-4721-88cb-66776b16a094"]={f:Ops.Sidebar.XYPad,objName:"Ops.Sidebar.XYPad"};




// **************************************************************
// 
// Ops.String.AddLineBreaks
// 
// **************************************************************

Ops.String.AddLineBreaks = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr=op.inString("String",""),
    inMaxLineChars=op.inInt("Max Characters per Line",20),
    outStr=op.outString("Result");

inMaxLineChars.onChange=
    inStr.onChange=update;

function update()
{
    const str=inStr.get();
    if(!str)
    {
        outStr.set("");
        return;
    }

    const numChars=inMaxLineChars.get();
    const parts=str.split(" ");
    const lines=[];
    var line="";
    for(var i=0;i<parts.length;i++)
    {
        var word=parts[i]+" ";

        if(line.length+word.length>numChars)
        {
            lines.push(line);
            line="";
        }

        line+=word;
    }
    lines.push(line);
    outStr.set(lines.join("\n"));
}


};

Ops.String.AddLineBreaks.prototype = new CABLES.Op();
CABLES.OPS["9746be6e-bf86-4a5f-86d9-d3b1c26d7f28"]={f:Ops.String.AddLineBreaks,objName:"Ops.String.AddLineBreaks"};




// **************************************************************
// 
// Ops.String.ArrayContainsString
// 
// **************************************************************

Ops.String.ArrayContainsString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inValue = op.inString("SearchValue"),
    outFound = op.outBoolNum("Found", false),
    outIndex = op.outNumber("Index", -1);

inValue.onChange = () =>
{
    op.setUiAttrib({ "extendTitle": inValue.get() });
    exec();
};

inArr.onChange = exec;

function exec()
{
    if (inArr.get())
    {
        const index = inArr.get().indexOf(inValue.get());

        outIndex.set(index);
        outFound.set(index > -1);
    }
}


};

Ops.String.ArrayContainsString.prototype = new CABLES.Op();
CABLES.OPS["bace9c9b-5e96-4a82-9bcd-02e316afb9de"]={f:Ops.String.ArrayContainsString,objName:"Ops.String.ArrayContainsString"};




// **************************************************************
// 
// Ops.String.ArrayOfStrings
// 
// **************************************************************

Ops.String.ArrayOfStrings = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("String", "default"),
    inLength = op.inInt("Length", 10),
    inAttachNum = op.inBool("Attach Number", false),
    outArr = op.outArray("Array");

inStr.onChange =
    inLength.onChange =
    inAttachNum.onChange = update;

function update()
{
    let arr = [];
    let str = inStr.get();
    let l = inLength.get();

    if (inAttachNum.get())
        for (let i = 0; i < l; i++)
            arr[i] = str + i;
    else
        for (let i = 0; i < l; i++)
            arr[i] = str;

    outArr.set(arr);
}


};

Ops.String.ArrayOfStrings.prototype = new CABLES.Op();
CABLES.OPS["846f9998-1c05-4757-8011-21020ed01c6d"]={f:Ops.String.ArrayOfStrings,objName:"Ops.String.ArrayOfStrings"};




// **************************************************************
// 
// Ops.String.Base64Decode_v2
// 
// **************************************************************

Ops.String.Base64Decode_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let r = "";
const
    inString = op.inString("String"),
    result = op.outString("Result");
inString.onChange = function ()
{
    result.set(b64DecodeUnicode(inString.get() || ""));
};

function b64DecodeUnicode(str)
{
    // Going backwards: from bytestream, to percent-encoding, to original string.

    if (str.indexOf("base64,") > 1)
    {
        str = str.substring(str.indexOf("base64,") + "base64,".length);
    }

    let r = "";

    try
    {
        r = decodeURIComponent(atob(str).split("").map(function (c)
        {
            return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(""));
    }
    catch (e)
    {
        op.error(e);
    }

    return r;
}


};

Ops.String.Base64Decode_v2.prototype = new CABLES.Op();
CABLES.OPS["4986a1d8-390f-48ee-aff4-c4257ddb480a"]={f:Ops.String.Base64Decode_v2,objName:"Ops.String.Base64Decode_v2"};




// **************************************************************
// 
// Ops.String.Base64Encode_v2
// 
// **************************************************************

Ops.String.Base64Encode_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let inString = op.inString("String");
let result = op.outString("Result");

inString.onChange = function ()
{
    result.set(b64EncodeUnicode(inString.get()));
};

function b64EncodeUnicode(str)
{
    // first we use encodeURIComponent to get percent-encoded UTF-8,
    // then we convert the percent encodings into raw bytes which
    // can be fed into btoa.
    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
        function toSolidBytes(match, p1)
        {
            return String.fromCharCode("0x" + p1);
        }));
}


};

Ops.String.Base64Encode_v2.prototype = new CABLES.Op();
CABLES.OPS["e6ff2e1b-0c7a-4d0b-b1cf-720c2bbe3514"]={f:Ops.String.Base64Encode_v2,objName:"Ops.String.Base64Encode_v2"};




// **************************************************************
// 
// Ops.String.CharacterRotate
// 
// **************************************************************

Ops.String.CharacterRotate = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpdate = op.inTriggerButton("Update"),
    inReset = op.inTriggerButton("Reset"),
    inText = op.inString("Text"),
    inSeed = op.inFloat("Random Seed", 0),
    inChars = op.inString("Characters", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 -_+!"),
    result = op.outString("Result");

let positions = [];
let position = 0;
let resultString = "";

inSeed.onChange = init;
inText.onChange = init;
inReset.onTriggered = init;

function init()
{
    position++;
    let txt = inText.get();
    if (!txt)
    {
        result.set("");
        return;
    }
    let alphab = inChars.get();

    resultString = "";

    Math.randomSeed = inSeed.get();

    for (let i = 0; i < txt.length; i++)
    {
        if (inSeed.get() == 0)
        {
            resultString += alphab[0];
        }
        else
        {
            resultString += alphab[Math.floor(Math.seededRandom() * alphab.length)];
        }
    }

    result.set(resultString);
}

inUpdate.onTriggered = function ()
{
    let txt = inText.get();
    let alphab = inChars.get();

    if (!txt)
    {
        result.set("");
        return;
    }

    if (!resultString) init();
    let newStr = "";

    for (let i = 0; i < txt.length; i++)
    {
        if (txt[i] == "\n")
        {
            newStr += "\n";
        }
        else
        if (txt[i] != resultString[i])
        {
            let newindex = alphab.indexOf(resultString[i]) + 1;

            if (newindex > alphab.length - 1)newindex = 0;
            newStr += alphab[newindex];
        }
        else
        {
            newStr += txt[i];
        }
    }
    resultString = newStr;

    result.set(resultString);
};


};

Ops.String.CharacterRotate.prototype = new CABLES.Op();
CABLES.OPS["9dcc7ad1-c790-4c9d-9f2a-a902bd8d6cc8"]={f:Ops.String.CharacterRotate,objName:"Ops.String.CharacterRotate"};




// **************************************************************
// 
// Ops.String.ConcatMulti_v2
// 
// **************************************************************

Ops.String.ConcatMulti_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const addSpacesCheckBox = op.inBool("add spaces", false),
    newLinesCheckBox = op.inBool("new lines", false),
    stringPorts = [],
    result = op.outString("concat string");

stringPorts.onChange = addSpacesCheckBox.onChange =
newLinesCheckBox.onChange = update;

addSpacesCheckBox.setUiAttribs({ "hidePort": true });
newLinesCheckBox.setUiAttribs({ "hidePort": true });

for (let i = 0; i < 8; i++)
{
    let p = op.inString("string " + i);
    stringPorts.push(p);
    p.onChange = update;
}

function update()
{
    let str = "";
    let nl = "";
    let space = addSpacesCheckBox.get();

    for (let i = 0; i < stringPorts.length; i++)
    {
        const inString = stringPorts[i].get();
        if (!inString) continue;
        if (i > 0 && space) str += " ";
        if (i > 0 && newLinesCheckBox.get()) nl = "\n";
        str += nl;
        str += inString;
    }
    result.set(str);
}


};

Ops.String.ConcatMulti_v2.prototype = new CABLES.Op();
CABLES.OPS["bc110e48-812d-489d-b1b3-b09c644c6982"]={f:Ops.String.ConcatMulti_v2,objName:"Ops.String.ConcatMulti_v2"};




// **************************************************************
// 
// Ops.String.Concat_v2
// 
// **************************************************************

Ops.String.Concat_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    string1 = op.inString("string1", "ABC"),
    string2 = op.inString("string2", "XYZ"),
    newLine = op.inValueBool("New Line", false),
    result = op.outString("result");

newLine.onChange = string2.onChange = string1.onChange = exec;
exec();

function exec()
{
    let s1 = string1.get();
    let s2 = string2.get();
    if (!s1 && !s2)
    {
        result.set("");
        return;
    }
    if (!s1)s1 = "";
    if (!s2)s2 = "";

    let nl = "";
    if (s1 && s2 && newLine.get())nl = "\n";
    result.set(String(s1) + nl + String(s2));
}


};

Ops.String.Concat_v2.prototype = new CABLES.Op();
CABLES.OPS["a52722aa-0ca9-402c-a844-b7e98a6c6e60"]={f:Ops.String.Concat_v2,objName:"Ops.String.Concat_v2"};




// **************************************************************
// 
// Ops.String.CopyToClipboard
// 
// **************************************************************

Ops.String.CopyToClipboard = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inCopy= op.inTriggerButton("Copy"),
    inStr=op.inString("String","cablez");

inCopy.onTriggered=()=>
{
    navigator.clipboard.writeText(inStr.get());
};


};

Ops.String.CopyToClipboard.prototype = new CABLES.Op();
CABLES.OPS["283c7eef-680b-45f2-880a-5d9f0762854b"]={f:Ops.String.CopyToClipboard,objName:"Ops.String.CopyToClipboard"};




// **************************************************************
// 
// Ops.String.FilterValidString
// 
// **************************************************************

Ops.String.FilterValidString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("String", ""),
    checkNull = op.inBool("Invalid if null", true),
    checkUndefined = op.inBool("Invalid if undefined", true),
    checkEmpty = op.inBool("Invalid if empty", true),
    checkZero = op.inBool("Invalid if 0", true),
    outStr = op.outString("Last Valid String"),
    result = op.outBoolNum("Is Valid");

inStr.onChange =
checkNull.onChange =
checkUndefined.onChange =
checkEmpty.onChange =
function ()
{
    const str = inStr.get();
    let r = true;

    if (r === false)r = false;
    if (r && checkZero.get() && (str === 0 || str === "0")) r = false;
    if (r && checkNull.get() && str === null) r = false;
    if (r && checkUndefined.get() && str === undefined) r = false;
    if (r && checkEmpty.get() && str === "") r = false;

    result.set(r);
    if (r)outStr.set(str);
};


};

Ops.String.FilterValidString.prototype = new CABLES.Op();
CABLES.OPS["a522235d-f220-46ea-bc26-13a5b20ec8c6"]={f:Ops.String.FilterValidString,objName:"Ops.String.FilterValidString"};




// **************************************************************
// 
// Ops.String.GateString
// 
// **************************************************************

Ops.String.GateString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    valueInPort = op.inString('String In', 'hello'),
    passThroughPort = op.inValueBool('Pass Through',false),
    valueOutPort = op.outString('String Out','');

valueInPort.onChange =
passThroughPort.onChange = update;

function update()
{
    if(passThroughPort.get())
    {
        valueOutPort.set(null);
        valueOutPort.set(valueInPort.get());
    }
        // else
        // valueOutPort.set('');
}

};

Ops.String.GateString.prototype = new CABLES.Op();
CABLES.OPS["0ce14933-2d91-4381-9d82-2304aae22c0e"]={f:Ops.String.GateString,objName:"Ops.String.GateString"};




// **************************************************************
// 
// Ops.String.LeftPad_v2
// 
// **************************************************************

Ops.String.LeftPad_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let val = op.inString("Value", 1);
let char = op.inString("Char", "0");
let num = op.inInt("Num", 4);
let out = op.outString("String");

val.onChange = update;
char.onChange = update;
num.onChange = update;

function update()
{
    let v = val.get();
    let n = num.get();

    let pad = "";
    for (let i = 0; i < n; i++)pad += ("" + char.get());

    let str = v + "";
    str = pad.substring(0, pad.length - str.length) + str;

    out.set(str);
}


};

Ops.String.LeftPad_v2.prototype = new CABLES.Op();
CABLES.OPS["da8aba9f-9e9c-4fca-87c9-2726b6e101e2"]={f:Ops.String.LeftPad_v2,objName:"Ops.String.LeftPad_v2"};




// **************************************************************
// 
// Ops.String.LimitLineBreaks_v2
// 
// **************************************************************

Ops.String.LimitLineBreaks_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("String", "default"),
    inNum = op.inInt("Num Lines", 5),
    inRev = op.inBool("Reverse", false),
    inAppend = op.inBool("Force Num Lines", false),
    outStr = op.outString("Result", "default");

let stringsNew = [];

inRev.onChange =
    inAppend.onChange =
    inStr.onChange =
    inNum.onChange = update;

function update()
{
    let strings = inStr.get().split("\n");
    var num = num = Math.max(0, Math.floor(inNum.get()) + 1);

    if (inRev.get())
    {
        if (strings.length > num)
        {
            for (var i = 0; i < num; i++)
                stringsNew[num - i] = strings[strings.length - i];

            strings = stringsNew;
        }
    }
    else
    {
        strings.length = Math.min(num, strings.length);
    }

    let str = strings.join("\n");

    if (inAppend.get())
    {
        if (strings.length < num)
            for (var i = strings.length; i < num; i++)
                str += "\n";
    }

    outStr.set(str);
}


};

Ops.String.LimitLineBreaks_v2.prototype = new CABLES.Op();
CABLES.OPS["fcf0f2a3-42db-485c-8c0b-15c5eb1f18c7"]={f:Ops.String.LimitLineBreaks_v2,objName:"Ops.String.LimitLineBreaks_v2"};




// **************************************************************
// 
// Ops.String.LineBreaksHtml
// 
// **************************************************************

Ops.String.LineBreaksHtml = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr=op.inString("String",""),
    inNum=op.inInt("Add Num Breaks",1),
    outStr=op.outString("HTML");

inNum.onChange=
inStr.onChange=function()
{
    var str=inStr.get();
    var newlines='';

    for(var i=0;i<inNum.get();i++) newlines+='<br/>';

    if(str) str = str.replace(/(?:\r\n|\r|\n)/g, newlines);
    outStr.set(str);

};

};

Ops.String.LineBreaksHtml.prototype = new CABLES.Op();
CABLES.OPS["bac20d9b-15c2-424b-9b6b-fd0a9af14f48"]={f:Ops.String.LineBreaksHtml,objName:"Ops.String.LineBreaksHtml"};




// **************************************************************
// 
// Ops.String.LoremIpsum
// 
// **************************************************************

Ops.String.LoremIpsum = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    outStr=op.outString("String"),
    outHtml=op.outString("HTML String"),
    outArray=op.outArray("Array");

const paragraphs=[
"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris pretium tempor enim, sit amet elementum ex sodales eu. Nulla porttitor, ante vel condimentum volutpat, nisi est faucibus enim, sed pulvinar arcu justo eget eros. Vivamus blandit ex et ipsum ornare bibendum. Proin rutrum nisl est, eu pellentesque enim fermentum vel. Praesent tempor eget ligula sed lacinia. Curabitur at interdum nibh. Mauris porta ultricies eros, eu varius nisi.",
"Maecenas quis sapien eget eros luctus lacinia in quis turpis. Fusce luctus, nibh ac dictum elementum, turpis libero tincidunt nulla, a facilisis nulla erat scelerisque felis. In hac habitasse platea dictumst. Vestibulum cursus malesuada diam ut laoreet. Interdum et malesuada fames ac ante ipsum primis in faucibus. Pellentesque venenatis arcu leo, ut ornare nunc ultrices a. Curabitur pellentesque odio ac est aliquet porta. Morbi metus felis, ornare vitae dictum sit amet, elementum sed dolor. Duis quis commodo dolor. Cras nec ipsum semper, lobortis libero et, finibus felis. Donec ipsum felis, fermentum et congue non, rhoncus non risus. Nullam et lacus eu eros imperdiet blandit in sed arcu. Nullam a massa nec turpis consequat aliquam. Nulla nec purus a sem convallis mattis.",
"Phasellus sed interdum risus. Aliquam fermentum nulla eget egestas condimentum. Vestibulum et nulla et leo suscipit facilisis. Pellentesque ut lectus porttitor, facilisis quam eu, ultrices nulla. Maecenas dapibus aliquet suscipit. Sed pretium justo molestie purus vehicula hendrerit. Quisque auctor tempus ipsum, ut tincidunt libero dapibus vel. Sed faucibus mi at nisi tristique, id efficitur nunc commodo. Quisque ac erat tincidunt, iaculis augue eu, imperdiet magna. Donec tempor facilisis placerat. Nam sed turpis molestie, efficitur dolor vitae, sollicitudin quam.",
"Nunc vehicula, nisl et egestas euismod, eros eros mollis lacus, sit amet vehicula quam mi ac massa. Integer pellentesque interdum porta. Cras iaculis velit orci, ut volutpat ex scelerisque id. Sed tincidunt massa eget lectus molestie eleifend. Nam egestas maximus urna, a volutpat felis. Mauris vehicula molestie justo vel accumsan. Nulla facilisi.",
"Praesent eu hendrerit nulla. Suspendisse quam risus, tincidunt ut viverra in, tristique ut massa. Integer dignissim consequat commodo. Integer mollis risus vitae augue congue, et fermentum tellus vehicula. Praesent sit amet posuere eros. Vivamus vulputate massa a augue luctus facilisis. Donec purus ipsum, venenatis ut commodo in, pretium ac erat. Donec vulputate tortor ut ante consequat molestie. Vestibulum tempus felis quam, vitae fringilla nulla facilisis non. Integer porttitor condimentum lacinia. Maecenas porttitor ullamcorper augue nec scelerisque. Etiam mattis felis eget lacus porta, sit amet lacinia diam efficitur."
];

outArray.set(paragraphs);
outStr.set(paragraphs.join('\n'));
outHtml.set(paragraphs.join('<br/><br/>'));


};

Ops.String.LoremIpsum.prototype = new CABLES.Op();
CABLES.OPS["c19ebc53-82d5-429c-a6cc-ff350a2c5d3e"]={f:Ops.String.LoremIpsum,objName:"Ops.String.LoremIpsum"};




// **************************************************************
// 
// Ops.String.Lowercase_v2
// 
// **************************************************************

Ops.String.Lowercase_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("String"),
    outStr = op.outString("Result", "");

inStr.onChange = function ()
{
    if (inStr.get() == 0)outStr.set("");
    else outStr.set((inStr.get() || "").toLowerCase());
};


};

Ops.String.Lowercase_v2.prototype = new CABLES.Op();
CABLES.OPS["bff9c3d9-e63a-46d2-a59f-932c715aceab"]={f:Ops.String.Lowercase_v2,objName:"Ops.String.Lowercase_v2"};




// **************************************************************
// 
// Ops.String.NumTotalLineBreaks
// 
// **************************************************************

Ops.String.NumTotalLineBreaks = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr=op.inString("String","default"),
    outNum=op.outNumber("Total Lines",0);


inStr.onChange=function()
{
    var strings=inStr.get().split('\n');
    outNum.set(strings.length);


};

};

Ops.String.NumTotalLineBreaks.prototype = new CABLES.Op();
CABLES.OPS["76a958cd-def3-40e5-ab2b-c08a3325d9cb"]={f:Ops.String.NumTotalLineBreaks,objName:"Ops.String.NumTotalLineBreaks"};




// **************************************************************
// 
// Ops.String.NumberFormatter
// 
// **************************************************************

Ops.String.NumberFormatter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inNum = op.inFloat("Input Number");
const inLocaleSwitch = op.inSwitch("Locale", ["browser", "custom"], "browser");
const inLocaleString = op.inString("Locale string", "en-US");
const inStyle = op.inSwitch("Style", ["decimal", "currency", "percent"], "decimal");
const inMinDig = op.inInt("Minimum Integer Digits", 1);
const inMinFrac = op.inInt("Minimum Fraction Digits", 3);
const inMaxFrac = op.inInt("Maximum Fraction Digits", 3);
op.setPortGroup("Format", [inMinDig, inMinFrac, inMaxFrac]);
const inMinSign = op.inInt("Minimum Significant Digits", 0);
const inMaxSign = op.inInt("Maximum Significant Digits", 0);
op.setPortGroup("Significant Digits", [inMaxSign, inMinSign]);
const inUseGroup = op.inBool("Use Grouping", true);

const inCurrencyName = op.inString("Currency Name", "EUR");
const inCurrencyDisplay = op.inSwitch("Currency Display", ["symbol", "code", "name"], "symbol");
op.setPortGroup("Currency", [inCurrencyName, inCurrencyDisplay]);

const outString = op.outString("Formatted Number", "0,000");
const outError = op.outBoolNum("Has error");

// Bind functions
inNum.onChange = inLocaleString.onChange =
inStyle.onChange = inMaxFrac.onChange =
inMaxSign.onChange = inMinFrac.onChange =
inMinDig.onChange = inMinSign.onChange =
inUseGroup.onChange = inCurrencyName.onChange =
inCurrencyDisplay.onChange = inLocaleSwitch.onChange = formatNumber;

function formatNumber()
{
    const num = inNum.get();
    const style = inStyle.get();

    let minimumFractionDigits = CABLES.clamp(inMinFrac.get(), 0, 20);
    let maximumFractionDigits = CABLES.clamp(inMaxFrac.get(), 0, 20);

    op.setUiError("minmaxfrac", null);
    if(minimumFractionDigits > maximumFractionDigits) {
        op.setUiError("minmaxfrac", "Minimum bigger than maximum for fraction digits, using minimum", 1);
        maximumFractionDigits = minimumFractionDigits;
    }

    let opts = {
        "style": style,
        "minimumFractionDigits": minimumFractionDigits,
        "maximumFractionDigits": maximumFractionDigits,
        "minimumIntegerDigits": CABLES.clamp(inMinDig.get(), 1, 21),
        "useGrouping": inUseGroup.get()
    };

    if (inMinSign.get() > 0) opts.minimumSignificantDigits = CABLES.clamp(inMinSign.get(), 1, 21);
    if (inMaxSign.get() > 0) opts.maximumSignificantDigits = CABLES.clamp(inMaxSign.get(), 1, 21);


    op.setUiError("minmaxsig", null);
    if(opts.minimumSignificantDigits > opts.maximumSignificantDigits) {
        op.setUiError("minmaxsig", "Minimum bigger than maximum for significant digits, using minimum", 1);
        opts.maximumSignificantDigits = opts.minimumSignificantDigits;
    }

    if (style === "currency")
    {
        opts.currency = inCurrencyName.get();
        opts.currencyDisplay = inCurrencyDisplay.get();
    }

    try
    {
        let res = "";
        if (inLocaleSwitch.get() === "browser")
            res = num.toLocaleString([], opts);
        else
            res = num.toLocaleString(inLocaleString.get(), opts);

        outString.set(res);

        if (outError.get())
            op.setUiError("format_error", null);
        outError.set(false);
    }
    catch (e)
    {
        outError.set(true);
        outString.set("");
        op.setUiError("format_error", e);
    }
}


};

Ops.String.NumberFormatter.prototype = new CABLES.Op();
CABLES.OPS["fb2ac304-5c36-419c-ba71-cdf43aed8a53"]={f:Ops.String.NumberFormatter,objName:"Ops.String.NumberFormatter"};




// **************************************************************
// 
// Ops.String.NumberSwitchByString
// 
// **************************************************************

Ops.String.NumberSwitchByString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inStr = op.inString("String", "default");
const outNum = op.outNumber("Result", 0);
const numberStrings = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten"];

const strings = [];
const numbers = [];

inStr.onChange = update;

for (let i = 0; i < numberStrings.length; i++)
{
    const idx = i + 1;
    const istr = op.inString("String " + idx, numberStrings[i]);
    const inum = op.inFloat("Number " + idx, idx);

    strings.push(istr);
    numbers.push(inum);
}

function update()
{
    const s = inStr.get();

    for (let i = 0; i < numberStrings.length; i++)
    {
        if (strings[i].get() == s)outNum.set(numbers[i].get());
    }
}


};

Ops.String.NumberSwitchByString.prototype = new CABLES.Op();
CABLES.OPS["bb3f53ab-c4ad-4c07-81df-d9ca7ee976f2"]={f:Ops.String.NumberSwitchByString,objName:"Ops.String.NumberSwitchByString"};




// **************************************************************
// 
// Ops.String.NumberToString_v2
// 
// **************************************************************

Ops.String.NumberToString_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inValue("Number"),
    result = op.outString("Result");

val.onChange = update;
update();

function update()
{
    result.set(String(val.get() || 0));
}


};

Ops.String.NumberToString_v2.prototype = new CABLES.Op();
CABLES.OPS["5c6d375a-82db-4366-8013-93f56b4061a9"]={f:Ops.String.NumberToString_v2,objName:"Ops.String.NumberToString_v2"};




// **************************************************************
// 
// Ops.String.OrString
// 
// **************************************************************

Ops.String.OrString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    str0=op.inString("String 1"),
    str1=op.inString("String 2"),
    str2=op.inString("String 3"),
    str3=op.inString("String 4"),
    str4=op.inString("String 5"),
    str5=op.inString("String 6"),
    str6=op.inString("String 7"),
    str7=op.inString("String 8"),
    result=op.outString("Result");

str0.onChange=
    str1.onChange=
    str2.onChange=
    str3.onChange=
    str4.onChange=
    str5.onChange=
    str6.onChange=
    str7.onChange=exec;

function exec()
{
    result.set( str0.get() || str1.get()  || str2.get() || str3.get() || str4.get() || str5.get() || str6.get() || str7.get() );
}



};

Ops.String.OrString.prototype = new CABLES.Op();
CABLES.OPS["6b7f9561-6faf-4df7-ac3b-64235dded700"]={f:Ops.String.OrString,objName:"Ops.String.OrString"};




// **************************************************************
// 
// Ops.String.ParseFloat
// 
// **************************************************************

Ops.String.ParseFloat = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    str = op.inString("String", 5711),
    outNum = op.outNumber("Number");

str.onChange = function ()
{
    let num = parseFloat(str.get());
    if (num != num) num = 0;
    outNum.set(num);
};


};

Ops.String.ParseFloat.prototype = new CABLES.Op();
CABLES.OPS["fa36a56b-a64d-4269-9a9e-addc16493006"]={f:Ops.String.ParseFloat,objName:"Ops.String.ParseFloat"};




// **************************************************************
// 
// Ops.String.ParseInt_v2
// 
// **************************************************************

Ops.String.ParseInt_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    str = op.inString("String", 5711),
    outNum = op.outNumber("Number");

str.onChange = function ()
{
    let num = parseInt(str.get());
    if (num != num) num = 0;
    outNum.set(num);
};


};

Ops.String.ParseInt_v2.prototype = new CABLES.Op();
CABLES.OPS["6d208424-daf2-4a2b-874f-daac406c1f66"]={f:Ops.String.ParseInt_v2,objName:"Ops.String.ParseInt_v2"};




// **************************************************************
// 
// Ops.String.RandomString_v2
// 
// **************************************************************

Ops.String.RandomString_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    chars = op.inString("chars", "cables"),
    len = op.inInt("Length", 10),
    generate = op.inTriggerButton("Generate"),
    result = op.outString("Result");

generate.onTriggered = gen;
gen();

function gen()
{
    const charArray = Array.from(chars.get());
    let str = "";
    if (charArray.length > 0)
    {
        let numChars = charArray.length - 1;
        for (let i = 0; i < Math.abs(len.get()); i++)
            str += charArray[Math.round(Math.random() * numChars)];
    }

    result.set(str);
}


};

Ops.String.RandomString_v2.prototype = new CABLES.Op();
CABLES.OPS["55285d4a-f542-4c8b-9839-02b33b15c916"]={f:Ops.String.RandomString_v2,objName:"Ops.String.RandomString_v2"};




// **************************************************************
// 
// Ops.String.RightPadNumber_v2
// 
// **************************************************************

Ops.String.RightPadNumber_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val=op.inValue("Value",1);
const num=op.inValueInt("Num",4);
const out=op.outString("String");

val.onChange=update;
num.onChange=update;

function update()
{
    var str=val.get()+'';

    var start=str.indexOf(".");
    var numChars=num.get();

    if(start==-1)
    {
        str+='.';
    }
    else
    {
        var parts=str.split(".");
        numChars=num.get()-parts[1].length;
    }

    for(var i=0;i<numChars;i++) str+="0";

    out.set(str);
}

};

Ops.String.RightPadNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["dfbb4d58-1557-421b-8f2d-fdd0e74f8c43"]={f:Ops.String.RightPadNumber_v2,objName:"Ops.String.RightPadNumber_v2"};




// **************************************************************
// 
// Ops.String.RightPad_v2
// 
// **************************************************************

Ops.String.RightPad_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inString("Value", 1),
    char = op.inString("Char", "0"),
    num = op.inValueInt("Num", 4),
    out = op.outString("String");

val.onChange =
char.onChange =
num.onChange = update;

function update()
{
    let str = val.get() + "";
    for (let i = str.length; i < num.get(); i++)
    {
        str += char.get();
    }
    out.set(str);
}


};

Ops.String.RightPad_v2.prototype = new CABLES.Op();
CABLES.OPS["b10c1bcb-c6aa-4238-bcba-bb9f33a2febf"]={f:Ops.String.RightPad_v2,objName:"Ops.String.RightPad_v2"};




// **************************************************************
// 
// Ops.String.RouteString
// 
// **************************************************************

Ops.String.RouteString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    NUM_PORTS = 10,
    indexPort = op.inInt('Index'),
    valuePort = op.inString('String in',"cables"),
    defaultStringPort = op.inString('Default string', ""),
    valuePorts = createOutPorts();

indexPort.onChange = valuePort.onChange = defaultStringPort.onChange = update;

setDefaultValues();
update();

function createOutPorts()
{
    var arr = [];
    for(var i=0; i<NUM_PORTS; i++)
    {
        var port = op.outString('Index ' + i + ' string');
        arr.push(port);
    }
    return arr;
};

function setDefaultValues()
{
    var defaultValue = defaultStringPort.get();
    if(!defaultStringPort.get())
    {
        defaultValue = "";
    }
    valuePorts.forEach(port => port.set(defaultValue));
};

function update()
{
    setDefaultValues();
    var index = indexPort.get();
    var value = valuePort.get();
    index = Math.round(index);
    index = clamp(index, 0, NUM_PORTS-1);
    valuePorts[index].set(value);
};

function clamp(value, min, max)
{
  return Math.min(Math.max(value, min), max);
};


};

Ops.String.RouteString.prototype = new CABLES.Op();
CABLES.OPS["9998ff83-335b-40cd-aa0e-4cae558cb551"]={f:Ops.String.RouteString,objName:"Ops.String.RouteString"};




// **************************************************************
// 
// Ops.String.SaveTextFile
// 
// **************************************************************

Ops.String.SaveTextFile = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    download = op.inTriggerButton("Download"),
    filename = op.inString("Filename", "textfile.txt"),
    inStr = op.inString("Content String");

download.onTriggered = function ()
{
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(inStr.get());
    const downloadAnchorNode = document.createElement("a");
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", filename.get() );
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
};


};

Ops.String.SaveTextFile.prototype = new CABLES.Op();
CABLES.OPS["ef5929f0-8163-460b-9042-6f20f4f7150b"]={f:Ops.String.SaveTextFile,objName:"Ops.String.SaveTextFile"};




// **************************************************************
// 
// Ops.String.StringCompose_v3
// 
// **************************************************************

Ops.String.StringCompose_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    format=op.inString('Format',"hello $a, $b $c und $d"),
    a=op.inString('String A','world'),
    b=op.inString('String B',1),
    c=op.inString('String C',2),
    d=op.inString('String D',3),
    e=op.inString('String E'),
    f=op.inString('String F'),
    result=op.outString("Result");

format.onChange=
    a.onChange=
    b.onChange=
    c.onChange=
    d.onChange=
    e.onChange=
    f.onChange=update;

update();

function update()
{
    var str=format.get()||'';
    if(typeof str!='string')
        str='';

    str = str.replace(/\$a/g, a.get());
    str = str.replace(/\$b/g, b.get());
    str = str.replace(/\$c/g, c.get());
    str = str.replace(/\$d/g, d.get());
    str = str.replace(/\$e/g, e.get());
    str = str.replace(/\$f/g, f.get());

    result.set(str);
}

};

Ops.String.StringCompose_v3.prototype = new CABLES.Op();
CABLES.OPS["6afea9f4-728d-4f3c-9e75-62ddc1448bf0"]={f:Ops.String.StringCompose_v3,objName:"Ops.String.StringCompose_v3"};




// **************************************************************
// 
// Ops.String.StringContains_v2
// 
// **************************************************************

Ops.String.StringContains_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("String"),
    inValue = op.inString("SearchValue"),
    outFound = op.outBoolNum("Found", false),
    outIndex = op.outNumber("Index", -1);

inValue.onChange =
    inStr.onChange = exec;

exec();

function exec()
{
    if (inStr.get() && inValue.get().length > 0)
    {
        const index = inStr.get().indexOf(inValue.get());
        outIndex.set(index);
        outFound.set(index > -1);
    }
    else
    {
        outIndex.set(-1);
        outFound.set(false);
    }
}


};

Ops.String.StringContains_v2.prototype = new CABLES.Op();
CABLES.OPS["2ca3e5d7-e6b4-46a7-8381-3fe1ad8b6879"]={f:Ops.String.StringContains_v2,objName:"Ops.String.StringContains_v2"};




// **************************************************************
// 
// Ops.String.StringEditor
// 
// **************************************************************

Ops.String.StringEditor = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    v = op.inStringEditor("value", ""),
    syntax = op.inValueSelect("Syntax", ["text", "glsl", "css", "html", "xml", "json", "javascript", "inline-css", "sql"], "text"),
    result = op.outString("Result");

syntax.onChange = updateSyntax;

function updateSyntax()
{
    let s = syntax.get();
    if (s == "javascript")s = "js";
    v.setUiAttribs({ "editorSyntax": s });
}

v.onChange = function ()
{
    result.set(v.get());
};


};

Ops.String.StringEditor.prototype = new CABLES.Op();
CABLES.OPS["6468b7c1-f63e-4db4-b809-4b203d27ead3"]={f:Ops.String.StringEditor,objName:"Ops.String.StringEditor"};




// **************************************************************
// 
// Ops.String.StringEquals
// 
// **************************************************************

Ops.String.StringEquals = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    str1 = op.inString("String 1"),
    str2 = op.inString("String 2"),
    result = op.outBoolNum("Result");

str1.onChange =
str2.onChange =
    function ()
    {
        result.set(str1.get() == str2.get());
    };


};

Ops.String.StringEquals.prototype = new CABLES.Op();
CABLES.OPS["ef15195a-760b-4ac5-9630-322b0ba7b722"]={f:Ops.String.StringEquals,objName:"Ops.String.StringEquals"};




// **************************************************************
// 
// Ops.String.StringIterator_v2
// 
// **************************************************************

Ops.String.StringIterator_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inExe = op.inTrigger("Exec"),
    inString = op.inString("String", "cables"),
    next = op.outTrigger("Next"),
    outChar = op.outString("Character"),
    outIndex = op.outNumber("Index"),
    outLength = op.outNumber("Length");

inExe.onTriggered = function ()
{
    let str = inString.get();
    outLength.set(str.length);

    for (let i = 0; i < str.length; i++)
    {
        outChar.set(str[i]);
        outIndex.set(i);
        next.trigger();
    }
};


};

Ops.String.StringIterator_v2.prototype = new CABLES.Op();
CABLES.OPS["2def6fdb-de39-4f56-9818-05b7a302583c"]={f:Ops.String.StringIterator_v2,objName:"Ops.String.StringIterator_v2"};




// **************************************************************
// 
// Ops.String.StringLength_v2
// 
// **************************************************************

Ops.String.StringLength_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("String"),
    result = op.outNumber("Result");

inStr.onChange = function ()
{
    if (!inStr.get()) result.set(0);
    else result.set(String(inStr.get()).length);
};


};

Ops.String.StringLength_v2.prototype = new CABLES.Op();
CABLES.OPS["aa47bb8b-d5d7-4175-b217-ab0157d3365d"]={f:Ops.String.StringLength_v2,objName:"Ops.String.StringLength_v2"};




// **************************************************************
// 
// Ops.String.StringReplace
// 
// **************************************************************

Ops.String.StringReplace = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("String"),
    inSearch = op.inString("Search For", "foo"),
    inRepl = op.inString("Replace", "bar"),
    inWhat = op.inSwitch("Replace What", ["All", "First"], "All"),
    outStr = op.outString("Result");

inRepl.onChange =
inStr.onChange =
inWhat.onChange =
inSearch.onChange = update;

function update()
{
    let str = "";

    if (inWhat.get() == "All") str = String(inStr.get()).replace(new RegExp(inSearch.get(), "g"), inRepl.get());
    else str = String(inStr.get()).replace(inSearch.get(), inRepl.get());

    outStr.set(str);
}


};

Ops.String.StringReplace.prototype = new CABLES.Op();
CABLES.OPS["4a053e7a-6b00-4e71-bd51-90cdb190994c"]={f:Ops.String.StringReplace,objName:"Ops.String.StringReplace"};




// **************************************************************
// 
// Ops.String.StringTrim_v2
// 
// **************************************************************

Ops.String.StringTrim_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr=op.inString("String"),
    outStr=op.outString("Result",'');

inStr.onChange=function()
{
    if(!inStr.get())outStr.set('');
        else outStr.set(inStr.get().trim());
};


};

Ops.String.StringTrim_v2.prototype = new CABLES.Op();
CABLES.OPS["a9aed302-328a-4d33-bd3f-27e3e6690b9e"]={f:Ops.String.StringTrim_v2,objName:"Ops.String.StringTrim_v2"};




// **************************************************************
// 
// Ops.String.String_v2
// 
// **************************************************************

Ops.String.String_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    v=op.inString("value",""),
    result=op.outString("String");

v.onChange=function()
{
    result.set(v.get());
};



};

Ops.String.String_v2.prototype = new CABLES.Op();
CABLES.OPS["d697ff82-74fd-4f31-8f54-295bc64e713d"]={f:Ops.String.String_v2,objName:"Ops.String.String_v2"};




// **************************************************************
// 
// Ops.String.StripHtml
// 
// **************************************************************

Ops.String.StripHtml = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("String", ""),
    outStr = op.outString("Result");

inStr.onChange = function ()
{
    // outStr.set((inStr.get() || "").replace(/(<([^>]+)>)/ig, ""));

    const parser = new DOMParser();
    const dom = parser.parseFromString(inStr.get(), "text/html");

    outStr.set(dom.body.textContent);
};


};

Ops.String.StripHtml.prototype = new CABLES.Op();
CABLES.OPS["8a868fc7-363f-4221-9789-67ffe5830e36"]={f:Ops.String.StripHtml,objName:"Ops.String.StripHtml"};




// **************************************************************
// 
// Ops.String.SubString_v2
// 
// **************************************************************

Ops.String.SubString_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr=op.inString("String","cables"),
    inStart=op.inValueInt("Start",0),
    inEnd=op.inValueInt("End",4),
    result=op.outString("Result");

inStr.onChange=
    inStart.onChange=
    inEnd.onChange=update;

update();

function update()
{
    var start=inStart.get();
    var end=inEnd.get();
    var str=inStr.get()+'';
    result.set( str.substring(start,end) );
}

};

Ops.String.SubString_v2.prototype = new CABLES.Op();
CABLES.OPS["6e994ba8-01d1-4da6-98b4-af7e822a2e6c"]={f:Ops.String.SubString_v2,objName:"Ops.String.SubString_v2"};




// **************************************************************
// 
// Ops.String.SwitchString
// 
// **************************************************************

Ops.String.SwitchString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    idx=op.inValueInt("Index"),
    result=op.outString("Result");

const valuePorts=[];

idx.onChange=update;

for(var i=0;i<10;i++)
{
    var p=op.inString("String "+i);
    valuePorts.push( p );
    p.onChange=update;
}

function update()
{
    if(idx.get()>=0 && valuePorts[idx.get()])
    {
        result.set( valuePorts[idx.get()].get() );
    }
}

};

Ops.String.SwitchString.prototype = new CABLES.Op();
CABLES.OPS["2a7a0c68-f7c9-4249-b19a-d2de5cb4862c"]={f:Ops.String.SwitchString,objName:"Ops.String.SwitchString"};




// **************************************************************
// 
// Ops.String.SwitchStringBoolean
// 
// **************************************************************

Ops.String.SwitchStringBoolean = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inBool=op.inValueBool("Boolean"),
    inStrTrue=op.inString("True","Yes"),
    inStrFalse=op.inString("False","No"),
    result=op.outString("Result");

inBool.onChange=
inStrFalse.onChange=
inStrTrue.onChange=update;

function update()
{
    if(inBool.get())result.set(inStrTrue.get());
        else result.set(inStrFalse.get());
}

update();

};

Ops.String.SwitchStringBoolean.prototype = new CABLES.Op();
CABLES.OPS["19e3c428-22ce-45a3-b903-fddfc46fc0a3"]={f:Ops.String.SwitchStringBoolean,objName:"Ops.String.SwitchStringBoolean"};




// **************************************************************
// 
// Ops.String.UUID
// 
// **************************************************************

Ops.String.UUID = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    generate = op.inTriggerButton("Generate"),
    result = op.outString("Id");

generate.onTriggered = update;
update();

function update()
{
    result.set(CABLES.uuid());
}


};

Ops.String.UUID.prototype = new CABLES.Op();
CABLES.OPS["0285022c-846a-43d4-8656-35ba3b5e03a6"]={f:Ops.String.UUID,objName:"Ops.String.UUID"};




// **************************************************************
// 
// Ops.String.Uppercase_v2
// 
// **************************************************************

Ops.String.Uppercase_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr=op.inString("String"),
    outStr=op.outString("Result");

inStr.onChange=function()
{
    if(!inStr.get())outStr.set('');
        else outStr.set(inStr.get().toUpperCase());
};

};

Ops.String.Uppercase_v2.prototype = new CABLES.Op();
CABLES.OPS["3f7e6ede-63b6-4262-9dcd-176b43374c4d"]={f:Ops.String.Uppercase_v2,objName:"Ops.String.Uppercase_v2"};




// **************************************************************
// 
// Ops.Systems.ArraySpray
// 
// **************************************************************

Ops.Systems.ArraySpray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("exe");
const timer = op.inValue("time");
const num = op.inValue("num", 100);
const sizeX = op.inValue("Size X");
const sizeY = op.inValue("Size Y");
const sizeZ = op.inValue("Size Z");
const movementX = op.inValue("movement x", 1);
const movementY = op.inValue("movement y", 1);
const movementZ = op.inValue("movement z", 1);

const centerX = op.inBool("Center X", false);
const centerY = op.inBool("Center Y", false);
const centerZ = op.inBool("Center Z", false);

const inReset = op.inTriggerButton("Reset");
const lifetime = op.inValue("lifetime", 10);
const lifetimeMin = op.inValue("Lifetime Minimum", 5);

const
    outTrigger = op.outTrigger("Trigger Out"),
    outPositions = op.outArray("Positions"),
    outLifetimes = op.outArray("Lifetime");
inReset.onTriggered = reset;
const cgl = op.patch.cgl;

const particles = [];
const transVec = vec3.create();
const positions = [];
const lifetimes = [];

num.onChange =
    sizeX.onChange =
    sizeY.onChange =
    sizeZ.onChange =
    lifetime.onChange =
    centerX.onChange =
    centerY.onChange =
    centerZ.onChange =
    lifetimeMin.onChange = reset;

reset();

function Particle()
{
    this.pos = null;
    this.startPos = null;
    this.startTime = 0;// timer.get()- (Math.random() * ( lifetime.get() - lifetimeMin.get() ) + lifetimeMin.get())/2.0;
    this.lifeTime = 0;
    this.lifeTimePercent = 0;
    this.endTime = 0;

    this.pos = [0, 0, 0];
    this.moveVec = [0, 0, 0];
    this.idDead = false;

    this.random1 = Math.random();
    this.random2 = Math.random();
    this.random3 = Math.random();

    this.update = function (time)
    {
        const timeRunning = time - this.startTime;
        if (time > this.endTime) this.isDead = true;
        this.lifeTimePercent = timeRunning / (this.lifeTime);

        this.pos = vec3.fromValues(
            this.startPos[0] + timeRunning * this.moveVec[0],
            (this.startPos[1] + timeRunning * this.moveVec[1]), // -this.lifeTimePercent*this.lifeTimePercent*2.8,
            this.startPos[2] + timeRunning * this.moveVec[2]
        );
    };

    this.reAnimate = function (time)
    {
        this.isDead = false;
        this.lifeTime = Math.random() * (lifetime.get() - lifetimeMin.get()) + lifetimeMin.get();
        if (time !== undefined)
        {
            this.startTime = time;
            this.endTime = time + this.lifeTime;
        }
        else
        {
            this.startTime = timer.get() - this.lifeTime * Math.random();
            this.endTime = timer.get() + this.lifeTime * Math.random();
        }

        let r = Math.random();

        if (centerX.get())r -= 0.5;
        const x = r * sizeX.get();

        r = Math.random();
        if (centerY.get())r -= 0.5;
        const y = r * sizeY.get();

        r = Math.random();
        if (centerZ.get())r -= 0.5;
        const z = r * sizeZ.get();

        this.startPos = vec3.fromValues(
            x,
            y,
            z);

        this.moveVec = [
            Math.random() * movementX.get(),
            Math.random() * movementY.get(),
            Math.random() * movementZ.get()
        ];
    };
    this.reAnimate(0);
}

exe.onTriggered = function ()
{
    const time = timer.get();

    if (positions.length != particles.length * 3) positions.length = particles.length * 3;
    if (lifetimes.length != particles.length) lifetimes.length = particles.length;

    for (let i = 0; i < particles.length; i++)
    {
        if (particles[i].isDead)particles[i].reAnimate(time);
        particles[i].update(time);

        positions[i * 3 + 0] = particles[i].pos[0];
        positions[i * 3 + 1] = particles[i].pos[1];
        positions[i * 3 + 2] = particles[i].pos[2];

        lifetimes[i] = particles[i].lifeTimePercent;
        if (lifetimes[i] > 1.0)lifetimes[i] = 1.0;
    }

    outPositions.set(null);
    outLifetimes.set(null);
    outPositions.set(positions);
    outLifetimes.set(lifetimes);
    outTrigger.trigger();
};

function reset()
{
    particles.length = 0;

    for (let i = 0; i < num.get(); i++)
    {
        const p = new Particle();
        p.reAnimate();
        particles.push(p);
    }
}


};

Ops.Systems.ArraySpray.prototype = new CABLES.Op();
CABLES.OPS["27023519-9e88-4b85-9fcf-b316847e0df7"]={f:Ops.Systems.ArraySpray,objName:"Ops.Systems.ArraySpray"};




// **************************************************************
// 
// Ops.Systems.Lsystem_v2
// 
// **************************************************************

Ops.Systems.Lsystem_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inExe = op.inTrigger("Trigger");
const inStrAxiom = op.inString("Axiom / seed", "F");
const inStrConstant1 = op.inString("Constant 1", "F");
const inStrRule1 = op.inString("Rule 1", "Fx5y2.2F[yxFF]fF[yXFFfzFZF]fF[yXzFFfzFZF]");
const inStrConstant2 = op.inString("Constant 2", "x");
const inStrRule2 = op.inString("Rule 2");
const inStrConstant3 = op.inString("Constant 3", "y");
const inStrRule3 = op.inString("Rule 3");
const inStrConstant4 = op.inString("Constant 4", "z");
const inStrRule4 = op.inString("Rule 4");

inStrAxiom.setUiAttribs({ "hidePort": true });
inStrConstant1.setUiAttribs({ "hidePort": true });
inStrRule1.setUiAttribs({ "hidePort": true });
inStrConstant2.setUiAttribs({ "hidePort": true });
inStrRule2.setUiAttribs({ "hidePort": true });
inStrConstant3.setUiAttribs({ "hidePort": true });
inStrRule3.setUiAttribs({ "hidePort": true });
inStrConstant4.setUiAttribs({ "hidePort": true });
inStrRule4.setUiAttribs({ "hidePort": true });

const inIterations = op.inValueInt("Iterations", 1);
const inStepLength = op.inValue("Step length", 1.0);
const inStepScale = op.inValue("Step scale multiplier", 1.0);
const inDefaultAngle = op.inValue("Default angle", 45.0);
const inRotateMutliplier = op.inValue("Rotation multiplier", 1.0);

const outTrigger = op.outTrigger("Out trigger geometry");
const lineTrigger = op.outTrigger("Line/point trigger");
// const outArray = op.outArray("Matrix Array out");
const outPoints = op.outArray("Points out");
const outMax = op.outNumber("Max Size");
const stringOut = op.outString("Final generated string");

const seed = op.inValue("random seed");
const inRandStr = op.inValue("random strength");

let angleMultiplier = inRotateMutliplier.get();
let len = inStepLength.get();
let lenScale = inStepScale.get();

const cgl = op.patch.cgl;

// create a matrix
let trans = mat4.create();
// array to put trans into
const transforms = [];
// pop in and out matrix for branch transforms
const stack = [];

// used for splines array
const pointArrays = [];
let currentPointArray = [];
const lastPointArray = [0, 0, 0];

// this becomes the axiom after the resetAll() is called
let sentence = "";// axiom;

// an array that holds the string replacment rules
let rules = [];

let needsCalc = true;
// UI input
inRotateMutliplier.onChange = calcLater;
inStepLength.onChange = calcLater;
inStepScale.onChange = calcLater;
inIterations.onChange = calcLater;
inExe.onTriggered = render;
seed.onChange = calcLater;
inRandStr.onChange = calcLater;
inDefaultAngle.onChange = calcLater;

// if user changes rules or constants definesRules is updated
inStrAxiom.onChange = defineRules;
inStrConstant1.onChange = defineRules;
inStrRule1.onChange = defineRules;
inStrConstant2.onChange = defineRules;
inStrRule2.onChange = defineRules;
inStrConstant3.onChange = defineRules;
inStrRule3.onChange = defineRules;
inStrConstant4.onChange = defineRules;
inStrRule4.onChange = defineRules;

op.init = function ()
{
    defineRules();
};
// creates the constants and the rule sets
function defineRules()
{
    rules =
    [
        inStrConstant1.get(),
        inStrRule1.get(),
        inStrConstant2.get(),
        inStrRule2.get(),
        inStrConstant3.get(),
        inStrRule3.get(),
        inStrConstant4.get(),
        inStrRule4.get()
    ];
    generate();
}

// reset everything
function resetAll()
{
    // define axiom here
    sentence = inStrAxiom.get();
    angleMultiplier = inRotateMutliplier.get();
    len = inStepLength.get();
    lenScale = inStepScale.get();
}

// generates the string from the ruleset array
function generate()
{
    // reset the state of everything
    resetAll();

    let nextSentence = "";
    const iterationsLimit = Math.min(6, inIterations.get());
    let iter;
    let i;
    let r;

    for (iter = 0; iter < iterationsLimit; iter++)
    {
        const sentenceArrayLength = sentence.length;
        const rulesArrayLength = rules.length;//

        for (i = 0; i < sentenceArrayLength; i++)
        {
            const current = sentence.charAt(i);
            let found = false;

            for (r = 0; r < rulesArrayLength; r += 2)
            {
                if (current === rules[r])
                {
                    found = true;
                    nextSentence += rules[r + 1];
                }
            }
            // if nothing is found continue no matter what
            if (!found)nextSentence += current;
        }
        // final result
        sentence = nextSentence;
        nextSentence = "";
        // removing this will add everything on top of each other recursively
        // nextSentence="";
    }
    stringOut.set(sentence);
    // draw everything once with the turtle function
    turtle();
    needsCalc = false;
}

// used to connect start and end of branches together correctly
const pos = vec3.create();
const empty = vec3.create();

// extracts the user defined angle
// FfFx45FF returns 45 on the x axis
function extract(str, pos)
{
    const slicedSentence = str.slice(pos);

    let output = "";
    let parsedNumber = "";
    let currentChar = "";
    let canceled = true;
    // starts i at 1 to drop character which is actually the identifying key!
    for (let i = 1; i < slicedSentence.length; i++)
    {
        // output = slicedSentence.slice(i);
        output = slicedSentence.substr(i, 8);
        for (let j = 0; j < output.length; j++)
        {
            currentChar = output.charAt(j);
            if (!Number.isNaN(currentChar))
            {
                parsedNumber += currentChar;
            }
            else if (Number.isNaN(currentChar))
            {
                canceled = true;
                break;
            }
        }
        if (canceled) break;
    }
    return parseFloat(parsedNumber);
}

// recreates the turtle algorithm
function turtle()
{
    // used to find max distance from starting point
    let max = 0;
    // create the main transform array
    trans = mat4.create();
    transforms.length = 0;
    pointArrays.length = 0;
    stack.length = 0;
    const branchCoordStack = [];

    currentPointArray = [];
    let angleUi = "";

    let currentBranch = 0;
    for (let i = 0; i < sentence.length; i++)
    {
        const current = sentence.charAt(i);
        // step forward, create point
        if (current == "F")
        {
            // apply to the trans matrix, take a step
            mat4.translate(trans, trans, [0.0, len, 0.0]);
            // push matrix for geometry
            transforms.push(mat4.clone(trans));
            // get xyz for point array
            vec3.transformMat4(pos, empty, trans);
            // spline
            currentPointArray.push(pos[0], pos[1], pos[2]);

            max = Math.max(max, Math.abs(pos[0]));
            max = Math.max(max, Math.abs(pos[1]));
            max = Math.max(max, Math.abs(pos[2]));
        }
        // step forward do not add a point
        else if (current == "f")
        {
            mat4.translate(trans, trans, [0.0, len, 0.0]);
        }
        // alter step length by step multiplier
        else if (current == ">")
        {
            len *= lenScale;
        }
        else if (current == "<")
        {
            len /= lenScale;
        }
        // turn counter clockwise x defined by angle
        else if (current == "x")
        {
            if (isNaN(sentence.charAt(i + 1)))
                angleUi = -inDefaultAngle.get() * angleMultiplier;
            else
                angleUi = -extract(sentence, i) * angleMultiplier;
            mat4.rotateX(trans, trans, CGL.DEG2RAD * (angleUi - Math.seededRandom() * inRandStr.get()));
        }
        // turn clockwise x defined by angleUi
        else if (current == "X")
        {
            if (isNaN(sentence.charAt(i + 1)))
                angleUi = inDefaultAngle.get() * angleMultiplier;
            else
                angleUi = extract(sentence, i) * angleMultiplier;
            mat4.rotateX(trans, trans, CGL.DEG2RAD * (angleUi + Math.seededRandom() * inRandStr.get()));
        }
        // turn counter clockwise y defined by angleUi
        else if (current == "y")
        {
            if (isNaN(sentence.charAt(i + 1)))
                angleUi = -inDefaultAngle.get() * angleMultiplier;
            else
                angleUi = -extract(sentence, i) * angleMultiplier;
            mat4.rotateY(trans, trans, CGL.DEG2RAD * (angleUi - Math.seededRandom() * inRandStr.get()));
        }
        // turn clockwise y defined by angleUi
        else if (current == "Y")
        {
            if (isNaN(sentence.charAt(i + 1)))
                angleUi = inDefaultAngle.get() * angleMultiplier;
            else
                angleUi = extract(sentence, i) * angleMultiplier;
            mat4.rotateY(trans, trans, CGL.DEG2RAD * (angleUi + Math.seededRandom() * inRandStr.get()));
        }
        // turn counter clockwise z defined by angleUi
        else if (current == "z")
        {
            if (isNaN(sentence.charAt(i + 1)))
                angleUi = -inDefaultAngle.get() * angleMultiplier;
            else
                angleUi = -extract(sentence, i) * angleMultiplier;
            mat4.rotateZ(trans, trans, CGL.DEG2RAD * (angleUi - Math.seededRandom() * inRandStr.get()));
        }
        // turn clockwise z defined by angleUi
        else if (current == "Z")
        {
            if (isNaN(sentence.charAt(i + 1)))
                angleUi = inDefaultAngle.get() * angleMultiplier;
            else
                angleUi = extract(sentence, i) * angleMultiplier;
            mat4.rotateZ(trans, trans, CGL.DEG2RAD * (angleUi + Math.seededRandom() * inRandStr.get()));
        }
        else if (current == "[")
        {
            // get current transform matrix push into stack, branch start
            stack.push(mat4.clone(trans));

            vec3.transformMat4(pos, empty, trans);

            branchCoordStack.push([pos[0], pos[1], pos[2]]);

            // output current branch number
            currentBranch += 1;
        }
        else if (current == "]")
        {
            // get the current branch push into the transform matrix
            // check if branch has a start to avoid error
            if (stack.length === 0)
            {
                break;
            }

            trans = stack[stack.length - 1];
            stack.pop();

            // this code section is used to correctly connect the branches together with spline
            const branchStartCoord = branchCoordStack[branchCoordStack.length - 1];

            branchCoordStack.pop();

            pointArrays.push(currentPointArray);

            if (branchStartCoord) currentPointArray = [branchStartCoord[0], branchStartCoord[1], branchStartCoord[2]];
            else currentPointArray = [];
        }
    }
    needsCalc = false;
    pointArrays.push(currentPointArray);
    // outArray.set(transforms);
    outMax.set(max);
}

function calcLater()
{
    needsCalc = true;
}

function render()
{
    if (needsCalc)
    {
        generate();
    }
    needsCalc = false;

    // iterate through transforms array and trigger all geometry
    for (var i = 0; i < transforms.length; i++)
    {
        cgl.pushModelMatrix();
        mat4.multiply(cgl.mMatrix, cgl.mMatrix, transforms[i]);
        outTrigger.trigger();
        cgl.popModelMatrix();
    }
    // iterate through points array for spline xyz data
    for (var i = 0; i < pointArrays.length; i++)
    {
        outPoints.set(pointArrays[i]);
        lineTrigger.trigger();
    }
}


};

Ops.Systems.Lsystem_v2.prototype = new CABLES.Op();
CABLES.OPS["ef4c436e-3de5-4a97-a392-10a52a5b3dc6"]={f:Ops.Systems.Lsystem_v2,objName:"Ops.Systems.Lsystem_v2"};




// **************************************************************
// 
// Ops.Templates.ExampleVizOp
// 
// **************************************************************

Ops.Templates.ExampleVizOp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNum = op.inFloat("Number", 23);

op.setUiAttrib({ "height": 200, "width": 200, "resizable": true });


op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(
        layer.x, layer.y,
        layer.width, layer.height);

    const padding = 10;

    ctx.fillStyle = "#05f";

    let circle = new Path2D();
    circle.arc(layer.x + layer.height / 2, layer.y + layer.height / 2, layer.height/2, 0, 2 * Math.PI, false);
    ctx.fill(circle);


    // draw text, use layer height for fontsize, so it is fixed when resizing the op or zooming the patch
    ctx.fillStyle = "#fff";
    const fontSize = layer.height * 0.7;
    ctx.font = "normal " + fontSize + "px sourceCodePro";
    ctx.fillText(Math.round(inNum.get() * 10000) / 10000, layer.x + padding, layer.y + fontSize);


    // this text will not scale and be at fixed size when zooming in/out
    ctx.font = "normal " + 12 + "px sourceCodePro";
    ctx.fillText(Math.round(inNum.get() * 10000) / 10000, layer.x + padding, layer.y+20);


};


};

Ops.Templates.ExampleVizOp.prototype = new CABLES.Op();
CABLES.OPS["08f3a509-1cad-4dfc-961c-2bd925e066dd"]={f:Ops.Templates.ExampleVizOp,objName:"Ops.Templates.ExampleVizOp"};




// **************************************************************
// 
// Ops.Templates.MinimalMaterial
// 
// **************************************************************

Ops.Templates.MinimalMaterial = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"shader_frag":"{{MODULE_BEGIN_FRAG}}\n\nvoid main()\n{\n   vec4 col=vec4(red,0.2,0.2,1.0);\n   {{MODULE_COLOR}}\n   outColor= col;\n}\n","shader_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\n\nvoid main()\n{\n   vec4 pos=vec4(vPosition,  1.0);\n   {{MODULE_VERTEX_POSITION}}\n   gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
const
    render = op.inTrigger("render"),
    trigger = op.outTrigger("trigger"),
    inRed = op.inValueSlider("Red");

const cgl = op.patch.cgl;

function doRender()
{
    cgl.pushShader(shader);
    trigger.trigger();
    cgl.popShader();
}

const shader = new CGL.Shader(cgl, "MinimalMaterial");
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
shader.setSource(attachments.shader_vert, attachments.shader_frag);

shader.addUniformFrag("f", "red", inRed);

render.onTriggered = doRender;


};

Ops.Templates.MinimalMaterial.prototype = new CABLES.Op();
CABLES.OPS["2df1b492-6a97-4064-b939-ff926d4414d0"]={f:Ops.Templates.MinimalMaterial,objName:"Ops.Templates.MinimalMaterial"};




// **************************************************************
// 
// Ops.Templates.PortsArrayExample
// 
// **************************************************************

Ops.Templates.PortsArrayExample = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// Create a input port of the type Array
const inArr = op.inArray("Array in");

// Create a output port of the type Array
const outArray = op.outArray("Array out");

// cache for errors
let showingError = false;

// when array in changes call the function update
inArr.onChange = update;

// TODO revalute error checking code !!
function update()
{
    // create an array called 'tempArray' and assign
    // the array coming in to it
    let tempArray = inArr.get();

    // error checking section
    // check if arrays come in correctly on startup
    // if no array comes in just return to avoid errors
    if (!inArr)
    {
        return;
    }
    // set outArray to tempArray
    outArray.set(tempArray);
}


};

Ops.Templates.PortsArrayExample.prototype = new CABLES.Op();
CABLES.OPS["c31a7377-0eca-476e-8146-c2d9b8d3b908"]={f:Ops.Templates.PortsArrayExample,objName:"Ops.Templates.PortsArrayExample"};




// **************************************************************
// 
// Ops.Templates.PortsBooleanExample
// 
// **************************************************************

Ops.Templates.PortsBooleanExample = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// Create a input port of the type Boolean
const inBoolean = op.inBool("Boolean in", false);

// Create a output port of the type value
const outBoolean = op.outBoolNum("Boolean out");

// when input port changes call the function 'update'
inBoolean.onChange = update;

// this function runs every time the input port changes
function update()
{
    // set the ouput port to the value of the input port
    outBoolean.set(inBoolean.get());
}


};

Ops.Templates.PortsBooleanExample.prototype = new CABLES.Op();
CABLES.OPS["a21cd004-5cdf-4da2-8866-d1372497c3ff"]={f:Ops.Templates.PortsBooleanExample,objName:"Ops.Templates.PortsBooleanExample"};




// **************************************************************
// 
// Ops.Templates.PortsObjectExample
// 
// **************************************************************

Ops.Templates.PortsObjectExample = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
//Create a input port of the type value
const inObj  = op.inObject("Object in");

//Create a output port of the type value
const outKeyVal=op.outObject("Object Out");

//when input port changes call the function 'update'
inObj.onChange = update;

//this function runs every time the input port changes
function update()
{
    outKeyVal.set(inObj.get());
};



};

Ops.Templates.PortsObjectExample.prototype = new CABLES.Op();
CABLES.OPS["d7f414bf-804f-4c1a-987f-dfdbb3d80e27"]={f:Ops.Templates.PortsObjectExample,objName:"Ops.Templates.PortsObjectExample"};




// **************************************************************
// 
// Ops.Templates.PortsStringExample
// 
// **************************************************************

Ops.Templates.PortsStringExample = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
//Create a input port of the type String
const inString  = op.inString("String in", "default string");
//Create a output port of the type String
const outString = op.outString("String out");

//when input port changes call the function 'update'
inString.onChange = update;

//this function runs every time the input port changes
function update()
{
    //set the output to the input string
    outString.set(inString.get());
}

};

Ops.Templates.PortsStringExample.prototype = new CABLES.Op();
CABLES.OPS["3d387694-022f-431f-b25e-636c6d666518"]={f:Ops.Templates.PortsStringExample,objName:"Ops.Templates.PortsStringExample"};




// **************************************************************
// 
// Ops.Templates.PortsTriggerExample
// 
// **************************************************************

Ops.Templates.PortsTriggerExample = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
//Create a input port of the type Trigger
const inExecute  = op.inTrigger("Trigger In");
//create a button in UI panel of the op which can be clicked
const inButton = op.inTriggerButton("Press me");

//Create a output port of the type Trigger
const outTrigger = op.outTrigger("Trigger out");

//when input port is triggered call the function 'update'
//Or
//if user presses the button in the op pane call function 'update'
inExecute.onTriggered = inButton.onTriggered= update;

//this function runs every time the input port is triggered
function update()
{
    //send a trigger out of the output port
    outTrigger.trigger();
}

};

Ops.Templates.PortsTriggerExample.prototype = new CABLES.Op();
CABLES.OPS["10728b97-ea46-4491-bb66-e6ad01289001"]={f:Ops.Templates.PortsTriggerExample,objName:"Ops.Templates.PortsTriggerExample"};




// **************************************************************
// 
// Ops.Templates.PortsValueExample
// 
// **************************************************************

Ops.Templates.PortsValueExample = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
//Create a input port of the type value
const inVal = op.inFloat("Number in ",0);

//Create a output port of the type value
const outResult  = op.outNumber("Value out");

//when input port changes call the function 'update'
inVal.onChange = update;

//this function runs every time the input port changes
function update()
{
    //set the ouput port to the value of the input port
    outResult.set(inVal.get());
}

};

Ops.Templates.PortsValueExample.prototype = new CABLES.Op();
CABLES.OPS["362a1c2f-c4e8-41eb-944b-d16c73a8d27b"]={f:Ops.Templates.PortsValueExample,objName:"Ops.Templates.PortsValueExample"};




// **************************************************************
// 
// Ops.Templates.ShaderEffectExample
// 
// **************************************************************

Ops.Templates.ShaderEffectExample = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"shaderEffectExample_body_frag":"\nfloat MOD_v=mod(MOD_posz,MOD_width)/MOD_width;\ncol*=vec4(MOD_v,MOD_v,MOD_v,1.0);","shaderEffectExample_body_vert":"MOD_posz=(viewMatrix*mMatrix*pos).z;\n","shaderEffectExample_head_frag":"\nIN float MOD_posz;\nUNI float MOD_width;","shaderEffectExample_head_vert":"OUT float MOD_posz;",};
const render = op.inTrigger("Render");
const inWidth = op.inValue("Width", 0.5);
const next = op.outTrigger("Next");

const cgl = op.patch.cgl;

let shader = null;
let moduleFrag = null;
let moduleVert = null;

render.onLinkChanged = removeModule;

function removeModule()
{
    if (shader && moduleFrag) shader.removeModule(moduleFrag);
    if (shader && moduleVert) shader.removeModule(moduleVert);
    shader = null;
}

render.onTriggered = function ()
{
    if (!cgl.getShader()) return;

    if (cgl.getShader() != shader)
    {
        if (shader) removeModule();
        shader = cgl.getShader();

        moduleVert = shader.addModule(
            {
                "title": op.objName,
                "name": "MODULE_VERTEX_POSITION",
                "srcHeadVert": attachments.shaderEffectExample_head_vert || "",
                "srcBodyVert": attachments.shaderEffectExample_body_vert || ""
            });

        moduleFrag = shader.addModule(
            {
                "title": op.objName,
                "name": "MODULE_COLOR",
                "srcHeadFrag": attachments.shaderEffectExample_head_frag || "",
                "srcBodyFrag": attachments.shaderEffectExample_body_frag || ""
            }, moduleVert);

        inWidth.uniform = new CGL.Uniform(shader, "f", moduleFrag.prefix + "width", inWidth);
    }

    if (!shader) return;

    next.trigger();
};


};

Ops.Templates.ShaderEffectExample.prototype = new CABLES.Op();
CABLES.OPS["a0df10ce-7ae5-49a4-83df-6afc1f5a3f3a"]={f:Ops.Templates.ShaderEffectExample,objName:"Ops.Templates.ShaderEffectExample"};




// **************************************************************
// 
// Ops.Templates.UiTestOp
// 
// **************************************************************

Ops.Templates.UiTestOp = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inLoadingTask = op.inBool("Loading Task", false),
    inWarning1 = op.inBool("Warning", false),
    inUiError = op.inBool("Error", false),
    inUiHint = op.inBool("Hint", false),
    innum = op.inFloatSlider("Slider", 0),
    inResize = op.inBool("Resizable"),
    trig = op.inTrigger("trigger"),

    inSwit = op.inBool("greyout"),
    ingreyoutLine = op.inFloatSlider("this will greyout"),

    inLog = op.inTriggerButton("op.log()"),
    inLogWarn = op.inTriggerButton("op.logWarn()"),
    inLogErr = op.inTriggerButton("op.logError()"),

    inPrompt = op.inTriggerButton("Open Prompt"),
    inModal = op.inTriggerButton("Open Modal"),
    inTab = op.inTriggerButton("Open new Tab"),
    inExc = op.inTriggerButton("Throw Exception"),
    outBlah = op.outNumber("Something");

op.setPortGroup("Greyout", [inSwit, ingreyoutLine]);
op.setPortGroup("Warnings", [inWarning1, inUiHint, inUiError]);
op.setPortGroup("Logging", [inLog, inLogWarn, inLogErr]);
op.setPortGroup("Modal", [inPrompt, inModal]);

let loadingId = null;

op.onDelete = () =>
{
    if (loadingId) op.patch.loading.finished(loadingId);
};

inSwit.onChange = () =>
{
    ingreyoutLine.setUiAttribs({ "greyout": inSwit.get() });
};

inLoadingTask.onChange = () =>
{
    if (inLoadingTask.get()) loadingId = op.patch.loading.start("test ui op file", "test.txt");
    else
    {
        op.patch.loading.finished(loadingId);
        loadingId = null;
    }
};

inWarning1.onChange = () =>
{
    if (inWarning1.get()) op.setUiError("Warn1", "Warning one", 1);
    else op.setUiError("Warn1", null);
};

inUiHint.onChange = () =>
{
    if (inUiHint.get()) op.setUiError("Hint1", "This is a hint!", 0);
    else op.setUiError("Hint1", null);
};

inUiError.onChange = () =>
{
    if (inUiError.get()) op.setUiError("Warn2", "Warning two", 2);
    else op.setUiError("Warn2", null);
};

innum.onChange = () =>
{
    const q = innum.get();

    if (q < 0.3) op.setUiError("qRange", "number to small", 1);
    else if (q > 0.6) op.setUiError("qRange", "number to big", 1);
    else
    {
        op.log("no error!");
        op.setUiError("qRange", null);
    }
    op.log(q);
};

inLog.onTriggered = () =>
{
    // if you dont see this open the logging filter
    // by pressing cmd/ctrl+p "logging"
    // and deactivate the filter for this op name.
    op.log("this is verbose logging!");
};

inLogWarn.onTriggered = () =>
{
    op.logWarn("this is a warning!");
};

inLogErr.onTriggered = () =>
{
    op.logError("this is an error!");
};

inPrompt.onTriggered = () =>
{
    new CABLES.UI.ModalDialog({
        "prompt": true,
        "title": "How Much",
        "text": "please enter something",
        "promptValue": "default",
        "promptOk": (v) =>
        {
            console.log("yes! prompt finished", v);
        }
    });
};

inResize.onChange = () =>
{
    op.setUiAttrib({ "resizable": inResize.get() });
};

inModal.onTriggered = () =>
{
    new CABLES.UI.ModalDialog({
        "title": "Title",
        "text": "Dialog content <b>can be <i>html</i><b>"
    });
};

inExc.onTriggered = () =>
{
    throw new Error("crash0r");
};

inTab.onTriggered = () =>
{
    const tab = new CABLES.UI.Tab("Example",
        {
            "icon": "cube",
            "padding": true,
            "singleton": false
        });

    gui.mainTabs.addTab(tab, true);
    tab.addEventListener("onClose", () => { console.log("tab was closed!"); });
    tab.html("this is the tab content. ");
    gui.maintabPanel.show(true);
};


};

Ops.Templates.UiTestOp.prototype = new CABLES.Op();
CABLES.OPS["14fb5b5b-2a4e-419d-a15b-f20d41cf663b"]={f:Ops.Templates.UiTestOp,objName:"Ops.Templates.UiTestOp"};




// **************************************************************
// 
// Ops.Time.DelayedTrigger
// 
// **************************************************************

Ops.Time.DelayedTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    delay = op.inValueFloat("delay", 1),
    cancel = op.inTriggerButton("Cancel"),
    next = op.outTrigger("next"),
    outDelaying = op.outBool("Delaying");

let lastTimeout = null;

cancel.onTriggered = function ()
{
    if (lastTimeout)clearTimeout(lastTimeout);
    lastTimeout = null;
};

exe.onTriggered = function ()
{
    outDelaying.set(true);
    if (lastTimeout)clearTimeout(lastTimeout);

    lastTimeout = setTimeout(
        function ()
        {
            outDelaying.set(false);
            lastTimeout = null;
            next.trigger();
        },
        delay.get() * 1000);
};


};

Ops.Time.DelayedTrigger.prototype = new CABLES.Op();
CABLES.OPS["f4ff66b0-8500-46f7-9117-832aea0c2750"]={f:Ops.Time.DelayedTrigger,objName:"Ops.Time.DelayedTrigger"};




// **************************************************************
// 
// Ops.Time.Milliseconds
// 
// **************************************************************

Ops.Time.Milliseconds = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};


const
    inUpdate=op.inTrigger("update"),
    res=op.outNumber("Result");

inUpdate.onTriggered=function()
{
  res.set(performance.now());
};

};

Ops.Time.Milliseconds.prototype = new CABLES.Op();
CABLES.OPS["2f447fcb-3c20-4c2f-9527-84daed3a6b0e"]={f:Ops.Time.Milliseconds,objName:"Ops.Time.Milliseconds"};




// **************************************************************
// 
// Ops.Time.TimeSinceTrigger
// 
// **************************************************************

Ops.Time.TimeSinceTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    trigger = op.inTriggerButton("trigger"),
    reset = op.inTriggerButton("reset"),
    next = op.outTrigger("next"),
    time = op.outNumber("time");

let lastTrigger = op.patch.freeTimer.get();
time.set(0);

exe.onTriggered = function ()
{
    time.set(op.patch.freeTimer.get() - lastTrigger);
    next.trigger();
};

reset.onTriggered = function ()
{
    time.set(0);
};

trigger.onTriggered = function ()
{
    lastTrigger = op.patch.freeTimer.get();
    time.set(0);
};


};

Ops.Time.TimeSinceTrigger.prototype = new CABLES.Op();
CABLES.OPS["df54103f-5ef6-4a4f-adcf-dddc005132f8"]={f:Ops.Time.TimeSinceTrigger,objName:"Ops.Time.TimeSinceTrigger"};




// **************************************************************
// 
// Ops.TimeLine.AutoPlay
// 
// **************************************************************

Ops.TimeLine.AutoPlay = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

op.patch.timer.play();

};

Ops.TimeLine.AutoPlay.prototype = new CABLES.Op();
CABLES.OPS["6069e8fe-6cf5-4be6-be38-4d46056ec9f7"]={f:Ops.TimeLine.AutoPlay,objName:"Ops.TimeLine.AutoPlay"};




// **************************************************************
// 
// Ops.TimeLine.DemoPrerender
// 
// **************************************************************

Ops.TimeLine.DemoPrerender = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Render"),
    inEvents = op.inArray("Times"),
    inRecord = op.inBool("Record Events", false),
    inReset = op.inTriggerButton("Reset"),
    inClear = op.inTriggerButton("Clear"),
    inReResize = op.inBool("ReRender on Resize", true),
    next = op.outTrigger("Next"),
    nextPrerendered = op.outTrigger("Prerendered Frame"),
    outProgress = op.outNumber("Progress", 0),
    numEvents = op.outNumber("Num Events");

exec.onTriggered = render;
inEvents.setUiAttribs({ "hidePort": true });

let isPrerendering = true;

let prerenderCount = 0;
let delaystart = false;
let restartTime = 0;
let restartTimeFreeTimer = 0;
let events = [0];

op.patch.cgl.on("resize", () =>
{
    if (inReResize.get())
    {
        if (!isPrerendering && outProgress.get() == 1)
        {
            restartTime = op.patch.timer.getTime();
            restartTimeFreeTimer = op.patch.freeTimer.getTime();

            isPrerendering = true;
            prerenderCount = 0;
        }
    }
});

inEvents.onChange = () =>
{
    numEvents.set(events.length);
    events = inEvents.get() || [0];
};

op.patch.cgl.on("heavyEvent", (e) =>
{
    if (inRecord.get() && !isPrerendering && CABLES.uniqueArray)
    {
        events.push(Math.round(op.patch.timer.getTime() * 60) / 60);
        events = CABLES.uniqueArray(events);
        inEvents.set(events);
    }
});

let curTime = 0;

inReset.onTriggered = () =>
{
    isPrerendering = true;
};

inClear.onTriggered = () =>
{
    events = [0];
    inEvents.set(events);
};

function fakeNow()
{
    return curTime * 1000;
}

function render()
{
    if (inRecord.get())
    {
        isPrerendering = false;
        outProgress.set(1);
        next.trigger();

        return;
    }
    if (isPrerendering)
    {
        // for(let i=0;i<events.length;i++)
        // {
        if (prerenderCount < events.length)
        {
            const oldInternalNow = CABLES.internalNow;
            CABLES.internalNow = fakeNow;

            curTime = events[prerenderCount];
            op.patch._frameNum = prerenderCount + 22;

            // op.log("isPrerendering at ", curTime);

            CABLES.overwriteTime = curTime;
            op.patch.timer.setTime(curTime);
            op.patch.freeTimer.setTime(curTime);

            // op.log("the time",op.patch.timer.getTime());

            CABLES.overwriteTime = undefined;
            CABLES.internalNow = oldInternalNow;

            // op.patch.timer.setTime(0);
            // op.patch.freeTimer.setTime(0);

            // }
        }

        const numExtraFrames = 30;
        if (prerenderCount >= events.length)
        {
            const t = (numExtraFrames - (prerenderCount - events.length)) / numExtraFrames;

            // op.log("empty prerender...", t);
            op.patch.timer.setTime(t);
            op.patch.freeTimer.setTime(t);
        }

        next.trigger();
        next.trigger();
        // next.trigger();
        // next.trigger();
        outProgress.set(Math.min(1, prerenderCount / (events.length + numExtraFrames)));
        // op.log("progress...", outProgress.get());

        nextPrerendered.trigger();

        if (prerenderCount >= events.length + numExtraFrames)
        {
            op.patch.timer.setTime(restartTime);
            op.patch.freeTimer.setTime(restartTimeFreeTimer);

            // setTimeout(() =>
            // {
            //     delaystart = false;
            isPrerendering = false;
            //     op.patch.timer.setTime(0);
            //     op.patch.freeTimer.setTime(0);
            // }, 500);
        }
        else
            prerenderCount++;
    }
    else
    {
        next.trigger();
    }
}


};

Ops.TimeLine.DemoPrerender.prototype = new CABLES.Op();
CABLES.OPS["962ea9e5-39ee-448c-9a2b-b71ceee47c11"]={f:Ops.TimeLine.DemoPrerender,objName:"Ops.TimeLine.DemoPrerender"};




// **************************************************************
// 
// Ops.TimeLine.GotoFrame
// 
// **************************************************************

Ops.TimeLine.GotoFrame = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
var inFrame=op.inValueInt("Frame");

inFrame.onChange=function()
{
    op.patch.timer.setTime(inFrame.get()/30.0);
    
    if(CABLES.UI) gui.timeLine().updateTime();
};


};

Ops.TimeLine.GotoFrame.prototype = new CABLES.Op();
CABLES.OPS["5ff97165-b16c-46cc-8ce5-119fddccf1a3"]={f:Ops.TimeLine.GotoFrame,objName:"Ops.TimeLine.GotoFrame"};




// **************************************************************
// 
// Ops.TimeLine.PreRender
// 
// **************************************************************

Ops.TimeLine.PreRender = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Render"),
    next = op.outTrigger("Next"),
    progress = op.outTrigger("Render Progress"),
    done = op.outTrigger("Done"),
    inMaxTime = op.inInt("Max Time", 1),

    inStep = op.inInt("Step", 30),
    inReset = op.inTriggerButton("Reset"),
    outProgress = op.outNumber("Progress", 0);

exec.onTriggered = render;

let start = true;
let curTime = -1;
let wait = true;

inReset.onTriggered = function ()
{
    if (curTime < 0)
        start = true;
};

function render()
{
    if (!start && curTime < 0)
    {
        if (!wait)
            next.trigger();
        wait = false;
        return;
    }

    const maxTime = inMaxTime.get();
    if (start)
    {
        curTime = maxTime;
        start = false;
        wait = true;
    }

    const oldInternalNow = CABLES.internalNow;
    CABLES.internalNow = function ()
    {
        return curTime * 1000;
    };

    CABLES.overwriteTime = curTime;
    op.patch.timer.setTime(curTime);
    op.patch.freeTimer.setTime(curTime);

    outProgress.set((maxTime - curTime) / maxTime);

    next.trigger();
    next.trigger();
    next.trigger();

    CABLES.overwriteTime = undefined;
    CABLES.internalNow = oldInternalNow;

    progress.trigger();

    if (curTime === 0)
    {
        done.trigger();
        curTime = -1;
    }
    else
    {
        curTime -= inStep.get();
        if (curTime < 0)
            curTime = 0;
    }
}


};

Ops.TimeLine.PreRender.prototype = new CABLES.Op();
CABLES.OPS["294efbca-f2b6-46fa-8b28-0530d6b9f9c8"]={f:Ops.TimeLine.PreRender,objName:"Ops.TimeLine.PreRender"};




// **************************************************************
// 
// Ops.TimeLine.TimeLineControls
// 
// **************************************************************

Ops.TimeLine.TimeLineControls = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const plauPause = op.outBoolNum("Play/Stop");
const time = op.outNumber("time");

op.patch.timer.on("playPause", seek);
op.patch.timer.on("timeChange", seek);

function seek()
{
    plauPause.set(false);

    setTimeout(function ()
    {
        time.set(op.patch.timer.getTime());
        plauPause.set(op.patch.timer.isPlaying());
    }, 10);
}


};

Ops.TimeLine.TimeLineControls.prototype = new CABLES.Op();
CABLES.OPS["53cb7b1a-56c7-405f-b427-12db78fbfd2f"]={f:Ops.TimeLine.TimeLineControls,objName:"Ops.TimeLine.TimeLineControls"};




// **************************************************************
// 
// Ops.TimeLine.TimeLineFrame
// 
// **************************************************************

Ops.TimeLine.TimeLineFrame = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
var theTime=op.addOutPort(new CABLES.Port(this,"time"));

op.onAnimFrame=function(time)
{
    theTime.set(Math.round(time*30.0));
};

};

Ops.TimeLine.TimeLineFrame.prototype = new CABLES.Op();
CABLES.OPS["a6c66f1f-2102-4b68-882b-afd25a4da538"]={f:Ops.TimeLine.TimeLineFrame,objName:"Ops.TimeLine.TimeLineFrame"};




// **************************************************************
// 
// Ops.TimeLine.TimeLineLength
// 
// **************************************************************

Ops.TimeLine.TimeLineLength = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// uses its input port for caching the length of the timeline...

const
    inLength = op.inFloat("len", 0),
    outLength = op.outNumber("Length");

inLength.setUiAttribs({ "hidePort": true, "hideParam": true });

if (CABLES.UI)
{
    inLength.set(gui.timeLine().getTimeLineLength());

    gui.on("timelineControl", (cmd, l) =>
    {
        if (cmd === "setLength")
        {
            inLength.set(l);
            outLength.set(inLength.get());
        }
    });
    outLength.set(inLength.get());
}

op.on("loadedValueSet", () =>
{
    outLength.set(inLength.get());
});


};

Ops.TimeLine.TimeLineLength.prototype = new CABLES.Op();
CABLES.OPS["c8aee7f4-ad53-406d-b7fe-527bf271c088"]={f:Ops.TimeLine.TimeLineLength,objName:"Ops.TimeLine.TimeLineLength"};




// **************************************************************
// 
// Ops.TimeLine.TimeLineLoop
// 
// **************************************************************

Ops.TimeLine.TimeLineLoop = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    execute = op.inTrigger("Execute"),
    duration = op.inValueFloat("duration", 2),
    trigger = op.outTrigger("trigger");

execute.onTriggered = function ()
{
    if (op.patch.timer.getTime() > duration.get())
        op.patch.timer.setTime(0);

    trigger.trigger();
};


};

Ops.TimeLine.TimeLineLoop.prototype = new CABLES.Op();
CABLES.OPS["e450a850-7311-48b5-abfc-07ec1fea3b8e"]={f:Ops.TimeLine.TimeLineLoop,objName:"Ops.TimeLine.TimeLineLoop"};




// **************************************************************
// 
// Ops.TimeLine.TimeLineOverwrite
// 
// **************************************************************

Ops.TimeLine.TimeLineOverwrite = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exec = op.inTrigger("exe");
const newTime = op.inValueFloat("new time");
const next = op.outTrigger("trigger");

let realTime = 0;
exec.onTriggered = function ()
{
    realTime = op.patch.timer.getTime();

    op.patch.timer.overwriteTime = newTime.get();
    next.trigger();
    op.patch.timer.overwriteTime = -1;
};


};

Ops.TimeLine.TimeLineOverwrite.prototype = new CABLES.Op();
CABLES.OPS["f0492ba2-5009-4a9a-bfd9-8a03633df31c"]={f:Ops.TimeLine.TimeLineOverwrite,objName:"Ops.TimeLine.TimeLineOverwrite"};




// **************************************************************
// 
// Ops.TimeLine.TimeLinePlay
// 
// **************************************************************

Ops.TimeLine.TimeLinePlay = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    play = op.inTriggerButton("Play"),
    pause = op.inTriggerButton("Pause"),
    next = op.outTrigger("Next");

play.onTriggered = function ()
{
    op.patch.timer.play();
    next.trigger();
};

pause.onTriggered = function ()
{
    op.patch.timer.pause();
    next.trigger();
};


};

Ops.TimeLine.TimeLinePlay.prototype = new CABLES.Op();
CABLES.OPS["fc75b841-a55f-4474-8746-61218588598d"]={f:Ops.TimeLine.TimeLinePlay,objName:"Ops.TimeLine.TimeLinePlay"};




// **************************************************************
// 
// Ops.TimeLine.TimeLinePlayer
// 
// **************************************************************

Ops.TimeLine.TimeLinePlayer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    play = op.inTriggerButton("Play"),
    pause = op.inTriggerButton("Pause"),
    rewind = op.inTriggerButton("rewind"),
    setTime = op.inFloat("Set current time", 0),

    outPlayTrigger = op.outTrigger("play trigger"),
    outPauseTrigger = op.outTrigger("pause trigger"),
    outrewindTrigger = op.outTrigger("rewind trigger"),
    isPlaying = op.outBool("is Playing"),
    outSetTimeTrigger = op.outNumber("set time (seconds)"),
    currentTime = op.outNumber("current time"),
    currentFrame = op.outNumber("current frame");

play.onTriggered = function ()
{
    op.patch.timer.play();

    op.patch.timer.setTime(setTime.get());
    outSetTimeTrigger.set(setTime.get());
    outPlayTrigger.trigger();
};

pause.onTriggered = function ()
{
    op.patch.timer.pause();
    outPauseTrigger.trigger();
};

op.onAnimFrame = function (time)
{
    currentFrame.set(Math.round(time * 30.0));
    currentTime.set(time);
    isPlaying.set(op.patch.timer.isPlaying());
};

rewind.onTriggered = function ()
{
    op.patch.timer.setTime(0);
    outrewindTrigger.trigger();
};


};

Ops.TimeLine.TimeLinePlayer.prototype = new CABLES.Op();
CABLES.OPS["97e57613-6a51-41cf-9de5-fe3dbc2c69b2"]={f:Ops.TimeLine.TimeLinePlayer,objName:"Ops.TimeLine.TimeLinePlayer"};




// **************************************************************
// 
// Ops.TimeLine.TimeLineRewind
// 
// **************************************************************

Ops.TimeLine.TimeLineRewind = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTriggerButton("exe"),
    next = op.outTrigger("Next");

exe.onTriggered = function ()
{
    op.patch.timer.setTime(0);
    next.trigger();
};


};

Ops.TimeLine.TimeLineRewind.prototype = new CABLES.Op();
CABLES.OPS["d3408604-858c-4226-8d4c-1ef669956f35"]={f:Ops.TimeLine.TimeLineRewind,objName:"Ops.TimeLine.TimeLineRewind"};




// **************************************************************
// 
// Ops.TimeLine.TimeLineSetTime
// 
// **************************************************************

Ops.TimeLine.TimeLineSetTime = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTriggerButton("Update"),
    inTime = op.inFloat("Time", 0),
    next = op.outTrigger("Next");

exe.onTriggered = function ()
{
    op.patch.timer.setTime(parseFloat(inTime.get()));
    next.trigger();
};


};

Ops.TimeLine.TimeLineSetTime.prototype = new CABLES.Op();
CABLES.OPS["c65f3975-0901-4252-b040-f21f9b144d70"]={f:Ops.TimeLine.TimeLineSetTime,objName:"Ops.TimeLine.TimeLineSetTime"};




// **************************************************************
// 
// Ops.TimeLine.TimeLineTime
// 
// **************************************************************

Ops.TimeLine.TimeLineTime = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const theTime = op.outNumber("time");

op.onAnimFrame = function (time)
{
    theTime.set(time);
};


};

Ops.TimeLine.TimeLineTime.prototype = new CABLES.Op();
CABLES.OPS["3ab26f26-a12a-4c48-9411-20591a5f569d"]={f:Ops.TimeLine.TimeLineTime,objName:"Ops.TimeLine.TimeLineTime"};




// **************************************************************
// 
// Ops.TimeLine.TimeLineTogglePlay
// 
// **************************************************************

Ops.TimeLine.TimeLineTogglePlay = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const play=op.inBool("Play",false);

play.onChange=function()
{
    if(play.get()) op.patch.timer.play();
    else op.patch.timer.pause();
}


};

Ops.TimeLine.TimeLineTogglePlay.prototype = new CABLES.Op();
CABLES.OPS["930c6f38-9271-4021-a58b-14dcfc5763b2"]={f:Ops.TimeLine.TimeLineTogglePlay,objName:"Ops.TimeLine.TimeLineTogglePlay"};




// **************************************************************
// 
// Ops.TimeLine.TimelineValue
// 
// **************************************************************

Ops.TimeLine.TimelineValue = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTime = op.inValue("Time"),
    animVal = op.inValue("Value"),
    timeUnit = op.inValueSelect("Unit", ["Seconds", "Frames"], "Seconds"),
    outVal = op.outNumber("Result"),
    outArr = op.outArray("Anim Array"),
    outEnded = op.outBoolNum("Anim Finished");

inTime.onChange = update;
let hasError = false;

animVal.setAnimated(true);
animVal.onChange = update;
animVal.anim.onChange = animChange;
op.onLoaded = animChange;

let useFrames = false;

timeUnit.onChange = function ()
{
    useFrames = (timeUnit.get() == "Frames");
};

function update()
{
    inTime.get();

    if (animVal.isAnimated())
    {
        let t = inTime.get();
        if (useFrames) t /= 30.0;
        const v = animVal.anim.getValue(t);
        outEnded.set(animVal.anim.hasEnded(t));
        outVal.set(v);
        if (hasError)
        {
            op.setUiError("noanim", null);
            hasError = false;

            animVal.anim.onChange = animChange;
        }
    }
    else
    {
        op.setUiError("noanim", "Port \"animVal\" should be animated");
        hasError = true;
    }
}

function animChange()
{
    const arr = [];
    if (animVal.anim.keys && animVal.anim.keys.length > 0)
    {
        arr.length = animVal.anim.keys.length * 2;

        for (let i = 0; i < animVal.anim.keys.length; i++)
        {
            arr[i * 2 + 0] = animVal.anim.keys[i].time;
            arr[i * 2 + 1] = animVal.anim.keys[i].value;
        }
    }

    outArr.set(null);
    outArr.set(arr);
}


};

Ops.TimeLine.TimelineValue.prototype = new CABLES.Op();
CABLES.OPS["c5f260da-c8e3-4890-a37e-937d49b9da7d"]={f:Ops.TimeLine.TimelineValue,objName:"Ops.TimeLine.TimelineValue"};




// **************************************************************
// 
// Ops.Trigger.GateTrigger
// 
// **************************************************************

Ops.Trigger.GateTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger('Execute'),
    passThrough = op.inValueBool('Pass Through',true),
    triggerOut = op.outTrigger('Trigger out');

exe.onTriggered = function()
{
    if(passThrough.get())
        triggerOut.trigger();
}


};

Ops.Trigger.GateTrigger.prototype = new CABLES.Op();
CABLES.OPS["65e8b8a2-ba13-485f-883a-2bcf377989da"]={f:Ops.Trigger.GateTrigger,objName:"Ops.Trigger.GateTrigger"};




// **************************************************************
// 
// Ops.Trigger.IfEqualsThen
// 
// **************************************************************

Ops.Trigger.IfEqualsThen = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("exe");
let value1 = op.inValue("Value 1", 0);
let value2 = op.inValue("Value 2", 0);

let triggerThen = op.addOutPort(new CABLES.Port(op, "then", CABLES.OP_PORT_TYPE_FUNCTION));
let triggerElse = op.addOutPort(new CABLES.Port(op, "else", CABLES.OP_PORT_TYPE_FUNCTION));

function exec()
{
    if (value1.get() == value2.get())
    {
        triggerThen.trigger();
    }
    else
    {
        triggerElse.trigger();
    }
}

exe.onTriggered = exec;


};

Ops.Trigger.IfEqualsThen.prototype = new CABLES.Op();
CABLES.OPS["e8196d70-d0a6-470a-9448-a7ac0c0e956e"]={f:Ops.Trigger.IfEqualsThen,objName:"Ops.Trigger.IfEqualsThen"};




// **************************************************************
// 
// Ops.Trigger.Interval
// 
// **************************************************************

Ops.Trigger.Interval = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    interval = op.inValue("interval"),
    trigger = op.outTrigger("trigger"),
    active = op.inValueBool("Active", true);

active.onChange = function ()
{
    if (!active.get())
    {
        clearTimeout(timeOutId);
        timeOutId = -1;
    }
    else exec();
};

interval.set(1000);
let timeOutId = -1;

function exec()
{
    if (!active.get()) return;
    if (timeOutId != -1) return;

    timeOutId = setTimeout(function ()
    {
        timeOutId = -1;
        trigger.trigger();
        exec();
    },
    interval.get());
}

interval.onChange = exec;

exec();


};

Ops.Trigger.Interval.prototype = new CABLES.Op();
CABLES.OPS["3e9bae10-38af-4e36-9fcc-35faeeaf57f8"]={f:Ops.Trigger.Interval,objName:"Ops.Trigger.Interval"};




// **************************************************************
// 
// Ops.Trigger.IsTriggered
// 
// **************************************************************

Ops.Trigger.IsTriggered = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Trigger"),
    next = op.outTrigger("Next"),
    result = op.outBool("Was Triggered", false);

let frameCount = 0;

op.onAnimFrame = function (tt)
{
    frameCount++;
    if (frameCount > 1) result.set(false);
};

exec.onTriggered = function ()
{
    frameCount = 0;
    result.set(true);
    next.trigger();
};


};

Ops.Trigger.IsTriggered.prototype = new CABLES.Op();
CABLES.OPS["7c96fee9-4c2f-45e1-a41b-096b06d286b8"]={f:Ops.Trigger.IsTriggered,objName:"Ops.Trigger.IsTriggered"};




// **************************************************************
// 
// Ops.Trigger.NthTrigger_v2
// 
// **************************************************************

Ops.Trigger.NthTrigger_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let DEFAULT_NTH = 5;

// inputs
let exePort = op.inTriggerButton("Execute");
let nthPort = op.inValue("Nth", DEFAULT_NTH);

// outputs
let triggerPort = op.outTrigger("Next");

let count = 0;
let nth = DEFAULT_NTH;

exePort.onTriggered = onExeTriggered;
nthPort.onChange = valueChanged;

function onExeTriggered()
{
    count++;
    if (count % nth === 0)
    {
        count = 0;
        triggerPort.trigger();
    }
}

function valueChanged()
{
    nth = nthPort.get();
    count = 0;
}


};

Ops.Trigger.NthTrigger_v2.prototype = new CABLES.Op();
CABLES.OPS["ea43c184-5842-4aa1-b298-5db4515cbed0"]={f:Ops.Trigger.NthTrigger_v2,objName:"Ops.Trigger.NthTrigger_v2"};




// **************************************************************
// 
// Ops.Trigger.ProbabilityTrigger
// 
// **************************************************************

Ops.Trigger.ProbabilityTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inTrigger = op.inTrigger("Trigger In");
const inProbability = op.inFloatSlider("Probability", 0.5);
const outTrigger = op.outTrigger("Trigger Output");
const outInverseTrigger = op.outTrigger("Inverse Trigger Output");
Math.randomSeed = 0;

let scheduleUpdate = false;
let probability = inProbability.get();
inProbability.onChange = () =>
{
    if (inTrigger.isLinked())
    {
        scheduleUpdate = true;
        return;
    }
    probability = inProbability.get();
};

inTrigger.onTriggered = () =>
{
    if (scheduleUpdate)
    {
        probability = inProbability.get();
        scheduleUpdate = false;
    }
    if (probability >= 1)
    {
        outTrigger.trigger();
        return;
    }

    if (probability <= 0)
    {
        outInverseTrigger.trigger();
        return;
    }
    if (Math.seededRandom() < probability)
    {
        outTrigger.trigger();
    }
    else
    {
        outInverseTrigger.trigger();
    }
};


};

Ops.Trigger.ProbabilityTrigger.prototype = new CABLES.Op();
CABLES.OPS["69436c67-eab0-4829-b0dc-d7bfd863a116"]={f:Ops.Trigger.ProbabilityTrigger,objName:"Ops.Trigger.ProbabilityTrigger"};




// **************************************************************
// 
// Ops.Trigger.RandomTrigger
// 
// **************************************************************

Ops.Trigger.RandomTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTrigger("Render"),
    inNum = op.inValue("Num Times", 3),
    inSeed = op.inValue("Seed", 1),
    inOnlyOnce = op.inValueBool("Only Once"),
    outIndex = op.outNumber("Index");

const linked = [];
const triggers = [];

for (let i = 0; i < 8; i++)
{
    const newIn = op.addOutPort(new CABLES.Port(op, "trigger " + i, CABLES.OP_PORT_TYPE_FUNCTION));
    triggers.push(newIn);
    newIn.onLinkChanged = updateLinkedArray;
}

exec.onTriggered = function ()
{
    if (linked.length == 0) return;

    Math.randomSeed = inSeed.get();

    let numTriggered = 0;

    if (inOnlyOnce.get())
    {
        for (var i = 0; i < linked.length; i++)
            linked[i].RTwasTriggered = false;
    }

    for (var i = 0; i < inNum.get(); i++)
    {
        outIndex.set(i);

        const r = Math.floor(Math.seededRandom() * linked.length);

        if (linked[r])
        {
            if (inOnlyOnce.get())
            {
                if (numTriggered == linked.length)
                {
                    return;
                }
                if (!linked[r].RTwasTriggered)
                {
                    linked[r].trigger();
                    numTriggered++;
                }
                else i--;
            }
            else
            {
                linked[r].trigger();
            }
            linked[r].RTwasTriggered = true;
        }
    }
};

function updateLinkedArray()
{
    linked.length = 0;
    for (let i = 0; i < triggers.length; i++)
    {
        if (triggers[i].isLinked())
            linked.push(triggers[i]);
    }
}


};

Ops.Trigger.RandomTrigger.prototype = new CABLES.Op();
CABLES.OPS["3996175e-0424-407b-bcff-a7b4791d75df"]={f:Ops.Trigger.RandomTrigger,objName:"Ops.Trigger.RandomTrigger"};




// **************************************************************
// 
// Ops.Trigger.Repeat2d
// 
// **************************************************************

Ops.Trigger.Repeat2d = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    numx = op.inValueInt("num x", 5),
    numy = op.inValueInt("num y", 5),
    mul = op.inValueFloat("mul", 1),
    center = op.inValueBool("center"),
    trigger = op.outTrigger("trigger"),
    outX = op.outNumber("x"),
    outY = op.outNumber("y"),
    idx = op.outNumber("index"),
    total = op.outNumber("total iterations");

exe.onTriggered = function ()
{
    let subX = 0;
    let subY = 0;
    const m = mul.get();
    const nx = numx.get();
    const ny = numy.get();

    if (center.get())
    {
        subX = ((nx - 1) * m) / 2.0;
        subY = ((ny - 1) * m) / 2.0;
    }

    for (let y = 0; y < ny; y++)
    {
        outY.set((y * m) - subY);
        for (let x = 0; x < nx; x++)
        {
            outX.set((x * m) - subX);
            idx.set(x + y * nx);
            trigger.trigger();
        }
    }
    total.set(numx.get() * numy.get());
};


};

Ops.Trigger.Repeat2d.prototype = new CABLES.Op();
CABLES.OPS["79934693-5887-4173-8b48-3e3a18fcf225"]={f:Ops.Trigger.Repeat2d,objName:"Ops.Trigger.Repeat2d"};




// **************************************************************
// 
// Ops.Trigger.Repeat_v2
// 
// **************************************************************

Ops.Trigger.Repeat_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe=op.inTrigger("Execute"),
    num=op.inValueInt("Repeats",5),
    dir=op.inSwitch("Direction",['Forward','Backward'],'Forward'),
    next=op.outTrigger("Next"),
    idx=op.addOutPort(new CABLES.Port(op,"index"));

dir.onChange=updateDir;
updateDir();

function updateDir()
{
    if(dir.get()=="Forward") exe.onTriggered=forward;
    else exe.onTriggered=backward;
}

function forward()
{
    const max=Math.floor(num.get());

    for(var i=0;i<max;i++)
    {
        idx.set(i);
        next.trigger();
    }
}

function backward()
{
    const numi=Math.floor(num.get());
    for(var i=numi-1;i>-1;i--)
    {
        idx.set(i);
        next.trigger();
    }
}


};

Ops.Trigger.Repeat_v2.prototype = new CABLES.Op();
CABLES.OPS["a4deea80-db97-478f-ad1a-5ee30f2f47cc"]={f:Ops.Trigger.Repeat_v2,objName:"Ops.Trigger.Repeat_v2"};




// **************************************************************
// 
// Ops.Trigger.RouteTrigger
// 
// **************************************************************

Ops.Trigger.RouteTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const NUM_PORTS = 24;

const exePort = op.inTriggerButton("Execute");
const switchPort = op.inValueInt("Switch Value");
const nextTriggerPort = op.outTrigger("Next Trigger");
const valueOutPort = op.outNumber("Switched Value");
const triggerPorts = [];
for (let j = 0; j < NUM_PORTS; j++)
{
    triggerPorts[j] = op.outTrigger("Trigger " + j);
}
const defaultTriggerPort = op.outTrigger("Default Trigger");

// functions

function update()
{
    const index = Math.round(switchPort.get());
    if (index >= 0 && index < NUM_PORTS)
    {
        valueOutPort.set(index);
        triggerPorts[index].trigger();
    }
    else
    {
        valueOutPort.set(-1);
        defaultTriggerPort.trigger();
    }
    nextTriggerPort.trigger();
}

// change listeners / trigger events
exePort.onTriggered = update;


};

Ops.Trigger.RouteTrigger.prototype = new CABLES.Op();
CABLES.OPS["44ceb5d8-b040-4722-b189-a6fb8172517d"]={f:Ops.Trigger.RouteTrigger,objName:"Ops.Trigger.RouteTrigger"};




// **************************************************************
// 
// Ops.Trigger.RouteTriggerString
// 
// **************************************************************

Ops.Trigger.RouteTriggerString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const NUM_PORTS = 24;
const exePort = op.inTriggerButton("Execute");
const switchPort = op.inString("Switch Value");
const nextTriggerPort = op.outTrigger("Next Trigger");
const valueOutPort = op.outNumber("Switched Index");

let index = -1;

const triggerPorts = [];
const namePorts = [];

for (let j = 0; j < NUM_PORTS; j++)
{
    triggerPorts[j] = op.outTrigger("Trigger " + j);
    namePorts[j] = op.inString("String " + j);
    namePorts[j].onChange = updateIndex;
}
// const defaultTriggerPort = op.outTrigger("Default Trigger");

op.onLoad =
op.onInit =
switchPort.onChange = updateIndex;

function updateIndex()
{
    index = -1;
    for (let i = 0; i < namePorts.length; i++)
    {
        if (namePorts[i].get() == switchPort.get())
        {
            index = i;
        }
    }
    // if (index >= 0 && index < NUM_PORTS)
    // {
    //     valueOutPort.set(index);
    //     triggerPorts[index].trigger();
    // }
    // else
    // {
    //     valueOutPort.set(-1);
    //     defaultTriggerPort.trigger();
    // }
}

exePort.onTriggered = () =>
{
    if (index >= 0) triggerPorts[index].trigger();

    valueOutPort.set(index);
    nextTriggerPort.trigger();
};


};

Ops.Trigger.RouteTriggerString.prototype = new CABLES.Op();
CABLES.OPS["973746cc-8b57-4510-af73-780b771e0dc7"]={f:Ops.Trigger.RouteTriggerString,objName:"Ops.Trigger.RouteTriggerString"};




// **************************************************************
// 
// Ops.Trigger.SetNumberOnTrigger
// 
// **************************************************************

Ops.Trigger.SetNumberOnTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    setValuePort = op.inTriggerButton("Set"),
    valuePort = op.inValueFloat("Number"),
    outNext = op.outTrigger("Next"),
    outValuePort = op.outNumber("Out Value");

outValuePort.changeAlways = true;

setValuePort.onTriggered = function ()
{
    outValuePort.set(valuePort.get());
    outNext.trigger();
};


};

Ops.Trigger.SetNumberOnTrigger.prototype = new CABLES.Op();
CABLES.OPS["9989b1c0-1073-4d5f-bfa0-36dd98b66e27"]={f:Ops.Trigger.SetNumberOnTrigger,objName:"Ops.Trigger.SetNumberOnTrigger"};




// **************************************************************
// 
// Ops.Trigger.SwitchTrigger
// 
// **************************************************************

Ops.Trigger.SwitchTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const NUM_PORTS = 16;

const
    inIndex = op.inValueInt("Trigger Index", 0),
    triggerPorts = [],
    outTrig = op.outTrigger("Trigger out");

for (let i = 0; i < NUM_PORTS; i++)
{
    const port = op.inTrigger("Trigger in " + i);
    port.onTriggered = function () { update(i); };
    triggerPorts.onChange = function () { update(i); };
    triggerPorts.push(port);
}

function update(inputNum)
{
    const index = Math.min(Math.max(inIndex.get(), 0), 15);
    if (inputNum == index) outTrig.trigger();
}


};

Ops.Trigger.SwitchTrigger.prototype = new CABLES.Op();
CABLES.OPS["aee29293-0c4f-404d-b724-484bbb57361e"]={f:Ops.Trigger.SwitchTrigger,objName:"Ops.Trigger.SwitchTrigger"};




// **************************************************************
// 
// Ops.Trigger.Threshold
// 
// **************************************************************

Ops.Trigger.Threshold = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// this op will send one trigger out if the threshold has been crossed
// but will not send another until the incoming inValue
// drops below the threshold and go's above it again

const inValue = op.inValue("Input"),
    inThreshold = op.inValue("Threshold"),
    output = op.outTrigger("Output");

let hasThresholdBeenExceeded = false;

inValue.onChange = update;
function update()
{
    if (!hasThresholdBeenExceeded && inValue.get() >= inThreshold.get())
    {
        hasThresholdBeenExceeded = true;
        output.trigger();
    }
    else if (hasThresholdBeenExceeded && inValue.get() <= inThreshold.get())
    {
        hasThresholdBeenExceeded = false;
    }
}


};

Ops.Trigger.Threshold.prototype = new CABLES.Op();
CABLES.OPS["ef0891db-6053-42ba-b7d5-29c7cf6d8208"]={f:Ops.Trigger.Threshold,objName:"Ops.Trigger.Threshold"};




// **************************************************************
// 
// Ops.Trigger.TimedSequence
// 
// **************************************************************

Ops.Trigger.TimedSequence = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("exe");
const current = op.inValueInt("current", 0);
const overwriteTime = op.inValueBool("overwriteTime");
const ignoreInSubPatch = op.inValueBool("ignoreInSubPatch", false);
const triggerAlways = op.outTrigger("triggerAlways");
const outNames = op.outArray("Names", []);
const currentKeyTime = op.outNumber("currentKeyTime");
const outCurrent = op.outNumber("Current");
let triggers = [];

for (let i = 0; i < 32; i++)
{
    let p = op.outTrigger("trigger " + i);
    p.onLinkChanged = updateNames;
    triggers.push(p);
}

function updateNames()
{
    let names = [];
    for (let i = 0; i < triggers.length; i++)
        if (triggers[i].isLinked()) names.push(triggers[i].links[0].getOtherPort(triggers[i]).parent.uiAttribs.title);
        else names.push("none");

    outNames.set(names);
}

op.onLoaded = updateNames;

let lastUiValue = -1;

exe.onTriggered = doTrigger;

function doTrigger(_time)
{
    let spl = 0;

    let outIndex = Math.round(current.get() - 0.5);

    if (window.gui)
    {
        if (current.get() != lastUiValue)
        {
            lastUiValue = current.get();
            for (spl = 0; spl < triggers.length; spl++)
            {
                if (spl == lastUiValue) triggers[spl].setUiActiveState(true);
                else triggers[spl].setUiActiveState(false);
            }
        }
    }

    if (current.anim)
    {
        let time = _time;
        if (_time === undefined) time = current.parent.patch.timer.getTime();
        let key = current.anim.getKey(time);

        let timeOff = 0;
        if (key) timeOff = key.time;

        currentKeyTime.set(time - timeOff);

        if (current.isAnimated())
        {
            if (overwriteTime.get())
            {
                current.parent.patch.timer.overwriteTime = currentKeyTime.get(); // todo  why current ? why  not self ?
            }
        }
    }

    if (op.patch.gui && ignoreInSubPatch.get())
    {
        for (let i = 0; i < triggers.length; i++)
        {
            for (spl = 0; spl < triggers[i].links.length; spl++)
            {
                if (triggers[i].links[spl])
                {
                    if (triggers[i].links[spl].portIn.parent.patchId)
                    {
                        if (CABLES.UI)
                            if (gui.patchView.getCurrentSubPatch() == triggers[i].links[spl].portIn.parent.patchId.get())
                            {
                                op.patch.timer.overwriteTime = -1;

                                triggers[i].trigger();
                                return;
                            }
                    }
                }
            }
        }
    }

    if (outIndex >= 0 && outIndex < triggers.length)
    {
        outCurrent.set(outIndex);
        triggers[outIndex].trigger();
    }

    op.patch.timer.overwriteTime = -1;
    triggerAlways.trigger();
}


};

Ops.Trigger.TimedSequence.prototype = new CABLES.Op();
CABLES.OPS["73c892c9-3e81-4ddc-952a-fbe6bf00ef2c"]={f:Ops.Trigger.TimedSequence,objName:"Ops.Trigger.TimedSequence"};




// **************************************************************
// 
// Ops.Trigger.TriggerButton
// 
// **************************************************************

Ops.Trigger.TriggerButton = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTrig = op.inTriggerButton("Trigger"),
    outTrig = op.outTrigger("Next");

inTrig.onTriggered = function ()
{
    outTrig.trigger();
};


};

Ops.Trigger.TriggerButton.prototype = new CABLES.Op();
CABLES.OPS["21630924-39e4-4df5-9965-b9136510d156"]={f:Ops.Trigger.TriggerButton,objName:"Ops.Trigger.TriggerButton"};




// **************************************************************
// 
// Ops.Trigger.TriggerCounter
// 
// **************************************************************

Ops.Trigger.TriggerCounter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTriggerButton("exe"),
    reset = op.inTriggerButton("reset"),
    trigger = op.outTrigger("trigger"),
    num = op.outNumber("timesTriggered");

op.toWorkPortsNeedToBeLinked(exe);

let n = 0;

reset.onTriggered =
op.onLoaded =
    doReset;

exe.onTriggered = function ()
{
    n++;
    num.set(n);
    op.setUiAttrib({ "extendTitle": n });
    trigger.trigger();
};

function doReset()
{
    n = 0;
    op.setUiAttrib({ "extendTitle": n });
    num.set(n);
}


};

Ops.Trigger.TriggerCounter.prototype = new CABLES.Op();
CABLES.OPS["e640619f-235c-4543-bbf8-b358e0283180"]={f:Ops.Trigger.TriggerCounter,objName:"Ops.Trigger.TriggerCounter"};




// **************************************************************
// 
// Ops.Trigger.TriggerCounterLoop
// 
// **************************************************************

Ops.Trigger.TriggerCounterLoop = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTriggerButton("trigger in"),
    reset = op.inTriggerButton("reset"),
    trigger = op.outTrigger("trigger out"),
    num = op.outNumber("current count"),

    inMinLoopValue = op.inValueInt("Loop min", 0.0),
    inMaxLoopValue = op.inValueInt("Loop max", 4.0);

let n = Math.floor(inMinLoopValue.get());

// increments with each trigger and loops
// depending on min and max loop values
// can also work with negative numbers
// if min is greater than max then it decrements
// instead of incrementing
exe.onTriggered = function ()
{
    let inMin = Math.floor(inMinLoopValue.get());
    let inMax = Math.floor(inMaxLoopValue.get());

    if (inMin < inMax)
    {
        if (n < inMin)
        {
            n = inMinLoopValue.get();
        }
        else if (n >= inMax)
        {
            n = inMinLoopValue.get();
        }
        else
        {
            n++;
        }
    }
    else if (inMin > inMax)
    {
        if (n < inMax)
        {
            n = inMin;
        }
        else if (n > inMin)
        {
            inMin;
        }
        else if (n <= inMax)
        {
            n = inMin;
        }
        else
        {
            n--;
        }
    }
    num.set(n);
    op.setUiAttrib({ "extendTitle": n });
    trigger.trigger();
};

reset.onTriggered = function ()
{
    let inMin = Math.floor(inMinLoopValue.get());
    let inMax = Math.floor(inMaxLoopValue.get());

    if (inMin < inMax)
    {
        n = inMin;
    }
    else if (inMax < inMin)
    {
        n = inMin;
    }
    else
    {
        n = 0;
    }
    op.setUiAttrib({ "extendTitle": n });
    num.set(n);
};


};

Ops.Trigger.TriggerCounterLoop.prototype = new CABLES.Op();
CABLES.OPS["d3356c53-e278-433f-af0b-d8327cd99a2d"]={f:Ops.Trigger.TriggerCounterLoop,objName:"Ops.Trigger.TriggerCounterLoop"};




// **************************************************************
// 
// Ops.Trigger.TriggerDistributeByValue
// 
// **************************************************************

Ops.Trigger.TriggerDistributeByValue = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const exe = op.inTrigger("exe");
let number = op.addInPort(new CABLES.Port(op, "number"));
let max = op.addInPort(new CABLES.Port(op, "max"));
let numOut = op.addInPort(new CABLES.Port(op, "num outputs"));
let num = op.addOutPort(new CABLES.Port(op, "num", CABLES.OP_PORT_TYPE_VALUE));

number.set(0);
max.set(1);
numOut.set(2);
num.set(0);

let triggers = [];
let numTriggers = 20;

let trigger = function ()
{
    let s = max.get() / numOut.get();
    let index = Math.abs(Math.floor(number.get() / s));

    num.set(index);

    if (!isNaN(index) && index < numTriggers)
    {
        triggers[index].trigger();
    }
};

exe.onTriggered = trigger;

for (let i = 0; i < numTriggers; i++)
{
    triggers.push(op.addOutPort(new CABLES.Port(op, "trigger " + i, CABLES.OP_PORT_TYPE_FUNCTION)));
}


};

Ops.Trigger.TriggerDistributeByValue.prototype = new CABLES.Op();
CABLES.OPS["e697380f-ac93-4d4a-9e9c-b54287773668"]={f:Ops.Trigger.TriggerDistributeByValue,objName:"Ops.Trigger.TriggerDistributeByValue"};




// **************************************************************
// 
// Ops.Trigger.TriggerExtender
// 
// **************************************************************

Ops.Trigger.TriggerExtender = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTriggerPort = op.inTriggerButton("Execute"),
    outTriggerPort = op.outTrigger("Next");

inTriggerPort.onTriggered = function ()
{
    outTriggerPort.trigger();
};


};

Ops.Trigger.TriggerExtender.prototype = new CABLES.Op();
CABLES.OPS["7ef594f3-4907-47b0-a2d3-9854eda1679d"]={f:Ops.Trigger.TriggerExtender,objName:"Ops.Trigger.TriggerExtender"};




// **************************************************************
// 
// Ops.Trigger.TriggerIfDecreased
// 
// **************************************************************

Ops.Trigger.TriggerIfDecreased = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inValue("Value"),
    trigger = op.outTrigger("Trigger");

let lastValue = -Number.MAX_VALUE;

value.onChange = function ()
{
    const v = value.get();
    if (v < lastValue)
    {
        trigger.trigger();
    }
    lastValue = v;
};


};

Ops.Trigger.TriggerIfDecreased.prototype = new CABLES.Op();
CABLES.OPS["16ec4069-3682-461e-95ff-1d86e3f44512"]={f:Ops.Trigger.TriggerIfDecreased,objName:"Ops.Trigger.TriggerIfDecreased"};




// **************************************************************
// 
// Ops.Trigger.TriggerIfIncreased
// 
// **************************************************************

Ops.Trigger.TriggerIfIncreased = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    value = op.inFloat("Value"),
    trigger = op.outTrigger("Trigger");

let lastValue = -Number.MAX_VALUE;

value.onChange = function ()
{
    const v = value.get();
    if (v > lastValue)
    {
        trigger.trigger();
    }
    lastValue = v;
};


};

Ops.Trigger.TriggerIfIncreased.prototype = new CABLES.Op();
CABLES.OPS["bc820891-48c7-4287-9b5e-4196e192741b"]={f:Ops.Trigger.TriggerIfIncreased,objName:"Ops.Trigger.TriggerIfIncreased"};




// **************************************************************
// 
// Ops.Trigger.TriggerLimiter
// 
// **************************************************************

Ops.Trigger.TriggerLimiter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTriggerPort = op.inTrigger("In Trigger"),
    timePort = op.inValue("Milliseconds", 300),
    outTriggerPort = op.outTrigger("Out Trigger"),
    progress = op.outNumber("Progress");

let lastTriggerTime = 0;

// change listeners
inTriggerPort.onTriggered = function ()
{
    const now = CABLES.now();
    let prog = (now - lastTriggerTime) / timePort.get();

    if (prog > 1.0)prog = 1.0;
    if (prog < 0.0)prog = 0.0;

    progress.set(prog);

    if (now >= lastTriggerTime + timePort.get())
    {
        lastTriggerTime = now;
        outTriggerPort.trigger();
    }
};


};

Ops.Trigger.TriggerLimiter.prototype = new CABLES.Op();
CABLES.OPS["47641d85-9f81-4287-8aa2-35753b0727e0"]={f:Ops.Trigger.TriggerLimiter,objName:"Ops.Trigger.TriggerLimiter"};




// **************************************************************
// 
// Ops.Trigger.TriggerNumber
// 
// **************************************************************

Ops.Trigger.TriggerNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe0 = op.inTriggerButton("0"),
    exe1 = op.inTriggerButton("1"),
    exe2 = op.inTriggerButton("2"),
    exe3 = op.inTriggerButton("3"),
    exe4 = op.inTriggerButton("4"),
    exe5 = op.inTriggerButton("5"),
    exe6 = op.inTriggerButton("6"),
    exe7 = op.inTriggerButton("7"),
    number = op.outNumber("number");

number.changeAlways = true;
const outTrig = op.outTrigger("Triggered");

exe0.onTriggered = function () { number.set(0); outTrig.trigger(); };
exe1.onTriggered = function () { number.set(1); outTrig.trigger(); };
exe2.onTriggered = function () { number.set(2); outTrig.trigger(); };
exe3.onTriggered = function () { number.set(3); outTrig.trigger(); };
exe4.onTriggered = function () { number.set(4); outTrig.trigger(); };
exe5.onTriggered = function () { number.set(5); outTrig.trigger(); };
exe6.onTriggered = function () { number.set(6); outTrig.trigger(); };
exe7.onTriggered = function () { number.set(7); outTrig.trigger(); };


};

Ops.Trigger.TriggerNumber.prototype = new CABLES.Op();
CABLES.OPS["43ed1123-1312-4383-b843-27b8ec540c09"]={f:Ops.Trigger.TriggerNumber,objName:"Ops.Trigger.TriggerNumber"};




// **************************************************************
// 
// Ops.Trigger.TriggerOnChangeArray
// 
// **************************************************************

Ops.Trigger.TriggerOnChangeArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inval=op.inArray("Array"),
    next=op.outTrigger("Changed"),
    outArr=op.outArray("Result");

inval.onChange=function()
{
    outArr.set(inval.get());
    next.trigger();
};

};

Ops.Trigger.TriggerOnChangeArray.prototype = new CABLES.Op();
CABLES.OPS["e4ddec93-4dee-422b-a402-6a0f6e469ce6"]={f:Ops.Trigger.TriggerOnChangeArray,objName:"Ops.Trigger.TriggerOnChangeArray"};




// **************************************************************
// 
// Ops.Trigger.TriggerOnChangeObject
// 
// **************************************************************

Ops.Trigger.TriggerOnChangeObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inval = op.inObject("Object"),
    next = op.outTrigger("Changed"),
    outArr = op.outObject("Result");

inval.onChange = function ()
{
    outArr.set(inval.get());
    next.trigger();
};


};

Ops.Trigger.TriggerOnChangeObject.prototype = new CABLES.Op();
CABLES.OPS["c7e3fa27-21e8-44ef-b176-e0e596837abb"]={f:Ops.Trigger.TriggerOnChangeObject,objName:"Ops.Trigger.TriggerOnChangeObject"};




// **************************************************************
// 
// Ops.Trigger.TriggerOnChangeString
// 
// **************************************************************

Ops.Trigger.TriggerOnChangeString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inval = op.inString("String"),
    next = op.outTrigger("Changed"),
    outStr = op.outString("Result");

inval.onChange = function ()
{
    outStr.set(inval.get());
    next.trigger();
};


};

Ops.Trigger.TriggerOnChangeString.prototype = new CABLES.Op();
CABLES.OPS["319d07e0-5cbe-4bc1-89fb-a934fd41b0c4"]={f:Ops.Trigger.TriggerOnChangeString,objName:"Ops.Trigger.TriggerOnChangeString"};




// **************************************************************
// 
// Ops.Trigger.TriggerOnChangeTexture
// 
// **************************************************************

Ops.Trigger.TriggerOnChangeTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inval = op.inTexture("Texture"),
    inFilter = op.inBool("Ignore empty/default Texture", false),
    next = op.outTrigger("Changed"),
    outTex = op.outTexture("Result", CGL.Texture.getEmptyTexture(op.patch.cgl));

inval.onLinkChanged =
inval.onChange = function ()
{
    const v = inval.get();
    if (inFilter.get() && (v == CGL.Texture.getEmptyTexture(op.patch.cgl) || v == null)) return;

    outTex.set(v || CGL.Texture.getEmptyTexture(op.patch.cgl));
    next.trigger();
};


};

Ops.Trigger.TriggerOnChangeTexture.prototype = new CABLES.Op();
CABLES.OPS["d7260ecb-d862-496a-8a26-f8165ab49dd2"]={f:Ops.Trigger.TriggerOnChangeTexture,objName:"Ops.Trigger.TriggerOnChangeTexture"};




// **************************************************************
// 
// Ops.Trigger.TriggerOnce
// 
// **************************************************************

Ops.Trigger.TriggerOnce = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTriggerButton("Exec"),
    reset = op.inTriggerButton("Reset"),
    next = op.outTrigger("Next"),
    outTriggered = op.outBoolNum("Was Triggered");

let triggered = false;

op.toWorkPortsNeedToBeLinked(exe);

reset.onTriggered = function ()
{
    triggered = false;
    outTriggered.set(triggered);
};

exe.onTriggered = function ()
{
    if (triggered) return;

    triggered = true;
    next.trigger();
    outTriggered.set(triggered);
};


};

Ops.Trigger.TriggerOnce.prototype = new CABLES.Op();
CABLES.OPS["cf3544e4-e392-432b-89fd-fcfb5c974388"]={f:Ops.Trigger.TriggerOnce,objName:"Ops.Trigger.TriggerOnce"};




// **************************************************************
// 
// Ops.Trigger.TriggerReceive
// 
// **************************************************************

Ops.Trigger.TriggerReceive = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const next = op.outTrigger("Triggered");
op.varName = op.inValueSelect("Named Trigger", [], "", true);

updateVarNamesDropdown();
op.patch.addEventListener("namedTriggersChanged", updateVarNamesDropdown);

let oldName = null;

function doTrigger()
{
    next.trigger();
}

function updateVarNamesDropdown()
{
    if (CABLES.UI)
    {
        let varnames = [];
        let vars = op.patch.namedTriggers;
        // varnames.push('+ create new one');
        for (let i in vars) varnames.push(i);
        op.varName.uiAttribs.values = varnames;
    }
}

op.varName.onChange = function ()
{
    if (oldName)
    {
        let oldCbs = op.patch.namedTriggers[oldName];
        let a = oldCbs.indexOf(doTrigger);
        if (a != -1) oldCbs.splice(a, 1);
    }

    op.setTitle(">" + op.varName.get());
    op.patch.namedTriggers[op.varName.get()] = op.patch.namedTriggers[op.varName.get()] || [];
    let cbs = op.patch.namedTriggers[op.varName.get()];

    cbs.push(doTrigger);
    oldName = op.varName.get();
    updateError();
    op.patch.emitEvent("opTriggerNameChanged", op, op.varName.get());
};

op.on("uiParamPanel", updateError);

function updateError()
{
    if (!op.varName.get())
    {
        op.setUiError("unknowntrigger", "unknown trigger");
    }
    else op.setUiError("unknowntrigger", null);
}


};

Ops.Trigger.TriggerReceive.prototype = new CABLES.Op();
CABLES.OPS["0816c999-f2db-466b-9777-2814573574c5"]={f:Ops.Trigger.TriggerReceive,objName:"Ops.Trigger.TriggerReceive"};




// **************************************************************
// 
// Ops.Trigger.TriggerReceiveFilter
// 
// **************************************************************

Ops.Trigger.TriggerReceiveFilter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const prefixIn = op.inString("Prefix", "");
const triggerOut = op.outTrigger("Trigger Out");
const triggerNameOut = op.outString("Trigger Name");

const listener = (triggerName) =>
{
    const prefix = prefixIn.get();
    if (triggerName)
    {
        if (prefix)
        {
            if (triggerName.startsWith(prefix))
            {
                triggerNameOut.set(triggerName);
                triggerOut.trigger();
            }
        }
        else
        {
            triggerNameOut.set(triggerName);
            triggerOut.trigger();
        }
    }
};

prefixIn.onChange = () =>
{
    if (prefixIn.get())
    {
        op.setUiAttrib({ "extendTitle": prefixIn.get() });
    }
};

op.patch.addEventListener("namedTriggerSent", listener);


};

Ops.Trigger.TriggerReceiveFilter.prototype = new CABLES.Op();
CABLES.OPS["7bf9e19a-55a8-4eb4-aaeb-5a15a8d2f958"]={f:Ops.Trigger.TriggerReceiveFilter,objName:"Ops.Trigger.TriggerReceiveFilter"};




// **************************************************************
// 
// Ops.Trigger.TriggerSend
// 
// **************************************************************

Ops.Trigger.TriggerSend = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const trigger = op.inTriggerButton("Trigger");
op.varName = op.inValueSelect("Named Trigger", [], "", true);

op.varName.onChange = updateName;

trigger.onTriggered = doTrigger;

op.patch.addEventListener("namedTriggersChanged", updateVarNamesDropdown);

updateVarNamesDropdown();

function updateVarNamesDropdown()
{
    if (CABLES.UI)
    {
        const varnames = [];
        const vars = op.patch.namedTriggers;
        varnames.push("+ create new one");
        for (const i in vars) varnames.push(i);
        op.varName.uiAttribs.values = varnames;
    }
}

function updateName()
{
    if (CABLES.UI)
    {
        if (op.varName.get() == "+ create new one")
        {
            new CABLES.UI.ModalDialog({
                "prompt": true,
                "title": "New Trigger",
                "text": "enter a name for the new trigger",
                "promptValue": "",
                "promptOk": (str) =>
                {
                    op.varName.set(str);
                    op.patch.namedTriggers[str] = op.patch.namedTriggers[str] || [];
                    updateVarNamesDropdown();
                }
            });
            return;
        }

        op.refreshParams();
    }

    if (!op.patch.namedTriggers[op.varName.get()])
    {
        op.patch.namedTriggers[op.varName.get()] = op.patch.namedTriggers[op.varName.get()] || [];
        op.patch.emitEvent("namedTriggersChanged");
    }

    op.setTitle(">" + op.varName.get());

    op.refreshParams();
    op.patch.emitEvent("opTriggerNameChanged", op, op.varName.get());
}

function doTrigger()
{
    const arr = op.patch.namedTriggers[op.varName.get()];
    // fire an event even if noone is receiving this trigger
    // this way TriggerReceiveFilter can still handle it
    op.patch.emitEvent("namedTriggerSent", op.varName.get());

    if (!arr)
    {
        op.setUiError("unknowntrigger", "unknown trigger");
        return;
    }
    else op.setUiError("unknowntrigger", null);

    for (let i = 0; i < arr.length; i++)
    {
        arr[i]();
    }
}


};

Ops.Trigger.TriggerSend.prototype = new CABLES.Op();
CABLES.OPS["ce1eaf2b-943b-4dc0-ab5e-ee11b63c9ed0"]={f:Ops.Trigger.TriggerSend,objName:"Ops.Trigger.TriggerSend"};




// **************************************************************
// 
// Ops.Trigger.TriggerSendNamed
// 
// **************************************************************

Ops.Trigger.TriggerSendNamed = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const trigger = op.inTriggerButton("Trigger");
const varname = op.inString("Named Trigger", "");

trigger.onTriggered = doTrigger;

varname.onChange = () =>
{
    op.setUiAttrib({ "extendTitle": varname.get() });
};

function doTrigger()
{
    const arr = op.patch.namedTriggers[varname.get()];
    // fire an event even if noone is receiving this trigger
    // this way TriggerReceiveFilter can still handle it
    op.patch.emitEvent("namedTriggerSent", varname.get());

    if (!arr)
    {
        return;
    }

    for (let i = 0; i < arr.length; i++)
    {
        arr[i]();
    }
}


};

Ops.Trigger.TriggerSendNamed.prototype = new CABLES.Op();
CABLES.OPS["45d07cd7-bdfb-48b7-bc76-7606de5afd76"]={f:Ops.Trigger.TriggerSendNamed,objName:"Ops.Trigger.TriggerSendNamed"};




// **************************************************************
// 
// Ops.Trigger.TriggerString
// 
// **************************************************************

Ops.Trigger.TriggerString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exec = op.inTriggerButton("Trigger"),
    inString = op.inString("String", ""),
    next = op.outTrigger("Next"),
    outString = op.outString("Result");

outString.changeAlways = true;
exec.onTriggered = function ()
{
    outString.set(inString.get());
    next.trigger();
};


};

Ops.Trigger.TriggerString.prototype = new CABLES.Op();
CABLES.OPS["217482b8-2ee6-4609-b7ad-4550e6aaa371"]={f:Ops.Trigger.TriggerString,objName:"Ops.Trigger.TriggerString"};




// **************************************************************
// 
// Ops.Trigger.TriggersPerSecond
// 
// **************************************************************

Ops.Trigger.TriggersPerSecond = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    cps = op.outNumber("cps");

let timeStart = 0;
let cpsCount = 0;

exe.onTriggered = function ()
{
    if (timeStart === 0)timeStart = CABLES.now();
    let now = CABLES.now();

    if (now - timeStart > 1000)
    {
        timeStart = CABLES.now();
        op.setUiAttrib({ "extendTitle": cpsCount });
        cps.set(cpsCount);
        cpsCount = 0;
    }

    cpsCount++;
};


};

Ops.Trigger.TriggersPerSecond.prototype = new CABLES.Op();
CABLES.OPS["ece2f153-eb31-4268-b0e5-8143ad2fdd81"]={f:Ops.Trigger.TriggersPerSecond,objName:"Ops.Trigger.TriggersPerSecond"};




// **************************************************************
// 
// Ops.Trigger.ValueBecameZeroTrigger
// 
// **************************************************************

Ops.Trigger.ValueBecameZeroTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let valueBefore = -1;

// input
let valuePort = op.inValue("Value", -1);

// output
let outTrigger = op.outTrigger("Became Zero Trigger");

valuePort.onChange = function ()
{
    let value = valuePort.get();
    if (valueBefore != 0 & value == 0)
    {
        outTrigger.trigger();
    }
    valueBefore = value;
};


};

Ops.Trigger.ValueBecameZeroTrigger.prototype = new CABLES.Op();
CABLES.OPS["822f925c-33e8-4b8a-8a89-be5d2e358ed7"]={f:Ops.Trigger.ValueBecameZeroTrigger,objName:"Ops.Trigger.ValueBecameZeroTrigger"};




// **************************************************************
// 
// Ops.Ui.Area
// 
// **************************************************************

Ops.Ui.Area = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inTitle = op.inString("Title", "");

inTitle.setUiAttribs({ "hidePort": true });

op.setUiAttrib({ "hasArea": true });

// exe.onTriggered=function()
// {
//     op.patch.instancing.pushLoop(inNum.get());

//     for(let i=0;i<inNum.get();i++)
//     {
//         idx.set(i);
//         trigger.trigger();
//         op.patch.instancing.increment();
//     }

//     op.patch.instancing.popLoop();
// };

op.init =
    inTitle.onChange =
    op.onLoaded = update;

update();

function update()
{
    if (CABLES.UI)
    {
        gui.setStateUnsaved();
        op.uiAttr(
            {
                "comment_title": inTitle.get() || " "
            });

        op.name = inTitle.get();
    }
}


};

Ops.Ui.Area.prototype = new CABLES.Op();
CABLES.OPS["38f79614-b0de-4960-8da5-2827e7f43415"]={f:Ops.Ui.Area,objName:"Ops.Ui.Area"};




// **************************************************************
// 
// Ops.Ui.Comment_v2
// 
// **************************************************************

Ops.Ui.Comment_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inTitle = op.inString("title", "New comment"),
    inText = op.inTextarea("text");
inTitle.setUiAttribs({ "hidePort": true });
inText.setUiAttribs({ "hidePort": true });

op.init =
    inTitle.onChange =
    inText.onChange =
    op.onLoaded = update;

update();

function update()
{
    if (CABLES.UI)
    {
        op.uiAttr(
            {
                "comment_title": inTitle.get(),
                "comment_text": inText.get()
            });

        op.name = inTitle.get();
    }
}


};

Ops.Ui.Comment_v2.prototype = new CABLES.Op();
CABLES.OPS["93492eeb-bf35-4a62-98f7-d85b0b79bfe5"]={f:Ops.Ui.Comment_v2,objName:"Ops.Ui.Comment_v2"};




// **************************************************************
// 
// Ops.Ui.PatchInput
// 
// **************************************************************

Ops.Ui.PatchInput = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const dyn = op.addOutPort(new CABLES.Port(op, "create port", CABLES.OP_PORT_TYPE_DYNAMIC));

function getPatchOp()
{
    for (let i in op.patch.ops)
    {
        if (op.patch.ops[i].patchId)
        {
            if (op.patch.ops[i].patchId.get() == op.uiAttribs.subPatch)
            {
                return op.patch.ops[i];
            }
        }
    }
}

dyn.onLinkChanged = () =>
{
    const mySubPatchOp = getPatchOp();

    if (!dyn.links.length) return;

    const otherPort = dyn.links[0].getOtherPort(dyn);
    dyn.removeLinks();

    const newPortName = mySubPatchOp.addNewInPort(otherPort);

    const l = gui.scene().link(
        otherPort.parent,
        otherPort.getName(),
        op,
        newPortName);

    mySubPatchOp.saveData();
};


};

Ops.Ui.PatchInput.prototype = new CABLES.Op();
CABLES.OPS["e3f68bc3-892a-4c78-9974-aca25c27025d"]={f:Ops.Ui.PatchInput,objName:"Ops.Ui.PatchInput"};




// **************************************************************
// 
// Ops.Ui.PatchOutput
// 
// **************************************************************

Ops.Ui.PatchOutput = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const dyn = op.addInPort(new CABLES.Port(op, "create port", CABLES.OP_PORT_TYPE_DYNAMIC));

function getPatchOp()
{
    for (let i in op.patch.ops)
    {
        if (op.patch.ops[i].patchId)
        {
            if (op.patch.ops[i].patchId.get() == op.uiAttribs.subPatch)
            {
                return op.patch.ops[i];
            }
        }
    }
}

dyn.onLinkChanged = () =>
{
    const mySubPatchOp = getPatchOp();

    if (!dyn.links.length) return;

    const otherPort = dyn.links[0].getOtherPort(dyn);
    dyn.removeLinks();

    const newPortName = mySubPatchOp.addNewOutPort(otherPort);

    const l = gui.scene().link(
        otherPort.parent,
        otherPort.getName(),
        op,
        newPortName);

    mySubPatchOp.saveData();
};


};

Ops.Ui.PatchOutput.prototype = new CABLES.Op();
CABLES.OPS["851b44cb-5667-4140-9800-5aeb7031f1d7"]={f:Ops.Ui.PatchOutput,objName:"Ops.Ui.PatchOutput"};




// **************************************************************
// 
// Ops.Ui.SubPatch
// 
// **************************************************************

Ops.Ui.SubPatch = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
op.dyn = op.addInPort(new CABLES.Port(op, "create port", CABLES.OP_PORT_TYPE_DYNAMIC));
op.dynOut = op.addOutPort(new CABLES.Port(op, "create port out", CABLES.OP_PORT_TYPE_DYNAMIC));

const dataStr = op.addInPort(new CABLES.Port(op, "dataStr", CABLES.OP_PORT_TYPE_VALUE, { "display": "readonly" }));
op.patchId = op.addInPort(new CABLES.Port(op, "patchId", CABLES.OP_PORT_TYPE_VALUE, { "display": "readonly" }));

if (CABLES.UI && CABLES.sandbox.isDevEnv())
{
    const inMakeBp = op.inTriggerButton("Create Blueprint");
    inMakeBp.setUiAttribs({ "hidePort": true });

    inMakeBp.onTriggered = makeBlueprint;
}

dataStr.setUiAttribs({ "hideParam": true });
op.patchId.setUiAttribs({ "hideParam": true });

let data = { "ports": [], "portsOut": [] };
let oldPatchId = CABLES.generateUUID();
op.patchId.set(oldPatchId);
getSubPatchInputOp();
getSubPatchOutputOp();

let dataLoaded = false;

op.saveData = saveData;

op.patchId.onChange = function ()
{
    const oldPatchOps = op.patch.getSubPatchOps(oldPatchId);

    if (oldPatchOps.length == 2)
    {
        for (let i = 0; i < oldPatchOps.length; i++)
        {
            op.patch.deleteOp(oldPatchOps[i].id);
        }
    }
    else
    {
    }
};

op.onLoaded = function ()
{
};

op.onLoadedValueSet = function ()
{
    data = JSON.parse(dataStr.get());
    if (!data)
    {
        data = { "ports": [], "portsOut": [] };
    }
    setupPorts();
};

function loadData()
{
}

dataStr.onChange = function ()
{
    if (dataLoaded) return;

    if (!dataStr.get()) return;
    try
    {
        loadData();
    }
    catch (e)
    {
        op.logError("cannot load subpatch data...");
        op.logError(e);
    }
};

function saveData()
{
    dataStr.set(JSON.stringify(data));
}

op.addPortListener = addPortListener;
function addPortListener(newPort, newPortInPatch)
{
    if (!newPort.hasSubpatchLstener)
    {
        newPort.hasSubpatchLstener = true;
        newPort.addEventListener("onUiAttrChange", function (attribs)
        {
            if (attribs.title)
            {
                let i = 0;
                for (i = 0; i < data.portsOut.length; i++)
                    if (data.portsOut[i].name == newPort.name)
                        data.portsOut[i].title = attribs.title;

                for (i = 0; i < data.ports.length; i++)
                    if (data.ports[i].name == newPort.name)
                        data.ports[i].title = attribs.title;

                saveData();
            }
        });
    }

    if (newPort.direction == CABLES.PORT_DIR_IN)
    {
        if (newPort.type == CABLES.OP_PORT_TYPE_FUNCTION)
        {
            newPort.onTriggered = function ()
            {
                if (newPortInPatch.isLinked())
                    newPortInPatch.trigger();
            };
        }
        else
        {
            newPort.onChange = function ()
            {
                newPortInPatch.set(newPort.get());
                if (!newPort.isLinked())
                {
                    for (let i = 0; i < data.ports.length; i++)
                    {
                        if (data.ports[i].name === newPort.name)
                        {
                            data.ports[i].value = newPort.get();
                        }
                    }
                    saveData();
                }
            };
        }
    }
}

op.setupPorts = setupPorts;
function setupPorts()
{
    if (!op.patchId.get()) return;
    const ports = data.ports || [];
    const portsOut = data.portsOut || [];
    let i = 0;

    for (i = 0; i < ports.length; i++)
    {
        if (!op.getPortByName(ports[i].name))
        {
            const newPort = op.addInPort(new CABLES.Port(op, ports[i].name, ports[i].type));

            const patchInputOp = getSubPatchInputOp();
            const newPortInPatch = patchInputOp.addOutPort(new CABLES.Port(patchInputOp, ports[i].name, ports[i].type));

            newPort.ignoreValueSerialize = true;
            newPort.setUiAttribs({ "editableTitle": true });
            if (ports[i].title)
            {
                newPort.setUiAttribs({ "title": ports[i].title });
                newPortInPatch.setUiAttribs({ "title": ports[i].title });
            }
            if (ports[i].objType)
            {
                newPort.setUiAttribs({ "objType": ports[i].objType });
                newPortInPatch.setUiAttribs({ "objType": ports[i].objType });
            }
            if (ports[i].value)
            {
                newPort.set(ports[i].value);
                newPortInPatch.set(ports[i].value);
            }
            addPortListener(newPort, newPortInPatch);
        }
    }

    for (i = 0; i < portsOut.length; i++)
    {
        if (!op.getPortByName(portsOut[i].name))
        {
            const newPortOut = op.addOutPort(new CABLES.Port(op, portsOut[i].name, portsOut[i].type));
            const patchOutputOp = getSubPatchOutputOp();
            const newPortOutPatch = patchOutputOp.addInPort(new CABLES.Port(patchOutputOp, portsOut[i].name, portsOut[i].type));

            newPortOut.ignoreValueSerialize = true;
            newPortOut.setUiAttribs({ "editableTitle": true });

            if (portsOut[i].title)
            {
                newPortOut.setUiAttribs({ "title": portsOut[i].title });
                newPortOutPatch.setUiAttribs({ "title": portsOut[i].title });
            }
            if (portsOut[i].objType)
            {
                newPortOut.setUiAttribs({ "objType": portsOut[i].objType });
                newPortOutPatch.setUiAttribs({ "objType": portsOut[i].objType });
            }

            // addPortListener(newPortOut,newPortOutPatch);
            addPortListener(newPortOutPatch, newPortOut);
        }
    }

    dataLoaded = true;
}

op.addNewInPort = function (otherPort, type, objType)
{
    const newName = "in" + data.ports.length + " " + otherPort.parent.name + " " + otherPort.name;

    const o = { "name": newName, "type": otherPort.type };
    if (otherPort.uiAttribs.objType)o.objType = otherPort.uiAttribs.objType;

    data.ports.push(o);
    setupPorts();
    return newName;
};

op.dyn.onLinkChanged = function ()
{
    if (op.dyn.isLinked())
    {
        const otherPort = op.dyn.links[0].getOtherPort(op.dyn);
        op.dyn.removeLinks();
        otherPort.removeLinkTo(op.dyn);

        op.log("dyn link changed!!!");

        // const newName = "in" + data.ports.length + " " + otherPort.parent.name + " " + otherPort.name;

        // const o = { "name": newName, "type": otherPort.type };
        // if (otherPort.uiAttribs.objType)o.objType = otherPort.uiAttribs.objType;
        // data.ports.push(o);

        // setupPorts();

        const newName = op.addNewInPort(otherPort);

        const l = gui.scene().link(
            otherPort.parent,
            otherPort.getName(),
            op,
            newName
        );

        dataLoaded = true;
        saveData();
    }
    else
    {
        setTimeout(function ()
        {
            op.dyn.removeLinks();
        }, 100);
    }
};

op.addNewOutPort = function (otherPort, type, objType)
{
    const newName = "out" + data.portsOut.length + " " + otherPort.parent.name + " " + otherPort.name;

    const o = { "name": newName, "type": otherPort.type };
    if (otherPort.uiAttribs.objType)o.objType = otherPort.uiAttribs.objType;

    data.portsOut.push(o);
    setupPorts();
    return newName;
};

op.dynOut.onLinkChanged = function ()
{
    if (op.dynOut.isLinked())
    {
        const otherPort = op.dynOut.links[0].getOtherPort(op.dynOut);
        op.dynOut.removeLinks();
        otherPort.removeLinkTo(op.dynOut);

        const newName = op.addNewOutPort(otherPort);

        gui.scene().link(
            otherPort.parent,
            otherPort.getName(),
            op,
            newName
        );

        dataLoaded = true;
        saveData();
    }
    else
    {
        setTimeout(function ()
        {
            op.dynOut.removeLinks();
        }, 100);

        op.log("dynOut unlinked...");
    }
};

function getSubPatchOutputOp()
{
    let patchOutputOP = op.patch.getSubPatchOp(op.patchId.get(), "Ops.Ui.PatchOutput");

    if (!patchOutputOP)
    {
        op.patch.addOp("Ops.Ui.PatchOutput", { "subPatch": op.patchId.get(), "translate": { "x": 0, "y": 0 } });
        patchOutputOP = op.patch.getSubPatchOp(op.patchId.get(), "Ops.Ui.PatchOutput");
        if (!patchOutputOP) op.warn("no patchoutput!");
    }
    return patchOutputOP;
}

function getSubPatchInputOp()
{
    let patchInputOP = op.patch.getSubPatchOp(op.patchId.get(), "Ops.Ui.PatchInput");

    if (!patchInputOP)
    {
        op.patch.addOp("Ops.Ui.PatchInput", { "subPatch": op.patchId.get(), "translate": { "x": 0, "y": 0 } });
        patchInputOP = op.patch.getSubPatchOp(op.patchId.get(), "Ops.Ui.PatchInput");
        if (!patchInputOP) op.warn("no patchinput2!");
    }

    return patchInputOP;
}

op.addSubLink = function (p, p2)
{
    const num = data.ports.length;
    const sublPortname = "in" + (num - 1) + " " + p2.parent.name + " " + p2.name;

    if (p.direction == CABLES.PORT_DIR_IN)
    {
        gui.scene().link(
            p.parent,
            p.getName(),
            getSubPatchInputOp(),
            sublPortname
        );
    }
    else
    {
        const numOut = data.portsOut.length;
        gui.scene().link(
            p.parent,
            p.getName(),
            getSubPatchOutputOp(),
            "out" + (numOut - 1) + " " + p2.parent.name + " " + p2.name
        );
    }

    const bounds = gui.patchView.getSubPatchBounds(op.patchId.get());

    getSubPatchInputOp().uiAttr(
        {
            "translate":
            {
                "x": bounds.minx,
                "y": bounds.miny - 100
            }
        });

    getSubPatchOutputOp().uiAttr(
        {
            "translate":
            {
                "x": bounds.minx,
                "y": bounds.maxy + 100
            }
        });
    saveData();
    return sublPortname;
};

op.onDelete = function ()
{
    for (let i = op.patch.ops.length - 1; i >= 0; i--)
    {
        if (op.patch.ops[i] && op.patch.ops[i].uiAttribs && op.patch.ops[i].uiAttribs.subPatch == op.patchId.get())
        {
            op.patch.deleteOp(op.patch.ops[i].id);
        }
    }
};

function makeBlueprint()
{
    const bpOp = op.patch.addOp(CABLES.UI.DEFAULTOPNAMES.blueprint);

    bpOp.getPortByName("externalPatchId").set(gui.patchId);
    bpOp.getPortByName("subPatchId").set(op.patchId.get());
    bpOp.getPortByName("active").set(true);

    bpOp.uiAttr(
        {
            "translate":
            {
                "x": op.uiAttribs.translate.x - 150,
                "y": op.uiAttribs.translate.y
            }
        });
}

op.rebuildListeners = () =>
{
    op.log("rebuild listeners...");

    const outop = getSubPatchOutputOp();
    for (let i = 0; i < outop.portsIn.length; i++)
    {
        if (outop.portsIn[i].isLinked())
        {
            addPortListener(outop.portsIn[i], this.portsOut[i]);
        }
    }
};


};

Ops.Ui.SubPatch.prototype = new CABLES.Op();
CABLES.OPS["84d9a6f0-ed7a-466d-b386-225ed9e89c60"]={f:Ops.Ui.SubPatch,objName:"Ops.Ui.SubPatch"};




// **************************************************************
// 
// Ops.Ui.VizArrayChart
// 
// **************************************************************

Ops.Ui.VizArrayChart = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array Numbers"),
    inArrTitles = op.inArray("Titles");
    // inStyle = op.inSwitch("Style", ["Pie", "Graph"], "Pie");

op.setUiAttrib({ "height": 100, "width": 200, "resizable": true });

let max = -Number.MAX_VALUE;
let min = Number.MAX_VALUE;
const padding = 10;

op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(
        layer.x, layer.y,
        layer.width, layer.height);

    const arr = inArr.get();
    const arrNames = inArrTitles.get();
    if (!arr)
    {
        return;
    }

    const colors = ["#7AC4E0", "#D183BF", "#9091D6", "#FFC395", "#F0D165", "#63A8E8", "#CF5D9D", "#66C984", "#D66AA6", "#515151"];

    let size = layer.height / 2;
    if (size != size || size < 0) return;
    let currentAngle = 0;
    let total = 0;
    for (let i = 0; i < arr.length; i++)
    {
        total += parseFloat(Math.abs(arr[i]));
    }

    let style = 0;
    // if (inStyle.get() === "Graph")style = 1;

    if (style == 0) // PIE
    {
        const fontSize = size / 10;
        ctx.font = "normal " + fontSize + "px sourceCodePro";

        ctx.fillStyle = "#fff";
        ctx.fillText("total sum:" + Math.round(total * 100) / 100, layer.x + (size * 2) + padding * 2, layer.y + fontSize);

        for (let i = 0; i < arr.length; i++)
        {
            let name = "";
            if (arrNames && arrNames[i])name = arrNames[i];
            let perc = (Math.abs(arr[i]) / total);
            let portionAngle = perc * 2 * Math.PI;

            ctx.beginPath();
            ctx.arc(layer.x + size, layer.y + size, Math.max(0, size - (padding * 2)), currentAngle, currentAngle + portionAngle);
            currentAngle += portionAngle;
            ctx.lineTo(layer.x + size, layer.y + size);

            ctx.fillStyle = colors[i % (colors.length - 1)];
            ctx.fill();

            ctx.fillText(i + ": " + name + " " + Math.round(perc * 1000) / 10 + "%", layer.x + (size * 2) + padding * 2, layer.y + fontSize * (i + 1 + 1));
        }

        ctx.beginPath();
        ctx.fillStyle = "#222";
        ctx.arc(layer.x + size, layer.y + size, size / 5, 0, 2 * Math.PI);
        ctx.fill();
    }
    else if (style == 1)
    {
        let posy = 0;
        for (let i = 0; i < arr.length; i++)
        {
            const perc = (Math.abs(arr[i]) / total);
            const h = perc * layer.height;

            ctx.fillStyle = colors[i % (colors.length - 1)];
            ctx.fillRect(
                layer.x + 21, layer.y + posy,
                12, h);
            posy += h;
        }
    }
};


};

Ops.Ui.VizArrayChart.prototype = new CABLES.Op();
CABLES.OPS["04ff8596-d35a-4ad5-86d6-db6a8c2ce8f0"]={f:Ops.Ui.VizArrayChart,objName:"Ops.Ui.VizArrayChart"};




// **************************************************************
// 
// Ops.Ui.VizArrayTable
// 
// **************************************************************

Ops.Ui.VizArrayTable = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inArr = op.inArray("Array"),
    inOffset = op.inInt("Start Row", 0);

op.setUiAttrib({ "height": 200, "width": 400, "resizable": true });

op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(layer.x, layer.y, layer.width, layer.height);

    ctx.save();
    ctx.scale(layer.scale, layer.scale);

    ctx.font = "normal 10px sourceCodePro";
    ctx.fillStyle = "#ccc";

    const arr = inArr.get() || [];
    let stride = 1;

    if (!arr)
    {
        op.setUiAttrib({ "extendTitle": "" });
        return;
    }

    op.setUiAttrib({ "extendTitle": "length: " + arr.length });

    if (inArr.links.length > 0 && inArr.links[0].getOtherPort(inArr))
        stride = inArr.links[0].getOtherPort(inArr).uiAttribs.stride || 1;

    let lines = Math.floor(layer.height / layer.scale / 10 - 1);
    let padding = 4;
    let offset = inOffset.get() * stride;

    for (let i = offset; i < offset + lines * stride; i += stride)
    {
        if (i < 0) continue;
        if (i + stride > arr.length) continue;

        ctx.fillStyle = "#666";

        const lineNum = (i) / stride;

        if (lineNum >= 0)
            ctx.fillText(lineNum,
                layer.x / layer.scale + padding,
                layer.y / layer.scale + 10 + (i - offset) / stride * 10 + padding);

        for (let s = 0; s < stride; s++)
        {
            let str = "";
            const v = arr[i + s];

            ctx.fillStyle = "#ccc";

            if (typeof v == "string") str = "\"" + v + "\"";
            else if (CABLES.UTILS.isNumeric(v)) str = String(Math.round(v * 10000) / 10000);
            else if (Array.isArray(v))
            {
                let preview = "...";
                if (v.length == 0) preview = "";
                str = "[" + preview + "] (" + v.length + ")";
            }
            else if (typeof v == "object")
            {
                try
                {
                    str = JSON.stringify(v, true, 1);
                }
                catch (e)
                {
                    str = "{???}";
                }
            }
            else if (v != v || v === undefined)
            {
                ctx.fillStyle = "#f00";
                str += String(v);
            }
            else
            {
                str += String(v);
            }

            ctx.fillText(str,
                layer.x / layer.scale + s * 100 + 50,
                layer.y / layer.scale + 10 + (i - offset) / stride * 10 + padding);
        }
    }

    const gradHeight = 30;

    if (offset > 0)
    {
        const radGrad = ctx.createLinearGradient(0, layer.y / layer.scale + 5, 0, layer.y / layer.scale + gradHeight);
        radGrad.addColorStop(0, "#222");
        radGrad.addColorStop(1, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(layer.x / layer.scale, layer.y / layer.scale, 200000, gradHeight);
    }

    if (offset + lines * stride < arr.length)
    {
        const radGrad = ctx.createLinearGradient(0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + 5, 0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + gradHeight);
        radGrad.addColorStop(1, "#222");
        radGrad.addColorStop(0, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(layer.x / layer.scale, layer.y / layer.scale + layer.height / layer.scale - gradHeight, 200000, gradHeight);
    }

    ctx.restore();
};


};

Ops.Ui.VizArrayTable.prototype = new CABLES.Op();
CABLES.OPS["af2eeaaf-ff86-4bfb-9a27-42f05160a5d8"]={f:Ops.Ui.VizArrayTable,objName:"Ops.Ui.VizArrayTable"};




// **************************************************************
// 
// Ops.Ui.VizBool
// 
// **************************************************************

Ops.Ui.VizBool = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNum = op.inBool("Boolean", 0),
    outBool = op.outBoolNum("Bool");

op.setUiAttrib({ "height": 100, "width": 100, "resizable": true });

inNum.onChange = () =>
{
    outBool.set(inNum.get());
};

op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(
        layer.x, layer.y,
        layer.width, layer.height);

    let isTrue = !!inNum.get();

    let circle = new Path2D();
    let radius = Math.min(layer.height, layer.width) / 2.4 * 0.8;
    if (radius < 0)radius = 0;
    circle.arc(layer.x + layer.width / 2, layer.y + layer.height / 2, radius, 0, 2 * Math.PI, false);

    ctx.strokeStyle = "#555";
    ctx.lineWidth = 7 * layer.scale;
    ctx.stroke(circle);

    if (isTrue)
    {
        if (op.uiAttribs.color)ctx.fillStyle = op.uiAttribs.color;
        else ctx.fillStyle = "#ccc";

        let circle = new Path2D();
        circle.arc(layer.x + layer.width / 2, layer.y + layer.height / 2, radius - (ctx.lineWidth / 2), 0, 2 * Math.PI, false);
        ctx.fill(circle);
    }
};


};

Ops.Ui.VizBool.prototype = new CABLES.Op();
CABLES.OPS["cf194306-175b-416a-b90e-31ff2192a190"]={f:Ops.Ui.VizBool,objName:"Ops.Ui.VizBool"};




// **************************************************************
// 
// Ops.Ui.VizGraph
// 
// **************************************************************

Ops.Ui.VizGraph = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNum1 = op.inFloat("Number 1"),
    inNum2 = op.inFloat("Number 2"),
    inNum3 = op.inFloat("Number 3"),
    inNum4 = op.inFloat("Number 4"),
    inNum5 = op.inFloat("Number 5"),
    inNum6 = op.inFloat("Number 6"),
    inNum7 = op.inFloat("Number 7"),
    inNum8 = op.inFloat("Number 8"),
    inReset = op.inTriggerButton("Reset");

op.setUiAttrib({ "height": 150, "resizable": true });

let buff = [];

let max = -Number.MAX_VALUE;
let min = Number.MAX_VALUE;

inNum1.onLinkChanged =
    inNum2.onLinkChanged =
    inNum3.onLinkChanged =
    inNum4.onLinkChanged =
    inNum5.onLinkChanged =
    inNum6.onLinkChanged =
    inNum7.onLinkChanged =
    inNum8.onLinkChanged =
    inReset.onTriggered = () =>
    {
        max = -Number.MAX_VALUE;
        min = Number.MAX_VALUE;
        buff = [];
    };

op.renderVizLayer = (ctx, layer) =>
{
    const perf = CABLES.UI.uiProfiler.start("previewlayer graph");

    const colors = [
        "#00ffff",
        "#ffff00",
        "#ff00ff",
        "#0000ff",
        "#00ff00",
        "#ff0000",
        "#ffffff",
        "#888888",
    ];

    ctx.fillStyle = "#222";
    ctx.fillRect(layer.x, layer.y, layer.width, layer.height);

    for (let p = 0; p < op.portsIn.length; p++)
    {
        if (!op.portsIn[p].isLinked()) continue;
        const newVal = op.portsIn[p].get();

        max = Math.max(op.portsIn[p].get(), max);
        min = Math.min(op.portsIn[p].get(), min);

        if (!buff[p]) buff[p] = [];
        buff[p].push(newVal);
        if (buff[p].length > 60) buff[p].shift();

        const texSlot = 5;
        const mulX = layer.width / 60;

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#555555";

        ctx.beginPath();
        ctx.moveTo(layer.x, CABLES.map(0, min, max, layer.height, 0) + layer.y);
        ctx.lineTo(layer.x + layer.width, CABLES.map(0, min, max, layer.height, 0) + layer.y);
        ctx.stroke();

        ctx.strokeStyle = colors[p];

        ctx.beginPath();

        for (let i = 0; i < buff[p].length; i++)
        {
            let y = buff[p][i];

            y = CABLES.map(y, min, max, layer.height, 0);
            y += layer.y;
            if (i === 0)ctx.moveTo(layer.x, y);
            else ctx.lineTo(layer.x + i * mulX, y);
        }

        ctx.stroke();
    }

    ctx.fillStyle = "#888";
    ctx.fillText("max:" + Math.round(max * 100) / 100, layer.x + 10, layer.y + layer.height - 10);
    ctx.fillText("min:" + Math.round(min * 100) / 100, layer.x + 10, layer.y + layer.height - 30);

    perf.finish();
};


};

Ops.Ui.VizGraph.prototype = new CABLES.Op();
CABLES.OPS["13c54eb4-60ef-4b9c-8425-d52a431f5c87"]={f:Ops.Ui.VizGraph,objName:"Ops.Ui.VizGraph"};




// **************************************************************
// 
// Ops.Ui.VizLogger
// 
// **************************************************************

Ops.Ui.VizLogger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inNum = op.inFloat("Number", 0);
const inString = op.inString("String", "");
const inClear = op.inTriggerButton("Clear");

let lines = 10;
const arr = [];

inClear.onTriggered = () =>
{
    arr.length = 0;
};

inString.onChange = () =>
{
    arr.push("" + inString.get());
};

inNum.onChange = () =>
{
    arr.push("" + inNum.get());
};

op.setUiAttrib({ "height": 200, "width": 400, "resizable": true });

op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(
        layer.x, layer.y,
        layer.width, layer.height);

    ctx.save();
    ctx.scale(layer.scale, layer.scale);

    ctx.font = "normal 10px sourceCodePro";
    ctx.fillStyle = "#ccc";

    if (lines > 0) while (arr.length - 1 > lines) arr.shift();

    lines = Math.floor(layer.height / layer.scale / 10 - 1);
    let padding = 4;

    ctx.fillStyle = "#ccc";

    for (let i = Math.min(lines, arr.length - 1); i > 0; i--)
    {
        ctx.fillText(arr[i], layer.x / layer.scale + padding, layer.y / layer.scale + 10 * i + padding);
    }

    ctx.restore();
};


};

Ops.Ui.VizLogger.prototype = new CABLES.Op();
CABLES.OPS["22b731fe-bc97-42fe-a550-92cf0cedb133"]={f:Ops.Ui.VizLogger,objName:"Ops.Ui.VizLogger"};




// **************************************************************
// 
// Ops.Ui.VizNumber
// 
// **************************************************************

Ops.Ui.VizNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inNum = op.inFloat("Number", 0);
const outNum = op.outNumber("Result");

op.setUiAttrib({ "widthOnlyGrow": true });

inNum.onChange = () =>
{
    let n = inNum.get();
    if (op.patch.isEditorMode())
    {
        let str = "";
        if (n === null)str = "null";
        else if (n === undefined)str = "undefined";
        else
        {
            str = "" + Math.round(n * 10000) / 10000;

            if (str[0] != "-")str = " " + str;
        }

        op.setUiAttribs({ "extendTitle": str });
    }

    outNum.set(n);
};


};

Ops.Ui.VizNumber.prototype = new CABLES.Op();
CABLES.OPS["2b60d12d-2884-4ad0-bda4-0caeb6882f5c"]={f:Ops.Ui.VizNumber,objName:"Ops.Ui.VizNumber"};




// **************************************************************
// 
// Ops.Ui.VizNumberBar
// 
// **************************************************************

Ops.Ui.VizNumberBar = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNum = op.inFloat("Number", 0);
    // inDrawBar=op.inBool("Draw Bar",true),
    // inDrawNUm=op.inBool("Draw Number",true);

op.setUiAttrib({ "height": 100, "width": 200, "resizable": true });

let max = -Number.MAX_VALUE;
let min = Number.MAX_VALUE;

inNum.onLinkChanged = () =>
{
    max = -Number.MAX_VALUE;
    min = Number.MAX_VALUE;
};

op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(
        layer.x, layer.y,
        layer.width, layer.height);

    // if(inDrawBar.get())
    {
        max = Math.max(max, inNum.get());
        min = Math.min(min, inNum.get());

        if (op.uiAttribs.color)ctx.fillStyle = op.uiAttribs.color;
        else ctx.fillStyle = "#555";

        let a = CABLES.map(0, min, max, 0, layer.width);
        let b = CABLES.map(inNum.get(), min, max, 0, layer.width);

        let xMin = Math.min(a, b);
        let xMax = Math.max(a, b);

        ctx.fillRect(
            xMin + layer.x, layer.y,
            xMax - xMin, layer.height);
    }

    // if(inDrawNUm.get())
    {
        const padding = 10;
        if (op.uiAttribs.color)ctx.fillStyle = "#fff";
        else ctx.fillStyle = "#ccc";

        const fontSize = layer.height * 0.7;
        ctx.font = "normal " + fontSize + "px sourceCodePro";
        ctx.fillText(Math.round(inNum.get() * 10000) / 10000, layer.x + padding, layer.y + fontSize);
    }
};


};

Ops.Ui.VizNumberBar.prototype = new CABLES.Op();
CABLES.OPS["37575d2e-4ba6-4d2b-b00c-c503666867c5"]={f:Ops.Ui.VizNumberBar,objName:"Ops.Ui.VizNumberBar"};




// **************************************************************
// 
// Ops.Ui.VizObject
// 
// **************************************************************

Ops.Ui.VizObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inObj = op.inObject("Object"),
    inConsole = op.inTriggerButton("console log");

inConsole.setUiAttribs({ "hidePort": true });

op.setUiAttrib({ "height": 200, "width": 400, "resizable": true });

inObj.onLinkChanged = () =>
{
    if (inObj.isLinked())
    {
        const p = inObj.links[0].getOtherPort(inObj);

        op.setUiAttrib({ "extendTitle": p.uiAttribs.objType });
    }
};

inConsole.onTriggered = () =>
{
    console.log(inObj.get());
};

op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(layer.x, layer.y, layer.width, layer.height);

    ctx.save();
    ctx.scale(layer.scale, layer.scale);

    ctx.font = "normal 10px sourceCodePro";
    ctx.fillStyle = "#ccc";
    const padding = 10;

    let obj = inObj.get();

    let str = "???";

    if (obj && obj.getInfo)
    {
        obj = obj.getInfo();
    }

    if (obj instanceof Element)
    {
        const o = {};

        o.id = obj.getAttribute("id");
        o.classes = obj.classList.value;
        o.innerText = obj.innerText;
        o.tagName = obj.tagName;

        obj = o;
    }

    if (obj && obj.constructor && obj.constructor.name != "Object")
    {
        // str =  + "()\n" + str;
        op.setUiAttribs({ "extendTitle": obj.constructor.name });
    }

    try
    {
        str = JSON.stringify(obj, false, 4);

        if (str == "{}" && obj && obj.constructor && obj.constructor.name != "Object")
        {
            str = "could not stringify object: " + obj.constructor.name + "\n";

            if (obj) for (let i in obj)
            {
                str += "\n" + i + " (" + typeof obj[i] + ")";
                // console.log(i)
            }
        }
    }
    catch (e)
    {
        str = "object can not be displayed as string";
    }

    if (str === undefined)str = "undefined";
    if (str === null)str = "null";
    str = String(str);
    let lines = str.split("\n");

    for (let j = 0; j < lines.length; j++)
        ctx.fillText(lines[j], layer.x / layer.scale + padding, layer.y / layer.scale + ((j + 1) * 12));

    ctx.restore();
};


};

Ops.Ui.VizObject.prototype = new CABLES.Op();
CABLES.OPS["d09bc53e-9f52-4872-94c7-4ef777512222"]={f:Ops.Ui.VizObject,objName:"Ops.Ui.VizObject"};




// **************************************************************
// 
// Ops.Ui.VizString
// 
// **************************************************************

Ops.Ui.VizString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inStr = op.inString("String", "");
const outNum = op.outString("Result");

op.setUiAttrib({ "widthOnlyGrow": true });

inStr.onChange = () =>
{
    let str = inStr.get();
    if (op.patch.isEditorMode())
    {
        if (str === null)str = "null";
        else if (str === undefined)str = "undefined";
        else str = "\"" + (String(str) || "") + "\"";
        op.setTitle(str);
    }

    outNum.set(inStr.get());
};


};

Ops.Ui.VizString.prototype = new CABLES.Op();
CABLES.OPS["b04ff547-f557-4a54-a3ad-8a668fe1303d"]={f:Ops.Ui.VizString,objName:"Ops.Ui.VizString"};




// **************************************************************
// 
// Ops.Ui.VizStringLong
// 
// **************************************************************

Ops.Ui.VizStringLong = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inStringEditor("String"),
    inPos = op.inFloatSlider("Scroll", 0);

op.setUiAttrib({ "height": 200, "width": 400, "resizable": true });
inStr.ignoreValueSerialize = true;

let lines = [];

inStr.onLinkChanged = () =>
{
    if (!inStr.isLinked())
    {
        lines = [];
        inStr.set(null);
    }
};

inStr.onChange = () =>
{
    if (inStr.get()) lines = inStr.get().split("\n");
    else lines = [];
};

op.renderVizLayer = (ctx, layer) =>
{
    ctx.fillStyle = "#222";
    ctx.fillRect(layer.x, layer.y, layer.width, layer.height);

    if (!inStr.get()) return;

    ctx.save();
    ctx.scale(layer.scale, layer.scale);

    ctx.font = "normal 10px sourceCodePro";
    ctx.fillStyle = "#ccc";

    let padding = 4;

    const lineHeight = 10;

    const numLines = Math.floor(layer.height / layer.scale / lineHeight);

    let offset = Math.floor(inPos.get() * lines.length);

    offset = Math.max(offset, 0);
    offset = Math.min(offset, lines.length - numLines);
    if (lines.length < numLines)offset = 0;

    const offsetLeft = ((offset + numLines + " ").length - 1) * 9.5;

    let indent = "";
    for (let i = 0; i < (offset + numLines + " ").length; i++) indent += " ";

    for (let i = offset; i < offset + numLines; i += 1)
    {
        if (i >= lines.length || i < 0) continue;

        ctx.fillStyle = "#888";

        ctx.fillText(i,
            layer.x / layer.scale + padding,
            layer.y / layer.scale + lineHeight + (i - offset) * lineHeight + padding);

        ctx.fillStyle = "#ccc";

        ctx.fillText(indent + lines[i],
            layer.x / layer.scale + padding,
            layer.y / layer.scale + lineHeight + (i - offset) * lineHeight + padding);
    }

    const gradHeight = 30;

    if (offset > 0)
    {
        const radGrad = ctx.createLinearGradient(0, layer.y / layer.scale + 5, 0, layer.y / layer.scale + gradHeight);
        radGrad.addColorStop(0, "#222");
        radGrad.addColorStop(1, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(layer.x / layer.scale, layer.y / layer.scale, 200000, gradHeight);
    }

    if (offset + numLines < lines.length)
    {
        const radGrad = ctx.createLinearGradient(0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + 5, 0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + gradHeight);
        radGrad.addColorStop(1, "#222");
        radGrad.addColorStop(0, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(layer.x / layer.scale, layer.y / layer.scale + layer.height / layer.scale - gradHeight, 200000, gradHeight);
    }

    ctx.restore();
};


};

Ops.Ui.VizStringLong.prototype = new CABLES.Op();
CABLES.OPS["b4c93fde-85c6-4c7e-9962-a6463a84838b"]={f:Ops.Ui.VizStringLong,objName:"Ops.Ui.VizStringLong"};




// **************************************************************
// 
// Ops.Ui.VizTexture
// 
// **************************************************************

Ops.Ui.VizTexture = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"viztex_frag":"IN vec2 texCoord;\nUNI sampler2D tex;\nUNI samplerCube cubeMap;\nUNI float width;\nUNI float height;\nUNI float type;\nUNI float time;\n\nfloat LinearizeDepth(float d,float zNear,float zFar)\n{\n    float z_n = 2.0 * d - 1.0;\n    return 2.0 * zNear / (zFar + zNear - z_n * (zFar - zNear));\n}\n\nvoid main()\n{\n    vec4 col=vec4(vec3(0.),0.0);\n\n    vec4 colTex=texture(tex,texCoord);\n\n\n\n    if(type==1.0)\n    {\n        vec4 depth=vec4(0.);\n        vec2 localST=texCoord;\n        localST.y = 1. - localST.y;\n\n        localST.t = mod(localST.t*3.,1.);\n        localST.s = mod(localST.s*4.,1.);\n\n        #ifdef WEBGL2\n            #define texCube texture\n        #endif\n        #ifdef WEBGL1\n            #define texCube textureCube\n        #endif\n\n//         //Due to the way my depth-cubeMap is rendered, objects to the -x,y,z side is projected to the positive x,y,z side\n//         //Inside where top/bottom is to be drawn?\n        if (texCoord.s*4.> 1. && texCoord.s*4.<2.)\n        {\n            //Bottom (-y) quad\n            if (texCoord.t*3. < 1.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-1.,-localST.t*2.+1.);//Due to the (arbitrary) way I choose as up in my depth-viewmatrix, i her emultiply the latter coordinate with -1\n                depth = texCube(cubeMap, dir);\n            }\n            //top (+y) quad\n            else if (texCoord.t*3. > 2.)\n            {\n                vec3 dir=vec3(localST.s*2.-1.,1.,localST.t*2.-1.);//Get lower y texture, which is projected to the +y part of my cubeMap\n                depth = texCube(cubeMap, dir);\n            }\n            else//Front (-z) quad\n            {\n                vec3 dir=vec3(localST.s*2.-1.,-localST.t*2.+1.,1.);\n                depth = texCube(cubeMap, dir);\n            }\n        }\n//         //If not, only these ranges should be drawn\n        else if (texCoord.t*3. > 1. && texCoord.t*3. < 2.)\n        {\n            if (texCoord.x*4. < 1.)//left (-x) quad\n            {\n                vec3 dir=vec3(-1.,-localST.t*2.+1.,localST.s*2.-1.);\n                depth = texCube(cubeMap, dir);\n            }\n            else if (texCoord.x*4. < 3.)//right (+x) quad (front was done above)\n            {\n                vec3 dir=vec3(1,-localST.t*2.+1.,-localST.s*2.+1.);\n                depth = texCube(cubeMap, dir);\n            }\n            else //back (+z) quad\n            {\n                vec3 dir=vec3(-localST.s*2.+1.,-localST.t*2.+1.,-1.);\n                depth = texCube(cubeMap, dir);\n            }\n        }\n        // colTex = vec4(vec3(depth),1.);\n        colTex = vec4(depth);\n    }\n\n    if(type==2.0)\n    {\n       float near = 0.1;\n       float far = 50.;\n       float depth = LinearizeDepth(colTex.r, near, far);\n       colTex.rgb = vec3(depth);\n    }\n\n    if(colTex.r>1.0 || colTex.r<0.0)\n    {\n        float r=mod( time+colTex.r,1.0)*0.5+0.5;\n        colTex.r=r;\n    }\n    if(colTex.g>1.0 || colTex.g<0.0)\n    {\n        float r=mod( time+colTex.g,1.0)*0.5+0.5;\n        colTex.g=r;\n    }\n    if(colTex.b>1.0 || colTex.b<0.0)\n    {\n        float r=mod( time+colTex.b,1.0)*0.5+0.5;\n        colTex.b=r;\n    }\n\n\n    outColor = mix(col,colTex,colTex.a);\n}\n\n","viztex_vert":"IN vec3 vPosition;\nIN vec2 attrTexCoord;\nOUT vec2 texCoord;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\nvoid main()\n{\n    texCoord=vec2(attrTexCoord.x,1.0-attrTexCoord.y);\n    vec4 pos = vec4( vPosition, 1. );\n    mat4 mvMatrix=viewMatrix * modelMatrix;\n    gl_Position = projMatrix * mvMatrix * pos;\n}",};
const
    inTex = op.inTexture("Texture In"),
    inShowInfo = op.inBool("Show Info", false),
    outTex = op.outTexture("Texture Out"),
    outInfo = op.outString("Info");

op.setUiAttrib({ "height": 150, "resizable": true });

const timer = new CABLES.Timer();
timer.play();

inTex.onChange = () =>
{
    const t = inTex.get();

    outTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
    outTex.set(t);
};

op.renderVizLayer = (ctx, layer) =>
{
    const port = inTex;
    const texSlot = 5;
    const texSlotCubemap = texSlot + 1;

    const perf = CABLES.UI.uiProfiler.start("previewlayer texture");
    const cgl = port.parent.patch.cgl;

    if (!this._emptyCubemap) this._emptyCubemap = CGL.Texture.getEmptyCubemapTexture(cgl);
    port.parent.patch.cgl.profileData.profileTexPreviews++;

    const portTex = port.get() || CGL.Texture.getEmptyTexture(cgl);

    if (!this._mesh)
    {
        const geom = new CGL.Geometry("preview op rect");
        geom.vertices = [1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, -1.0, 0.0];
        geom.texCoords = [
            1.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            0.0, 0.0];
        geom.verticesIndices = [0, 1, 2, 3, 1, 2];
        this._mesh = new CGL.Mesh(cgl, geom);
    }
    if (!this._shader)
    {
        this._shader = new CGL.Shader(cgl, "glpreviewtex");
        this._shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
        this._shader.setSource(attachments.viztex_vert, attachments.viztex_frag);
        this._shaderTexUniform = new CGL.Uniform(this._shader, "t", "tex", texSlot);
        this._shaderTexCubemapUniform = new CGL.Uniform(this._shader, "tc", "cubeMap", texSlotCubemap);

        this._shaderTexUniformW = new CGL.Uniform(this._shader, "f", "width", portTex.width);
        this._shaderTexUniformH = new CGL.Uniform(this._shader, "f", "height", portTex.height);
        this._shaderTypeUniform = new CGL.Uniform(this._shader, "f", "type", 0);
        this._shaderTimeUniform = new CGL.Uniform(this._shader, "f", "time", 0);
    }

    cgl.pushPMatrix();
    const sizeTex = [portTex.width, portTex.height];
    const small = port.parent.patch.cgl.canvasWidth > sizeTex[0] && port.parent.patch.cgl.canvasHeight > sizeTex[1];

    if (small)
    {
        mat4.ortho(cgl.pMatrix, 0, port.parent.patch.cgl.canvasWidth, port.parent.patch.cgl.canvasHeight, 0, 0.001, 11);
    }
    else mat4.ortho(cgl.pMatrix, -1, 1, 1, -1, 0.001, 11);

    const oldTex = cgl.getTexture(texSlot);
    const oldTexCubemap = cgl.getTexture(texSlotCubemap);

    let texType = 0;
    if (!portTex) return;
    if (portTex.cubemap) texType = 1;
    if (portTex.textureType == CGL.Texture.TYPE_DEPTH) texType = 2;

    if (texType == 0 || texType == 2)
    {
        cgl.setTexture(texSlot, portTex.tex);
        cgl.setTexture(texSlotCubemap, this._emptyCubemap.cubemap, cgl.gl.TEXTURE_CUBE_MAP);
    }
    else if (texType == 1)
    {
        cgl.setTexture(texSlotCubemap, portTex.cubemap, cgl.gl.TEXTURE_CUBE_MAP);
    }

    timer.update();
    this._shaderTimeUniform.setValue(timer.get());

    this._shaderTypeUniform.setValue(texType);
    let s = [port.parent.patch.cgl.canvasWidth, port.parent.patch.cgl.canvasHeight];

    cgl.gl.clearColor(0, 0, 0, 0);
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);

    cgl.pushModelMatrix();
    if (small)
    {
        s = sizeTex;
        mat4.translate(cgl.mMatrix, cgl.mMatrix, [sizeTex[0] / 2, sizeTex[1] / 2, 0]);
        mat4.scale(cgl.mMatrix, cgl.mMatrix, [sizeTex[0] / 2, sizeTex[1] / 2, 0]);
    }
    this._mesh.render(this._shader);
    cgl.popModelMatrix();

    if (texType == 0) cgl.setTexture(texSlot, oldTex);
    if (texType == 1) cgl.setTexture(texSlotCubemap, oldTexCubemap);

    cgl.popPMatrix();
    cgl.resetViewPort();

    const sizeImg = [layer.width, layer.height];

    const stretch = false;
    if (!stretch)
    {
        if (portTex.width > portTex.height) sizeImg[1] = layer.width * sizeTex[1] / sizeTex[0];
        else
        {
            sizeImg[1] = layer.width * (sizeTex[1] / sizeTex[0]);

            if (sizeImg[1] > layer.height)
            {
                const r = layer.height / sizeImg[1];
                sizeImg[0] *= r;
                sizeImg[1] *= r;
            }
        }
    }

    const scaledDown = sizeImg[0] > sizeTex[0] && sizeImg[1] > sizeTex[1];

    ctx.imageSmoothingEnabled = !small || !scaledDown;

    if (!ctx.imageSmoothingEnabled)
    {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(layer.x, layer.y - 10, 10, 10);
        ctx.fillStyle = "#000000";
        ctx.fillRect(layer.x, layer.y - 10, 5, 5);
        ctx.fillRect(layer.x + 5, layer.y - 10 + 5, 5, 5);
    }

    let numX = (10 * layer.width / layer.height);
    let stepY = (layer.height / 10);
    let stepX = (layer.width / numX);
    for (let x = 0; x < numX; x++)
        for (let y = 0; y < 10; y++)
        {
            if ((x + y) % 2 == 0)ctx.fillStyle = "#333333";
            else ctx.fillStyle = "#393939";
            ctx.fillRect(layer.x + stepX * x, layer.y + stepY * y, stepX, stepY);
        }

    ctx.fillStyle = "#222";
    const borderLeft = (layer.width - sizeImg[0]) / 2;
    const borderTop = (layer.height - sizeImg[1]) / 2;
    ctx.fillRect(
        layer.x, layer.y,
        borderLeft, (layer.height)
    );
    ctx.fillRect(
        layer.x + sizeImg[0] + borderLeft, layer.y,
        borderLeft, (layer.height)
    );
    ctx.fillRect(
        layer.x, layer.y,
        layer.width, borderTop
    );
    ctx.fillRect(
        layer.x, layer.y + sizeImg[1] + borderTop,
        layer.width, borderTop
    );

    if (sizeTex[1] == 1)
        ctx.drawImage(cgl.canvas,
            0, 0,
            s[0], s[1],
            layer.x, layer.y,
            layer.width, layer.height * 5);// workaround filtering problems
    if (sizeTex[0] == 1)
        ctx.drawImage(cgl.canvas,
            0, 0,
            s[0], s[1],
            layer.x, layer.y,
            layer.width * 5, layer.height); // workaround filtering problems
    else
        ctx.drawImage(cgl.canvas,
            0, 0,
            s[0], s[1],
            layer.x + (layer.width - sizeImg[0]) / 2, layer.y + (layer.height - sizeImg[1]) / 2,
            sizeImg[0], sizeImg[1]);

    let info = "unknown";

    if (port.get() && port.get().getInfoOneLine) info = port.get().getInfoOneLine();

    if (inShowInfo.get())
    {
        ctx.save();
        ctx.scale(layer.scale, layer.scale);
        ctx.font = "normal 10px sourceCodePro";
        ctx.fillStyle = "#000";
        ctx.fillText(info, layer.x / layer.scale + 5 + 0.75, (layer.y + layer.height) / layer.scale - 5 + 0.75);
        ctx.fillStyle = "#fff";
        ctx.fillText(info, layer.x / layer.scale + 5, (layer.y + layer.height) / layer.scale - 5);
        ctx.restore();
    }

    outInfo.set(info);

    cgl.gl.clearColor(0, 0, 0, 0);
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);

    perf.finish();
};


};

Ops.Ui.VizTexture.prototype = new CABLES.Op();
CABLES.OPS["4ea2d7b0-ca74-45db-962b-4d1965ac20c0"]={f:Ops.Ui.VizTexture,objName:"Ops.Ui.VizTexture"};




// **************************************************************
// 
// Ops.Ui.VizTextureTable
// 
// **************************************************************

Ops.Ui.VizTextureTable = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inTex = op.inTexture("Texture");

op.setUiAttrib({ "height": 200, "width": 380, "resizable": true });

let pixelData = null;
let lastWidth;
let lastHeight;
let fb;
let lastFloatingPoint;
let lastRead = 0;
const arr = [];

inTex.onLinkChanged = () =>
{
    op.setUiAttrib({ "extendTitle": "" });
};

op.renderVizLayer = (ctx, layer) =>
{
    const
        realTexture = inTex.get(),
        gl = op.patch.cgl.gl;

    ctx.fillStyle = "#222";
    ctx.fillRect(layer.x, layer.y, layer.width, layer.height);

    if (!realTexture) return;

    let lines = Math.floor(layer.height / layer.scale / 10 - 1);

    ctx.save();
    ctx.scale(layer.scale, layer.scale);

    ctx.font = "normal 10px sourceCodePro";
    ctx.fillStyle = "#ccc";

    if (!fb) fb = gl.createFramebuffer();

    let channels = gl.RGBA;
    let numChannels = 4;

    let texChanged = true;
    let channelType = gl.UNSIGNED_BYTE;

    if (texChanged)
    {
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

        gl.framebufferTexture2D(
            gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D, realTexture.tex, 0
        );

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        let isFloatingPoint = realTexture.isFloatingPoint();
        if (isFloatingPoint) channelType = gl.FLOAT;

        if (
            lastFloatingPoint != isFloatingPoint ||
                    lastWidth != realTexture.width ||
                    lastHeight != realTexture.height)
        {
            const size = realTexture.width * realTexture.height * numChannels;
            if (isFloatingPoint) pixelData = new Float32Array(size);
            else pixelData = new Uint8Array(size);

            lastFloatingPoint = isFloatingPoint;
            lastWidth = realTexture.width;
            lastHeight = realTexture.height;
        }

        texChanged = false;
    }

    let texRows = Math.max(1, Math.ceil(lines / realTexture.width));
    texRows = Math.min(texRows, realTexture.height);
    let readW = realTexture.width;
    if (lines / realTexture.width < 1)readW = realTexture.width * lines / realTexture.width;
    const readH = texRows;
    let readPixels = false;

    if (performance.now() - lastRead > 100)readPixels = true;

    if (readPixels)
    {
        lastRead = performance.now();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

        gl.readPixels(
            0,
            realTexture.height - texRows,
            readW,
            readH,
            channels,
            channelType,
            pixelData
        );

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    arr.length = pixelData.length;
    let stride = 4;
    let padding = 4;
    let lineHeight = 10;
    let isFp = realTexture.isFloatingPoint();

    for (let x = 0; x < readW; x++)
        for (let y = 0; y < readH; y++)
            for (let s = 0; s < stride; s++)
                arr[(x + (y * readW)) * stride + s] = pixelData[((x) + ((readH - y - 1) * readW)) * stride + s];

    if (realTexture && realTexture.getInfoOneLine)
        op.setUiAttrib({ "extendTitle": realTexture.getInfoOneLine() });

    for (let y = 0; y < readH; y++)
        for (let x = 0; x < readW; x++)
        {
            const count = x + y * readW;

            const i = x * stride + (y * readW * stride);

            ctx.fillStyle = "#666";

            ctx.fillText(i / stride,
                layer.x / layer.scale + padding,
                layer.y / layer.scale + lineHeight + i / stride * lineHeight + padding);

            const idx = count * stride;

            if (inTex.get().isFloatingPoint()) ctx.fillStyle = "rgba(" + arr[idx + 0] * 255 + "," + arr[idx + 1] * 255 + "," + arr[idx + 2] * 255 + "," + arr[idx + 3] * 255 + ")";
            else ctx.fillStyle = "rgba(" + arr[idx + 0] + "," + arr[idx + 1] + "," + arr[idx + 2] + "," + arr[idx + 3] + ")";

            ctx.fillRect(
                layer.x / layer.scale + padding + 25,
                layer.y / layer.scale + lineHeight + count * lineHeight + padding - 7,
                15, 8);

            ctx.fillStyle = "#ccc";

            for (let s = 0; s < stride; s++)
            {
                let v = arr[i + s];
                let str = "" + v;

                if (!isFp)v /= 255;
                str = String(Math.round(v * 10000) / 10000);

                ctx.fillText(str, layer.x / layer.scale + s * 60 + 70, layer.y / layer.scale + 10 + (i / stride) * 10 + padding);
            }
        }

    const gradHeight = 30;

    if (lines < readH * readW)
    {
        const radGrad = ctx.createLinearGradient(0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + 5, 0, layer.y / layer.scale + layer.height / layer.scale - gradHeight + gradHeight);
        radGrad.addColorStop(1, "#222");
        radGrad.addColorStop(0, "rgba(34,34,34,0.0)");
        ctx.fillStyle = radGrad;
        ctx.fillRect(layer.x / layer.scale, layer.y / layer.scale + layer.height / layer.scale - gradHeight, 200000, gradHeight);
    }

    ctx.restore();
};


};

Ops.Ui.VizTextureTable.prototype = new CABLES.Op();
CABLES.OPS["0e5cde34-35cd-440d-b8cd-f78e1b5b7722"]={f:Ops.Ui.VizTextureTable,objName:"Ops.Ui.VizTextureTable"};




// **************************************************************
// 
// Ops.Value.Boolean
// 
// **************************************************************

Ops.Value.Boolean = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    v = op.inValueBool("value", false),
    result = op.outBoolNum("result");

result.set(false);
v.onChange = exec;

function exec()
{
    if (result.get() != v.get()) result.set(v.get());
}


};

Ops.Value.Boolean.prototype = new CABLES.Op();
CABLES.OPS["83e2d74c-9741-41aa-a4d7-1bda4ef55fb3"]={f:Ops.Value.Boolean,objName:"Ops.Value.Boolean"};




// **************************************************************
// 
// Ops.Value.ColorValue
// 
// **************************************************************

Ops.Value.ColorValue = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const r = op.inValueSlider("r", Math.random());
const g = op.inValueSlider("g", Math.random());
const b = op.inValueSlider("b", Math.random());
r.setUiAttribs({ "colorPick": true });
const a = op.inValueSlider("a");

const outR = op.outNumber("outr");
const outG = op.outNumber("outg");
const outB = op.outNumber("outb");
const outA = op.outNumber("outa");
const outHex = op.outNumber("Hex", "000000");
const arrOut = op.outArray("Array");

r.onChange = g.onChange = b.onChange = a.onChange = exec;

/**
 * Float [0..1] -> Hex String [00..FF]
 */
function floatToHex(f)
{
    let s = Math.round(f * 255).toString(16);
    if (s.length === 1)
    {
        s = "0" + s;
    }
    return s.toUpperCase();
}

function exec()
{
    outR.set(r.get());
    outG.set(g.get());
    outB.set(b.get());
    outA.set(a.get());

    let hex = floatToHex(r.get()) + floatToHex(g.get()) + floatToHex(b.get());
    outHex.set(hex);

    arrOut.set([r.get(), g.get(), b.get()]);
}

exec();


};

Ops.Value.ColorValue.prototype = new CABLES.Op();
CABLES.OPS["7caa37c8-f2a7-49f2-a29c-96af362abca0"]={f:Ops.Value.ColorValue,objName:"Ops.Value.ColorValue"};




// **************************************************************
// 
// Ops.Value.DelayBooleanSimple
// 
// **************************************************************

Ops.Value.DelayBooleanSimple = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inFloat("Value"),
    delTrue = op.inFloat("Delay True", 1),
    delFalse = op.inFloat("Delay False", 1),
    outVal = op.outBoolNum("Out Value");

let timeout = -1;

val.onChange =
    delFalse.onChange =
    delTrue.onChange = update;

function update()
{
    clearTimeout(timeout);
    let v = val.get();

    let delay = 1;
    if (v) delay = delTrue.get() * 1000;
    else delay = delFalse.get() * 1000;

    timeout = setTimeout(function ()
    {
        outVal.set(v);
    }, delay);
}


};

Ops.Value.DelayBooleanSimple.prototype = new CABLES.Op();
CABLES.OPS["4516be54-9077-490f-a094-83696b9011ba"]={f:Ops.Value.DelayBooleanSimple,objName:"Ops.Value.DelayBooleanSimple"};




// **************************************************************
// 
// Ops.Value.DelayNumberSimple
// 
// **************************************************************

Ops.Value.DelayNumberSimple = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inValue("Value"),
    de = op.inValue("Delay", 1),
    outVal = op.outNumber("Out Value");

let timeout = -1;

val.onChange = update;
de.onChange = update;

function update()
{
    clearTimeout(timeout);
    let v = val.get();
    timeout = setTimeout(function ()
    {
        outVal.set(v);
    }, de.get() * 1000);
}


};

Ops.Value.DelayNumberSimple.prototype = new CABLES.Op();
CABLES.OPS["89ea7e9c-0dfb-4e1e-8e61-4e79112ee533"]={f:Ops.Value.DelayNumberSimple,objName:"Ops.Value.DelayNumberSimple"};




// **************************************************************
// 
// Ops.Value.DelayStringSimple
// 
// **************************************************************

Ops.Value.DelayStringSimple = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val=op.inString("Value"),
    de=op.inValue("Delay",1),
    outVal=op.outString("Out Value");

let timeout=-1;

val.onChange=
    de.onChange=update;

function update()
{
    clearTimeout(timeout);
    var v=val.get();
    timeout=setTimeout(function()
    {
        outVal.set(v);
    },de.get()*1000);

}


};

Ops.Value.DelayStringSimple.prototype = new CABLES.Op();
CABLES.OPS["0e3c0986-071e-4c98-be84-7f17306490c6"]={f:Ops.Value.DelayStringSimple,objName:"Ops.Value.DelayStringSimple"};




// **************************************************************
// 
// Ops.Value.DelayedValue
// 
// **************************************************************

Ops.Value.DelayedValue = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("Update"),
    v = op.inValue("Value", 0),
    delay = op.inValue("Delay", 0.5),
    result = op.outNumber("Result", 0),
    clear = op.inValueBool("Clear on Change", false);

const anim = new CABLES.Anim();
anim.createPort(op, "easing", function () {}).set("absolute");

exe.onTriggered = function ()
{
    result.set(anim.getValue(op.patch.freeTimer.get()) || 0);
};

v.onChange = function ()
{
    const current = anim.getValue(op.patch.freeTimer.get());
    const t = op.patch.freeTimer.get();

    if (clear.get()) anim.clear(t);

    anim.setValue(t + delay.get(), v.get());

    let lastKey = 0;
    for (let i = 0; i < anim.keys.length; i++)
    {
        if (anim.keys[i].time < t)lastKey = i;
    }
    if (lastKey > 2) anim.keys.splice(0, lastKey);
};


};

Ops.Value.DelayedValue.prototype = new CABLES.Op();
CABLES.OPS["8e7741e0-0b1b-40f3-a62c-ac8a8828dffb"]={f:Ops.Value.DelayedValue,objName:"Ops.Value.DelayedValue"};




// **************************************************************
// 
// Ops.Value.FileInput_v2
// 
// **************************************************************

Ops.Value.FileInput_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const inFile = op.inUrl("File");
const outPath = op.outString("URL");

inFile.onChange = function ()
{
    const url = op.patch.getFilePath(String(inFile.get()));
    outPath.set(url);
};


};

Ops.Value.FileInput_v2.prototype = new CABLES.Op();
CABLES.OPS["3f20a79f-a35f-4a4d-b2f3-c46973a4531f"]={f:Ops.Value.FileInput_v2,objName:"Ops.Value.FileInput_v2"};




// **************************************************************
// 
// Ops.Value.FilterValidNumber
// 
// **************************************************************

Ops.Value.FilterValidNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inNumber=op.inFloat("Number",0),
    inZero=op.inBool("Invalid when 0",false),
    inSmaller=op.inBool("Invalid when <0",false),

    outNum=op.outNumber("Last Valid Number"),
    outValid=op.outBool("Is Valid");

inZero.onChange=
inSmaller.onChange=
inNumber.onChange=
    update;


function update()
{
    const num=inNumber.get();

    var r=true;

    if(num===null || num===undefined || num!=num) r=false;
    if(inZero.get() && num===0) r=false;
    if(inSmaller.get() && num<0) r=false;

    if(r) outNum.set(num);

    outValid.set(r);
}

};

Ops.Value.FilterValidNumber.prototype = new CABLES.Op();
CABLES.OPS["5a4db4ef-33d2-4131-9825-aa926f1f5a98"]={f:Ops.Value.FilterValidNumber,objName:"Ops.Value.FilterValidNumber"};




// **************************************************************
// 
// Ops.Value.GateNumber
// 
// **************************************************************

Ops.Value.GateNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const valueInPort = op.inValue("Value In", 0);
const passThroughPort = op.inValueBool("Pass Through");
const valueOutPort = op.outNumber("Value Out");

valueInPort.onChange = update;
passThroughPort.onChange = update;

valueInPort.changeAlways = true;
valueOutPort.changeAlways = true;

function update()
{
    if (passThroughPort.get())
    {
        valueOutPort.set(valueInPort.get());
    }
}


};

Ops.Value.GateNumber.prototype = new CABLES.Op();
CABLES.OPS["594105c8-1fdb-4f3c-bbd5-29b9ad6b33e0"]={f:Ops.Value.GateNumber,objName:"Ops.Value.GateNumber"};




// **************************************************************
// 
// Ops.Value.Integer
// 
// **************************************************************

Ops.Value.Integer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    input = op.inInt("Integer",0),
    output = op.outNumber("Number out");

input.onChange=function()
{
    output.set(Math.floor(input.get()));
}

};

Ops.Value.Integer.prototype = new CABLES.Op();
CABLES.OPS["17bc01d7-04ad-4aab-b88b-bb09744c4a69"]={f:Ops.Value.Integer,objName:"Ops.Value.Integer"};




// **************************************************************
// 
// Ops.Value.MaximumSafeInteger
// 
// **************************************************************

Ops.Value.MaximumSafeInteger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
op.outNumber("Max Int", Number.MAX_SAFE_INTEGER);


};

Ops.Value.MaximumSafeInteger.prototype = new CABLES.Op();
CABLES.OPS["0efefbb7-461c-4a34-b7fd-28b89b0ceb3f"]={f:Ops.Value.MaximumSafeInteger,objName:"Ops.Value.MaximumSafeInteger"};




// **************************************************************
// 
// Ops.Value.MinimumSafeInteger
// 
// **************************************************************

Ops.Value.MinimumSafeInteger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
op.outNumber("Min Int", Number.MIN_SAFE_INTEGER);


};

Ops.Value.MinimumSafeInteger.prototype = new CABLES.Op();
CABLES.OPS["d74e5528-8049-4cbc-984b-1221532a2fd4"]={f:Ops.Value.MinimumSafeInteger,objName:"Ops.Value.MinimumSafeInteger"};




// **************************************************************
// 
// Ops.Value.Number
// 
// **************************************************************

Ops.Value.Number = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    v = op.inValueFloat("value"),
    result = op.outNumber("result");

v.onChange = exec;

function exec()
{
    result.set(Number(v.get()));
}


};

Ops.Value.Number.prototype = new CABLES.Op();
CABLES.OPS["8fb2bb5d-665a-4d0a-8079-12710ae453be"]={f:Ops.Value.Number,objName:"Ops.Value.Number"};




// **************************************************************
// 
// Ops.Value.NumberSequence
// 
// **************************************************************

Ops.Value.NumberSequence = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const NUM_PORTS = 4;
const inPort = op.inValue("In Value");
const outTrigger = op.outTrigger("Value Changed");

const outPorts = [];
for (let i = 0; i < NUM_PORTS; i++)
{
    outPorts.push(op.outNumber("Out Value " + i));
}

// change listener
inPort.onChange = function ()
{
    const inValue = inPort.get();
    for (let i = 0; i < NUM_PORTS; i++)
    {
        outPorts[i].set(inValue);
    }
    outTrigger.trigger();
};


};

Ops.Value.NumberSequence.prototype = new CABLES.Op();
CABLES.OPS["33b08c9a-639a-4edc-8908-fa4df58a4b51"]={f:Ops.Value.NumberSequence,objName:"Ops.Value.NumberSequence"};




// **************************************************************
// 
// Ops.Value.NumberSwitchBoolean
// 
// **************************************************************

Ops.Value.NumberSwitchBoolean = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inBool = op.inValueBool("Boolean"),
    valFalse = op.inValue("Value false", 0),
    valTrue = op.inValue("Value true", 1),
    outVal = op.outNumber("Result");

inBool.onChange =
    valTrue.onChange =
    valFalse.onChange = update;

op.setPortGroup("Output Values", [valTrue, valFalse]);

function update()
{
    if (inBool.get()) outVal.set(valTrue.get());
    else outVal.set(valFalse.get());
}


};

Ops.Value.NumberSwitchBoolean.prototype = new CABLES.Op();
CABLES.OPS["637c5fa8-840d-4535-96ab-3d27b458a8ba"]={f:Ops.Value.NumberSwitchBoolean,objName:"Ops.Value.NumberSwitchBoolean"};




// **************************************************************
// 
// Ops.Value.Preset
// 
// **************************************************************

Ops.Value.Preset = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    dataPort = op.inString("data", ""),
    setsPort = op.inString("sets", ""),
    id = op.inString("presetid", CABLES.shortId()),

    inInterPolate = op.inSwitch("Interpolation", ["None", "xfade", "a-b"], "None"), // "a..b","a..c"

    presetA = op.inFloat("Preset A", "0"),
    presetB = op.inFloat("Preset B", "1"),
    presetFade = op.inFloatSlider("Fade", 0.0),

    presetNames = op.inDropDown("Preset", []),
    presetCreate = op.inTriggerButton("Create new"),
    presetUpdate = op.inTriggerButton("Update"),
    move = op.inUiTriggerButtons("move", ["↑", "↓"]),

    presetDelete = op.inTriggerButton("Delete"),
    presetRename = op.inTriggerButton("Rename"),

    addPort = op.addOutPort(new CABLES.Port(op, "Create Variable", CABLES.OP_PORT_TYPE_DYNAMIC)),
    outNum = op.outNumber("Num Presets", 0),
    outNumCurrentPreset = op.outNumber("current Preset", 0),
    outDbgData = op.outArray("dbg_data"),
    outDbgSets = op.outArray("dbg_sets");
let data = [];
let presets = [];
const valuePorts = [];
let interpolate = 0;

presetB.changeAlways = true;
presetA.changeAlways = true;

op.setPortGroup("Manage Presets", [presetCreate, presetUpdate, presetDelete, presetNames, move, presetRename]);
dataPort.setUiAttribs({ "hideParam": true, "hidePort": true });
id.setUiAttribs({ "hideParam": true, "hidePort": true });
setsPort.setUiAttribs({ "hideParam": true, "hidePort": true });
presetCreate.setUiAttribs({ "hidePort": true });
presetUpdate.setUiAttribs({ "hidePort": true });
presetDelete.setUiAttribs({ "hidePort": true });
presetRename.setUiAttribs({ "hidePort": true });
presetNames.setUiAttribs({ "showIndex": true });
presetCreate.setUiAttribs({ "buttonTitle": "Create New Preset" });
presetDelete.setUiAttribs({ "buttonTitleClass": "button-small" });
presetRename.setUiAttribs({ "buttonTitleClass": "button-small" });

presetNames.onChange = updatePreset;
inInterPolate.onChange = updateInterpolation;
presetA.onChange =
    presetB.onChange =
    presetFade.onChange = updateFade;

updateInterpolation();
updateDropdown();
updatePreset();
updateButtons();

function movePreset(from, to)
{
    const f = presets.splice(from, 1)[0];
    presets.splice(to, 0, f);
}

move.onTriggered = function (which)
{
    const current = presetNames.get();
    const idx = presetNames.uiAttribs.values.indexOf(current);

    if (which == "↓") movePreset(idx, idx + 1);
    if (which == "↑") movePreset(idx, Math.max(0, idx - 1));

    updateDropdown();
    updatePreset();
};

op.init = function ()
{
    if (presets.length > 0 && data.length == 0)
    {
        op.logError("it happened again!!");

        // this happened only once for now, find out how to reproduce it!!!
        const keys = Object.keys(presets[0].values);

        for (let i = 0; i < keys.length; i++)
        {
            data.push(
                {
                    "varname": keys[i],
                    "type": 0,
                    "title": keys[i]

                });
        }
        saveData();
    }
};

function updateInterpolation()
{
    const ip = inInterPolate.get();
    if (ip === "None")
    {
        interpolate = 0;
        presetA.setUiAttribs({ "greyout": true });
        presetB.setUiAttribs({ "greyout": true });
        presetFade.setUiAttribs({ "greyout": true });
    }
    else if (ip === "xfade")
    {
        interpolate = 1;
        presetA.setUiAttribs({ "greyout": false });
        presetB.setUiAttribs({ "greyout": false });
        presetFade.setUiAttribs({ "greyout": false });
    }
    else if (ip === "a-b")
    {
        interpolate = 2;
        presetA.setUiAttribs({ "greyout": false });
        presetB.setUiAttribs({ "greyout": true });
        presetFade.setUiAttribs({ "greyout": true });
    }

    op.setUiAttrib({ "extendTitle": ip });

    if (interpolate !== 0) updateFade();
    else updatePreset();
}

function updateFade()
{
    if (interpolate === 0) return;

    let fade = 0;
    let idxa = 0;
    let idxb = 0;

    if (interpolate === 2) // a-b
    {
        const pr = presetA.get();
        idxa = Math.floor(pr);
        idxb = Math.ceil(pr);
        fade = pr % 1;

        if (idxa >= presets.length) idxa = presets.length - 1;
        if (idxb >= presets.length) idxb = presets.length - 1;
    }
    else if (interpolate === 1) // xfade
    {
        fade = presetFade.get();
        idxa = Math.floor(presetA.get());
        idxb = Math.floor(presetB.get());
    }

    const a = presets[idxa];
    const b = presets[idxb];

    if (!a || !b)
    {
        op.warn("preset not found");
        return;
    }

    // todo: cache variable, so no string lookup needed every time...

    for (const i in a.values)
    {
        const ip = a.values[i] + (b.values[i] - a.values[i]) * fade;
        op.patch.setVarValue(i, ip);
    }
}

function saveData()
{
    savePresets();
}

function savePresets()
{
    dataPort.set(JSON.stringify(data));

    setsPort.set(JSON.stringify(presets));
    outNum.set(presets.length);
    setDebugOutput();
}

function setPresetValues(preset)
{
    preset.values = preset.values || {};

    for (let i = 0; i < valuePorts.length; i++)
        preset.values[valuePorts[i].name] = valuePorts[i].value;

    return preset;
}

function updateButtons()
{
    presetDelete.setUiAttribs({ "greyout": presetNames.uiAttribs.values.length == 0 });
    presetUpdate.setUiAttribs({ "greyout": presetNames.uiAttribs.values.length == 0 });
    presetRename.setUiAttribs({ "greyout": presetNames.uiAttribs.values.length == 0 });

    move.setUiAttribs({ "greyout": presetNames.uiAttribs.values.length == 0 });

    const preset = getPreset(presetNames.get());
    if (preset)
    {
        presetDelete.setUiAttribs({ "buttonTitle": "Delete " + preset.name });
        presetUpdate.setUiAttribs({ "buttonTitle": "Update " + preset.name });
        presetRename.setUiAttribs({ "buttonTitle": "Rename " + preset.name });
    }
}

function updateDropdown()
{
    presetNames.uiAttribs.values.length = 0;
    for (let i = 0; i < presets.length; i++)
        presetNames.uiAttribs.values.push(presets[i].name);

    updateButtons();
    savePresets();
    setDebugOutput();
}

function getPreset(name)
{
    for (let i = 0; i < presets.length; i++)
        if (presets[i] && presets[i].name == name)
            return presets[i];
}

setsPort.onChange = function ()
{
    presets = JSON.parse(setsPort.get());
    outNum.set(presets.length);
    updateDropdown();
    setsPort.onChange = null;
};

function updatePreset()
{
    const preset = getPreset(presetNames.get());

    if (!preset) return;

    const varnames = Object.keys(preset.values);

    for (let i = 0; i < varnames.length; i++)
    {
        const p = op.getPort(varnames[i]);
        if (p)
        {
            p.set(preset.values[varnames[i]]);
            if (interpolate === 0)p.forceChange();
        }
    }

    if (interpolate !== 0) updateFade();

    updateButtons();
    op.refreshParams();
}

presetUpdate.onTriggered = function ()
{
    let preset = getPreset(presetNames.get());
    preset = setPresetValues(preset);
    savePresets();
};

presetCreate.onTriggered = function ()
{
    if (!op.patch.isEditorMode()) return;


    new CABLES.UI.ModalDialog({
        "prompt": true,
        "title": "New Preset",
        "text": "Enter a new preset name",
        "promptValue": "",
        "promptOk": (str) =>
        {
            op.refreshParams();
            presetNames.set(str);
            let preset = { "name": str };
            preset = setPresetValues(preset);
            presets.push(preset);
            updateDropdown();
            savePresets();
        } });
};

presetDelete.onTriggered = function ()
{
    if (!CABLES.UI) return;
    const current = presetNames.get();
    const idx = presetNames.uiAttribs.values.indexOf(current);
    presets.splice(idx, 1);
    saveData();

    if (presets.length > 0)
        presetNames.set(presets[0].name);

    op.refreshParams();
    updateDropdown();
    updateButtons();
};

presetRename.onTriggered = function ()
{
    if (!CABLES.UI) return;

    new CABLES.UI.ModalDialog({
        "prompt": true,
        "title": "New Preset",
        "text": "Enter a new preset name",
        "promptValue": "",
        "promptOk": (str) =>
        {
            if (!str) return;
            const current = presetNames.get();
            const idx = presetNames.uiAttribs.values.indexOf(current);
            presets[idx].name = str;
            presetNames.set(str);
            saveData();
            updateDropdown();
            op.refreshParams();
        }
    });
};

dataPort.onChange = function ()
{
    data = JSON.parse(dataPort.get());

    for (let i = 0; i < data.length; i++)
    {
        const portObject = data[i];

        const varname = portObject.varname;

        if (!op.getPort(varname))
        {
            if (portObject.type == CABLES.OP_PORT_TYPE_VALUE)
            {
                const val = op.patch.getVarValue(varname);
                const port = op.inFloat(varname, val);

                port.setUiAttribs({
                    "editableTitle": true,
                    "title": portObject.title });

                listenPortChange(port, varname);

                port.set(val);
                port.forceChange();
            }
        }
    }

    setDebugOutput();
    // dataPort.onChange=null;
};

function listenPortChange(port, varname)
{
    valuePorts.push(port);
    port.onChange = function ()
    {
        op.patch.setVarValue(varname, port.get());
    };

    port.addEventListener("onUiAttrChange", (attribs) =>
    {
        if (attribs.title)
        {
            const thePort = data.find((p) => { return p.varname === varname; });
            if (thePort)
            {
                thePort.title = attribs.title;
                saveData();
            }
        }
    });
}

op.patch.addEventListener("onOpDelete", (optodelete) =>
{
    if (optodelete.objName.indexOf("VarGet") == -1) return;

    const newData = [];
    for (let i = 0; i < data.length; i++)
    {
        let found = false;

        for (let oi = 0; oi < op.patch.ops.length; oi++)
        {
            const opt = op.patch.ops[oi];

            if (opt != optodelete &&
                opt.objName.indexOf("VarGet" > -1) &&
                opt.varName &&
                opt.varName.get &&
                opt.varName.get() == data[i].varname)
            {
                found = true;
                break;
            }
        }

        if (found)
        {
            newData.push(data[i]);
        }
        else
        {
            op.removePort(op.getPort(data[i].varname));
        }
    }

    data = newData;
    saveData();

    op.refreshParams();
    setTimeout(op.refreshParams.bind(this), 1000);
});

function setDebugOutput()
{
    outDbgData.set(data);
    outDbgSets.set(presets);
}

addPort.onLinkChanged = function ()
{
    if (addPort.links.length === 0)
    {
        op.log("no links!");
        return;
    }

    const link = addPort.links[0];
    const otherPort = link.getOtherPort(addPort);

    const varname = ".preset_" + otherPort.name + "_" + id.get() + "_" + CABLES.shortId();

    op.log("pilength", op.portsIn.length);

    data.push(
        {
            "varname": varname,
            "title": otherPort.parent.name + " " + otherPort.name,
            "type": otherPort.type
        });

    const oldValue = otherPort.get();

    op.patch.setVarValue(varname, oldValue);
    op.patch.getVar(varname).type = "preset";

    addPort.removeLinks();
    saveData();
    op.refreshParams();

    otherPort.setVariable(varname);
};

op.onDelete = (reloading) =>
{
    if (reloading) return;
    for (let i = 0; i < data.length; i++)
        op.patch.deleteVar(data[i].varname);
};


};

Ops.Value.Preset.prototype = new CABLES.Op();
CABLES.OPS["ffe981a5-67df-4da5-a6a9-7fcb910fc982"]={f:Ops.Value.Preset,objName:"Ops.Value.Preset"};




// **************************************************************
// 
// Ops.Value.PreviousValueStore
// 
// **************************************************************

Ops.Value.PreviousValueStore = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inValueFloat("Value"),
    outCurrent = op.outNumber("Current Value"),
    outOldVal = op.outNumber("Previous Value");

let oldValue = 0;

val.onChange = function ()
{
    outOldVal.set(oldValue);
    oldValue = val.get();
    outCurrent.set(val.get());
};


};

Ops.Value.PreviousValueStore.prototype = new CABLES.Op();
CABLES.OPS["01716872-67bd-4b31-a4a2-e0ccadf48411"]={f:Ops.Value.PreviousValueStore,objName:"Ops.Value.PreviousValueStore"};




// **************************************************************
// 
// Ops.Value.RouteNumber
// 
// **************************************************************

Ops.Value.RouteNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// constants and variables
const NUM_PORTS = 10;
const DEFAULT_VALUE_DEFAULT = 0;
let lastIdx = null;

// input
const indexPort = op.inValue("Index", 0);
const valuePort = op.inValue("Value", 0);
const defaultValuePort = op.inValue("Default Value", DEFAULT_VALUE_DEFAULT);
const onlyOnePort = op.inBool("Set inactive to default", false);

// output
const valuePorts = createOutPorts(DEFAULT_VALUE_DEFAULT);

// change listeners
indexPort.onChange = update;
valuePort.onChange = update; // TODO: Maybe only one update needed!?
defaultValuePort.onChange = setDefaultValues;
onlyOnePort.onChange = onlyOnePortChange;

setDefaultValues();

// functions

/**
 * creates the output-port array
 */
function createOutPorts()
{
    let arr = [];
    for (let i = 0; i < NUM_PORTS; i++)
    {
        let port = op.outNumber("Index " + i + " Value");
        arr.push(port);
    }
    return arr;
}

/**
 * Sets all value ports to the default value
 */
function setDefaultValues()
{
    const defaultValue = defaultValuePort.get();
    valuePorts.forEach((valuePort) =>
    {
        valuePort.set(defaultValue);
    });
}

/**
 * Update
 */
function update()
{
    let index = indexPort.get();
    index = Math.round(index);
    index = clamp(index, 0, NUM_PORTS - 1);

    if (onlyOnePort.get() && lastIdx !== null && lastIdx != index)
    {
        valuePorts[lastIdx].set(defaultValuePort.get());
    }

    const value = valuePort.get();
    valuePorts[index].set(value);

    lastIdx = index;
}

/**
 * Returns a number whose value is limited to the given range.
 */
function clamp(value, min, max)
{
    return Math.min(Math.max(value, min), max);
}

/**
 * Reset all ports to default value and set current index
 * or let have several ports with old value
 */
function onlyOnePortChange()
{
    if (onlyOnePort.get())
    {
        setDefaultValues();
        update();
    }
}


};

Ops.Value.RouteNumber.prototype = new CABLES.Op();
CABLES.OPS["e3b1fc2d-a813-4d9b-8cb0-595fc95af4e2"]={f:Ops.Value.RouteNumber,objName:"Ops.Value.RouteNumber"};




// **************************************************************
// 
// Ops.Value.SwitchFile_v2
// 
// **************************************************************

Ops.Value.SwitchFile_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let idx = op.inValueInt("Index");
let valuePorts = [];
let result = op.outString("Result");

idx.onChange = update;

for (let i = 0; i < 10; i++)
{
    let p = op.inUrl("File " + i);
    valuePorts.push(p);
    p.onChange = update;
}

function update()
{
    const index = idx.get();
    if (index >= 0 && valuePorts[index])
    {
        result.set(valuePorts[index].get());
    }
}


};

Ops.Value.SwitchFile_v2.prototype = new CABLES.Op();
CABLES.OPS["250c8d79-2b83-419f-8c23-910d95936f2c"]={f:Ops.Value.SwitchFile_v2,objName:"Ops.Value.SwitchFile_v2"};




// **************************************************************
// 
// Ops.Value.SwitchNumber
// 
// **************************************************************

Ops.Value.SwitchNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const idx = op.inValueInt("Index");
const valuePorts = [];
const result = op.outNumber("Result");

idx.onChange = update;

for (let i = 0; i < 16; i++)
{
    let p = op.inValue("Value " + i);
    valuePorts.push(p);
    p.onChange = update;
}

function update()
{
    if (idx.get() >= 0 && valuePorts[idx.get()])
    {
        result.set(valuePorts[idx.get()].get());
    }
}


};

Ops.Value.SwitchNumber.prototype = new CABLES.Op();
CABLES.OPS["fbb89f72-f2e3-4d34-ad01-7d884a1bcdc0"]={f:Ops.Value.SwitchNumber,objName:"Ops.Value.SwitchNumber"};




// **************************************************************
// 
// Ops.Value.SwitchNumberOnTrigger
// 
// **************************************************************

Ops.Value.SwitchNumberOnTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    currentVal = op.outNumber("Value"),
    oldVal = op.outNumber("Last Value"),
    triggered = op.outTrigger("Triggered");

let triggers = [];
let inVals = [];
let inExes = [];

function onTrigger()
{
    oldVal.set(currentVal.get());
    currentVal.set(inVals[this.slot].get());
    triggered.trigger();
}

let num = 8;
for (let i = 0; i < num; i++)
{
    let newExe = op.addInPort(new CABLES.Port(op, "Trigger " + i, CABLES.OP_PORT_TYPE_FUNCTION));
    newExe.slot = i;
    newExe.onTriggered = onTrigger.bind(newExe);
    let newVal = op.addInPort(new CABLES.Port(op, "Value " + i, CABLES.OP_PORT_TYPE_VALUE));
    inVals.push(newVal);
}

let defaultVal = op.inValueString("Default Value");

currentVal.set(defaultVal.get());
oldVal.set(defaultVal.get());

defaultVal.onChange = function ()
{
    oldVal.set(currentVal.get());
    currentVal.set(defaultVal.get());
};


};

Ops.Value.SwitchNumberOnTrigger.prototype = new CABLES.Op();
CABLES.OPS["338032c5-bf47-454b-8ae1-cd91f17e5c5b"]={f:Ops.Value.SwitchNumberOnTrigger,objName:"Ops.Value.SwitchNumberOnTrigger"};




// **************************************************************
// 
// Ops.Value.ToggleNumber
// 
// **************************************************************

Ops.Value.ToggleNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    useValue1Port = op.inValueBool("Use Value 1", false),
    value0port = op.inValue("Value 0", 0),
    value1port = op.inValue("Value 1", 1),
    outValuePort = op.outNumber("Out Value", 0);

value0port.onChange =
    value1port.onChange =
    useValue1Port.onChange = setOutput;

function setOutput()
{
    const useValue1 = useValue1Port.get();
    if (useValue1)
    {
        outValuePort.set(value1port.get());
    }
    else
    {
        outValuePort.set(value0port.get());
    }
}


};

Ops.Value.ToggleNumber.prototype = new CABLES.Op();
CABLES.OPS["400eea7d-5a68-4dda-a94d-2bb2ee7c2331"]={f:Ops.Value.ToggleNumber,objName:"Ops.Value.ToggleNumber"};




// **************************************************************
// 
// Ops.Value.Trigger3Numbers
// 
// **************************************************************

Ops.Value.Trigger3Numbers = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    x = op.inValueFloat("value x"),
    y = op.inValueFloat("value y"),
    z = op.inValueFloat("value z"),
    resultX = op.outNumber("result x"),
    resultY = op.outNumber("result y"),
    resultZ = op.outNumber("result z");

exe.onTriggered =
    x.onChange =
    y.onChange =
    z.onChange = exec;

function frame(time)
{
    exec();
}

function exec()
{
    if (resultX.get() != x.get()) resultX.set(x.get());
    if (resultY.get() != y.get()) resultY.set(y.get());
    if (resultZ.get() != z.get()) resultZ.set(z.get());
}


};

Ops.Value.Trigger3Numbers.prototype = new CABLES.Op();
CABLES.OPS["d56326a2-6351-4261-898a-635ca0636dd0"]={f:Ops.Value.Trigger3Numbers,objName:"Ops.Value.Trigger3Numbers"};




// **************************************************************
// 
// Ops.Value.TriggerOnChangeNumber
// 
// **************************************************************

Ops.Value.TriggerOnChangeNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inval = op.inFloat("Value"),
    next = op.outTrigger("Next"),
    number = op.outNumber("Number");

inval.onChange = function ()
{
    number.set(inval.get());
    next.trigger();
};


};

Ops.Value.TriggerOnChangeNumber.prototype = new CABLES.Op();
CABLES.OPS["f5c8c433-ce13-49c4-9a33-74e98f110ed0"]={f:Ops.Value.TriggerOnChangeNumber,objName:"Ops.Value.TriggerOnChangeNumber"};




// **************************************************************
// 
// Ops.Value.TypeOf_v2
// 
// **************************************************************

Ops.Value.TypeOf_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const input = op.inValue("input");
const result = op.outString("result");

input.onChange = update;

function update()
{
    result.set(typeof (input.get()));
}


};

Ops.Value.TypeOf_v2.prototype = new CABLES.Op();
CABLES.OPS["50fd0008-7bcb-4ab3-8a8c-82fc55a3e7a9"]={f:Ops.Value.TypeOf_v2,objName:"Ops.Value.TypeOf_v2"};




// **************************************************************
// 
// Ops.Value.Value2d
// 
// **************************************************************

Ops.Value.Value2d = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    exe = op.inTrigger("exe"),
    x = op.inValueFloat("value x"),
    y = op.inValueFloat("value y"),
    resultX = op.outNumber("result x"),
    resultY = op.outNumber("result y");

exe.onTriggered = exec;

x.onChange = exec;
y.onChange = exec;

function frame(time)
{
    updateAnims();
    exec();
}

function exec()
{
    if (resultX.get() != x.get()) resultX.set(x.get());
    if (resultY.get() != y.get()) resultY.set(y.get());
}


};

Ops.Value.Value2d.prototype = new CABLES.Op();
CABLES.OPS["ef4fa87b-a075-4f29-9628-b4f26ce41533"]={f:Ops.Value.Value2d,objName:"Ops.Value.Value2d"};




// **************************************************************
// 
// Ops.Value.ValueChangeCounter
// 
// **************************************************************

Ops.Value.ValueChangeCounter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inVal = op.inValue("Value"),
    inReset = op.inTriggerButton("Reset"),
    outResult = op.outNumber("Result");

let count = 0;

inReset.onTriggered = function ()
{
    count = 0;
};

inVal.onChange = function ()
{
    count++;
    outResult.set(count);
};


};

Ops.Value.ValueChangeCounter.prototype = new CABLES.Op();
CABLES.OPS["cbd50d32-bfc1-45c8-ba02-a6afa1fdd0e1"]={f:Ops.Value.ValueChangeCounter,objName:"Ops.Value.ValueChangeCounter"};




// **************************************************************
// 
// Ops.Value.ValueChangedTrigger
// 
// **************************************************************

Ops.Value.ValueChangedTrigger = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inFloat("Value", 0),
    exe = op.inTrigger("Execute"),
    trigger = op.outTrigger("trigger");

let changed = false;

exe.onTriggered = function ()
{
    if (changed)
    {
        changed = false;
        trigger.trigger();
    }
};

val.onChange = function ()
{
    changed = true;
};


};

Ops.Value.ValueChangedTrigger.prototype = new CABLES.Op();
CABLES.OPS["9f353fcc-da0b-4af8-ae5c-4edd256fc9e3"]={f:Ops.Value.ValueChangedTrigger,objName:"Ops.Value.ValueChangedTrigger"};




// **************************************************************
// 
// Ops.Values.FreezeArray
// 
// **************************************************************

Ops.Values.FreezeArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inArray("Number"),
    inFreeze = op.inTriggerButton("Button"),
    inHidden = op.inString("storedJson"),
    outArr = op.outArray("Frozen Array");

inFreeze.onTriggered =
inHidden.onTriggered = update;

inHidden.setUiAttribs({ "hideParam": true, "hidePort": true, "ignoreBigPort": true });

function update()
{
    inHidden.set(JSON.stringify(inStr.get()));
}

outArr.onLinkChanged = () =>
{
    outArr.set(JSON.parse(inHidden.get()));
};

inHidden.onChange = () =>
{
    outArr.set(null);
    try
    {
        outArr.set(JSON.parse(inHidden.get()));
    }
    catch (e) {}
};


};

Ops.Values.FreezeArray.prototype = new CABLES.Op();
CABLES.OPS["340fb9e2-27ab-47f0-b3cc-2ef001f485c5"]={f:Ops.Values.FreezeArray,objName:"Ops.Values.FreezeArray"};




// **************************************************************
// 
// Ops.Values.FreezeNumber
// 
// **************************************************************

Ops.Values.FreezeNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inFloat("Number", 0),
    inFreeze = op.inTriggerButton("Button"),
    inHidden = op.inFloat("StoredNumber"),
    outNum = op.outNumber("Frozen Number");

inFreeze.onTriggered =
inHidden.onTriggered = update;

inHidden.setUiAttribs({ "hideParam": true, "hidePort": true });

outNum.onLinkChanged = () =>
{
    outNum.set(inHidden.get());
};

function update()
{
    inHidden.set(inStr.get());
    outNum.set(inHidden.get());
}


};

Ops.Values.FreezeNumber.prototype = new CABLES.Op();
CABLES.OPS["97dea923-f00f-44cf-bef9-808a2556105b"]={f:Ops.Values.FreezeNumber,objName:"Ops.Values.FreezeNumber"};




// **************************************************************
// 
// Ops.Values.FreezeString
// 
// **************************************************************

Ops.Values.FreezeString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inStr = op.inString("String", "default"),
    inFreeze = op.inTriggerButton("Button"),
    inHidden = op.inString("StoredString"),
    outString = op.outString("Frozen String");

inFreeze.onTriggered =
inHidden.onTriggered = update;

inHidden.setUiAttribs({ "hideParam": true, "hidePort": true, "ignoreBigPort": true });

outString.onLinkChanged = () =>
{
    outString.set(inHidden.get());
};

function update()
{
    inHidden.set(inStr.get());
    outString.set(inHidden.get());
}


};

Ops.Values.FreezeString.prototype = new CABLES.Op();
CABLES.OPS["9ae2598f-8b5a-4749-aff3-a507c9957225"]={f:Ops.Values.FreezeString,objName:"Ops.Values.FreezeString"};




// **************************************************************
// 
// Ops.Values.SequenceNumbers
// 
// **************************************************************

Ops.Values.SequenceNumbers = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

const outputs=[];
const inputs=[];

for(let i=0;i<16;i++)
{
    const inp=op.inFloat("Number "+i,0);
    const out=op.outNumber("Output "+i);

    inp.changeAlways=true;

    outputs.push(out);
    inputs.push(inp);
};


for(let i=0;i<inputs.length;i++)
{
    const inp=inputs[i];
    inp.onChange=function()
    {
        for(let j=0;j<outputs.length;j++) outputs[j].set(inp.get());
    }

}


};

Ops.Values.SequenceNumbers.prototype = new CABLES.Op();
CABLES.OPS["98e8a6cf-1f2f-4cb8-9e33-e5189e3d70ce"]={f:Ops.Values.SequenceNumbers,objName:"Ops.Values.SequenceNumbers"};




// **************************************************************
// 
// Ops.Values.SequenceObjects
// 
// **************************************************************

Ops.Values.SequenceObjects = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const outputs = [];
const inputs = [];

for (let i = 0; i < 16; i++)
{
    const inp = op.inObject("Number " + i, 0);
    const out = op.outObject("Output " + i);

    inp.changeAlways = true;

    outputs.push(out);
    inputs.push(inp);
}


for (let i = 0; i < inputs.length; i++)
{
    const inp = inputs[i];
    inp.onChange = function ()
    {
        for (let j = 0; j < outputs.length; j++) outputs[j].set(inp.get());
    };
}


};

Ops.Values.SequenceObjects.prototype = new CABLES.Op();
CABLES.OPS["2ce0a537-cd45-4199-93f7-02a9379e00f2"]={f:Ops.Values.SequenceObjects,objName:"Ops.Values.SequenceObjects"};




// **************************************************************
// 
// Ops.Values.SequenceStrings
// 
// **************************************************************

Ops.Values.SequenceStrings = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const outputs = [];
const inputs = [];

for (let i = 0; i < 16; i++)
{
    const inp = op.inString("String " + i, 0);
    const out = op.outString("Output " + i);

    inp.changeAlways = true;

    outputs.push(out);
    inputs.push(inp);
}


for (let i = 0; i < inputs.length; i++)
{
    const inp = inputs[i];
    inp.onChange = function ()
    {
        for (let j = 0; j < outputs.length; j++) outputs[j].set(inp.get());
    };
}


};

Ops.Values.SequenceStrings.prototype = new CABLES.Op();
CABLES.OPS["ee0459bd-3dc1-4b32-b6c1-01f98d06eebd"]={f:Ops.Values.SequenceStrings,objName:"Ops.Values.SequenceStrings"};




// **************************************************************
// 
// Ops.Vars.VarGetArray_v2
// 
// **************************************************************

Ops.Vars.VarGetArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val = op.outArray("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "array", op.varName, val);


};

Ops.Vars.VarGetArray_v2.prototype = new CABLES.Op();
CABLES.OPS["afa79294-aa9c-43bc-a49a-cade000a1de5"]={f:Ops.Vars.VarGetArray_v2,objName:"Ops.Vars.VarGetArray_v2"};




// **************************************************************
// 
// Ops.Vars.VarGetNumber_v2
// 
// **************************************************************

Ops.Vars.VarGetNumber_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val = op.outNumber("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "number", op.varName, val);


};

Ops.Vars.VarGetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["421f5b52-c0fa-47c4-8b7a-012b9e1c864a"]={f:Ops.Vars.VarGetNumber_v2,objName:"Ops.Vars.VarGetNumber_v2"};




// **************************************************************
// 
// Ops.Vars.VarGetObject_v2
// 
// **************************************************************

Ops.Vars.VarGetObject_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val = op.outObject("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "object", op.varName, val);


};

Ops.Vars.VarGetObject_v2.prototype = new CABLES.Op();
CABLES.OPS["321419d9-69c7-4310-a327-93d310bc2b8e"]={f:Ops.Vars.VarGetObject_v2,objName:"Ops.Vars.VarGetObject_v2"};




// **************************************************************
// 
// Ops.Vars.VarGetString
// 
// **************************************************************

Ops.Vars.VarGetString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
var val=op.outString("Value");
op.varName=op.inValueSelect("Variable",[],"",true);

new CABLES.VarGetOpWrapper(op,"string",op.varName,val);


};

Ops.Vars.VarGetString.prototype = new CABLES.Op();
CABLES.OPS["3ad08cfc-bce6-4175-9746-fef2817a3b12"]={f:Ops.Vars.VarGetString,objName:"Ops.Vars.VarGetString"};




// **************************************************************
// 
// Ops.Vars.VarGetTexture_v2
// 
// **************************************************************

Ops.Vars.VarGetTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val = op.outTexture("Value");
op.varName = op.inValueSelect("Variable", [], "", true);

new CABLES.VarGetOpWrapper(op, "object", op.varName, val);


};

Ops.Vars.VarGetTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["5f8ce5fc-9787-45c9-9a83-0eebd2c6de15"]={f:Ops.Vars.VarGetTexture_v2,objName:"Ops.Vars.VarGetTexture_v2"};




// **************************************************************
// 
// Ops.Vars.VarSetArray_v2
// 
// **************************************************************

Ops.Vars.VarSetArray_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val = op.inArray("Value", null);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "array", val, op.varName);


};

Ops.Vars.VarSetArray_v2.prototype = new CABLES.Op();
CABLES.OPS["8088290f-45d4-4312-b4ca-184d34ca4667"]={f:Ops.Vars.VarSetArray_v2,objName:"Ops.Vars.VarSetArray_v2"};




// **************************************************************
// 
// Ops.Vars.VarSetNumber_v2
// 
// **************************************************************

Ops.Vars.VarSetNumber_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val = op.inValueFloat("Value", 0);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "number", val, op.varName);


};

Ops.Vars.VarSetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["b5249226-6095-4828-8a1c-080654e192fa"]={f:Ops.Vars.VarSetNumber_v2,objName:"Ops.Vars.VarSetNumber_v2"};




// **************************************************************
// 
// Ops.Vars.VarSetObject_v2
// 
// **************************************************************

Ops.Vars.VarSetObject_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val = op.inObject("Value", null);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "object", val, op.varName);


};

Ops.Vars.VarSetObject_v2.prototype = new CABLES.Op();
CABLES.OPS["c7608375-5b45-4bca-87ef-d0c5e970779a"]={f:Ops.Vars.VarSetObject_v2,objName:"Ops.Vars.VarSetObject_v2"};




// **************************************************************
// 
// Ops.Vars.VarSetString_v2
// 
// **************************************************************

Ops.Vars.VarSetString_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val=op.inString("Value","New String");
op.varName=op.inDropDown("Variable",[],"",true);

new CABLES.VarSetOpWrapper(op,"string",val,op.varName);




};

Ops.Vars.VarSetString_v2.prototype = new CABLES.Op();
CABLES.OPS["0b4d9229-8024-4a30-9cc0-f6653942c2e4"]={f:Ops.Vars.VarSetString_v2,objName:"Ops.Vars.VarSetString_v2"};




// **************************************************************
// 
// Ops.Vars.VarSetTexture_v2
// 
// **************************************************************

Ops.Vars.VarSetTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const val = op.inTexture("Value", null);
op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "object", val, op.varName);


};

Ops.Vars.VarSetTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["4fbfc71e-1429-439f-8591-ad35961252ed"]={f:Ops.Vars.VarSetTexture_v2,objName:"Ops.Vars.VarSetTexture_v2"};




// **************************************************************
// 
// Ops.Vars.VarTriggerArray
// 
// **************************************************************

Ops.Vars.VarTriggerArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inArray("Value", null),
    trigger = op.inTriggerButton("Trigger"),
    next = op.outTrigger("Next");

op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "array", val, op.varName, trigger, next);


};

Ops.Vars.VarTriggerArray.prototype = new CABLES.Op();
CABLES.OPS["9fd759cf-6fcc-487e-9dd9-9c9ab6143683"]={f:Ops.Vars.VarTriggerArray,objName:"Ops.Vars.VarTriggerArray"};




// **************************************************************
// 
// Ops.Vars.VarTriggerNumber
// 
// **************************************************************

Ops.Vars.VarTriggerNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    trigger = op.inTriggerButton("Trigger"),
    val = op.inValueFloat("Value", 0),
    next = op.outTrigger("Next");

op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "number", val, op.varName, trigger, next);


};

Ops.Vars.VarTriggerNumber.prototype = new CABLES.Op();
CABLES.OPS["2c29baf0-2af2-486d-9218-4299594ee9c1"]={f:Ops.Vars.VarTriggerNumber,objName:"Ops.Vars.VarTriggerNumber"};




// **************************************************************
// 
// Ops.Vars.VarTriggerObject
// 
// **************************************************************

Ops.Vars.VarTriggerObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    val = op.inObject("Value", null),
    trigger = op.inTriggerButton("Trigger"),
    next = op.outTrigger("Next");

op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "object", val, op.varName, trigger, next);


};

Ops.Vars.VarTriggerObject.prototype = new CABLES.Op();
CABLES.OPS["93939bed-e43c-48e1-aa45-0a73534bd5d6"]={f:Ops.Vars.VarTriggerObject,objName:"Ops.Vars.VarTriggerObject"};




// **************************************************************
// 
// Ops.Vars.VarTriggerString
// 
// **************************************************************

Ops.Vars.VarTriggerString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    trigger = op.inTriggerButton("Trigger"),
    val = op.inString("Value", "New String"),
    next = op.outTrigger("Next");

op.varName = op.inDropDown("Variable", [], "", true);

new CABLES.VarSetOpWrapper(op, "string", val, op.varName, trigger, next);


};

Ops.Vars.VarTriggerString.prototype = new CABLES.Op();
CABLES.OPS["d75992b7-65e2-44d8-b264-320d4c5a5630"]={f:Ops.Vars.VarTriggerString,objName:"Ops.Vars.VarTriggerString"};




// **************************************************************
// 
// Ops.Vars.VariablesAsObject
// 
// **************************************************************

Ops.Vars.VariablesAsObject = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

const
    exec=op.inTriggerButton("Execute"),
    prefix=op.inString("Filter Prefix",""),
    result=op.outObject("Result");

exec.onTriggered=update;

function update()
{
    var r={};
    const vars=op.patch.getVars();
    const pre=prefix.get();
    for(let i in vars)
    {
        if(i.indexOf(pre)===0 && typeof (vars[i].getValue()) !="object" )
        {
            const newName=i.substr(pre.length);
            r[newName]=vars[i].getValue();
        }
    }

    result.set(null);
    result.set(r);
}


};

Ops.Vars.VariablesAsObject.prototype = new CABLES.Op();
CABLES.OPS["b8726368-9628-42e1-8d98-d88469c1c475"]={f:Ops.Vars.VariablesAsObject,objName:"Ops.Vars.VariablesAsObject"};




// **************************************************************
// 
// Ops.WebAudio.AnalyzerTexture_v2
// 
// **************************************************************

Ops.WebAudio.AnalyzerTexture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"default_frag":"IN vec2 texCoord;\n\nUNI sampler2D texFFT;\nUNI float width;\n\nvoid main()\n{\n   outColor = texture(texFFT, texCoord);\n}","mirror_frag":"IN vec2 texCoord;\n\nUNI sampler2D tex;\nUNI float width;\n\nvoid main()\n{\n   vec4 col = vec4(1.0, 0.0, 0.0, 1.0);\n\n   float x = texCoord.x;\n\n   if (texCoord.x >= 0.5) x = 1.0 - texCoord.x;\n\n    x *= (1. - width) * 2.0;\n\n   col = texture(tex, vec2(x, texCoord.y));\n\n   outColor = col;\n}",};
const cgl = op.patch.cgl;

const inRefresh = op.inTrigger("Refresh");
const inFFTArray = op.inArray("FFT Array");

const inMirrorActive = op.inBool("Mirror Active", false);
const inMirrorWidth = op.inFloatSlider("Mirror Width", 0.5);

const inTextureSize = op.inSwitch("Texture Size", [64, 128, 256, 512, 1024, 2048], 512);

op.setPortGroup("Texture Options", [inTextureSize]);
op.setPortGroup("Mirror Options", [inMirrorActive, inMirrorWidth]);

const outTexture = op.outTexture("Texture Out", null, "texture");
const outPosition = op.outNumber("Position");

let updateTextureSize = false;
inTextureSize.onChange = () =>
{
    updateTextureSize = true;
};

inMirrorActive.onChange = () =>
{
    inMirrorWidth.setUiAttribs({ "greyout": !inMirrorActive.get() });
};

const texFFT = new CGL.Texture(cgl,
    {
        "name": "AnalyzerTexture - FFT Texture " + op.id,
        "wrap": CGL.Texture.CLAMP_TO_EDGE,
        "filter": CGL.Texture.FILTER_LINEAR,
    });

const texDefault = new CGL.Texture(cgl,
    {
        "name": "AnalyzerTexture - Render Texture " + op.id,
        "wrap": CGL.Texture.CLAMP_TO_EDGE,
        "filter": CGL.Texture.FILTER_LINEAR,
        "width": Number(inTextureSize.get()),
        "height": Number(inTextureSize.get()),
    });

let data = [];

let line = 0;
let height = 256;

let buffer = new Uint8Array();

function updateFFT()
{
    const arr = inFFTArray.get();
    if (!arr) return;

    const width = arr.length;
    // height = width;
    if (!width) return;

    if (data.length === 0 || data.length !== width * 4)
    {
        data.length = width * 4;
        buffer = new Uint8Array(width * height * 4);
    }

    line++;

    if (line >= height) line = 0;

    outPosition.set(line / height);

    for (let i = 0; i < width; i++)
    {
        data[i * 4 + 0] = arr[i];
        data[i * 4 + 1] = arr[i];
        data[i * 4 + 2] = arr[i];
        data[i * 4 + 3] = 255;
    }

    buffer.set(data, line * width * 4);

    if (texFFT.width != width || texFFT.height != height)
    {
        texFFT.setSize(
            width, height
        );
        // effect.setSourceTexture(texFFT);
    }

    texFFT.initFromData(
        buffer,
        width, height,
        // Number(inTextureSize.get()),
        // Number(inTextureSize.get()),
        CGL.Texture.FILTER_LINEAR,
        CGL.Texture.WRAP_CLAMP_TO_EDGE
    );
}

let effect = new CGL.TextureEffect(cgl,
    {
        // "isFloatingPointTexture": true,
        "filter": CGL.Texture.FILTER_LINEAR,
        "wrap": CGL.Texture.WRAP_CLAMP_TO_EDGE,
        "width": Number(inTextureSize.get()),
        "height": Number(inTextureSize.get()),
    }
);

let prevViewPort = [0, 0, 0, 0];

// ------------------

const shaderDefault = new CGL.Shader(cgl, "AnalyzerTexture - defaultShader");
shaderDefault.setSource(shaderDefault.getDefaultVertexShader(), attachments.default_frag);
const texUniformDefault = new CGL.Uniform(shaderDefault, "t", "texFFT", 1);

const shaderMirror = new CGL.Shader(cgl, "AnalyzerTexture mirror");

shaderMirror.setSource(shaderMirror.getDefaultVertexShader(), attachments.mirror_frag);

const textureUniformMirror = new CGL.Uniform(shaderMirror, "t", "tex", 0);
const uniWidthMirror = new CGL.Uniform(shaderMirror, "f", "width", inMirrorWidth);

function mirrorTexture()
{
    cgl.pushShader(shaderMirror);

    effect.startEffect();
    effect.setSourceTexture(effect.getCurrentSourceTexture());

    effect.bind();

    cgl.setTexture(0, texFFT.tex);

    effect.finish();
    effect.endEffect();

    cgl.popShader();
}

inRefresh.onTriggered = () =>
{
    if (!inFFTArray.get()) return;

    updateFFT();

    if (updateTextureSize)
    {
        texDefault.setSize(
            Number(inTextureSize.get()),
            Number(inTextureSize.get()),
        );

        effect.setSourceTexture(texDefault);
        updateTextureSize = false;
    }

    if (texFFT)
    {
        cgl.pushShader(shaderDefault);
        effect.startEffect();
        effect.setSourceTexture(texDefault);
        effect.bind();

        cgl.setTexture(1, texFFT.tex);

        effect.finish();
        effect.endEffect();

        cgl.popShader();
    }

    if (inMirrorActive.get()) mirrorTexture();

    outTexture.set(null);
    outTexture.set(effect.getCurrentSourceTexture());
};


};

Ops.WebAudio.AnalyzerTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["decba955-636b-41c5-bfb8-c2506cbcabd2"]={f:Ops.WebAudio.AnalyzerTexture_v2,objName:"Ops.WebAudio.AnalyzerTexture_v2"};




// **************************************************************
// 
// Ops.WebAudio.AudioAnalyzer_v2
// 
// **************************************************************

Ops.WebAudio.AudioAnalyzer_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
const MAX_DBFS_RANGE_24_BIT = -144;
const MAX_DBFS_RANGE_26_BIT = -96;

let audioCtx = CABLES.WEBAUDIO.createAudioContext(op);

const inTrigger = op.inTrigger("Trigger In");

const analyser = audioCtx.createAnalyser();
analyser.smoothingTimeConstant = 0.3;
analyser.fftSize = 256;

const FFT_BUFFER_SIZES = [32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768];

const audioIn = op.inObject("Audio In", null, "audioNode");
const inFFTSize = op.inDropDown("FFT size", FFT_BUFFER_SIZES, 256);
const inSmoothing = op.inFloatSlider("Smoothing", 0.3);

const inRangeMin = op.inFloat("Min", -90);
const inRangeMax = op.inFloat("Max", 0);

op.setPortGroup("Inputs", [inTrigger, audioIn]);
op.setPortGroup("FFT Options", [inFFTSize, inSmoothing]);
op.setPortGroup("Range (in dBFS)", [inRangeMin, inRangeMax]);
const outTrigger = op.outTrigger("Trigger Out");
const audioOut = op.outObject("Audio Out", null, "audioNode");
const fftOut = op.outArray("FFT Array");
const ampOut = op.outArray("Waveform Array");
const frequencyOut = op.outArray("Frequencies by Index Array");
const fftLength = op.outNumber("Array Length");
const avgVolumePeak = op.outNumber("Average Volume");
const avgVolumeAmp = op.outNumber("Average Volume Time-Domain");
const avgVolumeRMS = op.outNumber("RMS Volume");
let updating = false;

let fftBufferLength = analyser.frequencyBinCount;
let fftDataArray = new Uint8Array(fftBufferLength);
let ampDataArray = new Uint8Array(fftBufferLength);
let frequencyArray = [];
frequencyArray.length = fftBufferLength;
let oldAudioIn = null;

audioIn.onChange = () =>
{
    if (audioIn.get())
    {
        const audioNode = audioIn.get();
        if (audioNode.connect)
        {
            audioNode.connect(analyser);
            audioOut.set(analyser);
        }
    }
    else
    {
        if (oldAudioIn)
        {
            if (oldAudioIn.disconnect) oldAudioIn.disconnect(analyser);
            audioOut.set(null);
        }
    }

    oldAudioIn = audioIn.get();
};

function updateAnalyser()
{
    try
    {
        const fftSize = Number(inFFTSize.get());
        analyser.smoothingTimeConstant = clamp(inSmoothing.get(), 0.0, 1.0);
        analyser.fftSize = fftSize;
        const minDecibels = clamp(inRangeMin.get(), MAX_DBFS_RANGE_24_BIT, -0.0001);
        const maxDecibels = Math.max(inRangeMax.get(), analyser.minDecibels + 0.0001);
        analyser.minDecibels = minDecibels;
        analyser.maxDecibels = maxDecibels;

        if (minDecibels < MAX_DBFS_RANGE_24_BIT)
        {
            op.setUiError("maxDbRangeMin",
                "Your minimum is below the lowest possible dBFS value: "
                + MAX_DBFS_RANGE_24_BIT
                + "dBFS. To make sure your analyser data is correct, try increasing the minimum.",
                1
            );
        }
        else
        {
            op.setUiError("maxDbRangeMin", null);
        }

        if (maxDecibels > 0)
        {
            op.setUiError("maxDbRangeMax", "Your maximum is above 0 dBFS. As digital signals only go to 0 dBFS and not above, you should use 0 as your maximum.", 1);
        }
        else
        {
            op.setUiError("maxDbRangeMax", null);
        }

        if (FFT_BUFFER_SIZES.indexOf(fftSize) >= 6)
        {
            op.setUiError("highFftSize", "Please be careful with high FFT sizes as they can slow down rendering. Check the profiler to see if performance is impacted.", 1);
        }
        else
        {
            op.setUiError("highFftSize", null);
        }
    }
    catch (e)
    {
        op.log(e);
    }
}

inFFTSize.onChange = inSmoothing.onChange
= inRangeMin.onChange = inRangeMax.onChange = () =>
    {
        if (inTrigger.isLinked()) updating = true;
        else updateAnalyser();
    };

inTrigger.onTriggered = function ()
{
    if (updating)
    {
        updateAnalyser();
        updating = false;
    }

    if (fftBufferLength != analyser.frequencyBinCount)
    {
        fftBufferLength = analyser.frequencyBinCount;
        fftDataArray = new Uint8Array(fftBufferLength);
        ampDataArray = new Uint8Array(fftBufferLength);

        frequencyArray = [];
        frequencyArray.length = fftBufferLength;

        for (let index = 0; index < fftBufferLength; index += 1)
        {
            frequencyArray[index] = Math.round(index * audioCtx.sampleRate / (analyser.fftSize * 2));
        }

        frequencyOut.set(null);
        frequencyOut.set(frequencyArray);
    }

    if (!fftDataArray) return;
    if (!ampDataArray) return;

    const fftSize = Number(inFFTSize.get());

    try
    {
        analyser.getByteFrequencyData(fftDataArray);
        analyser.getByteTimeDomainData(ampDataArray);

        let values = 0;
        let peakValues = 0;
        let ampPeakValues = 0;
        for (let i = 0; i < analyser.frequencyBinCount; i++)
        {
            values += ampDataArray[i] * ampDataArray[i];
            peakValues += fftDataArray[i];
            ampPeakValues += ampDataArray[i];
        }

        const peakAverage = peakValues / analyser.frequencyBinCount;
        const peakAmpAverage = ampPeakValues / analyser.frequencyBinCount;

        avgVolumePeak.set(peakAverage / 128);
        avgVolumeAmp.set(peakAmpAverage / 256);

        let rms = Math.sqrt(values / analyser.frequencyBinCount);
        rms = Math.max(rms, rms * inSmoothing.get());
        avgVolumeRMS.set(rms / 256);
    }
    catch (e) { op.log(e); }

    fftOut.set(null);
    fftOut.set(fftDataArray);

    ampOut.set(null);
    ampOut.set(ampDataArray);

    fftLength.set(fftDataArray.length);
    outTrigger.trigger();
};


};

Ops.WebAudio.AudioAnalyzer_v2.prototype = new CABLES.Op();
CABLES.OPS["ff9bf46c-676f-4aa1-95bf-5595a6813ed7"]={f:Ops.WebAudio.AudioAnalyzer_v2,objName:"Ops.WebAudio.AudioAnalyzer_v2"};




// **************************************************************
// 
// Ops.WebAudio.AudioBufferPlayer_v2
// 
// **************************************************************

Ops.WebAudio.AudioBufferPlayer_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// input ports
const audioBufferPort = op.inObject("Audio Buffer", null, "audioBuffer");
const playPort = op.inBool("Start / Stop", false);

const loopPort = op.inBool("Loop", false);
const inResetStart = op.inTriggerButton("Restart");
const offsetPort = op.inFloat("Offset", 0);
const playbackRatePort = op.inFloat("Playback Rate", 1);
const detunePort = op.inFloat("Detune", 0);

op.setPortGroup("Playback Controls", [playPort, loopPort, inResetStart]);
op.setPortGroup("Time Controls", [offsetPort]);
op.setPortGroup("Miscellaneous", [playbackRatePort, detunePort]);

// output ports
const audioOutPort = op.outObject("Audio Out", null, "audioNode");
const outPlaying = op.outBool("Is Playing", false);
const outLoading = op.outBool("Loading", false);

// vars
let source = null;
let isPlaying = false;
let hasEnded = false;
let pausedAt = null;
let startedAt = null;
let isLoading = false;

const audioCtx = CABLES.WEBAUDIO.createAudioContext(op);

const gainNode = audioCtx.createGain();

if (!audioBufferPort.isLinked())
{
    op.setUiError("inputNotConnected", "To be able to play back sound, you need to connect an AudioBuffer to this op.", 0);
}
else
{
    op.setUiError("inputNotConnected", null);
}

audioBufferPort.onLinkChanged = () =>
{
    if (!audioBufferPort.isLinked())
    {
        op.setUiError("inputNotConnected", "To be able to play back sound, you need to connect an AudioBuffer to this op.", 0);
    }
    else
    {
        op.setUiError("inputNotConnected", null);
    }
};

if (!audioOutPort.isLinked())
{
    op.setUiError("outputNotConnected", "To be able to hear sound playing, you need to connect this op to an Output op.", 0);
}
else
{
    op.setUiError("outputNotConnected", null);
}

audioOutPort.onLinkChanged = () =>
{
    if (!audioOutPort.isLinked())
    {
        op.setUiError("outputNotConnected", "To be able to hear sound playing, you need to connect this op to an Output op.", 0);
    }
    else
    {
        op.setUiError("outputNotConnected", null);
    }
};

// change listeners
audioBufferPort.onChange = function ()
{
    if (audioBufferPort.get()) createAudioBufferSource();
    else
    {
        if (isLoading)
        {
            isLoading = false;
            outLoading.set(isLoading);
        }

        if (isPlaying)
        {
            stop(0);
            source.buffer = null;
            source = null;
        }
    }
};

playPort.onChange = function ()
{
    if (!audioBufferPort.get()) return;

    if (!source)
    {
        if (!isLoading) createAudioBufferSource();
    }

    if (playPort.get())
    {
        const startTime = 0;
        start(startTime);
    }
    else
    {
        const stopTime = 0;
        stop(stopTime);
    }
};

loopPort.onChange = function ()
{
    if (source)
    {
        source.loop = !!loopPort.get();
    }
};

detunePort.onChange = setDetune;

function setDetune()
{
    if (!source) return;

    const detune = detunePort.get() || 0;
    if (source.detune)
    {
        source.detune.setValueAtTime(
            detune,
            audioCtx.currentTime
        );
    }
}

playbackRatePort.onChange = setPlaybackRate;

function setPlaybackRate()
{
    if (!source) return;

    const playbackRate = playbackRatePort.get() || 0;
    if (playbackRate >= source.playbackRate.minValue && playbackRate <= source.playbackRate.maxValue)
    {
        source.playbackRate.setValueAtTime(
            playbackRate,
            audioCtx.currentTime
        );
    }
}

let resetTriggered = false;
inResetStart.onTriggered = function ()
{
    if (!source) return;
    if (!audioBufferPort.get()) return;
    else
    {
        if (!(audioBufferPort.get() instanceof AudioBuffer)) return;
    }

    if (playPort.get())
    {
        if (isPlaying)
        {
            resetTriggered = true;
            stop(0);
        }
        else
        {
            start(0);
        }
    }
};

// functions
function createAudioBufferSource(dontStart = false)
{
    if (isLoading) return;
    if (!(audioBufferPort.get() instanceof AudioBuffer)) return;

    isLoading = true;
    outLoading.set(isLoading);

    if (source)
    {
        source.onended = null;

        if (source.buffer)
        {
            stop(0);
            source.disconnect(gainNode);
            source.buffer = null;
        }

        source = null;
    }

    source = audioCtx.createBufferSource();

    const buffer = audioBufferPort.get();

    if (!buffer)
    {
        isLoading = false;
        outLoading.set(isLoading);
        return;
    }

    source.buffer = buffer;
    source.onended = onPlaybackEnded;
    source.loop = loopPort.get();

    source.connect(gainNode);
    setPlaybackRate();
    setDetune();
    audioOutPort.set(gainNode);

    isLoading = false;
    outLoading.set(isLoading);

    if (resetTriggered)
    {
        start(0);
        resetTriggered = false;
        return;
    }

    if (playPort.get() && !dontStart)
    {
        // if (!isPlaying)
        start(0);
    }
}

let timeOuting = false;
let timerId = null;

offsetPort.onChange = () =>
{
    if (offsetPort.get() >= 0) op.setUiError("offsetNegative", null);
    else
    {
        op.setUiError("offsetNegative", "Offset cannot be negative. Setting to 0.", 1);
    }

    if (source)
    {
        if (source.buffer)
        {
            if (offsetPort.get() > source.buffer.duration)
            {
                op.setUiError("offsetTooLong", "Your offset value is higher than the total time of your audio file. Please decrease the duration to be able to hear sound when playing back your buffer.", 1);
            }
            else
            {
                op.setUiError("offsetTooLong", null);
            }
        }
    }
};

function start(time)
{
    try
    {
        if (source)
        {
            let offset = Math.max(0, offsetPort.get());
            source.start(time, offset); // 0 = now

            isPlaying = true;
            hasEnded = false;
            outPlaying.set(true);
        }
        else
        {
            op.log("start() but no src...");
        }
    }
    catch (e)
    {
        op.log("Error on start: ", e.message);
        outPlaying.set(false);

        isPlaying = false;
    }
}

function recreateBuffer()
{
    let dontStart = !loopPort.get();
    createAudioBufferSource(dontStart);
}

function stop(time)
{
    try
    {
        if (source)
        {
            source.stop();
            if (!resetTriggered) recreateBuffer();
        }

        isPlaying = false;
        outPlaying.set(false);
    }
    catch (e)
    {
        op.setUiError(e);
        outPlaying.set(false);
    }
}

function onPlaybackEnded()
{
    if (loopPort.get())
    {
        isPlaying = true;
        hasEnded = false;
    }
    else
    {
        isPlaying = false;
        hasEnded = true;
    }
    outPlaying.set(isPlaying);

    recreateBuffer();
}


};

Ops.WebAudio.AudioBufferPlayer_v2.prototype = new CABLES.Op();
CABLES.OPS["3abd0dbb-eeee-4c65-ae31-b8bc2345e2d5"]={f:Ops.WebAudio.AudioBufferPlayer_v2,objName:"Ops.WebAudio.AudioBufferPlayer_v2"};




// **************************************************************
// 
// Ops.WebAudio.AudioBufferToSplineArray
// 
// **************************************************************

Ops.WebAudio.AudioBufferToSplineArray = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// currently only uses mono, if we want to extract stereo data some changes in extractPeaks are needed

// constants
const SAMPLES_PER_PIXEL_MIN = 100; // might crash when this is too low

function findMinMax(array)
{
    let min = Infinity;
    let max = -Infinity;
    let i = 0;
    let len = array.length;
    let curr;

    for (; i < len; i++)
    {
        curr = array[i];
        if (min > curr)
        {
            min = curr;
        }
        if (max < curr)
        {
            max = curr;
        }
    }

    return {
        "min": min,
        "max": max
    };
}

const cgl = op.patch.cgl;

// input
const renderPort = op.inTrigger("Render");
const audioBufferPort = op.inObject("Audio Buffer", null, "audioBuffer");
const inWidth = op.inFloat("Width", 1);
const inHeight = op.inFloat("Height", 0.5);
const samplesPerPixelPort = op.inInt("Samples Per Pixel", 10000);

op.setPortGroup("Waveform Settings", [inWidth, inHeight, samplesPerPixelPort]);
// output
const nextPort = op.outTrigger("Next");
const outArray = op.outArray("Array Out");

// change listeners
let updating = true;
audioBufferPort.onChange = samplesPerPixelPort.onChange
= inWidth.onChange = inHeight.onChange = () =>
    {
        if (audioBufferPort.get())
        {
            if (!renderPort.isLinked())
            {
                const audioBuffer = audioBufferPort.get();
                if (!(audioBuffer instanceof AudioBuffer)) return;
            }
        }

        updating = true;
    };

renderPort.onTriggered = () =>
{
    if (updating)
    {
        extractPeaks();
        updating = false;
    }
    nextPort.trigger();
};

function extractPeaks()
{
    const audioBuffer = audioBufferPort.get();
    if (audioBuffer)
    {
        op.setUiError("noBuffer", null);

        if (!(audioBuffer instanceof AudioBuffer)) return;
    }
    else
    {
        op.setUiError("noBuffer", "You need to connect the \"Audio Buffer\" input for this op to work!", 0);
    }

    if (audioBuffer)
    {
        let samplesPerPixel = samplesPerPixelPort.get();
        if (samplesPerPixel < SAMPLES_PER_PIXEL_MIN)
        {
            op.setUiError("minSamples", "The value for \"Samples Per Pixel\" is lower than the minimum value " + SAMPLES_PER_PIXEL_MIN + ". Therefore the value has been set to " + SAMPLES_PER_PIXEL_MIN + ".", 1);
            samplesPerPixel = SAMPLES_PER_PIXEL_MIN;
        }
        else
        {
            op.setUiError("minSamples", null);
        }

        let makeMono = audioBuffer.numberOfChannels < 2; // TODO: If we make this a parameter, we have to check if the audio actually is stereo

        const peaks = webaudioPeaks(audioBuffer, samplesPerPixel, makeMono);

        // because we extract mono peaks we just access [0] here
        const typedArr = peaks.data[0];
        const regularArr = Array.prototype.slice.call(typedArr);
        const minMax = findMinMax(regularArr);
        const normalizedArray = [];
        for (let i = 0; i < regularArr.length; i += 1)
        {
            normalizedArray.push(
                CABLES.map(i, 0, regularArr.length - 1, -inWidth.get(), inWidth.get())
            );
            normalizedArray.push(
                CABLES.map(regularArr[i], minMax.min, minMax.max, -inHeight.get(), inHeight.get())
            );
            normalizedArray.push(0);
        }

        outArray.set(null);
        outArray.set(normalizedArray);
    }
    else
    {
        outArray.set(null);
    }
}


};

Ops.WebAudio.AudioBufferToSplineArray.prototype = new CABLES.Op();
CABLES.OPS["0a573407-f1af-4580-ba37-1604108151bd"]={f:Ops.WebAudio.AudioBufferToSplineArray,objName:"Ops.WebAudio.AudioBufferToSplineArray"};




// **************************************************************
// 
// Ops.WebAudio.AudioBuffer_v2
// 
// **************************************************************

Ops.WebAudio.AudioBuffer_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;

const
    audioCtx = CABLES.WEBAUDIO.createAudioContext(op),
    inUrlPort = op.inUrl("URL", "audio"),
    inLoadingTask = op.inBool("Create Loading Task", true),
    audioBufferPort = op.outObject("Audio Buffer", null, "audioBuffer"),
    finishedLoadingPort = op.outBoolNum("Finished Loading", false),
    sampleRatePort = op.outNumber("Sample Rate", 0),
    lengthPort = op.outNumber("Length", 0),
    durationPort = op.outNumber("Duration", 0),
    numberOfChannelsPort = op.outNumber("Number of Channels", 0),
    outLoading = op.outBool("isLoading", 0);

let currentBuffer = null;
let isLoading = false;
let currentFileUrl = null;
let urlToLoadNext = null;
let clearAfterLoad = false;
let fromData = false;
let fromDataNew = false;
let fileReader = new FileReader();
let arrayBuffer = null;
let loadingIdDataURL = 0;

if (!audioBufferPort.isLinked())
{
    op.setUiError("notConnected", "To play back sound, connect this op to a playback operator such as SamplePlayer or AudioBufferPlayer.", 0);
}
else
{
    op.setUiError("notConnected", null);
}

audioBufferPort.onLinkChanged = () =>
{
    if (audioBufferPort.isLinked())
    {
        op.setUiError("notConnected", null);
    }
    else
    {
        op.setUiError("notConnected", "To play back sound, connect this op to a playback operator such as SamplePlayer or AudioBufferPlayer.", 0);
    }
};

function loadAudioFile(url, loadFromData)
{
    currentFileUrl = url;
    isLoading = true;
    outLoading.set(isLoading);

    if (!loadFromData)
    {
        const ext = url.substr(url.lastIndexOf(".") + 1);
        if (ext === "wav")
        {
            op.setUiError("wavFormat", "You are using a .wav file. Make sure the .wav file is 16 bit to be supported by all browsers. Safari does not support 24 bit .wav files.", 1);
        }
        else
        {
            op.setUiError("wavFormat", null);
        }

        CABLES.WEBAUDIO.loadAudioFile(op.patch, url, onLoadFinished, onLoadFailed, inLoadingTask.get());
    }
    else
    {
        let fileBlob = dataURItoBlob(url);

        if (fileBlob.type === "audio/wav")
        {
            op.setUiError("wavFormat", "You are using a .wav file. Make sure the .wav file is 16 bit to be supported by all browsers. Safari does not support 24 bit .wav files.", 1);
        }
        else
        {
            op.setUiError("wavFormat", null);
        }

        if (inLoadingTask.get())
        {
            loadingIdDataURL = cgl.patch.loading.start("audiobuffer from data-url " + op.id, "");
            if (cgl.patch.isEditorMode()) gui.jobs().start({ "id": "loadaudio" + loadingIdDataURL, "title": " loading audio data url (" + op.id + ")" });
        }

        fileReader.readAsArrayBuffer(fileBlob);
    }
}

function dataURItoBlob(dataURI)
{
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    let byteString = atob(dataURI.split(",")[1]);

    // separate out the mime component
    let mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0];

    // write the bytes of the string to an ArrayBuffer
    let ab = new ArrayBuffer(byteString.length);

    // create a view into the buffer
    let ia = new Uint8Array(ab);

    // set the bytes of the buffer to the correct values
    for (let i = 0; i < byteString.length; i++)
    {
        ia[i] = byteString.charCodeAt(i);
    }

    // write the ArrayBuffer to a blob, and you're done
    let blob = new Blob([ab], { "type": mimeString });
    return blob;
}

// change listeners
inUrlPort.onChange = function ()
{
    if (inUrlPort.get())
    {
        fromData = String(inUrlPort.get()).indexOf("data:") == 0;

        if (isLoading)
        {
            fromDataNew = String(inUrlPort.get()).indexOf("data:") == 0;
            const newUrl = fromDataNew ? inUrlPort.get() : op.patch.getFilePath(inUrlPort.get());
            if (newUrl !== currentFileUrl)
            {
                urlToLoadNext = newUrl;
            }
            else
            {
                urlToLoadNext = null;
            }

            clearAfterLoad = false;
            return;
        }

        invalidateOutPorts();
        const url = fromData ? inUrlPort.get() : op.patch.getFilePath(inUrlPort.get());

        loadAudioFile(url, fromData);
    }
    else
    {
        if (isLoading)
        {
            clearAfterLoad = true;
            return;
        }
        invalidateOutPorts();
        op.setUiError("wavFormat", null);
        op.setUiError("failedLoading", null);
    }
};

fileReader.onloadend = () =>
{
    arrayBuffer = fileReader.result;
    cgl.patch.loading.finished(loadingIdDataURL);
    if (cgl.patch.isEditorMode()) gui.jobs().finish("loadaudio" + loadingIdDataURL);
    loadFromDataURL();
};

function loadFromDataURL()
{
    if (arrayBuffer) audioCtx.decodeAudioData(arrayBuffer, onLoadFinished, onLoadFailed);
}

function onLoadFinished(buffer)
{
    isLoading = false;
    outLoading.set(isLoading);

    if (clearAfterLoad)
    {
        invalidateOutPorts();
        clearAfterLoad = false;
        return;
    }

    if (urlToLoadNext)
    {
        loadAudioFile(urlToLoadNext, fromDataNew);
        urlToLoadNext = null;
    }
    else
    {
        currentBuffer = buffer;
        lengthPort.set(buffer.length);
        durationPort.set(buffer.duration);
        numberOfChannelsPort.set(buffer.numberOfChannels);
        sampleRatePort.set(buffer.sampleRate);
        audioBufferPort.set(buffer);
        op.setUiError("failedLoading", null);
        finishedLoadingPort.set(true);
        fromData = false;
        fromDataNew = false;
    }
}

function onLoadFailed(e)
{
    op.logError("Error: Loading audio file failed: ", e);
    op.setUiError("failedLoading", "The audio file could not be loaded. Make sure the right file URL is used.", 2);
    isLoading = false;
    invalidateOutPorts();
    outLoading.set(isLoading);
    currentBuffer = null;

    if (urlToLoadNext)
    {
        loadAudioFile(urlToLoadNext, fromDataNew);
        urlToLoadNext = null;
    }
}

function invalidateOutPorts()
{
    lengthPort.set(0);
    durationPort.set(0);
    numberOfChannelsPort.set(0);
    sampleRatePort.set(0);

    audioBufferPort.set(null);

    finishedLoadingPort.set(false);
}


};

Ops.WebAudio.AudioBuffer_v2.prototype = new CABLES.Op();
CABLES.OPS["5f1d6a2f-1c04-4744-b0fb-910825beceee"]={f:Ops.WebAudio.AudioBuffer_v2,objName:"Ops.WebAudio.AudioBuffer_v2"};




// **************************************************************
// 
// Ops.WebAudio.AudioPanner
// 
// **************************************************************

Ops.WebAudio.AudioPanner = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function clamp(val, min, max)
{
    return Math.min(Math.max(val, min), max);
}

const audioIn = op.inObject("audio in", null, "audioNode");
const pan = op.inFloat("Pan", 0);
pan.onChange = updateGain;
const audioOut = op.outObject("audio out", null, "audioNode");

let audioContext = CABLES.WEBAUDIO.createAudioContext(op);

let isIOS = false;
let panNode = null;
if (audioContext.createStereoPanner)
{
    panNode = audioContext.createStereoPanner();
}
else
{
    panNode = audioContext.createPanner();
    panNode.panningModel = "equalpower";
    isIOS = true;
}

function updateGain()
{
    const panning = clamp(pan.get(), -1, 1);

    if (!isIOS) panNode.pan.setValueAtTime(panning, audioContext.currentTime);
    else
    {
        panNode.setPosition(panning, 0, 1 - Math.abs(panning));
    }
}

let oldAudioIn = null;

audioIn.onChange = function ()
{
    if (!audioIn.get())
    {
        if (oldAudioIn)
        {
            try
            {
                if (oldAudioIn.disconnect)
                {
                    oldAudioIn.disconnect(panNode);
                }
            }
            catch (e)
            {
                op.log(e);
            }
        }

        audioOut.set(null);
    }
    else
    {
        if (audioIn.get().connect)
        {
            audioIn.get().connect(panNode);
            audioOut.set(panNode);
        }
    }
    oldAudioIn = audioIn.get();
};


};

Ops.WebAudio.AudioPanner.prototype = new CABLES.Op();
CABLES.OPS["313ebceb-fa16-4400-aa2b-20859614c7c6"]={f:Ops.WebAudio.AudioPanner,objName:"Ops.WebAudio.AudioPanner"};




// **************************************************************
// 
// Ops.WebAudio.AudioRecorder
// 
// **************************************************************

Ops.WebAudio.AudioRecorder = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"inc_mediarecorder_js":"\nclass IOSMediaRecorder {\n  /**\n   * @param {MediaStream} stream The audio stream to record.\n   */\n  constructor (stream, config = null) {\n    /**\n     * The `MediaStream` passed into the constructor.\n     * @type {MediaStream}\n     */\n    this.stream = stream\n    this.config = config\n    /**\n     * The current state of recording process.\n     * @type {\"inactive\"|\"recording\"|\"paused\"}\n     */\n    this.state = 'inactive'\n\n    this.em = document.createDocumentFragment()\n    const blob = new Blob([attachments.waveencoder_js], { \"type\": \"text/javascript\" });\n    const fileURL = URL.createObjectURL(blob);\n    this.blob = blob;\n    this.fileURL = fileURL;\n    this.encoder = new Worker(this.fileURL, { \"name\": \"AudioRecorder Encoder with op-id: \" + op.id });\n    this.encoder.onmessage = e => {\n        let event = new Event('dataavailable');\n\n        event.data = new Blob([e.data], { type: this.mimeType });\n        this.em.dispatchEvent(event);\n\n        // clean up worker after recording\n        this.encoder.terminate();\n        this.encoder = null;\n\n        if (this.state === 'inactive') {\n            this.em.dispatchEvent(new Event('stop'))\n        }\n    };\n\n  }\n\n    error(method) {\n        let event = new Event('error')\n        event.data = new Error('Wrong state for ' + method)\n        return event\n    }\n\n    terminateWorker() {\n        if (this.encoder) {\n            this.encoder.terminate();\n            this.encoder = null;\n        }\n    }\n  /**\n   * Begins recording media.\n   *\n   * @param {number} [timeslice] The milliseconds to record into each `Blob`.\n   *                             If this parameter isn’t included, single `Blob`\n   *                             will be recorded.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * recordButton.addEventListener('click', () => {\n   *   recorder.start()\n   * })\n   */\n  start (timeslice) {\n\n\n    if (!this.encoder) {\n        this.encoder = new Worker(this.fileURL, { \"name\": \"AudioRecorder Encoder with op-id: \" + op.id });\n        this.encoder.onmessage = e => {\n            let event = new Event('dataavailable');\n\n            event.data = new Blob([e.data], { type: this.mimeType });\n            this.em.dispatchEvent(event);\n\n            // clean up worker after recording\n            this.encoder.terminate();\n            this.encoder = null;\n            if (this.state === 'inactive') {\n                this.em.dispatchEvent(new Event('stop'))\n            }\n        };\n    }\n\n    if (this.state !== 'inactive') {\n      return this.em.dispatchEvent(this.error('start'))\n    }\n\n    this.state = 'recording'\n\n\n\n    this.clone = this.stream.clone()\n    this.input = audioCtx.createMediaStreamSource(this.clone)\n\n    this.numberOfChannels = this.input.channelCount;\n\n    this.processor = audioCtx.createScriptProcessor(2048, this.numberOfChannels, this.numberOfChannels);\n\n    this.encoder.postMessage(['init', audioCtx.sampleRate])\n\n    this.processor.onaudioprocess = e => {\n      if (this.state === 'recording') {\n        this.encoder.postMessage([\n            'encode',\n            [\n                [e.inputBuffer.getChannelData(0), e.inputBuffer.getChannelData(1)],\n                this.numberOfChannels\n            ],\n        ]);\n      }\n    }\n\n    this.input.connect(this.processor)\n    this.processor.connect(audioCtx.destination)\n\n    this.em.dispatchEvent(new Event('start'))\n\n    if (timeslice) {\n      this.slicing = setInterval(() => {\n        if (this.state === 'recording') this.requestData()\n      }, timeslice)\n    }\n    return undefined\n  }\n\n  /**\n   * Stop media capture and raise `dataavailable` event with recorded data.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * finishButton.addEventListener('click', () => {\n   *   recorder.stop()\n   * })\n   */\n  stop () {\n    if (this.state === 'inactive') {\n      return this.em.dispatchEvent(this.error('stop'))\n    }\n\n    this.requestData()\n    this.state = 'inactive'\n    this.clone.getTracks().forEach(track => {\n      track.stop()\n    })\n    this.processor.disconnect()\n    this.input.disconnect()\n    return clearInterval(this.slicing)\n  }\n\n  /**\n   * Pauses recording of media streams.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * pauseButton.addEventListener('click', () => {\n   *   recorder.pause()\n   * })\n   */\n  pause () {\n    if (this.state !== 'recording') {\n      return this.em.dispatchEvent(this.error('pause'))\n    }\n\n    this.state = 'paused'\n    return this.em.dispatchEvent(new Event('pause'))\n  }\n\n  /**\n   * Resumes media recording when it has been previously paused.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * resumeButton.addEventListener('click', () => {\n   *   recorder.resume()\n   * })\n   */\n  resume () {\n    if (this.state !== 'paused') {\n      return this.em.dispatchEvent(this.error('resume'))\n    }\n\n    this.state = 'recording'\n    return this.em.dispatchEvent(new Event('resume'))\n  }\n\n  /**\n   * Raise a `dataavailable` event containing the captured media.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * this.on('nextData', () => {\n   *   recorder.requestData()\n   * })\n   */\n  requestData () {\n    if (this.state === 'inactive') {\n      return this.em.dispatchEvent(this.error('requestData'))\n    }\n\n    return this.encoder.postMessage([\n        'dump',\n        [audioCtx.sampleRate, this.numberOfChannels],\n    ]);\n  }\n\n  /**\n   * Add listener for specified event type.\n   *\n   * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"|\"error\"}\n   * type Event type.\n   * @param {function} listener The listener function.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * recorder.addEventListener('dataavailable', e => {\n   *   audio.src = URL.createObjectURL(e.data)\n   * })\n   */\n  addEventListener (...args) {\n    this.em.addEventListener(...args)\n  }\n\n  /**\n   * Remove event listener.\n   *\n   * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"|\"error\"}\n   * type Event type.\n   * @param {function} listener The same function used in `addEventListener`.\n   *\n   * @return {undefined}\n   */\n  removeEventListener (...args) {\n    this.em.removeEventListener(...args)\n  }\n\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {Event} event The event object.\n   *\n   * @return {boolean} Is event was no canceled by any listener.\n   */\n  dispatchEvent (...args) {\n    this.em.dispatchEvent(...args)\n  }\n}\n\n/**\n * The MIME type that is being used for recording.\n * @type {string}\n */\nIOSMediaRecorder.prototype.mimeType = 'audio/wav'\n\n/**\n * Returns `true` if the MIME type specified is one the polyfill can record.\n *\n * This polyfill supports `audio/wav` and `audio/mpeg`.\n *\n * @param {string} mimeType The mimeType to check.\n *\n * @return {boolean} `true` on `audio/wav` and `audio/mpeg` MIME type.\n */\nIOSMediaRecorder.isTypeSupported = mimeType => {\n  return IOSMediaRecorder.prototype.mimeType === mimeType\n}\n\n/**\n * `true` if MediaRecorder can not be polyfilled in the current browser.\n * @type {boolean}\n *\n * @example\n * if (IOSMediaRecorder.notSupported) {\n *   showWarning('Audio recording is not supported in this browser')\n * }\n */\nIOSMediaRecorder.notSupported = !navigator.mediaDevices || !AudioContext\n\n/**\n * Converts RAW audio buffer to compressed audio files.\n * It will be loaded to Web Worker.\n * By default, WAVE encoder will be used.\n * @type {function}\n *\n * @example\n * IOSMediaRecorder.prototype.mimeType = 'audio/ogg'\n * IOSMediaRecorder.encoder = oggEncoder\n */","waveencoder_js":"function clamp(val, min, max)\n{\n    return Math.min(Math.max(val, min), max);\n}\n\nlet BYTES_PER_SAMPLE = 2\n\n  let recorded = []\n\n  function encode ([buffers, numberOfChannels]) {\n    let length = buffers[0].length\n    let data = new Uint8Array(length * numberOfChannels * BYTES_PER_SAMPLE)\n    // Interleave\n    for (let i = 0; i < length; i++ ) {\n\n        for (let channel = 0; channel < numberOfChannels; channel++ ) {\n            const outputIndex = ( i * numberOfChannels + channel ) * BYTES_PER_SAMPLE;\n\n            // clip the signal if it exceeds [-1, 1]\n            let sample = clamp(buffers[channel][i], -1, 1);\n            sample = sample * 32767.5 - 0.5;\n            data[ outputIndex] = sample;\n            data[ outputIndex + 1 ] = sample >> 8;\n        }\n    }\n    recorded.push(data)\n  }\n\n  function dump ([sampleRate, numberOfChannels]) {\n    let bufferLength = recorded.length ? recorded[0].length : 0\n    let length = recorded.length * bufferLength\n    let wav = new Uint8Array(44 + length)\n    let view = new DataView(wav.buffer)\n\n    // RIFF identifier 'RIFF'\n    view.setUint32(0, 1380533830, false)\n    // file length minus RIFF identifier length and file description length\n    view.setUint32(4, 36 + length, true)\n    // RIFF type 'WAVE'\n    view.setUint32(8, 1463899717, false)\n    // format chunk identifier 'fmt '\n    view.setUint32(12, 1718449184, false)\n    // format chunk length\n    view.setUint32(16, 16, true)\n    // sample format (raw)\n    view.setUint16(20, 1, true)\n    // channel count\n    view.setUint16(22, numberOfChannels, true)\n    // sample rate\n    view.setUint32(24, sampleRate, true)\n    // byte rate (sample rate * block align)\n    view.setUint32(28, sampleRate * BYTES_PER_SAMPLE * numberOfChannels, true)\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, BYTES_PER_SAMPLE * numberOfChannels, true)\n    // bits per sample\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true)\n    // data chunk identifier 'data'\n    view.setUint32(36, 1684108385, false)\n    // data chunk length\n    view.setUint32(40, length, true)\n\n    for (let i = 0; i < recorded.length; i++) {\n      wav.set(recorded[i], i * bufferLength + 44)\n    }\n\n    recorded = []\n    postMessage(wav.buffer, [wav.buffer])\n  }\n\n  onmessage = e => {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    } else if (e.data[0] === 'dump') {\n      dump(e.data[1])\n    }\n  }",};

class IOSMediaRecorder {
  /**
   * @param {MediaStream} stream The audio stream to record.
   */
  constructor (stream, config = null) {
    /**
     * The `MediaStream` passed into the constructor.
     * @type {MediaStream}
     */
    this.stream = stream
    this.config = config
    /**
     * The current state of recording process.
     * @type {"inactive"|"recording"|"paused"}
     */
    this.state = 'inactive'

    this.em = document.createDocumentFragment()
    const blob = new Blob([attachments.waveencoder_js], { "type": "text/javascript" });
    const fileURL = URL.createObjectURL(blob);
    this.blob = blob;
    this.fileURL = fileURL;
    this.encoder = new Worker(this.fileURL, { "name": "AudioRecorder Encoder with op-id: " + op.id });
    this.encoder.onmessage = e => {
        let event = new Event('dataavailable');

        event.data = new Blob([e.data], { type: this.mimeType });
        this.em.dispatchEvent(event);

        // clean up worker after recording
        this.encoder.terminate();
        this.encoder = null;

        if (this.state === 'inactive') {
            this.em.dispatchEvent(new Event('stop'))
        }
    };

  }

    error(method) {
        let event = new Event('error')
        event.data = new Error('Wrong state for ' + method)
        return event
    }

    terminateWorker() {
        if (this.encoder) {
            this.encoder.terminate();
            this.encoder = null;
        }
    }
  /**
   * Begins recording media.
   *
   * @param {number} [timeslice] The milliseconds to record into each `Blob`.
   *                             If this parameter isn’t included, single `Blob`
   *                             will be recorded.
   *
   * @return {undefined}
   *
   * @example
   * recordButton.addEventListener('click', () => {
   *   recorder.start()
   * })
   */
  start (timeslice) {


    if (!this.encoder) {
        this.encoder = new Worker(this.fileURL, { "name": "AudioRecorder Encoder with op-id: " + op.id });
        this.encoder.onmessage = e => {
            let event = new Event('dataavailable');

            event.data = new Blob([e.data], { type: this.mimeType });
            this.em.dispatchEvent(event);

            // clean up worker after recording
            this.encoder.terminate();
            this.encoder = null;
            if (this.state === 'inactive') {
                this.em.dispatchEvent(new Event('stop'))
            }
        };
    }

    if (this.state !== 'inactive') {
      return this.em.dispatchEvent(this.error('start'))
    }

    this.state = 'recording'



    this.clone = this.stream.clone()
    this.input = audioCtx.createMediaStreamSource(this.clone)

    this.numberOfChannels = this.input.channelCount;

    this.processor = audioCtx.createScriptProcessor(2048, this.numberOfChannels, this.numberOfChannels);

    this.encoder.postMessage(['init', audioCtx.sampleRate])

    this.processor.onaudioprocess = e => {
      if (this.state === 'recording') {
        this.encoder.postMessage([
            'encode',
            [
                [e.inputBuffer.getChannelData(0), e.inputBuffer.getChannelData(1)],
                this.numberOfChannels
            ],
        ]);
      }
    }

    this.input.connect(this.processor)
    this.processor.connect(audioCtx.destination)

    this.em.dispatchEvent(new Event('start'))

    if (timeslice) {
      this.slicing = setInterval(() => {
        if (this.state === 'recording') this.requestData()
      }, timeslice)
    }
    return undefined
  }

  /**
   * Stop media capture and raise `dataavailable` event with recorded data.
   *
   * @return {undefined}
   *
   * @example
   * finishButton.addEventListener('click', () => {
   *   recorder.stop()
   * })
   */
  stop () {
    if (this.state === 'inactive') {
      return this.em.dispatchEvent(this.error('stop'))
    }

    this.requestData()
    this.state = 'inactive'
    this.clone.getTracks().forEach(track => {
      track.stop()
    })
    this.processor.disconnect()
    this.input.disconnect()
    return clearInterval(this.slicing)
  }

  /**
   * Pauses recording of media streams.
   *
   * @return {undefined}
   *
   * @example
   * pauseButton.addEventListener('click', () => {
   *   recorder.pause()
   * })
   */
  pause () {
    if (this.state !== 'recording') {
      return this.em.dispatchEvent(this.error('pause'))
    }

    this.state = 'paused'
    return this.em.dispatchEvent(new Event('pause'))
  }

  /**
   * Resumes media recording when it has been previously paused.
   *
   * @return {undefined}
   *
   * @example
   * resumeButton.addEventListener('click', () => {
   *   recorder.resume()
   * })
   */
  resume () {
    if (this.state !== 'paused') {
      return this.em.dispatchEvent(this.error('resume'))
    }

    this.state = 'recording'
    return this.em.dispatchEvent(new Event('resume'))
  }

  /**
   * Raise a `dataavailable` event containing the captured media.
   *
   * @return {undefined}
   *
   * @example
   * this.on('nextData', () => {
   *   recorder.requestData()
   * })
   */
  requestData () {
    if (this.state === 'inactive') {
      return this.em.dispatchEvent(this.error('requestData'))
    }

    return this.encoder.postMessage([
        'dump',
        [audioCtx.sampleRate, this.numberOfChannels],
    ]);
  }

  /**
   * Add listener for specified event type.
   *
   * @param {"start"|"stop"|"pause"|"resume"|"dataavailable"|"error"}
   * type Event type.
   * @param {function} listener The listener function.
   *
   * @return {undefined}
   *
   * @example
   * recorder.addEventListener('dataavailable', e => {
   *   audio.src = URL.createObjectURL(e.data)
   * })
   */
  addEventListener (...args) {
    this.em.addEventListener(...args)
  }

  /**
   * Remove event listener.
   *
   * @param {"start"|"stop"|"pause"|"resume"|"dataavailable"|"error"}
   * type Event type.
   * @param {function} listener The same function used in `addEventListener`.
   *
   * @return {undefined}
   */
  removeEventListener (...args) {
    this.em.removeEventListener(...args)
  }

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {Event} event The event object.
   *
   * @return {boolean} Is event was no canceled by any listener.
   */
  dispatchEvent (...args) {
    this.em.dispatchEvent(...args)
  }
}

/**
 * The MIME type that is being used for recording.
 * @type {string}
 */
IOSMediaRecorder.prototype.mimeType = 'audio/wav'

/**
 * Returns `true` if the MIME type specified is one the polyfill can record.
 *
 * This polyfill supports `audio/wav` and `audio/mpeg`.
 *
 * @param {string} mimeType The mimeType to check.
 *
 * @return {boolean} `true` on `audio/wav` and `audio/mpeg` MIME type.
 */
IOSMediaRecorder.isTypeSupported = mimeType => {
  return IOSMediaRecorder.prototype.mimeType === mimeType
}

/**
 * `true` if MediaRecorder can not be polyfilled in the current browser.
 * @type {boolean}
 *
 * @example
 * if (IOSMediaRecorder.notSupported) {
 *   showWarning('Audio recording is not supported in this browser')
 * }
 */
IOSMediaRecorder.notSupported = !navigator.mediaDevices || !AudioContext

/**
 * Converts RAW audio buffer to compressed audio files.
 * It will be loaded to Web Worker.
 * By default, WAVE encoder will be used.
 * @type {function}
 *
 * @example
 * IOSMediaRecorder.prototype.mimeType = 'audio/ogg'
 * IOSMediaRecorder.encoder = oggEncoder
 */// inspired by: https://github.com/kaliatech/web-audio-recording-tests/blob/master/src/shared/RecorderService.js

const audioCtx = CABLES.WEBAUDIO.createAudioContext(op);

const inAudio = op.inObject("Audio In", null, "audioNode");
const inStartRecording = op.inTriggerButton("Start Recording");
const inStopRecording = op.inTriggerButton("Stop Recording");
const inRecordGain = op.inFloatSlider("Input Gain", 1);
op.setPortGroup("Recording", [inStartRecording, inStopRecording, inRecordGain]);

const inStartPlayback = op.inTriggerButton("Start Playback");
const inStopPlayback = op.inTriggerButton("Stop Playback");
const inClearBuffer = op.inTriggerButton("Clear Buffer");
const inPlaybackGain = op.inFloatSlider("Playback Gain", 1);
const inLoop = op.inBool("Loop Playback", false);
op.setPortGroup("Playback", [inStartPlayback, inStopPlayback, inLoop, inClearBuffer, inPlaybackGain]);
const inDownloadButton = op.inTriggerButton("Download .wav File");

const outOriginal = op.outObject("Audio Out", null, "audioNode");
const outRecorded = op.outObject("Recorded Audio Out", null, "audioNode");
const outIsRecording = op.outBool("Is Recording");
const outIsPlayingBack = op.outBool("Is Playing Back");
const outState = op.outString("State");
const outBuffer = op.outObject("AudioBuffer Out", null, "audioBuffer");
const outDataUrl = op.outString("Data URL");

inDownloadButton.setUiAttribs({ "greyout": true });
outDataUrl.ignoreValueSerialize = true;

const inputGain = audioCtx.createGain();
const outputGain = audioCtx.createGain();

let isIOS = !navigator.hasOwnProperty("MediaRecorder");

const STATES = {
    "RECORDING": "recording",
    "PROCESSING": "processing",
    "READY": "ready",
    "PLAYING": "playing",
    "IDLING": "idling"
};

let state = STATES.IDLING;
outState.set(state);

const inputStream = audioCtx.createMediaStreamDestination();

let mediaRecorder = null;
let fileReader = null;
let blob = null;

if (isIOS)
{
    mediaRecorder = new IOSMediaRecorder(inputStream.stream);
    fileReader = new FileReader();
}
else
{
    mediaRecorder = new MediaRecorder(inputStream.stream);
}

mediaRecorder.addEventListener("dataavailable", (e) =>
{
    blob = e.data;
    if (blob)
    {
        inDownloadButton.setUiAttribs({ "greyout": !blob });
        let reader = new FileReader();
        reader.onload = function (e)
        {
            outDataUrl.set(e.target.result);
        };
        reader.readAsDataURL(blob);
    }

    if (!isIOS)
    {
        e.data.arrayBuffer() // its a blob
            .then((buffer) =>
            {
                arrayBuffer = buffer;
                audioCtx.decodeAudioData(arrayBuffer, (buffer) =>
                {
                    audioBuffer = buffer;
                    outBuffer.set(audioBuffer);
                    createAudioBufferSource();
                });
            })
            .catch((e) => op.log(e));
    }
    else
    {
        fileReader.onload = () =>
        {
            arrayBuffer = fileReader.result;
            audioCtx.decodeAudioData(arrayBuffer, (buffer) =>
            {
                audioBuffer = buffer;
                outBuffer.set(audioBuffer);
                createAudioBufferSource();
            });
        };
        fileReader.readAsArrayBuffer(e.data);
    }
});

let oldAudioIn = null;

let isRecording = false;
let isPlayingBack = false;
let bufferReady = false;

inStartRecording.onTriggered = () =>
{
    switch (state)
    {
    case STATES.RECORDING:
        return;
    case STATES.PROCESSING:
        return;
    case STATES.PLAYING:
        return;
    case STATES.READY:
        break;
    case STATES.IDLING:
        break;
    }

    if (!inAudio.get())
    {
        op.setUiError("noAudioInput", "No audio input is connected. Recording aborted.", 2);
        state = STATES.IDLING;
        return;
    }
    op.setUiError("noAudioInput", null);
    op.setUiError("recording", "Recoding audio...", 0);

    mediaRecorder.start();
    state = STATES.RECORDING;

    isRecording = true;
    outIsRecording.set(isRecording);
    outState.set(state);
};

inStopRecording.onTriggered = () =>
{
    switch (state)
    {
    case STATES.RECORDING:
        break;
    case STATES.PROCESSING:
        return;
    case STATES.PLAYING:
        return;
    case STATES.READY:
        return;
    case STATES.IDLING:
        return;
    }

    op.setUiError("recording", null);
    state = STATES.PROCESSING;
    isRecording = false;
    outState.set(state);

    mediaRecorder.stop();
    outIsRecording.set(isRecording);
    op.setUiError("stopRecording", "Recording stopped. Preparing...", 0);
};

inStartPlayback.onTriggered = () =>
{
    switch (state)
    {
    case STATES.RECORDING:
        return;
    case STATES.PROCESSING:
        return;
    case STATES.PLAYING:
        return;
    case STATES.READY:
        break;
    case STATES.IDLING:
        // if (loopSource) break;
        return;
    }

    op.setUiError("readyPlayback", null);
    loopSource.start();
    isPlayingBack = true;
    state = STATES.PLAYING;
    outState.set(state);
    outIsPlayingBack.set(isPlayingBack);
    op.setUiError("playingLoop", "Loop is playing...", 0);
};

inStopPlayback.onTriggered = () =>
{
    switch (state)
    {
    case STATES.RECORDING:
        return;
    case STATES.PROCESSING:
        return;
    case STATES.PLAYING:
        break;
    case STATES.READY:
        return;
    case STATES.IDLING:
        return;
    }

    op.setUiError("playingLoop", null);
    loopSource.stop();
    isPlayingBack = false;
    outIsPlayingBack.set(isPlayingBack);
    state = STATES.IDLING;
    outState.set(state);
    createAudioBufferSource();
};

inPlaybackGain.onChange = () =>
{
    outputGain.gain.linearRampToValueAtTime(inPlaybackGain.get(), audioCtx.currentTime + 0.01);
};

let arrayBuffer = null;
let audioBuffer = null;
let loopSource = null;

inLoop.onChange = () =>
{
    if (loopSource) loopSource.loop = inLoop.get();
};

function createAudioBufferSource()
{
    if (loopSource)
    {
        if (state === STATES.PLAYING)
        {
            loopSource.stop();
            isPlayingBack = false;
            outIsPlayingBack.set(isPlayingBack);
            loopSource.disconnect(outputGain);
        }
    }

    if (!audioBuffer) return;

    loopSource = audioCtx.createBufferSource();
    loopSource.buffer = audioBuffer;

    loopSource.onended = () =>
    {
        if (!state !== STATES.IDLING) createAudioBufferSource();
    };
    loopSource.loop = inLoop.get();

    loopSource.connect(outputGain);
    outRecorded.set(outputGain);
    bufferReady = true;
    state = STATES.READY;
    outState.set(state);
    op.setUiError("stopRecording", null);
}

inClearBuffer.onTriggered = () =>
{
    switch (state)
    {
    case STATES.RECORDING:
        return;
    case STATES.PROCESSING:
        return;
    case STATES.PLAYING:
        op.setUiError("playingLoop", null);
        break;
    case STATES.READY:
        break;
    case STATES.IDLING:
        break;
    }

    if (!audioBuffer) return;

    state = STATES.IDLING;
    outState.set(state);

    if (isPlayingBack)
    {
        loopSource.stop();
        isPlayingBack = false;
        outIsPlayingBack.set(isPlayingBack);
    }

    audioBuffer = null;
    outBuffer.set(audioBuffer);
    blob = null;
    inDownloadButton.setUiAttribs({ "greyout": true });
    outDataUrl.set(null);
};

inDownloadButton.onTriggered = () =>
{
    if (!blob) return;

    const anchor = document.createElement("a");

    anchor.download = "AudioRecorder " + op.id + ".wav";
    anchor.href = URL.createObjectURL(blob);

    setTimeout(function ()
    {
        anchor.click();
    }, 100);
};

inAudio.onLinkChanged = () =>
{
    if (!inAudio.isLinked())
    {
        switch (state)
        {
        case STATES.RECORDING:
            break;
        case STATES.PROCESSING:
            return;
        case STATES.PLAYING:
            return;
        case STATES.READY:
            return;
        case STATES.IDLING:
            return;
        }

        mediaRecorder.stop();
        if (isIOS) mediaRecorder.terminateWorker();
        state = STATES.IDLING;
        outState.set(state);
    }
};

op.onDelete = () =>
{
    switch (state)
    {
    case STATES.RECORDING:
        mediaRecorder.stop();
        break;
    case STATES.PROCESSING:
        break;
    case STATES.PLAYING:
        break;
    case STATES.READY:
        break;
    case STATES.IDLING:
        break;
    }
    if (isIOS) mediaRecorder.terminateWorker();
};

inAudio.onChange = () =>
{
    if (!inAudio.get())
    {
        if (oldAudioIn)
        {
            try
            {
                if (oldAudioIn.disconnect)
                {
                    oldAudioIn.disconnect(inputGain);
                    oldAudioIn.disconnect(inputStream);
                }
            }
            catch (e)
            {
                op.log(e);
            }
        }

        outOriginal.set(null);
    }
    else
    {
        if (inAudio.get().connect)
        {
            inAudio.get().connect(inputGain);
            inAudio.get().connect(inputStream);
        }

        outOriginal.set(inputGain);
    }

    oldAudioIn = inAudio.get();
};

op.onDelete = () =>
{
    if (loopSource)
    {
        loopSource.disconnect();
    }
};


};

Ops.WebAudio.AudioRecorder.prototype = new CABLES.Op();
CABLES.OPS["b4d46521-a8f8-4d54-abdb-98f1bfb80edd"]={f:Ops.WebAudio.AudioRecorder,objName:"Ops.WebAudio.AudioRecorder"};




// **************************************************************
// 
// Ops.WebAudio.BiquadFilter_v2
// 
// **************************************************************

Ops.WebAudio.BiquadFilter_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function clamp(val, min, max)
{
    return Math.min(Math.max(val, min), max);
}

const audioContext = CABLES.WEBAUDIO.createAudioContext(op);

// default values + min and max
const FREQUENCY_MIN = 10;
const FREQUENCY_MAX = audioContext.sampleRate / 2; // Nyquist frequency.
const Q_MIN = 0.0001;
const Q_MAX = 1000;
const GAIN_MIN = -40;
const GAIN_MAX = 40;

const filterNode = audioContext.createBiquadFilter();

const inAudio = op.inObject("Audio In", null, "audioNode");
const inFilterType = op.inDropDown("Type", ["peaking", "lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass"], "peaking");

const inFrequency = op.inFloat("Frequency", 2000);
const inQ = op.inFloat("Q", 0.0001);
const inGain = op.inFloat("Gain", 0);

const inDetune = op.inInt("Detune", 0);
const inFrequencyArray = op.inArray("Frequency Array");

op.setPortGroup("Filter Settings", [inFilterType, inFrequency, inQ, inGain]);
op.setPortGroup("Detune (in cents)", [inDetune]);
op.setPortGroup("Filter Response Input", [inFrequencyArray]);
const outAudio = op.outObject("Audio Out", null, "audioNode");
const outMagnitudeResponseArray = op.outArray("Magnitude Response Array");
const outPhaseResponseArray = op.outArray("Phase Response Array");
const responseArraysLength = op.outNumber("Response Arrays Length");

let oldAudioIn = null;
filterNode.type = inFilterType.get();

let oldLength = 0;
let frequencyArray = null;
let phaseResponseArray = null;
let magnitudeResponseArray = null;

function updateFrequencyResponse()
{
    const frequencies = inFrequencyArray.get();

    if (!frequencies) return;

    if (inAudio.get())
    {
        if (oldLength !== frequencies.length)
        {
            frequencyArray = new Float32Array(frequencies);
            phaseResponseArray = new Float32Array(frequencies.length);
            magnitudeResponseArray = new Float32Array(frequencies.length);
            oldLength = frequencies.length;
        }

        if (oldLength)
        {
            filterNode.getFrequencyResponse(frequencyArray, phaseResponseArray, magnitudeResponseArray);

            outMagnitudeResponseArray.set(null);
            outMagnitudeResponseArray.set(magnitudeResponseArray);

            outPhaseResponseArray.set(null);
            outPhaseResponseArray.set(phaseResponseArray);

            responseArraysLength.set(frequencies.length);
        }
        else
        {
            outMagnitudeResponseArray.set(null);
            outPhaseResponseArray.set(null);
            responseArraysLength.set(0);
        }
    }
}

inFrequencyArray.onChange = () => updateFrequencyResponse();
inAudio.onChange = function ()
{
    if (!inAudio.get())
    {
        if (oldAudioIn)
        {
            try
            {
                if (oldAudioIn.disconnect) oldAudioIn.disconnect(filterNode);
            }
            catch (e)
            {
                op.log(e);
            }
        }

        outAudio.set(null);
    }
    else
    {
        if (inAudio.get().connect) inAudio.get().connect(filterNode);
    }
    oldAudioIn = inAudio.get();
    outAudio.set(filterNode);
};

inFilterType.onChange = () =>
{
    const type = inFilterType.get();
    inGain.setUiAttribs({
        "greyout": ["lowpass", "highpass", "bandpass", "notch", "allpass"].includes(type)
    });

    inQ.setUiAttribs({
        "greyout": ["lowshelf", "highshelf"].includes(type)
    });

    filterNode.type = type;
    updateFrequencyResponse();
};

inFrequency.onChange = () =>
{
    const freq = inFrequency.get();
    if (freq)
    {
        if (freq >= FREQUENCY_MIN && freq <= FREQUENCY_MAX)
        {
            filterNode.frequency.setValueAtTime(clamp(freq, FREQUENCY_MIN, FREQUENCY_MAX), audioContext.currentTime);
            op.setUiError("freqRange", null);
        }
        if (freq < FREQUENCY_MIN)
        {
            op.setUiError("freqRange", "The frequency you selected is lower than the possible frequency of " + FREQUENCY_MIN + " Hz.", 1);
        }
        else if (freq > FREQUENCY_MAX)
        {
            op.setUiError("freqRange", "The frequency you selected is higher than the possible frequency of " + FREQUENCY_MAX + " Hz.", 1);
        }
    }
    updateFrequencyResponse();
};

inDetune.onChange = () =>
{
    filterNode.detune.setValueAtTime(inDetune.get(), audioContext.currentTime);
    updateFrequencyResponse();
};

inQ.onChange = () =>
{
    const q = inQ.get();
    filterNode.Q.setValueAtTime(clamp(q, Q_MIN, Q_MAX), audioContext.currentTime);

    if (q < Q_MIN) op.setUiError("qRange", "Your Q value is below the minimum possible value of " + Q_MIN + ".", 1);
    else if (q > Q_MAX) op.setUiError("qRange", "Your Q value is above the maximum possible value of " + Q_MAX + ".", 1);
    else
    {
        op.setUiError("qRange", null);
    }
    updateFrequencyResponse();
};

inGain.onChange = () =>
{
    const gain = inGain.get();
    filterNode.gain.setValueAtTime(clamp(gain, GAIN_MIN, GAIN_MAX), audioContext.currentTime);
    if (gain < GAIN_MIN) op.setUiError("gainRange", "Your gain value is below the minimum possible value of " + GAIN_MIN + " dB.", 1);
    else if (gain > GAIN_MAX) op.setUiError("gainRange", "Your gain value is above the maximum possible value of " + GAIN_MAX + " dB.", 1);
    else
    {
        op.setUiError("gainRange", null);
    }
    updateFrequencyResponse();
};


};

Ops.WebAudio.BiquadFilter_v2.prototype = new CABLES.Op();
CABLES.OPS["a7b30545-6db3-47b5-8ffc-f659accd0eb6"]={f:Ops.WebAudio.BiquadFilter_v2,objName:"Ops.WebAudio.BiquadFilter_v2"};




// **************************************************************
// 
// Ops.WebAudio.ClockSequencer
// 
// **************************************************************

Ops.WebAudio.ClockSequencer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"worker_js":"let timerIDs = [];\nlet timerID = null;\nconst LOOKAHEAD_IN_MS = 25.;\nonmessage = (e) => {\n    if (e.data === \"start\") {\n        timerID = setInterval(() => postMessage(\"tick\"), LOOKAHEAD_IN_MS);\n        return;\n    }\n\n    if (e.data === \"stop\") {\n        clearInterval(timerID);\n        timerID = null;\n        console.log(\"stopped\");\n    }\n};\n\nonerror = (e) => {\n    console.log(\"worker error\", e);\n}\n",};
const audioCtx = CABLES.WEBAUDIO.createAudioContext(op);

const inBPM = op.inInt("BPM", 100);
const inStart = op.inTriggerButton("Start");
const inStop = op.inTriggerButton("Stop");
const inReset = op.inTriggerButton("Reset");

const outTriggers = [];
for (let i = 0; i < 7 * 3; i += 1)
{
    const noteValue = Math.pow(2, i % 7);
    let string = "1/" + noteValue;
    if (i > 6 && i < 14)
    {
        string = "1/" + noteValue + " Triplet";
    }
    else if (i > 13)
    {
        string = "1/" + noteValue + " Dotted";
    }
    outTriggers[i] = op.outTrigger(string + " Note Trigger");
}

const outRunning = op.outBool("Sequencer Running");
const outBPM = op.outNumber("BPM Out");
const outStart = op.outTrigger("Start Out");
const outStop = op.outTrigger("Stop Out");
const outReset = op.outTrigger("Reset Out");

const MIN_BPM = 20;

const NOTE_QUEUE = [];
const LOOKAHEAD_IN_MS = 25.0;
const SCHEDULEAHEAD_IN_S = 0.1;

const MULTIPLIERS = [
    4, 2, 1, 1 / 2, 1 / 4, 1 / 8, 1 / 16,
    8 / 3, 4 / 3, 2 / 3, 1 / 3, 1 / 6, 1 / 12, 1 / 24, // triplet
    6, 3, 3 / 2, 3 / 4, 3 / 8, 3 / 16, 3 / 32 // dotted
];

const MODULO_PER_NOTE = MULTIPLIERS.map((val) => Math.floor(val * 48 / 2));
const TICK_INDEX = 7 * 2 - 1; // 1/64 triplet fastest note
const MAX_ENUMERATOR = 288;
let NOTES_IN_S = [];
let QUARTER_NOTE_S = 60 / inBPM.get();
NOTES_IN_S = MULTIPLIERS.map((multiplier) => multiplier * QUARTER_NOTE_S);
let TICK_S = NOTES_IN_S[TICK_INDEX] / 2;

outBPM.set(inBPM.get());

let resetTickCount = false;
let changeWhileRunning = false;
inBPM.onChange = updateBpm;

let worker = null;
let isPlaying = false;
let currentNote = 0;
let nextNoteTime = null;
let tickCount = 0;
let workerRunning = false;
let waitForSchedule = false;
updateBpm();

function updateBpm()
{
    outBPM.set(inBPM.get());

    if (workerRunning)
    {
        changeWhileRunning = true;
        return;
    }
    QUARTER_NOTE_S = 60 / inBPM.get();
    NOTES_IN_S = MULTIPLIERS.map((multiplier) => multiplier * QUARTER_NOTE_S);
    TICK_S = NOTES_IN_S[TICK_INDEX];
}

function nextNote()
{
    nextNoteTime += TICK_S;
    tickCount = (tickCount + 1) % MAX_ENUMERATOR;
}

function scheduleNote()
{
    if (waitForSchedule)
    { // code block to swallow initial hickup when starting the sequencer
        let compareValue = 8;
        if (inBPM.get() > 140) compareValue = 12;
        if (inBPM.get() > 160) compareValue = 20;
        if (tickCount === compareValue)
        { // half of highest value
            resetTickCount = true;
            waitForSchedule = false;
        }
        else
        {
            return;
        }
    }

    if (resetTickCount)
    {
        tickCount = 0;
        resetTickCount = false;
    }
    for (let i = 0, len = MODULO_PER_NOTE.length; i < len; i += 1)
    {
        if (tickCount % MODULO_PER_NOTE[i] === 0) outTriggers[i].trigger();
    }
}
function startScheduling()
{
    if (changeWhileRunning)
    {
        QUARTER_NOTE_S = 60 / inBPM.get();
        NOTES_IN_S = MULTIPLIERS.map((multiplier) => multiplier * QUARTER_NOTE_S);
        TICK_S = NOTES_IN_S[TICK_INDEX];
        changeWhileRunning = false;
    }
    while (nextNoteTime < audioCtx.currentTime + SCHEDULEAHEAD_IN_S)
    {
        scheduleNote();
        nextNote();
    }
}

inStart.onTriggered = () =>
{
    if (workerRunning) return;

    if (!worker)
    {
        const blob = new Blob([attachments.worker_js], { "type": "text/javascript" });
        const fileURL = URL.createObjectURL(blob);

        worker = new Worker(fileURL, { "name": "ClockSequencer with op-id: " + op.id });
        worker.addEventListener("message", (e) =>
        {
            if (e.data === "tick") startScheduling();
            if (e.data === "stopped") workerRunning = false;
        },
        false);

        nextNoteTime = audioCtx.currentTime;
        /* dummy buffer source for time */
        const audioBuffer = audioCtx.createBufferSource();
        audioBuffer.start(0);
        workerRunning = true;
        tickCount = 0;
        worker.postMessage("start");
        waitForSchedule = true;
        outRunning.set(workerRunning);
    }

    outStart.trigger();
};

inStop.onTriggered = () =>
{
    if (worker)
    {
        worker.postMessage("stop");
        worker.terminate();
        worker = null;
        workerRunning = false;
        outRunning.set(workerRunning);
    }

    outStop.trigger();
};

inReset.onTriggered = () =>
{
    resetTickCount = true;
    outReset.trigger();
};

op.onDelete = () =>
{
    if (!inStart.isLinked())
    {
        if (worker)
        {
            worker.postMessage("stop");
            worker.terminate();
            worker = null;
            workerRunning = false;
        }
    }
};
inStart.onLinkChanged = () =>
{
    if (!inStart.isLinked())
    {
        if (worker)
        {
            worker.postMessage("stop");
            worker.terminate();
            worker = null;
            workerRunning = false;
            outRunning.set(workerRunning);
        }
    }
};


};

Ops.WebAudio.ClockSequencer.prototype = new CABLES.Op();
CABLES.OPS["7994c33f-d4ca-455b-af72-83dcbf5ae83f"]={f:Ops.WebAudio.ClockSequencer,objName:"Ops.WebAudio.ClockSequencer"};




// **************************************************************
// 
// Ops.WebAudio.ClockSequencerPattern
// 
// **************************************************************

Ops.WebAudio.ClockSequencerPattern = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const STEPS = Array(32).fill().map((_, i) => 1 + i);

const inTrigger = op.inTrigger("Clock Trigger Input");
const inSequenceArray = op.inArray("Sequence Array");
const inSteps = op.inDropDown("Steps", STEPS, "16");
const inReset = op.inTriggerButton("Reset");

const outTrigger = op.outTrigger("Sequence Trigger Output");
const outValue = op.outNumber("Sequenced Value");
const outTickCount = op.outNumber("Current Step");

let updateParameters = false;
let arrayChanged = false;
let hasArray = false;

let COUNT_MODULO = Number(inSteps.get());
let tickCount = 0;
inSteps.onChange = () =>
{
    if (inTrigger.isLinked())
    {
        updateParameters = true;
        return;
    }
    COUNT_MODULO = Number(inSteps.get());
};

inSequenceArray.onChange = () => arrayChanged = true;
let resetCount = false;
inReset.onTriggered = () => resetCount = true;

inTrigger.onTriggered = () =>
{
    if (updateParameters)
    {
        COUNT_MODULO = Number(inSteps.get());
        updateParameters = false;
    }

    if (resetCount)
    {
        tickCount = 0;
        resetCount = false;
    }
    const arr = inSequenceArray.get();

    if (arrayChanged)
    {
        if (!arr)
        {
            op.setUiError("noArr", "No array connected. Passing through clock.", 1);
            hasArray = false;
        }
        else
        {
            op.setUiError("noArr", null);
            hasArray = true;
        }
        arrayChanged = false;
    }

    if (hasArray)
    {
        if (arr[tickCount])
        {
            outTrigger.trigger();
            outValue.set(arr[tickCount]);
        }
        else
        {
            outValue.set(0);
        }
    }
    else
    {
        outTrigger.trigger();
    }
    outTickCount.set(tickCount);
    tickCount = (tickCount + 1) % COUNT_MODULO;
};


};

Ops.WebAudio.ClockSequencerPattern.prototype = new CABLES.Op();
CABLES.OPS["3b9b9ff5-4c25-42e3-9897-262b11c9cb94"]={f:Ops.WebAudio.ClockSequencerPattern,objName:"Ops.WebAudio.ClockSequencerPattern"};




// **************************************************************
// 
// Ops.WebAudio.Convolver_v2
// 
// **************************************************************

Ops.WebAudio.Convolver_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function clamp(val, min, max)
{
    return Math.min(Math.max(val, min), max);
}

const MAX_DELAY_TIME_IN_SECONDS = 179.999;

const cgl = op.patch.cgl;
const audioContext = CABLES.WEBAUDIO.createAudioContext(op);

const audioIn = op.inObject("Audio In", null, "audioNode");

const impulseResponse = op.inUrl("Impulse Response");
const normalize = op.inBool("Normalize", true);
const inConvolverGain = op.inFloatSlider("IR Gain", 0.7);
const inPreDelayMS = op.inFloat("Predelay (MS)", 0);

const inDryWet = op.inFloatSlider("Dry/Wet", 0.5);
const inOutputGain = op.inFloatSlider("Output Gain", 1);

const audioOut = op.outObject("Audio Out", null, "audioNode");
const wetOut = op.outObject("Wet Out", null, "audioNode");

op.setPortGroup("IR Options", [impulseResponse, inConvolverGain, normalize, inPreDelayMS]);
op.setPortGroup("Output", [inDryWet, inOutputGain]);

const convolver = audioContext.createConvolver();
const convolverGain = audioContext.createGain();
const predelayNode = audioContext.createDelay(MAX_DELAY_TIME_IN_SECONDS);
const dryNode = audioContext.createGain();
const wetNode = audioContext.createGain();
const inputNode = audioContext.createGain();
const outputNode = audioContext.createGain();

wetNode.gain.value = parseFloat(inDryWet.get());
dryNode.gain.value = 1.0 - parseFloat(inDryWet.get());

wetNode.connect(outputNode);
dryNode.connect(outputNode);
inputNode.connect(dryNode);

inputNode.connect(predelayNode);
predelayNode.connect(convolverGain);
convolverGain.connect(convolver);
convolver.connect(wetNode);

let oldAudioIn = null;
let myImpulseBuffer = null;
let impulseResponseLoaded = false;
let scheduleConnection = false;
let loadingId = null;

impulseResponse.onChange = () =>
{
    loadingId = cgl.patch.loading.start("IR convolver", "");
    const impulseUrl = impulseResponse.get();

    const ajaxRequest = new XMLHttpRequest();

    if (impulseUrl)
    {
        const url = op.patch.getFilePath(impulseUrl);
        const ext = url.substr(url.lastIndexOf(".") + 1);

        if (ext === "wav")
        {
            op.setUiError("wavExt", "Even though impulse responses are .wav files most of the time, if you plan on using WebAudio in Safari, make sure you use a .wav file that is 16bit or use an .mp3 file instead.", 1);
        }
        else
        {
            op.setUiError("wavExt", null);
        }

        impulseResponseLoaded = false;
        ajaxRequest.open("GET", url, true);
        ajaxRequest.responseType = "arraybuffer";
        ajaxRequest.onload = function ()
        {
            const impulseData = ajaxRequest.response;

            audioContext.decodeAudioData(impulseData, function (buffer)
            {
                if (buffer.sampleRate != audioContext.sampleRate)
                {
                    op.log("[impulse response] Sample rate of the impulse response does not match! Should be " + audioContext.sampleRate);
                    op.setUiError("wrongSampleRate", "Sample rate of the impulse response does not match! Should be " + audioContext.sampleRate, 2);
                    return;
                }
                else
                {
                    op.setUiError("wrongSampleRate", null);
                }
                myImpulseBuffer = buffer;
                convolver.buffer = myImpulseBuffer;
                convolver.loop = false;
        		convolver.normalize = normalize.get();
        		convolverGain.gain.value = inConvolverGain.get();

        		audioOut.set(null);

        		try
                {
                    if (audioIn.get())
                    {
                        audioIn.get().connect(inputNode);
                        audioOut.set(outputNode);
                        wetOut.set(convolver);
                    }
                    else
                    {
                        scheduleConnection = true;
                    }
        		}
                catch (e)
                {
        		    op.log("[audio in] Could not connect audio in to convolver" + e);
        		}

                op.log("[impulse response] Impulse Response (" + impulseUrl + ") loaded");

                impulseResponseLoaded = true;
                cgl.patch.loading.finished(loadingId);
                op.setUiError("noIR", null);
            }, function (e)
            {
                op.log("[impulse response] Error decoding audio data" + e.err);
                impulseResponseLoaded = false;
                cgl.patch.loading.finished(loadingId);
            });
        };

        ajaxRequest.send();
    }
    else
    {
        impulseResponseLoaded = false;
        op.setUiError("noIR", "No impulse response loaded. Original audio will be passed through the Audio Out output.", 1);
        op.setUiError("wavExt", null);

        convolver.buffer = null;
        audioOut.set(outputNode);
    }
};

inConvolverGain.onChange = () =>
{
    convolverGain.gain.linearRampToValueAtTime(Number(inConvolverGain.get()) || 0, audioContext.currentTime + 0.01);
};

inDryWet.onChange = () =>
{
    wetNode.gain.linearRampToValueAtTime(Number(inDryWet.get()), audioContext.currentTime + 0.01);
    dryNode.gain.linearRampToValueAtTime(1 - Number(inDryWet.get()), audioContext.currentTime + 0.01);
};

inOutputGain.onChange = () =>
{
    outputNode.gain.linearRampToValueAtTime(inOutputGain.get(), audioContext.currentTime + 0.01);
};

inPreDelayMS.onChange = () =>
{
    if (inPreDelayMS.get() < 0) op.setUiError("delayTime", "Pre-Delay should be between 0 ms and " + MAX_DELAY_TIME_IN_SECONDS * 1000 + " ms. Setting to 0.", 1);
    else if (inPreDelayMS.get() > MAX_DELAY_TIME_IN_SECONDS * 1000) op.setUiError("delayTime", "Pre-Delay should be between 0 ms and " + MAX_DELAY_TIME_IN_SECONDS * 1000 + " ms. Setting to " + MAX_DELAY_TIME_IN_SECONDS * 1000 + ".", 1);
    else op.setUiError("delayTime", null);

    const predelayMS = clamp(inPreDelayMS.get(), 0.0, MAX_DELAY_TIME_IN_SECONDS) / 1000;
    predelayNode.delayTime.linearRampToValueAtTime(predelayMS, audioContext.currentTime + 0.05);
};

audioIn.onChange = function ()
{
    if (audioIn.get())
    {
        if (!audioIn.get().connect)
        {
            oldAudioIn = null;
            return;
        }

        op.log("[audio in] connected");

        try
        {
            audioIn.get().connect(inputNode);

            oldAudioIn = audioIn.get();
        }
        catch (e)
        {
            op.log("[audio in] Could not connect" + e);
        }

        if (!impulseResponseLoaded)
        {
            op.setUiError("noIR", "No impulse response loaded. Original audio will be passed through the Audio Out output.", 1);
            audioOut.set(outputNode);
        }
        else
        {
            op.setUiError("noIR", null);
            audioOut.set(outputNode);
            wetOut.set(convolver);
        }
    }
    else
    {
        if (impulseResponseLoaded)
        {
            op.setUiError("noIR", null);
        }

        if (oldAudioIn)
        {
            oldAudioIn.disconnect(inputNode);
        }
        audioOut.set(null);
        wetOut.set(null);

        oldAudioIn = null;
    }
};

normalize.onChange = function ()
{
    convolver.normalize = normalize.get();
};

op.onDelete = () =>
{
    wetNode.disconnect();
    dryNode.disconnect();
    inputNode.disconnect();
    predelayNode.disconnect();
    convolverGain.disconnect();
    convolver.disconnect();
};


};

Ops.WebAudio.Convolver_v2.prototype = new CABLES.Op();
CABLES.OPS["63c619be-2256-4bbe-a83f-36b2bb6faa52"]={f:Ops.WebAudio.Convolver_v2,objName:"Ops.WebAudio.Convolver_v2"};




// **************************************************************
// 
// Ops.WebAudio.CutFilter
// 
// **************************************************************

Ops.WebAudio.CutFilter = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function clamp(val, min, max)
{
    return Math.min(Math.max(val, min), max);
}

let audioContext = CABLES.WEBAUDIO.createAudioContext(op);

// default values + min and max
const FREQUENCY_MIN = 10;
const FREQUENCY_MAX = audioContext.sampleRate / 2; // Nyquist frequency.
const Q_MIN = 0.0001;
const Q_MAX = 1000;
const GAIN_MIN = -40;
const GAIN_MAX = 40;
const SLOPES = [12, 24, 36, 48];
const inAudio = op.inObject("Audio In", null, "audioNode");

const inLowActive = op.inBool("Highpass active ", true);
const inLowSlope = op.inSwitch("Highpass Slope (in dB)", SLOPES, 12);
const inLowFrequency = op.inFloat("Low Frequency", 250);
const inLowQ = op.inFloat("Low Q", 0.0001);
op.setPortGroup("Highpass / Lowcut", [inLowActive, inLowSlope, inLowFrequency, inLowQ]);

const inHighActive = op.inBool("Lowpass active ", true);
const inHighSlope = op.inSwitch("Lowpass Slope (in dB)", SLOPES, 12);
const inHighFrequency = op.inFloat("High Frequency", 5000);
const inHighQ = op.inFloat("High Q", 0.0001);
op.setPortGroup("Lowpass / Highcut", [inHighActive, inHighSlope, inHighFrequency, inHighQ]);

const lowFilterNodes = SLOPES.map(entry => audioContext.createBiquadFilter());
const highFilterNodes = SLOPES.map(() => audioContext.createBiquadFilter());

/* instantiation */
lowFilterNodes.forEach((node, index) =>
{
    if (index === 0) node.type = "highpass";
    else node.type = "peaking";

    const freq = inLowFrequency.get();
    node.frequency.setValueAtTime(clamp(freq, FREQUENCY_MIN, FREQUENCY_MAX), audioContext.currentTime);
    node.gain.setValueAtTime(clamp(0, GAIN_MIN, GAIN_MAX), audioContext.currentTime);
    node.Q.setValueAtTime(clamp(Number(inLowQ.get()), Q_MIN, Q_MAX), audioContext.currentTime);

    if (index < SLOPES.length - 1) node.connect(lowFilterNodes[index + 1]);
    else node.connect(highFilterNodes[0]);
});

highFilterNodes.forEach((node, index) =>
{
    if (index === 0) node.type = "lowpass";
    else node.type = "peaking";

    const freq = inHighFrequency.get();
    node.frequency.setValueAtTime(clamp(freq, FREQUENCY_MIN, FREQUENCY_MAX), audioContext.currentTime);
    node.gain.setValueAtTime(clamp(0, GAIN_MIN, GAIN_MAX), audioContext.currentTime);
    node.Q.setValueAtTime(clamp(Number(inHighQ.get()), Q_MIN, Q_MAX), audioContext.currentTime);

    if (index < SLOPES.length - 1) node.connect(highFilterNodes[index + 1]);
});

/* onChange handlers */

let lastHighState = highFilterNodes.map(node => node.type);

inHighActive.onChange = () =>
{
    inHighSlope.setUiAttribs({ "greyout": !inHighActive.get() });
    inHighFrequency.setUiAttribs({ "greyout": !inHighActive.get() });
    inHighQ.setUiAttribs({ "greyout": !inHighActive.get() });

    if (inHighActive.get())
    {
        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = highFilterNodes[i];
            node.type = lastHighState[i];
        }
    }
    else
    {
        lastHighState = highFilterNodes.map(node => node.type);

        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = highFilterNodes[i];
            node.type = "peaking";
        }
    }
};

let lastLowState = lowFilterNodes.map(node => node.type);

inLowActive.onChange = () =>
{
    inLowSlope.setUiAttribs({ "greyout": !inLowActive.get() });
    inLowFrequency.setUiAttribs({ "greyout": !inLowActive.get() });
    inLowQ.setUiAttribs({ "greyout": !inLowActive.get() });

    if (inLowActive.get())
    {
        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = lowFilterNodes[i];
            node.type = lastLowState[i];
        }
    }
    else
    {
        lastLowState = lowFilterNodes.map(node => node.type);

        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = lowFilterNodes[i];
            node.type = "peaking";
        }
    }
};

inHighFrequency.onChange = () =>
{
    if (inHighActive.get())
    {
        const freq = inHighFrequency.get();

        if (freq >= FREQUENCY_MIN && freq <= FREQUENCY_MAX) op.setUiError("freqRangeHigh", null);

        if (freq < FREQUENCY_MIN)
        {
            op.setUiError("freqRangeHigh", "The frequency you selected for the lowpass filter is lower than the possible frequency of " + FREQUENCY_MIN + " Hz.", 1);
        }
        else if (freq > FREQUENCY_MAX)
        {
            op.setUiError("freqRangeHigh", "The frequency you selected for the lowpass filter is higher than the possible frequency of " + FREQUENCY_MAX + " Hz.", 1);
        }

        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = highFilterNodes[i];
            node.frequency.setValueAtTime(clamp(freq, FREQUENCY_MIN, FREQUENCY_MAX), audioContext.currentTime);
        }
    }
};

inLowFrequency.onChange = () =>
{
    if (inLowActive.get())
    {
        const freq = inLowFrequency.get();

        if (freq >= FREQUENCY_MIN && freq <= FREQUENCY_MAX) op.setUiError("freqRangeLow", null);

        if (freq < FREQUENCY_MIN)
        {
            op.setUiError("freqRangeLow", "The frequency you selected for the highpass filter is lower than the possible frequency of " + FREQUENCY_MIN + " Hz.", 1);
        }
        else if (freq > FREQUENCY_MAX)
        {
            op.setUiError("freqRangeLow", "The frequency you selected for the highpass filter is higher than the possible frequency of " + FREQUENCY_MAX + " Hz.", 1);
        }

        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = lowFilterNodes[i];
            node.frequency.setValueAtTime(clamp(freq, FREQUENCY_MIN, FREQUENCY_MAX), audioContext.currentTime);
        }
    }
};

inHighSlope.onChange = () =>
{
    if (inHighActive.get())
    {
        const cascadeAmount = SLOPES.indexOf(Number(inHighSlope.get()));
        if (cascadeAmount < 0) return;

        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = highFilterNodes[i];
            if (i <= cascadeAmount) node.type = "lowpass";
            else node.type = "peaking";
        }
    }
};

inLowSlope.onChange = () =>
{
    if (inLowActive.get())
    {
        const cascadeAmount = SLOPES.indexOf(Number(inLowSlope.get()));

        if (cascadeAmount < 0) return;

        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = lowFilterNodes[i];
            if (i <= cascadeAmount) node.type = "highpass";
            else node.type = "peaking";
        }
    }
};

inHighQ.onChange = () =>
{
    if (inHighActive.get())
    {
        const q = inHighQ.get();

        if (q < Q_MIN) op.setUiError("qRangeHigh", "Your Q value for the lowpass filter is below the minimum possible value of " + Q_MIN + ".", 1);
        else if (q > Q_MAX) op.setUiError("qRangeHigh", "Your Q value for lowpass filter is above the maximum possible value of " + Q_MAX + ".", 1);
        else op.setUiError("qRangeHigh", null);

        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = highFilterNodes[i];
            node.Q.setValueAtTime(clamp(q, Q_MIN, Q_MAX), audioContext.currentTime);
        }
    }
};

inLowQ.onChange = () =>
{
    if (inLowActive.get())
    {
        const q = inLowQ.get();

        if (q < Q_MIN) op.setUiError("qRangeLow", "Your Q value for the highpass filter is below the minimum possible value of " + Q_MIN + ".", 1);
        else if (q > Q_MAX) op.setUiError("qRangeLow", "Your Q value for highpass filter is above the maximum possible value of " + Q_MAX + ".", 1);
        else op.setUiError("qRangeLow", null);

        for (let i = 0; i < SLOPES.length; i += 1)
        {
            const node = lowFilterNodes[i];
            node.Q.setValueAtTime(clamp(q, Q_MIN, Q_MAX), audioContext.currentTime);
        }
    }
};

const outAudio = op.outObject("Audio Out", null, "audioNode");

let oldAudioIn = null;

inAudio.onChange = function ()
{
    if (!inAudio.get())
    {
        if (oldAudioIn)
        {
            try
            {
                if (oldAudioIn.disconnect)
                {
                    oldAudioIn.disconnect(lowFilterNodes[0]);
                }
            }
            catch (e)
            {
                op.log(e);
            }
        }
        outAudio.set(null);
    }
    else
    {
        if (inAudio.get().connect) inAudio.get().connect(lowFilterNodes[0]);
    }

    oldAudioIn = inAudio.get();
    outAudio.set(highFilterNodes[SLOPES.length - 1]);
};

op.onDelete = () =>
{
    lowFilterNodes.forEach((node, index) =>
    {
        node.disconnect();
    });

    highFilterNodes.forEach((node, index) =>
    {
        if (index < SLOPES.length - 1) node.disconnect();
    });
};


};

Ops.WebAudio.CutFilter.prototype = new CABLES.Op();
CABLES.OPS["de1f1d82-49b3-47e3-840e-2ab75ffc0045"]={f:Ops.WebAudio.CutFilter,objName:"Ops.WebAudio.CutFilter"};




// **************************************************************
// 
// Ops.WebAudio.Delay
// 
// **************************************************************

Ops.WebAudio.Delay = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function clamp(val, min, max)
{
    return Math.min(Math.max(val, min), max);
}

const audioCtx = CABLES.WEBAUDIO.createAudioContext(op);
const NOTE_NAMES = [];
const MAX_DELAY_TIME = 179.999;

for (let i = 0; i < 7 * 3; i += 1)
{
    const noteValue = Math.pow(2, i % 7);
    let string = "1/" + noteValue;
    if (i > 6 && i < 14)
    {
        string = "1/" + noteValue + " Triplet";
    }
    else if (i > 13)
    {
        string = "1/" + noteValue + " Dotted";
    }
    NOTE_NAMES.push(string + " Note");
}

const audioIn = op.inObject("Audio In", null, "audioNode");
const inDryWet = op.inFloatSlider("Dry/Wet", 0.4);
const inFeedback = op.inFloatSlider("Feedback", 0.4);
const inDelayMS = op.inFloat("Delay Time (MS)", 100);
const inDelayShift = op.inFloat("Delay Shift (MS)", 0);
const inBpmSync = op.inBool("BPM based delay time", false);
const inBPM = op.inFloat("BPM", 120);
const inDelayNotes = op.inDropDown("Delay Time (note value) ", NOTE_NAMES, "1/8 Dotted Note");
const inUseModulation = op.inBool("Use Filter & Modulation", false);
const inHighpassFrequency = op.inFloat("Highpass Frequency", 300);
const inHighpassQ = op.inFloat("Highpass Q", 2);
const inLowpassFrequency = op.inFloat("Lowpass Frequency", 9000);
const inLowpassQ = op.inFloat("Lowpass Q", 2);
const inLfoSpeed = op.inFloat("LFO Speed (Hz) ", 3.14);
const inLfoIntensity = op.inFloatSlider("LFO Intensity", 0.4);
const inLfoWave = op.inDropDown("LFO Waveform", ["sine", "triangle"], "sine");
inLowpassFrequency.setUiAttribs({ "greyout": !inUseModulation.get() });
inLowpassQ.setUiAttribs({ "greyout": !inUseModulation.get() });
inHighpassFrequency.setUiAttribs({ "greyout": !inUseModulation.get() });
inHighpassQ.setUiAttribs({ "greyout": !inUseModulation.get() });
inLfoSpeed.setUiAttribs({ "greyout": !inUseModulation.get() });
inLfoIntensity.setUiAttribs({ "greyout": !inUseModulation.get() });
inLfoWave.setUiAttribs({ "greyout": !inUseModulation.get() });
op.setPortGroup("Filters & Modulation", [inLowpassFrequency, inLowpassQ, inHighpassFrequency, inHighpassQ, inLfoSpeed, inLfoIntensity, inLfoWave]);

const audioOut = op.outObject("Mix Out", null, "audioNode");
const delayOut = op.outObject("Wet Out", null, "audioNode");

const MULTIPLIERS = [
    4, 2, 1, 1 / 2, 1 / 4, 1 / 8, 1 / 16,
    8 / 3, 4 / 3, 2 / 3, 1 / 3, 1 / 6, 1 / 12, 1 / 24,
    6, 3, 3 / 2, 3 / 4, 3 / 8, 3 / 16, 3 / 32 // dotted
];

const MIN_BPM = 20;
let QUARTER_NOTE_S = 60 / Math.max(20, inBPM.get());
let NOTES_IN_S = MULTIPLIERS.map((multiplier) => multiplier * QUARTER_NOTE_S);

const calculateDelayTime = () =>
{
    if (inBpmSync.get())
    {
        const timeIndex = NOTE_NAMES.indexOf(inDelayNotes.get());

        const timeValue = NOTES_IN_S[timeIndex] + (parseFloat(inDelayShift.get()) / 1000);
        clamp(timeValue, 0, MAX_DELAY_TIME);
        return timeValue;
    }

    const unsyncedTime = (parseFloat(inDelayMS.get()) + parseFloat(inDelayShift.get())) / 1000.0;

    if (unsyncedTime < 0) op.setUiError("minDelayTime", "The delay time is lower than 0 ms. Setting to 0.", 1);
    else op.setUiError("minDelayTime", null);

    return Math.max(0, unsyncedTime);
};

op.setPortGroup("Main Controls", [inDryWet, inFeedback, inDelayMS, inDelayShift]);
op.setPortGroup("Synced Controls", [inBPM, inDelayNotes]);

inBPM.setUiAttribs({ "greyout": !inBpmSync.get() });
inDelayNotes.setUiAttribs({ "greyout": !inBpmSync.get() });
inDelayMS.setUiAttribs({ "greyout": inBpmSync.get() });

inBpmSync.onChange = () =>
{
    inBPM.setUiAttribs({ "greyout": !inBpmSync.get() });
    inDelayNotes.setUiAttribs({ "greyout": !inBpmSync.get() });
    inDelayMS.setUiAttribs({ "greyout": inBpmSync.get() });

    delayNode.delayTime.linearRampToValueAtTime(calculateDelayTime(), audioCtx.currentTime + 0.2);

    if (inBPM.get() < MIN_BPM) op.setUiError("minBPM", "The minimum BPM value is " + MIN_BPM + " BPM.", 1);
    else op.setUiError("minBPM", null);
};

const inputNode = audioCtx.createGain(); // we create an input node so we can change the delay without requiring the input signal
const delayNode = audioCtx.createDelay(MAX_DELAY_TIME);
const dryNode = audioCtx.createGain();
const wetNode = audioCtx.createGain();

const feedbackNode = audioCtx.createGain();
const outputNode = audioCtx.createGain();

const filterHighpassNode = audioCtx.createBiquadFilter();
const filterLowpassNode = audioCtx.createBiquadFilter();
filterLowpassNode.type = "lowpass";
filterLowpassNode.frequency.value = inLowpassFrequency.get();
filterLowpassNode.Q.value = inLowpassQ.get();

filterHighpassNode.connect(filterLowpassNode);
filterHighpassNode.type = "highpass";
filterHighpassNode.frequency.value = inHighpassFrequency.get();
filterHighpassNode.Q.value = inHighpassQ.get();

const lfoNode = audioCtx.createOscillator();
lfoNode.frequency.value = inLfoSpeed.get(); // Freq. in Hz
const lfoGainNode = audioCtx.createGain();
lfoGainNode.gain.value = inLfoIntensity.get() / 800;
lfoNode.connect(lfoGainNode);
lfoNode.start();

delayNode.delayTime.value = calculateDelayTime();
feedbackNode.gain.value = parseFloat(inFeedback.get());
wetNode.gain.value = parseFloat(inDryWet.get());
dryNode.gain.value = 1.0 - parseFloat(inDryWet.get());

delayNode.connect(feedbackNode);
feedbackNode.connect(delayNode);

inputNode.connect(dryNode);
inputNode.connect(delayNode);

dryNode.connect(outputNode);
delayNode.connect(wetNode);

wetNode.connect(outputNode);

inUseModulation.onChange = () =>
{
    inLowpassFrequency.setUiAttribs({ "greyout": !inUseModulation.get() });
    inLowpassQ.setUiAttribs({ "greyout": !inUseModulation.get() });
    inHighpassFrequency.setUiAttribs({ "greyout": !inUseModulation.get() });
    inHighpassQ.setUiAttribs({ "greyout": !inUseModulation.get() });
    inLfoSpeed.setUiAttribs({ "greyout": !inUseModulation.get() });
    inLfoIntensity.setUiAttribs({ "greyout": !inUseModulation.get() });
    inLfoWave.setUiAttribs({ "greyout": !inUseModulation.get() });

    if (inUseModulation.get())
    {
        lfoGainNode.connect(delayNode.delayTime);

        inputNode.disconnect(delayNode);

        inputNode.connect(filterHighpassNode);
        filterLowpassNode.connect(delayNode);
    }
    else
    {
        lfoGainNode.disconnect(delayNode.delayTime);

        inputNode.disconnect(filterHighpassNode);
        filterLowpassNode.disconnect(delayNode);

        inputNode.connect(delayNode);
    }
};

inLfoIntensity.onChange = () =>
{
    lfoGainNode.gain.linearRampToValueAtTime(inLfoIntensity.get() / 800, audioCtx.currentTime + 0.1);
};

inLfoSpeed.onChange = () =>
{
    lfoNode.frequency.linearRampToValueAtTime(inLfoSpeed.get(), audioCtx.currentTime + 0.1);
};

inLfoWave.onChange = () =>
{
    lfoNode.type = inLfoWave.get();
};
inDelayMS.onChange = inDelayShift.onChange = inDelayNotes.onChange = () =>
{
    if (inBPM.get() < MIN_BPM) op.setUiError("minBPM", "The minimum BPM value is " + MIN_BPM + " BPM.", 1);
    else op.setUiError("minBPM", null);

    delayNode.delayTime.linearRampToValueAtTime(calculateDelayTime(), audioCtx.currentTime + 0.2);
};

inBPM.onChange = () =>
{
    QUARTER_NOTE_S = 60 / Math.max(MIN_BPM, inBPM.get());
    NOTES_IN_S = MULTIPLIERS.map((multiplier) => multiplier * QUARTER_NOTE_S);

    delayNode.delayTime.linearRampToValueAtTime(calculateDelayTime(), audioCtx.currentTime + 0.1);

    if (inBPM.get() < MIN_BPM) op.setUiError("minBPM", "The minimum BPM value is " + MIN_BPM + " BPM.", 1);
    else op.setUiError("minBPM", null);
};

inDryWet.onChange = () =>
{
    wetNode.gain.linearRampToValueAtTime(Number(inDryWet.get()), audioCtx.currentTime + 0.01);
    dryNode.gain.linearRampToValueAtTime((1 - Number(inDryWet.get())), audioCtx.currentTime + 0.01);
};

inFeedback.onChange = () =>
{
    feedbackNode.gain.linearRampToValueAtTime(Number(inFeedback.get()), audioCtx.currentTime + 0.01);
};

const FREQUENCY_MIN = 10;
const FREQUENCY_MAX = audioCtx.sampleRate / 2; // Nyquist frequency.
const Q_MIN = 0.0001;
const Q_MAX = 1000;

inHighpassFrequency.onChange = () =>
{
    const freq = inHighpassFrequency.get();
    if (freq)
    {
        if (freq >= FREQUENCY_MIN && freq <= FREQUENCY_MAX)
        {
            filterHighpassNode.frequency.linearRampToValueAtTime(clamp(freq, FREQUENCY_MIN, FREQUENCY_MAX), audioContext.currentTime, +0.01);
            op.setUiError("freqRangeHighpass", null);
        }
        if (freq < FREQUENCY_MIN)
        {
            op.setUiError("freqRangeHighpass", "The highpass frequency you selected is lower than the possible frequency of " + FREQUENCY_MIN + " Hz.", 1);
        }
        else if (freq > FREQUENCY_MAX)
        {
            op.setUiError("freqRangeHighpass", "The highpass frequency you selected is higher than the possible frequency of " + FREQUENCY_MAX + " Hz.", 1);
        }
    }
};

inHighpassQ.onChange = () =>
{
    const q = inHighpassQ.get();
    filterHighpassNode.Q.linearRampToValueAtTime(clamp(q, Q_MIN, Q_MAX), audioContext.currentTime + 0.01);

    if (q < Q_MIN) op.setUiError("qRangeHighpass", "Your highpass Q value is below the minimum possible value of " + Q_MIN + ".", 1);
    else if (q > Q_MAX) op.setUiError("qRangeHighpass", "Your highpass Q value is above the maximum possible value of " + Q_MAX + ".", 1);
    else
    {
        op.setUiError("qRangeHighpass", null);
    }
};

inLowpassFrequency.onChange = () =>
{
    const freq = inLowpassFrequency.get();
    if (freq)
    {
        if (freq >= FREQUENCY_MIN && freq <= FREQUENCY_MAX)
        {
            filterLowpassNode.frequency.linearRampToValueAtTime(clamp(freq, FREQUENCY_MIN, FREQUENCY_MAX), audioContext.currentTime, +0.01);
            op.setUiError("freqRangeLowpass", null);
        }
        if (freq < FREQUENCY_MIN)
        {
            op.setUiError("freqRangeLowpass", "The lowpass frequency you selected is lower than the possible frequency of " + FREQUENCY_MIN + " Hz.", 1);
        }
        else if (freq > FREQUENCY_MAX)
        {
            op.setUiError("freqRangeLowpass", "The lowpass frequency you selected is higher than the possible frequency of " + FREQUENCY_MAX + " Hz.", 1);
        }
    }
};

inLowpassQ.onChange = () =>
{
    const q = inLowpassQ.get();
    filterLowpassNode.Q.linearRampToValueAtTime(clamp(q, Q_MIN, Q_MAX), audioContext.currentTime + 0.01);

    if (q < Q_MIN) op.setUiError("qRangeLowpass", "Your lowpass Q value is below the minimum possible value of " + Q_MIN + ".", 1);
    else if (q > Q_MAX) op.setUiError("qRangeLowpass", "Your lowpass Q value is above the maximum possible value of " + Q_MAX + ".", 1);
    else
    {
        op.setUiError("qRangeLowpass", null);
    }
};

let oldAudioIn = null;
audioIn.onChange = function ()
{
    if (!audioIn.get())
    {
        if (oldAudioIn)
        {
            try
            {
                if (oldAudioIn.disconnect)
                {
                    oldAudioIn.disconnect(inputNode);
                }
            }
            catch (e)
            {
                op.log(e);
            }
        }
        audioOut.set(null);
    }
    else
    {
        if (audioIn.get().connect) audioIn.get().connect(inputNode);
    }

    oldAudioIn = audioIn.get();
    audioOut.set(outputNode);
    delayOut.set(delayNode);
};

op.onDelete = () =>
{
    lfoNode.disconnect();
    delayNode.disconnect();
    feedbackNode.disconnect();

    inputNode.disconnect();

    dryNode.disconnect();
    delayNode.disconnect();

    wetNode.disconnect();
    filterHighpassNode.disconnect();

    if (inUseModulation.get())
    {
        lfoGainNode.disconnect();
        filterLowpassNode.disconnect();
    }
};


};

Ops.WebAudio.Delay.prototype = new CABLES.Op();
CABLES.OPS["60a557be-109a-494d-aba7-fcc61bbad033"]={f:Ops.WebAudio.Delay,objName:"Ops.WebAudio.Delay"};




// **************************************************************
// 
// Ops.WebAudio.FFTAreaAverage_v2
// 
// **************************************************************

Ops.WebAudio.FFTAreaAverage_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;
const TEX_SIZES = [128, 256, 512, 1024, 2048];
const
    refresh = op.inTriggerButton("Refresh"),
    fftArr = op.inArray("FFT Array"),
    x = op.inValueSlider("X Position"),
    y = op.inValueSlider("Y Position"),
    w = op.inValueSlider("Width", 0.2),
    h = op.inValueSlider("Height", 0.2),
    drawTex = op.inValueBool("Create Texture", true),
    inCanvasSize = op.inSwitch("Texture Size", TEX_SIZES, 128),
    texOut = op.outTexture("Texture Out", null, "texture"),
    value = op.outNumber("Area Average Volume");

op.setPortGroup("Area Settings", [x, y, w, h]);
op.setPortGroup("Texture Settings", [drawTex, inCanvasSize]);

let updateTexture = false;
inCanvasSize.onChange = () =>
{
    updateTexture = true;
};
const data = [];
const line = 0;
let size = Number(inCanvasSize.get());

const canvas = document.createElement("canvas");
canvas.id = "fft_" + CABLES.uuid();
canvas.width = canvas.height = size;
canvas.style.display = "none";
const body = document.getElementsByTagName("body")[0];
body.appendChild(canvas);
const ctx = canvas.getContext("2d");

const MULTIPLIERS = [0.5, 1, 2, 4, 8];
let multiplier = 1;

let areaX = 0;
let areaY = 0;
let areaW = 20;
let areaH = 20;
let amount = 0;

refresh.onTriggered = function ()
{
    const arr = fftArr.get();
    if (!arr)
    {
        return;
    }

    const width = arr.length;

    const draw = drawTex.get();

    if (updateTexture)
    {
        size = Number(inCanvasSize.get());
        canvas.width = canvas.height = size;

        const indexOfSize = TEX_SIZES.indexOf(Number(inCanvasSize.get()));
        multiplier = MULTIPLIERS[indexOfSize];

        updateTexture = false;
    }

    if (draw)
    {
        ctx.beginPath();
        ctx.fillStyle = "#000";
        ctx.strokeStyle = "#ff0";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#888";
        for (let i = 0; i < arr.length; i++)
            ctx.fillRect(i, size - arr[i] * multiplier, 1, arr[i] * multiplier);
    }

    areaX = x.get() * canvas.width;
    areaY = y.get() * canvas.height;

    areaW = w.get() * size / 2;
    areaH = h.get() * size / 2;

    if (draw)ctx.rect(areaX, areaY, areaW, areaH);
    if (draw)
    {
        ctx.lineWidth = 2 * multiplier;
        ctx.stroke();
    }

    const val = 0;
    let count = 0;
    for (let xc = areaX; xc < areaX + areaW; xc++)
        for (let yc = areaY; yc < areaY + areaH; yc++)
            if (arr[Math.round(xc)] * multiplier > size - yc)count++;

    if (amount != amount)amount = 0;
    amount += count / (areaW * areaH);
    amount /= 2;
    value.set(amount);

    if (draw)
    {
        ctx.fillStyle = "#ff0";
        ctx.fillRect(0, 0, amount * canvas.width, 6 * multiplier);

        if (texOut.get()) texOut.get().initTexture(canvas, CGL.Texture.FILTER_NEAREST);
        else
        {
            texOut.set(new CGL.Texture.createFromImage(cgl, canvas, { "filter": CGL.Texture.FILTER_NEAREST }));
        }
    }
};


};

Ops.WebAudio.FFTAreaAverage_v2.prototype = new CABLES.Op();
CABLES.OPS["8dd14fde-57d1-408c-a3ef-441a65bfe53a"]={f:Ops.WebAudio.FFTAreaAverage_v2,objName:"Ops.WebAudio.FFTAreaAverage_v2"};




// **************************************************************
// 
// Ops.WebAudio.Gain
// 
// **************************************************************

Ops.WebAudio.Gain = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const audioIn = op.inObject("audio in", null, "audioNode");
const gain = op.inFloatSlider("gain", 1);
const inMute = op.inBool("Mute", false);
const audioOut = op.outObject("audio out", null, "audioNode");

const audioCtx = CABLES.WEBAUDIO.createAudioContext(op);
const gainNode = audioContext.createGain();

gain.onChange = () =>
{
    if (inMute.get()) return;

    gainNode.gain.setValueAtTime(Number(gain.get()) || 0, audioCtx.currentTime);
};

inMute.onChange = () =>
{
    if (inMute.get())
    {
        gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.01);
    }
    else
    {
        gainNode.gain.linearRampToValueAtTime(Number(gain.get()) || 0, audioCtx.currentTime + 0.01);
    }
};
let oldAudioIn = null;

audioIn.onChange = function ()
{
    if (!audioIn.get())
    {
        if (oldAudioIn)
        {
            try
            {
                if (oldAudioIn.disconnect) oldAudioIn.disconnect(gainNode);
            }
            catch (e)
            {
                op.log(e);
            }
        }
        audioOut.set(null);
    }
    else
    {
        if (audioIn.get().connect) audioIn.get().connect(gainNode);
    }
    oldAudioIn = audioIn.get();
    audioOut.set(gainNode);
};


};

Ops.WebAudio.Gain.prototype = new CABLES.Op();
CABLES.OPS["29402bba-48ee-4f28-94f0-bdc345e6bb67"]={f:Ops.WebAudio.Gain,objName:"Ops.WebAudio.Gain"};




// **************************************************************
// 
// Ops.WebAudio.KeyPiano
// 
// **************************************************************

Ops.WebAudio.KeyPiano = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let c_on = this.addInPort(new CABLES.Port(this, "c note on", CABLES.OP_PORT_TYPE_FUNCTION));
let c_off = this.addInPort(new CABLES.Port(this, "c note off", CABLES.OP_PORT_TYPE_FUNCTION));
let cis_on = this.addInPort(new CABLES.Port(this, "cis note on", CABLES.OP_PORT_TYPE_FUNCTION));
let cis_off = this.addInPort(new CABLES.Port(this, "cis note off", CABLES.OP_PORT_TYPE_FUNCTION));
let d_on = this.addInPort(new CABLES.Port(this, "d note on", CABLES.OP_PORT_TYPE_FUNCTION));
let d_off = this.addInPort(new CABLES.Port(this, "d note off", CABLES.OP_PORT_TYPE_FUNCTION));
let dis_on = this.addInPort(new CABLES.Port(this, "dis note on", CABLES.OP_PORT_TYPE_FUNCTION));
let dis_off = this.addInPort(new CABLES.Port(this, "dis note off", CABLES.OP_PORT_TYPE_FUNCTION));
let e_on = this.addInPort(new CABLES.Port(this, "e note on", CABLES.OP_PORT_TYPE_FUNCTION));
let e_off = this.addInPort(new CABLES.Port(this, "e note off", CABLES.OP_PORT_TYPE_FUNCTION));
let f_on = this.addInPort(new CABLES.Port(this, "f note on", CABLES.OP_PORT_TYPE_FUNCTION));
let f_off = this.addInPort(new CABLES.Port(this, "f note off", CABLES.OP_PORT_TYPE_FUNCTION));
let fis_on = this.addInPort(new CABLES.Port(this, "fis note on", CABLES.OP_PORT_TYPE_FUNCTION));
let fis_off = this.addInPort(new CABLES.Port(this, "fis note off", CABLES.OP_PORT_TYPE_FUNCTION));
let g_on = this.addInPort(new CABLES.Port(this, "g note on", CABLES.OP_PORT_TYPE_FUNCTION));
let g_off = this.addInPort(new CABLES.Port(this, "g note off", CABLES.OP_PORT_TYPE_FUNCTION));
let gis_on = this.addInPort(new CABLES.Port(this, "gis note ons", CABLES.OP_PORT_TYPE_FUNCTION));
let gis_off = this.addInPort(new CABLES.Port(this, "gis note off", CABLES.OP_PORT_TYPE_FUNCTION));
let a_on = this.addInPort(new CABLES.Port(this, "a note on", CABLES.OP_PORT_TYPE_FUNCTION));
let a_off = this.addInPort(new CABLES.Port(this, "a note off", CABLES.OP_PORT_TYPE_FUNCTION));
let ais_on = this.addInPort(new CABLES.Port(this, "ais note on", CABLES.OP_PORT_TYPE_FUNCTION));
let ais_off = this.addInPort(new CABLES.Port(this, "ais note off", CABLES.OP_PORT_TYPE_FUNCTION));
let b_on = this.addInPort(new CABLES.Port(this, "b note on", CABLES.OP_PORT_TYPE_FUNCTION));
let b_off = this.addInPort(new CABLES.Port(this, "b note off", CABLES.OP_PORT_TYPE_FUNCTION));

let frequency = this.addOutPort(new CABLES.Port(this, "frequency", CABLES.OP_PORT_TYPE_VALUE));
let isPressed = this.addOutPort(new CABLES.Port(this, "is pressed", CABLES.OP_PORT_TYPE_VALUE));

let OCTAVE_MIN = 1;
let OCTAVE_MAX = 7;

let toneFreqMap = [];

for (let i = OCTAVE_MIN; i <= OCTAVE_MAX; i++)
{
    toneFreqMap[i] = {};
}

// octave 1
toneFreqMap[1].c = 32.7032;
toneFreqMap[1].cis = 34.6478;
toneFreqMap[1].d = 36.7081;
toneFreqMap[1].dis = 38.8909;
toneFreqMap[1].e = 41.2034;
toneFreqMap[1].f = 43.6535;
toneFreqMap[1].fis = 46.2493;
toneFreqMap[1].g = 48.9994;
toneFreqMap[1].gis = 51.9131;
toneFreqMap[1].a = 55.0000;
toneFreqMap[1].ais = 58.2705;
toneFreqMap[1].b = 61.7354;
// octave 2
toneFreqMap[2].c = 65.4064;
toneFreqMap[2].cis = 69.2957;
toneFreqMap[2].d = 73.4162;
toneFreqMap[2].dis = 77.7817;
toneFreqMap[2].e = 82.4069;
toneFreqMap[2].f = 87.3071;
toneFreqMap[2].fis = 92.4986;
toneFreqMap[2].g = 97.9989;
toneFreqMap[2].gis = 103.826;
toneFreqMap[2].a = 110.000;
toneFreqMap[2].ais = 116.541;
toneFreqMap[2].b = 123.471;
// octave 3
toneFreqMap[3].c = 130.813;
toneFreqMap[3].cis = 138.591;
toneFreqMap[3].d = 146.832;
toneFreqMap[3].dis = 155.563;
toneFreqMap[3].e = 164.814;
toneFreqMap[3].f = 174.614;
toneFreqMap[3].fis = 184.997;
toneFreqMap[3].g = 195.998;
toneFreqMap[3].gis = 207.652;
toneFreqMap[3].a = 220.000;
toneFreqMap[3].ais = 233.082;
toneFreqMap[3].b = 246.942;
// octave 4
toneFreqMap[4].c = 261.626;
toneFreqMap[4].cis = 277.183;
toneFreqMap[4].d = 293.665;
toneFreqMap[4].dis = 311.127;
toneFreqMap[4].e = 329.628;
toneFreqMap[4].f = 349.228;
toneFreqMap[4].fis = 369.994;
toneFreqMap[4].g = 391.995;
toneFreqMap[4].gis = 415.305;
toneFreqMap[4].a = 440.000;
toneFreqMap[4].ais = 466.164;
toneFreqMap[4].b = 493.883;
// octave 5
toneFreqMap[5].c = 523.251;
toneFreqMap[5].cis = 554.365;
toneFreqMap[5].d = 587.330;
toneFreqMap[5].dis = 622.254;
toneFreqMap[5].e = 659.255;
toneFreqMap[5].f = 698.456;
toneFreqMap[5].fis = 739.989;
toneFreqMap[5].g = 783.991;
toneFreqMap[5].gis = 830.609;
toneFreqMap[5].a = 880.000;
toneFreqMap[5].ais = 932.328;
toneFreqMap[5].b = 987.767;
// octave 6
toneFreqMap[6].c = 1046.50;
toneFreqMap[6].cis = 1108.73;
toneFreqMap[6].d = 1174.66;
toneFreqMap[6].dis = 1244.51;
toneFreqMap[6].e = 1318.51;
toneFreqMap[6].f = 1396.91;
toneFreqMap[6].fis = 1479.98;
toneFreqMap[6].g = 1567.98;
toneFreqMap[6].gis = 1661.22;
toneFreqMap[6].a = 1760.00;
toneFreqMap[6].ais = 1864.66;
toneFreqMap[6].b = 1975.53;
// octave 7
toneFreqMap[7].c = 2093.00;
toneFreqMap[7].cis = 2217.46;
toneFreqMap[7].d = 2349.32;
toneFreqMap[7].dis = 2489.02;
toneFreqMap[7].e = 2637.02;
toneFreqMap[7].f = 2793.83;
toneFreqMap[7].fis = 2959.96;
toneFreqMap[7].g = 3135.96;
toneFreqMap[7].gis = 3322.44;
toneFreqMap[7].a = 3520.00;
toneFreqMap[7].ais = 3729.31;
toneFreqMap[7].b = 3951.07;

function octaveInRange(oct)
{
    return oct >= OCTAVE_MIN && oct <= OCTAVE_MAX;
}

function handleNoteOn(tone)
{
    let oct = parseInt(octave.get());
    if (octaveInRange(oct))
    {
        let freq = (toneFreqMap[oct][tone]);
        frequency.set(freq);
        isPressed.set(1.0);
        op.log("[note on] " + tone + oct + " (" + freq + "Hz)");
    }
}

c_on.onTriggered = function () { handleNoteOn("c"); };
cis_on.onTriggered = function () { handleNoteOn("cis"); };
d_on.onTriggered = function () { handleNoteOn("d"); };
dis_on.onTriggered = function () { handleNoteOn("dis"); };
e_on.onTriggered = function () { handleNoteOn("e"); };
f_on.onTriggered = function () { handleNoteOn("f"); };
fis_on.onTriggered = function () { handleNoteOn("fis"); };
g_on.onTriggered = function () { handleNoteOn("g"); };
gis_on.onTriggered = function () { handleNoteOn("gis"); };
a_on.onTriggered = function () { handleNoteOn("a"); };
ais_on.onTriggered = function () { handleNoteOn("ais"); };
b_on.onTriggered = function () { handleNoteOn("b"); };

function handleNoteOff(tone)
{
    let oct = parseInt(octave.get());
    if (octaveInRange(oct))
    {
        let freq = (toneFreqMap[oct][tone]);
        frequency.set(freq);
        isPressed.set(0.0);
        op.log("[note on] " + tone + oct + " (" + freq + "Hz)");
    }
}

c_off.onTriggered = function () { handleNoteOff("c"); };
cis_off.onTriggered = function () { handleNoteOff("cis"); };
d_off.onTriggered = function () { handleNoteOff("d"); };
dis_off.onTriggered = function () { handleNoteOff("dis"); };
e_off.onTriggered = function () { handleNoteOff("e"); };
f_off.onTriggered = function () { handleNoteOff("f"); };
fis_off.onTriggered = function () { handleNoteOff("fis"); };
g_off.onTriggered = function () { handleNoteOff("g"); };
gis_off.onTriggered = function () { handleNoteOff("gis"); };
a_off.onTriggered = function () { handleNoteOff("a"); };
ais_off.onTriggered = function () { handleNoteOff("ais"); };
b_off.onTriggered = function () { handleNoteOff("b"); };

let octave = this.addInPort(new CABLES.Port(this, "octave", CABLES.OP_PORT_TYPE_));

octave.set(4);
frequency.set(0);


};

Ops.WebAudio.KeyPiano.prototype = new CABLES.Op();
CABLES.OPS["9f7d2411-ed87-45be-95a7-e6759d51582d"]={f:Ops.WebAudio.KeyPiano,objName:"Ops.WebAudio.KeyPiano"};




// **************************************************************
// 
// Ops.WebAudio.MicrophoneIn_v2
// 
// **************************************************************

Ops.WebAudio.MicrophoneIn_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const cgl = op.patch.cgl;

let microphone = null;
const audioCtx = CABLES.WEBAUDIO.createAudioContext(op);

const inInit = op.inTriggerButton("Start");
const inInputDevices = op.inDropDown("Audio Input", ["None"]);
const inGain = op.inFloatSlider("Volume", 1);
const inMute = op.inBool("Mute", false);
const audioOut = op.outObject("Audio Out", null, "audioNode");
const recording = op.outBool("Listening", false);
const outDevices = op.outArray("List of Input Devices");

op.setPortGroup("Volume Settings", [inGain, inMute]);
let audioInputsLoaded = false;
let loadingId = null;

const gainNode = audioCtx.createGain();

function streamAudio(stream)
{
    microphone = audioCtx.createMediaStreamSource(stream);
    microphone.connect(gainNode);
    audioOut.set(gainNode);
    op.log("[microphoneIn] streaming mic audio!", stream, microphone);
    recording.set(true);
}

inGain.onChange = () =>
{
    if (inMute.get()) return;
    gainNode.gain.setValueAtTime(Number(inGain.get()) || 0, audioCtx.currentTime);
};

inMute.onChange = () =>
{
    if (inMute.get())
    {
        gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
    }
    else
    {
        gainNode.gain.setValueAtTime(Number(inGain.get()) || 0, audioCtx.currentTime);
    }
};

inInit.onTriggered = function ()
{
    if (!audioCtx)
    {
        op.log("[microphoneIn] no audiocontext!");
        return;
    }

    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
    {
        op.log("[microphoneIn] new micro");

        if (audioInputsLoaded)
        {
            op.setUiError("noAudioInputs", null);

            const device = inInputDevices.get();

            if (device === "None")
            {
                op.setUiError("noDeviceSelected", "No audio device selected!", 1);
                return;
            }
            else
            {
                op.setUiError("noDeviceSelected", null);
            }
            const constraints = {
                "audio": { "deviceId": device },
            };

            navigator.mediaDevices.getUserMedia(constraints)
                .then((stream) =>
                {
                    microphone = audioCtx.createMediaStreamSource(stream);
                    microphone.connect(gainNode);
                    audioOut.set(gainNode);
                    op.log("streaming mic audio!", stream, microphone, gainNode);
                    recording.set(true);
                    op.setUiError("devicesLoaded", null);
                })
                .catch((e) =>
                {
                    op.log("ERROR STREAMNG", e);
                });
        }
        else
        {
            op.setUiError("noAudioInputs", "There are no audio inputs to use the MicrophoneIn op with.", 2);
        }
    }
    else
    {
        // old method
        navigator.getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia);

        if (navigator.getUserMedia)
        {
            navigator.getUserMedia(
                { "audio": true },
                streamAudio,
                function (e)
                {
                    op.log("[microphoneIn]No live audio input " + e);
                    recording.set(false);
                }
            );
        }
        else
        {
            op.log("[op microphone] could not get usermedia");
            recording.set(false);
        }
    }
};

/* INIT FUNCTION */
loadingId = cgl.patch.loading.start("MIC inputs", "");
navigator.mediaDevices.getUserMedia({ "audio": true })
    .then((res) =>
        navigator.mediaDevices.enumerateDevices())
    .then((devices) =>
    {
        const audioInputDevices = devices
            .filter((device) => device.kind === "audioinput")
            .map((deviceInfo, index) => deviceInfo.label || `microphone ${index + 1}`);

        inInputDevices.uiAttribs.values = audioInputDevices;
        op.setUiError("devicesLoaded", "Input devices have been loaded. Please choose a device from the dropdown menu and click the \"Start\" button to activate the microphone input.", 0);
        cgl.patch.loading.finished(loadingId);
        audioInputsLoaded = true;
        outDevices.set(null);
        outDevices.set(audioInputDevices);
    })
    .catch((e) =>
    {
        op.log("error", e);
        cgl.patch.loading.finished(loadingId);
        audioInputsLoaded = false;
    });


};

Ops.WebAudio.MicrophoneIn_v2.prototype = new CABLES.Op();
CABLES.OPS["cbfbbffd-a5a8-4b21-bcb5-5d031cc5e11a"]={f:Ops.WebAudio.MicrophoneIn_v2,objName:"Ops.WebAudio.MicrophoneIn_v2"};




// **************************************************************
// 
// Ops.WebAudio.MidiValueToFrequency
// 
// **************************************************************

Ops.WebAudio.MidiValueToFrequency = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    midiValuePort = op.inValue("MIDI Value"),
    tuningPort = op.inValue("Tuning", 440),
    frequencyPort = op.outNumber("Frequency");

midiValuePort.onChange =
    tuningPort.onChange = setFrequency;

function setFrequency()
{
    let frequency = freq(tuningPort.get(), midiValuePort.get());
    frequencyPort.set(frequency);
}

// Taken from danigb - https://github.com/danigb/midi-freq
function freq(tuning, midi)
{
    tuning = tuning || 440;
    if (arguments.length > 1) return freq(tuning)(midi);

    return function (m)
    {
        return m === 0 || (m > 0 && m < 128) ? Math.pow(2, (m - 69) / 12) * tuning : null;
    };
}


};

Ops.WebAudio.MidiValueToFrequency.prototype = new CABLES.Op();
CABLES.OPS["751c0067-e015-4f73-90b1-2d265b6e6d72"]={f:Ops.WebAudio.MidiValueToFrequency,objName:"Ops.WebAudio.MidiValueToFrequency"};




// **************************************************************
// 
// Ops.WebAudio.Mixer
// 
// **************************************************************

Ops.WebAudio.Mixer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function clamp(val, min, max)
{
    return Math.min(Math.max(val, min), max);
}

const audioCtx = CABLES.WEBAUDIO.createAudioContext(op);

const inAudio0 = op.inObject("Audio In 0", null, "audioNode");
const inAudio1 = op.inObject("Audio In 1", null, "audioNode");
const inAudio2 = op.inObject("Audio In 2", null, "audioNode");
const inAudio3 = op.inObject("Audio In 3", null, "audioNode");
const inAudio4 = op.inObject("Audio In 4", null, "audioNode");
const inAudio5 = op.inObject("Audio In 5", null, "audioNode");
const inAudio6 = op.inObject("Audio In 6", null, "audioNode");
const inAudio7 = op.inObject("Audio In 7", null, "audioNode");

const inAudio0Gain = op.inFloatSlider("In 0 Gain", 1);
const inAudio1Gain = op.inFloatSlider("In 1 Gain", 1);
const inAudio2Gain = op.inFloatSlider("In 2 Gain", 1);
const inAudio3Gain = op.inFloatSlider("In 3 Gain", 1);
const inAudio4Gain = op.inFloatSlider("In 4 Gain", 1);
const inAudio5Gain = op.inFloatSlider("In 5 Gain", 1);
const inAudio6Gain = op.inFloatSlider("In 6 Gain", 1);
const inAudio7Gain = op.inFloatSlider("In 7 Gain", 1);

const inAudio0Pan = op.inFloat("In 0 Pan", 0);
const inAudio1Pan = op.inFloat("In 1 Pan", 0);
const inAudio2Pan = op.inFloat("In 2 Pan", 0);
const inAudio3Pan = op.inFloat("In 3 Pan", 0);
const inAudio4Pan = op.inFloat("In 4 Pan", 0);
const inAudio5Pan = op.inFloat("In 5 Pan", 0);
const inAudio6Pan = op.inFloat("In 6 Pan", 0);
const inAudio7Pan = op.inFloat("In 7 Pan", 0);

const inMasterGain = op.inFloatSlider("Output Gain", 1);

let isIOS = false;
let panNode = null;

let createPanner = () => {};
if (audioCtx.createStereoPanner)
{
    isIOS = false;
}
else
{
    isIOS = true;
}

const audioOut = op.outObject("Audio Out", null, "audioNode");

const gain = audioCtx.createGain();
audioOut.set(gain);

const N_PORTS = 8;

const audioIns = [inAudio0, inAudio1, inAudio2, inAudio3, inAudio4, inAudio5, inAudio6, inAudio7];
const audioInGains = [inAudio0Gain, inAudio1Gain, inAudio2Gain, inAudio3Gain, inAudio4Gain, inAudio5Gain, inAudio6Gain, inAudio7Gain];
const audioInPans = [inAudio0Pan, inAudio1Pan, inAudio2Pan, inAudio3Pan, inAudio4Pan, inAudio5Pan, inAudio6Pan, inAudio7Pan];
op.setPortGroup("Audio Inputs", audioIns);
op.setPortGroup("Input", audioInGains);
op.setPortGroup("Panning", audioInPans);
op.setPortGroup("Output ", [inMasterGain]);
const oldAudioIns = audioIns.map(() => ({ "node": null, "isConnected": false }));

audioInGains.forEach((port, index) =>
{
    port.gainNode = audioCtx.createGain();
    port.onChange = () => port.gainNode.gain.linearRampToValueAtTime((audioInGains[index].get() || 0), audioCtx.currentTime + 0.01);
});

audioInPans.forEach((port, index) =>
{
    if (isIOS)
    {
        port.panNode = audioCtx.createPanner();
        port.panNode.panningModel = "equalpower";
    }
    else
    {
        port.panNode = audioCtx.createStereoPanner();
    }

    port.panNode.connect(audioInGains[index].gainNode);

    port.onChange = () =>
    {
        const panning = clamp(audioInPans[index].get(), -1, 1);
        if (!isIOS) port.panNode.pan.linearRampToValueAtTime(panning, audioCtx.currentTime + 0.01);
        else port.panNode.setPosition(panning, 0, 1 - Math.abs(panning));
    };
});

audioIns.forEach((port, index) =>
{
    port.onChange = () =>
    {
        const audioNode = audioIns[index].get();
        try
        {
            if (audioNode)
            {
                if (audioNode.connect)
                {
                    const bufferedNode = oldAudioIns[index];
                    bufferedNode.node = audioNode;
                    const gainNodePort = audioInGains[index].gainNode;
                    const panNodePort = audioInPans[index].panNode;

                    if (!bufferedNode.isConnected)
                    {
                        bufferedNode.node.connect(panNodePort);
                        gainNodePort.connect(gain);
                        bufferedNode.isConnected = true;
                    }
                }
            }
            else
            {
                const bufferedNode = oldAudioIns[index];
                const gainNodePort = audioInGains[index].gainNode;
                const panNodePort = audioInPans[index].panNode;

                if (bufferedNode.isConnected)
                {
                    bufferedNode.node.disconnect(panNodePort);
                    gainNodePort.disconnect(gain);
                    bufferedNode.isConnected = false;
                }
            }
        }
        catch (e)
        {
            op.log(e);
        }
    };

    port.audioInPortNr = index;
});

inMasterGain.onChange = () => gain.gain.linearRampToValueAtTime((inMasterGain.get() || 0), audioCtx.currentTime + 0.01);

op.onDelete = () =>
{
    for (let i = 0; i < audioInPans.length; i += 1)
    {
        audioInPans[i].panNode.disconnect();
    }
};


};

Ops.WebAudio.Mixer.prototype = new CABLES.Op();
CABLES.OPS["363980dc-39b8-4690-8b8d-bff954f65d49"]={f:Ops.WebAudio.Mixer,objName:"Ops.WebAudio.Mixer"};




// **************************************************************
// 
// Ops.WebAudio.MusicalScales
// 
// **************************************************************

Ops.WebAudio.MusicalScales = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function clamp(val, min, max)
{
    return Math.min(Math.max(val, min), max);
}

// constants
const NOTE_NUMBERS = [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];

const BASE_TONES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
const BASE_TONE_DEFAULT = "C";
const SCALE_TYPE_DEFAULT = "Minor";
const APPEND_OCTAVE_DEFAULT = true;
const OCTAVE_DEFAULT = 4;
const OCTAVE_MIN = -1;
const OCTAVE_MAX = 9;
const INCLUDE_HIGH_BASE_TONE_DEFAULT = false;

// scale types taken from: https://github.com/stagas/scales/blob/master/index.js
const SCALE_TYPES = {
    "Major": [0, 2, 4, 5, 7, 9, 11],
    "Minor": [0, 2, 3, 5, 7, 8, 10],
    "Ionian": [0, 2, 4, 5, 7, 9, 11],
    "Aeolian": [0, 2, 3, 5, 7, 8, 10],
    "Dorian": [0, 2, 3, 5, 7, 9, 10],
    "Mixolydian": [0, 2, 4, 5, 7, 9, 10],
    "Lydian": [0, 2, 4, 6, 7, 9, 11],
    "Phrygian": [0, 1, 3, 5, 7, 8, 10],
    "Locrian": [0, 1, 3, 5, 6, 8, 10],
    "Diminished": [0, 1, 3, 4, 6, 7, 9, 10],
    "Whole Half": [0, 2, 3, 5, 6, 8, 9, 11],
    "Whole Tone": [0, 2, 4, 6, 8, 10],
    "Minor Blues": [0, 3, 5, 6, 7, 10],
    "Minor Pentatonic": [0, 3, 5, 7, 10],
    "Major Pentatonic": [0, 2, 4, 7, 9],
    "Harmonic Minor": [0, 2, 3, 5, 7, 8, 11],
    "Melodic Minor": [0, 2, 3, 5, 7, 9, 11],
    "Super Locrian": [0, 1, 3, 4, 6, 8, 10],
    "Bhairav": [0, 1, 4, 5, 7, 8, 11],
    "Hungarian Minor": [0, 2, 3, 6, 7, 8, 11],
    "Minor Gypsy": [0, 1, 4, 5, 7, 8, 10],
    "Hirojoshi": [0, 2, 3, 7, 8],
    "In Sen": [0, 1, 5, 7, 10],
    "Iwato": [0, 1, 5, 6, 10],
    "Kumoi": [0, 2, 3, 7, 9],
    "Pelog": [0, 1, 3, 4, 7, 8],
    "Spanish": [0, 1, 3, 4, 5, 6, 8, 10],
    "Ion Aeol": [0, 2, 3, 4, 5, 7, 8, 9, 10, 11]
};

// input
const baseTonePort = op.inDropDown("Root Note", BASE_TONES, BASE_TONE_DEFAULT);
const scaleTypePort = op.inDropDown("Scale Type", Object.keys(SCALE_TYPES), SCALE_TYPE_DEFAULT);
const includeHighBaseTonePort = op.inBool("Include Upper Root Note", INCLUDE_HIGH_BASE_TONE_DEFAULT);
const octavePort = op.inInt("Octave", OCTAVE_DEFAULT);
const appendOctavePort = op.inBool("Append Octave To Names", APPEND_OCTAVE_DEFAULT);

op.setPortGroup("Scale Settings", [baseTonePort, scaleTypePort, includeHighBaseTonePort, octavePort, appendOctavePort]);

// output
const outNoteNames = op.outArray("Note Names Array");
const outNoteSteps = op.outArray("Note Step Number Array");
const outMidiNotes = op.outArray("Midi Note Array");
const outCurrentScale = op.outString("Current Scale");
// change listeners
baseTonePort.onChange = scaleTypePort.onChange = octavePort.onChange
= appendOctavePort.onChange = includeHighBaseTonePort.onChange = setOutput;

// functions
function getToneAt(index, offset)
{
    let i = index + offset;
    if (i >= BASE_TONES.length)
    {
        i -= BASE_TONES.length;
    }
    return BASE_TONES[i];
}

function getToneIndex(tone)
{
    for (let i = 0; i < BASE_TONES.length; i++)
    {
        if (BASE_TONES[i] === tone)
        {
            return i;
        }
    }
    return -1;
}

function setOutput()
{
    const baseTone = baseTonePort.get();
    const baseToneIndex = getToneIndex(baseTone);
    const scaleType = scaleTypePort.get();

    if (SCALE_TYPES.hasOwnProperty(scaleType) && BASE_TONES.indexOf(baseTone) > -1)
    {
        const scale = SCALE_TYPES[scaleType];
        const noteNamesArray = [];
        const noteStepsArray = [];
        const appendOctave = appendOctavePort.get();
        let octave = octavePort.get();

        if (octave > OCTAVE_MAX) op.setUiError("octave", "Octave value higher than " + OCTAVE_MAX + ". Setting to " + OCTAVE_MAX + ". Highest midi note is 127.", 1);
        else if (octave < OCTAVE_MIN) op.setUiError("octave", "Octave value lower than " + OCTAVE_MIN + ". Setting to " + OCTAVE_MIN + ". Lowest midi note is 0.", 1);
        else op.setUiError("octave", null);

        octave = clamp(Math.round(octave), OCTAVE_MIN, OCTAVE_MAX);

        for (let i = 0; i < scale.length; i++)
        {
            noteNamesArray.push(getToneAt(scale[i], baseToneIndex) + (appendOctave ? octave : ""));
            noteStepsArray.push(scale[i]);
        }

        // append the base tone in the next octave
        if (includeHighBaseTonePort.get())
        {
            noteStepsArray.push(scale[0] + 12);
            noteNamesArray.push(getToneAt(scale[0], baseToneIndex) + (appendOctave ? octave + 1 : ""));
        }

        const midiNotes = NOTE_NUMBERS
            .filter((nr) => noteStepsArray.includes(nr - 12)) // only get scale notes
            .map((nr) => nr + BASE_TONES.indexOf(baseTone) + 12 * octave) // map to midi note number
            .filter((midiNote) => midiNote <= 127); // only use values <= 127 (highest possible midi note)

        outNoteNames.set(null);
        outNoteNames.set(noteNamesArray);

        outNoteSteps.set(null);
        outNoteSteps.set(noteStepsArray);

        outMidiNotes.set(null);
        outMidiNotes.set(midiNotes);

        outCurrentScale.set(scaleTypePort.get());
    }
}

setOutput();


};

Ops.WebAudio.MusicalScales.prototype = new CABLES.Op();
CABLES.OPS["9e8c08d9-8c9a-4cff-8e5b-05c72d1f8522"]={f:Ops.WebAudio.MusicalScales,objName:"Ops.WebAudio.MusicalScales"};




// **************************************************************
// 
// Ops.WebAudio.Output_v2
// 
// **************************************************************

Ops.WebAudio.Output_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inAudio = op.inObject("Audio In", null, "audioNode"),
    inGain = op.inFloatSlider("Volume", 1),
    inMute = op.inBool("Mute", false),
    inShowSusp = op.inBool("Show Audio Suspended Button", true),
    outVol = op.outNumber("Current Volume", 0),
    outState = op.outString("Context State", "unknown");

op.setPortGroup("Volume Settings", [inMute, inGain]);

let isSuspended = false;
let audioCtx = CABLES.WEBAUDIO.createAudioContext(op);
let gainNode = audioCtx.createGain();
const destinationNode = audioCtx.destination;
let oldAudioIn = null;
let connectedToOut = false;
// let fsElement = null;

inMute.onChange = () =>
{
    mute(inMute.get());
};

inGain.onChange = setVolume;
op.onMasterVolumeChanged = setVolume;

let pauseId = op.patch.on("pause", setVolume);
let resumeId = op.patch.on("resume", setVolume);

audioCtx.addEventListener("statechange", updateStateError);
inShowSusp.onChange = updateAudioStateButton;

updateStateError();
updateAudioStateButton();

op.onDelete = () =>
{
    if (gainNode) gainNode.disconnect();
    gainNode = null;
    CABLES.interActionNeededButton.remove("audiosuspended");
    if (pauseId) op.patch.off(pauseId);
    if (resumeId) op.patch.off(resumeId);
};

inAudio.onChange = function ()
{
    if (!inAudio.get())
    {
        if (oldAudioIn)
        {
            try
            {
                if (oldAudioIn.disconnect)
                {
                    oldAudioIn.disconnect(gainNode);
                }
            }
            catch (e)
            {
                op.logError(e);
            }
        }

        op.setUiError("multipleInputs", null);

        if (connectedToOut)
        {
            if (gainNode)gainNode.disconnect(destinationNode);
            connectedToOut = false;
        }
    }
    else
    {
        if (inAudio.links.length > 1) op.setUiError("multipleInputs", "You have connected multiple inputs. It is possible that you experience unexpected behaviour. Please use a Mixer op to connect multiple audio streams.", 1);
        else op.setUiError("multipleInputs", null);

        if (inAudio.get().connect) inAudio.get().connect(gainNode);
    }

    oldAudioIn = inAudio.get();

    if (!connectedToOut)
    {
        if (gainNode)gainNode.connect(destinationNode);
        connectedToOut = true;
    }

    setVolume();
};

function setVolume(fromMute)
{
    const masterVolume = op.patch.config.masterVolume || 0;

    let volume = inGain.get() * masterVolume;

    if (op.patch._paused || inMute.get()) volume = 0;

    let addTime = 0.05;
    if (fromMute) addTime = 0.2;

    volume = CABLES.clamp(volume, 0, 1);

    if (!gainNode)
        op.logError("gainNode undefined");

    if (gainNode) gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + addTime);

    outVol.set(volume);
}

function mute(b)
{
    if (b)
    {
        if (audioCtx.state === "suspended")
        { // make sure that when audio context is suspended node will also be muted
            // this prevents the initial short sound burst being heard when context is suspended
            // and started from user interaction
            // also note, we have to cancle the already scheduled values as we have no influence over
            // the order in which onchange handlers are executed

            if (gainNode)
            {
                gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
                gainNode.gain.value = 0;
                gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            }

            outVol.set(0);

            return;
        }
    }

    setVolume(true);
}

function updateStateError()
{
    outState.set(audioCtx.state);
    op.logVerbose("audioCtx.state change", audioCtx.state);

    if (audioCtx.state == "suspended") op.setUiError("ctxSusp", "Your Browser suspended audio context, use playButton op to play audio after a user interaction");
    else op.setUiError("ctxSusp", null);

    updateAudioStateButton();
}

function updateAudioStateButton()
{
    if (audioCtx.state == "suspended")
    {
        mute(true);
        if (inShowSusp.get())
        {
            isSuspended = true;

            CABLES.interActionNeededButton.add(op.patch, "audiosuspended", () =>
            {
                if (audioCtx && audioCtx.state == "suspended")
                {
                    audioCtx.resume();
                    CABLES.interActionNeededButton.remove("audiosuspended");
                }
            });
        }
        else
        {
            CABLES.interActionNeededButton.remove("audiosuspended");
        }
    }
    else
    {
        CABLES.interActionNeededButton.remove("audiosuspended");

        if (isSuspended)
        {
            op.log("was suspended - set vol");
            setVolume(true);
        }
    }
}


};

Ops.WebAudio.Output_v2.prototype = new CABLES.Op();
CABLES.OPS["90b95403-b0c4-4980-ab3b-b6c354771c81"]={f:Ops.WebAudio.Output_v2,objName:"Ops.WebAudio.Output_v2"};




// **************************************************************
// 
// Ops.WebAudio.SamplePlayer
// 
// **************************************************************

Ops.WebAudio.SamplePlayer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function clamp(value, min, max)
{
    return Math.min(Math.max(value, min), max);
}

const audioCtx = CABLES.WEBAUDIO.createAudioContext(op);

// input ports
const audioBufferPort = op.inObject("Audio Buffer", null, "audioBuffer");
const inTrigger = op.inTriggerButton("Play Sample");
const inTriggerStop = op.inTriggerButton("Stop Playback");
const offsetPort = op.inValue("Offset", 0);
const maxSamples = op.inInt("Buffer Size", 32);
const playbackRatePort = op.inValue("Playback Rate", 1);
const detunePort = op.inValue("Detune", 0);

op.setPortGroup("Time Controls", [offsetPort]);
op.setPortGroup("Miscellaneous", [playbackRatePort, detunePort]);
// output ports
const audioOutPort = op.outObject("Audio Out", null, "audioNode");
const outPlaying = op.outBool("Is Playing", false);

if (!audioBufferPort.isLinked())
{
    op.setUiError("inputNotConnected", "To be able to play back sound, you need to connect an AudioBuffer to this op.", 0);
}
else
{
    op.setUiError("inputNotConnected", null);
}

audioBufferPort.onLinkChanged = () =>
{
    if (!audioBufferPort.isLinked())
    {
        op.setUiError("inputNotConnected", "To be able to play back sound, you need to connect an AudioBuffer to this op.", 0);
    }
    else
    {
        op.setUiError("inputNotConnected", null);
    }
};

if (!audioOutPort.isLinked())
{
    op.setUiError("outputNotConnected", "To be able to hear sound playing, you need to connect this op to an Output op.", 0);
}
else
{
    op.setUiError("outputNotConnected", null);
}

audioOutPort.onLinkChanged = () =>
{
    if (!audioOutPort.isLinked())
    {
        op.setUiError("outputNotConnected", "To be able to hear sound playing, you need to connect this op to an Output op.", 0);
    }
    else
    {
        op.setUiError("outputNotConnected", null);
    }
};

// vars
let isPlaying = false;

const gainNode = audioCtx.createGain();

let sourceSize = maxSamples.get() || 32;
let SOURCES = new Array(sourceSize).fill(0).map(() =>
    ({
        "bufferSource": audioCtx.createBufferSource(),
        "isPlaying": false,
        "gainNode": audioCtx.createGain(),
        "isGainNodeConnected": false
    }));
let SOURCES_LENGTH = SOURCES.length;

maxSamples.onChange = () =>
{
    op.setUiError("maxSamples", null);
    if (!maxSamples.get() || maxSamples.get < 1 || maxSamples.get() > 32)
    {
        op.setUiError("maxSamples", "Buffer Size needs to be a number (1-32)");
    }
    sourceSize = maxSamples.get() || 32;
    SOURCES = new Array(sourceSize).fill(0).map(() =>
        ({
            "bufferSource": audioCtx.createBufferSource(),
            "isPlaying": false,
            "gainNode": audioCtx.createGain(),
            "isGainNodeConnected": false
        }));
    SOURCES_LENGTH = SOURCES.length;
    currentSample = 0;
    createAudioBufferSources();
};

detunePort.onChange = playbackRatePort.onChange = () =>
{
    op.setUiError("playbackRate", null);
    if (playbackRatePort.get() < 0)
    {
        op.setUiError("playbackRate", "Playback Rate needs to be a positive number");
    }
    try
    {
        SOURCES.forEach((src) =>
        {
        /* playback rate */
            const playbackRate = clamp(playbackRatePort.get(), 0.01, 4);
            if (
                playbackRate >= src.bufferSource.playbackRate.minValue
            && playbackRate <= src.bufferSource.playbackRate.maxValue
            )
            {
                src.bufferSource.playbackRate.setValueAtTime(
                    playbackRate,
                    audioCtx.currentTime + 0.01
                );
            }

            /* detune */
            const detune = detunePort.get();
            if (src.bufferSource.detune)
            {
                src.bufferSource.detune.setValueAtTime(
                    detune,
                    audioCtx.currentTime + 0.01
                );
            }
        });
    }
    catch (e)
    {
        op.log("err in param change", e);
    }
};

function createAudioBufferSources()
{
    const buffer = audioBufferPort.get();
    if (!buffer) return;

    for (let i = 0; i < SOURCES_LENGTH; i += 1)
    {
        const src = SOURCES[i];
        createSingleSource(src);
    }

    audioOutPort.set(gainNode);
}

function createSingleSource(src)
{
    const buffer = audioBufferPort.get();
    if (!buffer) return;
    if (src.isPlaying) return;

    if (src.isGainNodeConnected) src.bufferSource.disconnect(src.gainNode);

    src.bufferSource = audioCtx.createBufferSource();

    /* end callback */
    src.bufferSource.onended = () =>
    {
        src.isPlaying = false;
        outPlaying.set(SOURCES.some((src) => src.isPlaying === true));
        createSingleSource(src);
    };

    src.bufferSource.buffer = buffer;
    src.bufferSource.loop = false;

    /* playback rate */
    const playbackRate = clamp(playbackRatePort.get(), 0.01, 4);
    if (
        playbackRate >= src.bufferSource.playbackRate.minValue
        && playbackRate <= src.bufferSource.playbackRate.maxValue
    )
    {
        src.bufferSource.playbackRate.setValueAtTime(
            playbackRate,
            audioCtx.currentTime
        );
    }

    /* detune */
    const detune = detunePort.get();
    if (src.bufferSource.detune)
    {
        src.bufferSource.detune.setValueAtTime(
            detune,
            audioCtx.currentTime
        );
    }

    src.bufferSource.connect(src.gainNode);
    src.gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
    src.gainNode.connect(gainNode);
    src.isGainNodeConnected = true;
}

let currentSample = 0;
inTrigger.onTriggered = () =>
{
    if (!maxSamples.get() || maxSamples.get < 1 || maxSamples.get() > 32) return;
    if (playbackRatePort.get() < 0) return;

    if (!audioBufferPort.get() || !(audioBufferPort.get() instanceof AudioBuffer)) return;
    try
    {
        const time = 0;
        const offset = Number(offsetPort.get());

        if (!SOURCES[currentSample].isPlaying)
        {
            SOURCES[currentSample].bufferSource.start(Math.max(0, time), Math.max(0, offset));
            SOURCES[currentSample].gainNode.gain.linearRampToValueAtTime(1.0, audioCtx.currentTime + 0.01);
            SOURCES[currentSample].isPlaying = true;
            outPlaying.set(true);
        }

        currentSample += 1;
        currentSample %= SOURCES_LENGTH;
    }
    catch (e)
    {
        op.setUiError(e);
        op.log("Error: ", e);
        outPlaying.set(false);
    }
};

inTriggerStop.onTriggered = () =>
{
    SOURCES.forEach((src, index) =>
    {
        if (src.isPlaying && src.bufferSource) src.bufferSource.stop();
        src.isPlaying = false;
    });
    outPlaying.set(false);
};

inTrigger.onLinkChanged = () =>
{
    if (!inTrigger.isLinked())
    {
        SOURCES.forEach((src, index) =>
        {
            if (src.isPlaying && src.bufferSource) src.bufferSource.stop();
            src.isPlaying = false;
        });
        outPlaying.set(false);
    }
};
// change listeners
audioBufferPort.onChange = function ()
{
    if (audioBufferPort.get())
    {
        if ((audioBufferPort.get() instanceof AudioBuffer))
        {
            createAudioBufferSources();
        }
    }
    else
    {
        SOURCES.forEach((src) =>
        {
            if (src.bufferSource && src.isGainNodeConnected)
            {
                src.bufferSource.disconnect(src.gainNode);
                src.gainNode.disconnect(gainNode);
                src.isGainNodeConnected = false;
            }
            src.bufferSource = null;
        });

        outPlaying.set(false);
    }
};


};

Ops.WebAudio.SamplePlayer.prototype = new CABLES.Op();
CABLES.OPS["47796760-f211-47f5-9d6b-cc9cd6944897"]={f:Ops.WebAudio.SamplePlayer,objName:"Ops.WebAudio.SamplePlayer"};




// **************************************************************
// 
// Ops.WebAudio.TextToSpeech.Say_v2
// 
// **************************************************************

Ops.WebAudio.TextToSpeech.Say_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

// default / min /max values
let PITCH_DEFAULT = 1;
let PITCH_MIN = 0;
let PITCH_MAX = 2;
let RATE_DEFAULT = 1;
let RATE_MIN = 0.1;
let RATE_MAX = 10;
let VOLUME_DEFAULT = 1;
let VOLUME_MIN = 0;
let VOLUME_MAX = 1;

// vars
let synth = window.speechSynthesis;
let voiceMap = getVoiceMap(synth.getVoices());
let voiceMapKeys = Object.keys(voiceMap);

// inputs
let updateStatePort = op.inTrigger("Update State");
let textPort = op.inString("Text", "Wazzup");
let triggerPort = op.inTriggerButton("Say");
let voicePort = op.inDropDown("Voice", voiceMapKeys);
let pitchPort = op.inFloatSlider("Pitch", PITCH_DEFAULT, PITCH_MIN, PITCH_MAX);
let ratePort = op.inFloatSlider("Rate", RATE_DEFAULT, RATE_MIN, RATE_MAX);
let volumePort = op.inFloatSlider("Volume", VOLUME_DEFAULT, VOLUME_MIN, VOLUME_MAX);

let sayOnTextChangePort = op.inBool("Say on Text Change", false);
let pausePort = op.inTriggerButton("Pause");
let resumePort = op.inTriggerButton("Resume");
let cancelPort = op.inTriggerButton("Cancel");

// outputs
let nextPort = op.outTrigger("Next");
let speakingPort = op.outBoolNum("Speaking", false);
let pendingPort = op.outBoolNum("Pending", false);
let pausedPort = op.outBoolNum("Paused", false);

// change listeners
updateStatePort.onTriggered = updateState;
triggerPort.onTriggered = say;
sayOnTextChangePort.onChange = function ()
{
    if (sayOnTextChangePort.get())
    {
        textPort.onChange = say;
    }
    else
    {
        textPort.onChange = function () {}; // don't do anything
    }
};
pausePort.onTriggered = function ()
{
    synth.pause();
};
resumePort.onTriggered = function ()
{
    synth.resume();
};
cancelPort.onTriggered = function ()
{
    synth.cancel();
};

// voices loaded callback (async)
window.speechSynthesis.onvoiceschanged = function ()
{
    voiceMap = getVoiceMap(synth.getVoices());
    voiceMapKeys = Object.keys(voiceMap);
    if (CABLES.UI)
    {
        voicePort.uiAttribs.values = voiceMapKeys; // update dropdown values
        op.refreshParams(); // update visible dropdown menu
    }
};

/**
 * Updates the state output ports
 */
function updateState()
{
    speakingPort.set(synth.speaking);
    pendingPort.set(synth.pending);
    pausedPort.set(synth.paused);
    nextPort.trigger();
}

/**
 * says the text from text-port using voice voice
 */
function say()
{
    let text = textPort.get();
    let voice;
    let voiceDisplayName = voicePort.get();
    if (voiceDisplayName && voiceMap.hasOwnProperty(voiceDisplayName))
    { // voices are loaded async, at start it may not be there
        voice = voiceMap[voiceDisplayName];
    }
    let utterance = new SpeechSynthesisUtterance(text);
    if (voice)
    {
        utterance.voice = voice;
    }
    let pitch = pitchPort.get();
    if (pitch < PITCH_MIN) { pitch = PITCH_MIN; }
    else if (pitch > PITCH_MAX) { pitch = PITCH_MAX; }
    utterance.pitch = pitch;
    let rate = ratePort.get();
    if (rate < RATE_MIN) { rate = RATE_MIN; }
    else if (rate > RATE_MAX) { rate = RATE_MAX; }
    utterance.rate = rate;
    let volume = volumePort.get();
    if (volume < VOLUME_MIN) { volume = VOLUME_MIN; }
    else if (volume > VOLUME_MAX) { volume = VOLUME_MAX; }
    utterance.volume = volume;
    synth.speak(utterance);
}

/**
 * Returns a map of voices
 * e.g. { "Alex (de-DE)": { voice object }, ...}
 */
function getVoiceMap(voices)
{
    let ret = {};
    if (!voices || voices.length === 0) { return ret; }

    voices.forEach(function (voice)
    {
        let key = voice.name + " (" + voice.lang + ")";
        ret[key] = voice;
    });
    return ret;
}


};

Ops.WebAudio.TextToSpeech.Say_v2.prototype = new CABLES.Op();
CABLES.OPS["eb71ad36-9756-449b-89e6-54bf5c944d81"]={f:Ops.WebAudio.TextToSpeech.Say_v2,objName:"Ops.WebAudio.TextToSpeech.Say_v2"};




// **************************************************************
// 
// Ops.WebAudio.ThreeBandEqualizer
// 
// **************************************************************

Ops.WebAudio.ThreeBandEqualizer = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
function clamp(val, min, max)
{
    return Math.min(Math.max(val, min), max);
}

let audioContext = CABLES.WEBAUDIO.createAudioContext(op);

// default values + min and max
const FREQUENCY_MIN = 10;
const FREQUENCY_MAX = audioContext.sampleRate / 2; // Nyquist frequency.
const Q_MIN = 0.0001;
const Q_MAX = 1000;
const GAIN_MIN = -40;
const GAIN_MAX = 40;

const inAudio = op.inObject("Audio In", null, "audioNode");

const inLowFilterType = op.inDropDown("Low Filter Type", ["peaking", "lowshelf"], "lowshelf");
const inLowFrequency = op.inFloat("Low Frequency", 250);
const inLowQ = op.inFloat("Low Q", 0.0001);
const inLowGain = op.inFloat("Low Gain", 0);
op.setPortGroup("Low", [inLowFilterType, inLowFrequency, inLowQ, inLowGain]);

const inMidFilterType = op.inDropDown("Mid Filter Type", ["peaking", "notch"], "peaking");
const inMidFrequency = op.inFloat("Mid Frequency", 1000);
const inMidQ = op.inFloat("Mid Q", 0.0001);
const inMidGain = op.inFloat("Mid Gain", 0);
op.setPortGroup("Mid", [inMidFilterType, inMidFrequency, inMidQ, inMidGain]);

const inHighFilterType = op.inDropDown("High Filter Type", ["peaking", "highshelf"], "highshelf");
const inHighFrequency = op.inFloat("High Frequency", 5000);
const inHighQ = op.inFloat("High Q", 0.0001);
const inHighGain = op.inFloat("High Gain", 0);
op.setPortGroup("High", [inHighFilterType, inHighFrequency, inHighQ, inHighGain]);

const lowFilterNode = audioContext.createBiquadFilter();
const midFilterNode = audioContext.createBiquadFilter();
const highFilterNode = audioContext.createBiquadFilter();
lowFilterNode.connect(midFilterNode);
midFilterNode.connect(highFilterNode);

lowFilterNode.type = inLowFilterType.get();
midFilterNode.type = inMidFilterType.get();
highFilterNode.type = inHighFilterType.get();
const FILTER_TYPES = [
    { "node": lowFilterNode, "port": inLowFilterType },
    { "node": midFilterNode, "port": inMidFilterType },
    { "node": highFilterNode, "port": inHighFilterType }
];

const FILTER_FREQUENCIES = [
    { "node": lowFilterNode, "port": inLowFrequency, "name": "low" },
    { "node": midFilterNode, "port": inMidFrequency, "name": "mid" },
    { "node": highFilterNode, "port": inHighFrequency, "name": "high" }
];

const FILTER_QS = [
    { "node": lowFilterNode, "port": inLowQ, "name": "low" },
    { "node": midFilterNode, "port": inMidQ, "name": "mid" },
    { "node": highFilterNode, "port": inHighQ, "name": "high" }
];

const FILTER_GAINS = [
    { "node": lowFilterNode, "port": inLowGain, "name": "low" },
    { "node": midFilterNode, "port": inMidGain, "name": "mid" },
    { "node": highFilterNode, "port": inHighGain, "name": "high" }
];

FILTER_TYPES.forEach((obj, index) =>
{
    /* initial greyout-ing */
    const type = obj.port.get();

    FILTER_GAINS[index].port.setUiAttribs({
        "greyout": ["lowpass", "highpass", "bandpass", "notch", "allpass"].includes(type)
    });

    FILTER_QS[index].port.setUiAttribs({
        "greyout": ["lowshelf", "highshelf"].includes(type)
    });

    /* onChange handler */
    obj.port.onChange = () =>
    {
        const type = obj.port.get();
        FILTER_GAINS[index].port.setUiAttribs({
            "greyout": ["lowpass", "highpass", "bandpass", "notch", "allpass"].includes(type)
        });

        FILTER_QS[index].port.setUiAttribs({
            "greyout": ["lowshelf", "highshelf"].includes(type)
        });

        obj.node.type = type;
    };
});

FILTER_FREQUENCIES.forEach((obj, index) =>
{
    obj.port.onChange = () =>
    {
        const freq = obj.port.get();
        if (freq)
        {
            if (freq >= FREQUENCY_MIN && freq <= FREQUENCY_MAX)
            {
                obj.node.frequency.setValueAtTime(clamp(freq, FREQUENCY_MIN, FREQUENCY_MAX), audioContext.currentTime);
                op.setUiError("freqRange", null);
            }
            if (freq < FREQUENCY_MIN)
            {
                op.setUiError("freqRange", "The frequency you selected for the " + obj.name + " band is lower than the possible frequency of " + FREQUENCY_MIN + " Hz.", 1);
            }
            else if (freq > FREQUENCY_MAX)
            {
                op.setUiError("freqRange", "The frequency you selected for the " + obj.name + " band is higher than the possible frequency of " + FREQUENCY_MAX + " Hz.", 1);
            }
        }
    };
});

FILTER_QS.forEach((obj, index) =>
{
    obj.port.onChange = () =>
    {
        const q = obj.port.get();
        obj.node.Q.setValueAtTime(clamp(q, Q_MIN, Q_MAX), audioContext.currentTime);

        if (q < Q_MIN) op.setUiError(obj.name + "_qRange", "Your Q value for the " + obj.name + " band is below the minimum possible value of " + Q_MIN + ".", 1);
        else if (q > Q_MAX) op.setUiError(obj.name + "_qRange", "Your Q value for the " + obj.name + " band is above the maximum possible value of " + Q_MAX + ".", 1);
        else
        {
            op.setUiError(obj.name + "_qRange", null);
        }
    };
});

FILTER_GAINS.forEach((obj, index) =>
{
    obj.port.onChange = () =>
    {
        const gain = obj.port.get();

        obj.node.gain.setValueAtTime(clamp(gain, GAIN_MIN, GAIN_MAX), audioContext.currentTime);

        if (gain < GAIN_MIN) op.setUiError(obj.name + "GainRange", "Your gain value for the " + obj.name + " band is below the minimum possible value of " + GAIN_MIN + " dB.", 1);
        else if (gain > GAIN_MAX) op.setUiError(obj.name + "GainRange", "Your gain value for the " + obj.name + " band is above the maximum possible value of " + GAIN_MAX + " dB.", 1);
        else
        {
            op.setUiError(obj.name + "GainRange", null);
        }
    };
});

const outAudio = op.outObject("Audio Out", null, "audioNode");

let oldAudioIn = null;

inAudio.onChange = function ()
{
    if (!inAudio.get())
    {
        if (oldAudioIn)
        {
            try
            {
                if (oldAudioIn.disconnect)
                {
                    oldAudioIn.disconnect(lowFilterNode);
                }
            }
            catch (e)
            {
                op.log(e);
            }
        }
        outAudio.set(null);
    }
    else
    {
        if (inAudio.get().connect) inAudio.get().connect(lowFilterNode);
    }
    oldAudioIn = inAudio.get();
    outAudio.set(highFilterNode);
};

op.onDelete = () =>
{
    lowFilterNode.disconnect();
    midFilterNode.disconnect();
};


};

Ops.WebAudio.ThreeBandEqualizer.prototype = new CABLES.Op();
CABLES.OPS["eb875ed3-335b-4709-82ab-3d6514ae2ae6"]={f:Ops.WebAudio.ThreeBandEqualizer,objName:"Ops.WebAudio.ThreeBandEqualizer"};




// **************************************************************
// 
// Ops.WebAudio.WaveformMesh
// 
// **************************************************************

Ops.WebAudio.WaveformMesh = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
// currently only uses mono, if we want to extract stereo data some changes in extractPeaks are needed

// constants
const SAMPLES_PER_PIXEL_MIN = 100; // might crash when this is too low

function findMinMax(array)
{
    let min = Infinity;
    let max = -Infinity;
    let i = 0;
    let len = array.length;
    let curr;

    for (; i < len; i++)
    {
        curr = array[i];
        if (min > curr)
        {
            min = curr;
        }
        if (max < curr)
        {
            max = curr;
        }
    }

    return {
        "min": min,
        "max": max
    };
}

// vars
const geom = new CGL.Geometry("Waveform");
let mesh = null;
const cgl = op.patch.cgl;

// input
const renderPort = op.inTrigger("Render");
const audioBufferPort = op.inObject("Audio Buffer", null, "audioBuffer");
const renderActivePort = op.inBool("Render Active", true);
const showBottomHalfPort = op.inBool("Show bottom half", true);
const centerPort = op.inBool("Center Origin", true);
const widthPort = op.inValue("Width", 30);
const samplesPerPixelPort = op.inInt("Samples Per Pixel", 10000);
const inCalculateUV = op.inBool("Calculate Tex Coords", true);

op.setPortGroup("Render Options", [renderActivePort, showBottomHalfPort, centerPort]);
op.setPortGroup("Waveform Settings", [widthPort, samplesPerPixelPort]);
op.setPortGroup("Mesh Options", [inCalculateUV]);
// output
const nextPort = op.outTrigger("Next");
const geometryPort = op.outObject("Geometry", null, "geometry");

// change listeners
let updating = true;
audioBufferPort.onChange = samplesPerPixelPort.onChange
= showBottomHalfPort.onChange = centerPort.onChange
= widthPort.onChange = inCalculateUV.onChange = () =>
        {
            updating = true;
        };

renderPort.onTriggered = () =>
{
    if (updating)
    {
        extractPeaks();
        updating = false;
    }
    if (mesh && renderActivePort.get())
    {
        mesh.render(cgl.getShader());
    }
    nextPort.trigger();
};

// functions
function calculateUV(meshPoints)
{
    const texCoordsNew = [];
    const xTex = [];
    const yTex = [];

    for (let i = 0; i < meshPoints.length; i += 3)
    {
        xTex.push(meshPoints[i + 0]);
        yTex.push(meshPoints[i + 1]);
    }

    const minMaxX = findMinMax(xTex);
    const minMaxY = findMinMax(yTex);

    const normalizedTexX = xTex.map((val) => mapRange(val, minMaxX.min, minMaxX.max, 0, 1));
    const normalizedTexY = yTex.map((val) => mapRange(val, minMaxY.min, minMaxY.max, 0, 1));

    const finalTexCoords = [];

    for (let i = 0; i < normalizedTexX.length; i += 1)
    {
        finalTexCoords.push(normalizedTexX[i], 1.0 - normalizedTexY[i]);
    }

    return finalTexCoords;
}

function createMesh(meshPoints)
{
    geom.clear();
    geom.vertices = meshPoints;

    if (inCalculateUV.get())
    {
        const texCoords = calculateUV(meshPoints);
        geom.setTexCoords(texCoords);
    }
    else
    {
        geom.setTexCoords([]);
    }

    geom.calculateNormals();

    for (let i = 0; i < geom.vertexNormals.length; i += 3)
    {
        geom.vertexNormals[i + 2] *= -1;
    }

    mesh = new CGL.Mesh(cgl, geom);
    geometryPort.set(null);
    geometryPort.set(geom);
}

/*
 * Add to triangles to the mesh
 * z-coordinate is assumed to be 0.
 * @param meshPoints The mesh to add triangles to, [x0, y0, z0, x1, y1, z1, ...]
 * @param splinePoints The source for the traingle coordinates, [x0, y0, z0, x1, y1, z1, ...]
 @ param i The index of the first x-coordinate in splinePoints array
 */
function addTrianglesToMesh(meshPoints, splinePoints, i)
{
    // first triangle
    meshPoints.push(splinePoints[i], splinePoints[i + 1], 0); // point a
    meshPoints.push(splinePoints[i + 3], splinePoints[i + 4], 0); // point b
    meshPoints.push(splinePoints[i + 3], 0, 0); // point b (y=0)
    // second triangle
    meshPoints.push(splinePoints[i], splinePoints[i + 1], 0); // point a
    meshPoints.push(splinePoints[i + 3], 0, 0); // point b (y=0)
    meshPoints.push(splinePoints[i], 0, 0); // point a (y=0)
}

/**
 * Creates triangles in the form [ax, ay, az, bx, by, bz, cx, cy, cz, ...]
 * based on all points in splinePoints
 */
function createMeshPoints(splinePoints)
{
    // TODO: calc indices ? optimize mesh poitns
    if (!splinePoints) { return []; }
    let meshPoints = [];
    // if we only draw one half, we can just go over all points
    if (!showBottomHalfPort.get())
    {
        for (var i = 0; i < splinePoints.length - 5; i += 3)
        {
            addTrianglesToMesh(meshPoints, splinePoints, i);
        }
    }
    // if both sides are drawn, we need to handle the end point differently
    else
    {
        // add top half
        for (var i = 0; i < (splinePoints.length / 2) - 5; i += 3)
        {
            addTrianglesToMesh(meshPoints, splinePoints, i);
        }
        // add bottom half
        for (var i = (splinePoints.length / 2); i < splinePoints.length - 5; i += 3)
        {
            addTrianglesToMesh(meshPoints, splinePoints, i);
        }
    }
    return meshPoints;
}

function extractPeaks()
{
    const audioBuffer = audioBufferPort.get();
    if (audioBuffer)
    {
        op.setUiError("noBuffer", null);

        if (!(audioBuffer instanceof AudioBuffer)) return;
    }
    else op.setUiError("noBuffer", "You need to connect the \"Audio Buffer\" input for this op to work!", 0);

    if (audioBuffer)
    {
        let samplesPerPixel = samplesPerPixelPort.get();
        if (samplesPerPixel < SAMPLES_PER_PIXEL_MIN)
        {
            op.setUiError("minSamples", "The value for \"Samples Per Pixel\" is lower than the minimum value " + SAMPLES_PER_PIXEL_MIN + ". Therefore the value has been set to " + SAMPLES_PER_PIXEL_MIN + ".", 1);
            samplesPerPixel = SAMPLES_PER_PIXEL_MIN;
        }
        else
        {
            op.setUiError("minSamples", null);
        }

        let makeMono = audioBuffer.numberOfChannels < 2; // TODO: If we make this a parameter, we have to check if the audio actually is stereo

        const peaks = webaudioPeaks(audioBuffer, samplesPerPixel, makeMono);

        // because we extract mono peaks we just access [0] here
        const typedArr = peaks.data[0];
        const regularArr = Array.prototype.slice.call(typedArr);

        const normalizedArray = [];
        normalizedArray.length = regularArr.length;

        const minMax = findMinMax(regularArr);

        for (let i = 0; i < regularArr.length; i += 1)
        {
            normalizedArray[i] = mapRange(regularArr[i], minMax.min, minMax.max, -1, 1);
        }

        // currently the array contains values like this: [y1top, y1bottom, y2top, ...]
        // we want it to be: [y1top, y2top, ..., y2bottom, y1bottom]

        const resortedArr = [];

        // to center the waveform around the corrdinate origin, we need to offset its position

        let offset = 0;
        let width = widthPort.get();

        if (centerPort.get()) offset = 1;

        for (var i = 1; i < normalizedArray.length; i += 2)
        {
            const xCoord = i / normalizedArray.length;
            const yCoord = normalizedArray[i];

            resortedArr.push(xCoord - offset, yCoord, 0);
        }

        const minX = resortedArr[0];
        const maxX = resortedArr[resortedArr.length - 3];

        if (showBottomHalfPort.get())
        {
            for (var i = normalizedArray.length - 2; i >= 0; i -= 2)
            {
                const xCoord = i / regularArr.length;
                const yCoord = normalizedArray[i];
                resortedArr.push(xCoord - offset, yCoord, 0);
            }
        }

        // re-map range of x-coordinates
        let toMin = 0;
        let toMax = width;

        if (centerPort.get())
        {
            toMin = -width / 2;
            toMax = width / 2;
        }

        for (let i = 0; i < resortedArr.length; i += 3)
        {
            resortedArr[i] = mapRange(resortedArr[i], minX, maxX, toMin, toMax);
        }

        // resortedArr now looks like: [yTop0, yTop1, ..., yBottom1, yBottom0]
        const meshPoints = createMeshPoints(resortedArr);
        createMesh(meshPoints);
    }
    else
    {
        geometryPort.set(null);
        if (geom) geom.clear();
        if (mesh)
        {
            mesh.dispose();
            mesh = null;
        }
    }
}

function mapRange(value, inMin, inMax, outMin, outMax)
{
    return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
}


};

Ops.WebAudio.WaveformMesh.prototype = new CABLES.Op();
CABLES.OPS["9f61a958-90b1-46df-a893-de48a5844583"]={f:Ops.WebAudio.WaveformMesh,objName:"Ops.WebAudio.WaveformMesh"};




// **************************************************************
// 
// Ops.WebAudio.Waveshaper
// 
// **************************************************************

Ops.WebAudio.Waveshaper = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
let audioContext = CABLES.WEBAUDIO.createAudioContext(op);

const inAudio = op.inObject("audio in", null, "audioNode");
const inDryWet = op.inFloatSlider("Dry/Wet", 1);
const inOversampling = op.inSwitch("Oversampling", ["none", "2x", "4x"], "4x");
const inDistortionAmount = op.inInt("Distortion Amount", 15);

const inWaveshapeArray = op.inArray("Waveshape Array In");
const inOutputGain = op.inFloatSlider("Output Gain", 0.5);

op.setPortGroup("Waveshape Settings", [inOversampling, inDistortionAmount, inWaveshapeArray]);
const audioOut = op.outObject("audio out", null, "audioNode");
const outCurve = op.outArray("Curve Out");
const outCurveLength = op.outNumber("Curve Length");

// * webaudio nodes * //
const inputNode = audioContext.createGain();
const dryNode = audioContext.createGain();
const wetNode = audioContext.createGain();
const outputNode = audioContext.createGain();
wetNode.gain.value = parseFloat(inDryWet.get());
dryNode.gain.value = 1.0 - parseFloat(inDryWet.get());

const waveshaperNode = audioContext.createWaveShaper();

function makeDefaultDistortionCurve(amount)
{
    let n_samples = 256, curve = new Float32Array(n_samples);
    for (let i = 0; i < n_samples; ++i)
    {
        // normalize [-1,1];
        let x = i * 2 / n_samples - 1;
        // transfer function
        curve[i] = (Math.PI + amount) * x / (Math.PI + amount * Math.abs(x));
    }
    return curve;
}

waveshaperNode.curve = makeDefaultDistortionCurve(400);
waveshaperNode.oversample = inOversampling.get();
outCurve.set(waveshaperNode.curve);
outCurve.set(waveshaperNode.curve.length);
inputNode.connect(dryNode);
inputNode.connect(waveshaperNode);

dryNode.connect(outputNode);
waveshaperNode.connect(wetNode);

wetNode.connect(outputNode);

changeDistortion();

function changeDistortion()
{
    if (inWaveshapeArray.get())
    {
        inDistortionAmount.setUiAttribs({ "greyout": true });
        waveshaperNode.curve = Float32Array.from(inWaveshapeArray.get());
    }
    else
    {
        inDistortionAmount.setUiAttribs({ "greyout": false });
        if (inDistortionAmount.get() < 0)
        {
            op.setUiError("distAmountOutOfRange", "The minimum amount of possible distortion is 0. Choosing values lower than 0 will set them to 0.", 1);
        }
        else
        {
            op.setUiError("distAmountOutOfRange", null);
        }
        waveshaperNode.curve = makeDefaultDistortionCurve(Math.max(0, inDistortionAmount.get()));
    }

    outCurve.set(Array.from(waveshaperNode.curve));
    outCurveLength.set(waveshaperNode.curve.length);
}

// * onChange handlers * //
inDryWet.onChange = () =>
{
    wetNode.gain.linearRampToValueAtTime(Number(inDryWet.get()), audioContext.currentTime + 0.01);
    dryNode.gain.linearRampToValueAtTime((1 - Number(inDryWet.get())), audioContext.currentTime + 0.01);
};

inWaveshapeArray.onChange = inDistortionAmount.onChange = changeDistortion;

inOversampling.onChange = updateOversampling;

function updateOversampling()
{
    waveshaperNode.oversample = inOversampling.get();
}

inOutputGain.onChange = updateGain;

function updateGain()
{
    outputNode.gain.linearRampToValueAtTime(Number(inOutputGain.get()), audioContext.currentTime + 0.01);
}

let oldAudioIn = null;
inAudio.onChange = function ()
{
    if (!inAudio.get())
    {
        if (oldAudioIn)
        {
            try
            {
                if (oldAudioIn.disconnect)
                {
                    oldAudioIn.disconnect(inputNode);
                }
            }
            catch (e)
            {
                op.log(e);
            }
        }

        audioOut.set(null);
    }
    else
    {
        if (inAudio.get().connect)
        {
            inAudio.get().connect(inputNode);
            audioOut.set(outputNode);
            updateGain();
            updateOversampling();
        }
    }
    oldAudioIn = inAudio.get();
};


};

Ops.WebAudio.Waveshaper.prototype = new CABLES.Op();
CABLES.OPS["c7c957a7-4531-4909-8721-172e568ee076"]={f:Ops.WebAudio.Waveshaper,objName:"Ops.WebAudio.Waveshaper"};




// **************************************************************
// 
// Ops.WebXr.Vr.Vr
// 
// **************************************************************

Ops.WebXr.Vr.Vr = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={"icon_svg":"%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20245.82%20141.73%22%3E%3Cdefs%3E%3Cstyle%3E.a%7Bfill%3A%23fff%3Bfill-rule%3Aevenodd%3B%7D%3C%2Fstyle%3E%3C%2Fdefs%3E%3Ctitle%3Emask%3C%2Ftitle%3E%3Cpath%20class%3D%22a%22%20d%3D%22M175.56%2C111.37c-22.52%2C0-40.77-18.84-40.77-42.07S153%2C27.24%2C175.56%2C27.24s40.77%2C18.84%2C40.77%2C42.07S198.08%2C111.37%2C175.56%2C111.37ZM26.84%2C69.31c0-23.23%2C18.25-42.07%2C40.77-42.07s40.77%2C18.84%2C40.77%2C42.07-18.26%2C42.07-40.77%2C42.07S26.84%2C92.54%2C26.84%2C69.31ZM27.27%2C0C11.54%2C0%2C0%2C12.34%2C0%2C28.58V110.9c0%2C16.24%2C11.54%2C30.83%2C27.27%2C30.83H99.57c2.17%2C0%2C4.19-1.83%2C5.4-3.7L116.47%2C118a8%2C8%2C0%2C0%2C1%2C12.52-.18l11.51%2C20.34c1.2%2C1.86%2C3.22%2C3.61%2C5.39%2C3.61h72.29c15.74%2C0%2C27.63-14.6%2C27.63-30.83V28.58C245.82%2C12.34%2C233.93%2C0%2C218.19%2C0H27.27Z%22%2F%3E%3C%2Fsvg%3E","present_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\n\nvoid main()\n{\n    outColor= texture(tex,texCoord);\n    // outColor=vec4(texCoord.x,texCoord.y,0.0,1.0);\n}\n\n","present_vert":"{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\n\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord=vec2(attrTexCoord.x,1.0-attrTexCoord.y);\n    vec4 pos=vec4(vPosition,  1.0);\n    mat4 mMatrix=modelMatrix;\n    {{MODULE_VERTEX_POSITION}}\n    gl_Position = projMatrix * (viewMatrix*mMatrix) * pos;\n}\n",};
/*
https://web.dev/vr-comes-to-the-web-pt-ii/
*/

const
    inMainloop = op.inTrigger("Mainloop"),
    inStop = op.inTriggerButton("Stop"),
    inShowButton = op.inBool("Show Button", true),
    inButtonStyle = op.inStringEditor("Button Style", "padding:10px;\nposition:absolute;\nleft:50%;\ntop:50%;\ntransform: translate(-50%,-50%);\nwidth:50px;\nheight:50px;\ncursor:pointer;\nborder-radius:40px;\nbackground:#444;\nbackground-repeat:no-repeat;\nbackground-size:70%;\nbackground-position:center center;\nz-index:9999;\nbackground-image:url(data:image/svg+xml," + attachments.icon_svg + ");", "inline-css"),
    inRender2Tex = op.inBool("Render to texture", false),
    inShader = op.inObject("Shader", null, "shader"),
    msaa = op.inSwitch("MSAA", ["none", "2x", "4x", "8x"], "none"),
    next = op.outTrigger("Next"),
    nextPre = op.outTrigger("Render After Eyes"),
    outPose = op.outObject("Viewer Pose"),
    outEyeIndex = op.outNumber("Eye Index"),
    outVr = op.outBoolNum("VR Support"),
    outMat = op.outArray("Matrix"),
    outElement = op.outObject("DOM Overlay Ele", null, "element"),
    outSession = op.outBoolNum("In Session"),
    outMs = op.outArray("Ms per eye"),
    outTex = op.outTexture("Texture"),
    outDepth = op.outTexture("Texture Depth");

const cgl = op.patch.cgl;
const canvas = op.patch.cgl.canvas.parentElement;

op.setPortGroup("Startbutton", [inButtonStyle, inShowButton]);
op.setPortGroup("Texture", [inRender2Tex, msaa]);

let msEyes = [0, 0];
let xr = navigator.xr;
let fb = null;

let hadError = false;
let buttonEle = null;
let glLayer = null;
let xrSession = null;
let webGLRenContext = null;
let xrReferenceSpace = null;
let vmat = mat4.create();
let xrViewerPose = null;

inStop.onTriggered = stopVr;
inButtonStyle.onChange = () => { if (buttonEle)buttonEle.style = inButtonStyle.get(); };

if (xr) xr.isSessionSupported("immersive-vr").then(
    (r) =>
    {
        outVr.set(true);

        if (r) initButton();
        else removeButton();
    });
else removeButton();

op.onDelete = () =>
{
    removeButton();
};

inShowButton.onChange = () =>
{
    if (!inShowButton.get())removeButton();
    else initButton();
};

function stopVr()
{
    if (xrSession)xrSession.end();
    xrSession = null;
    outSession.set(false);

    cgl.frameStore.xrSession = null;
    cgl.frameStore.xrFrame = null;
    cgl.frameStore.xrViewerPose = null;
    cgl.frameStore.xrReferenceSpace = null;
}

function startVr()
{
    if (xrSession)
    {
        stopVr();
        return;
    }

    xr.requestSession("immersive-vr", {})
        .then(
            async (session) =>
            {
                xrSession = session;
                outSession.set(true);

                xrSession.requestReferenceSpace("local").then(
                    (refSpace) =>
                    {
                        xrReferenceSpace = refSpace;
                    });

                if (xrSession)
                {
                    await cgl.gl.makeXRCompatible();

                    let canvas = cgl.canvas;
                    webGLRenContext = canvas.getContext("webgl2", { "xrCompatible": true });

                    xrSession.updateRenderState({ "baseLayer": new XRWebGLLayer(xrSession, webGLRenContext) });
                    xrSession.requestAnimationFrame(onXRFrame);
                }
            },
            (err) =>
            {
                // error....
                op.error(err);
            });
}

function onXRFrame(hrTime, xrFrame)
{
    if (hadError) return;

    let xrSession = xrFrame.session;
    xrSession.requestAnimationFrame(onXRFrame);

    try
    {
        xrViewerPose = xrFrame.getViewerPose(xrReferenceSpace);

        cgl.frameStore.xrSession = xrSession;
        cgl.frameStore.xrFrame = xrFrame;
        cgl.frameStore.xrViewerPose = xrViewerPose;
        cgl.frameStore.xrReferenceSpace = xrReferenceSpace;

        outMat.set(xrViewerPose.transform.matrix);

        outPose.set(null);
        outPose.set(xrViewerPose);

        if (xrViewerPose)
        {
            glLayer = xrSession.renderState.baseLayer;
            webGLRenContext.bindFramebuffer(webGLRenContext.FRAMEBUFFER, glLayer.framebuffer);
        }

        CABLES.patch.emitOnAnimFrameEvent();

        cgl.renderStart(cgl);

        if (inRender2Tex.get()) r2texStart();

        cgl.gl.clearColor(0, 0, 0, 1);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);

        op.patch.cg = cgl;

        for (let i = 0; i < xrViewerPose.views.length; i++)
        {
            let start = performance.now();
            outEyeIndex.set(i);
            renderPre();
            renderEye(xrViewerPose.views[i]);

            msEyes[i] = performance.now() - start;
            renderPost();

            if (CGL.MESH.lastMesh)CGL.MESH.lastMesh.unBind();
        }

        if (CGL.MESH.lastMesh)CGL.MESH.lastMesh.unBind();

        if (inRender2Tex.get()) r2texEnd();

        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, glLayer.framebuffer); // gllayer has a default framebuffer.... interferes with cables fb stack...

        nextPre.trigger();

        if (inRender2Tex.get())
        {
            cgl.gl.clearColor(0, 0, 1, 1);
            cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);

            cgl.pushPMatrix();
            cgl.pushViewMatrix();

            mat4.ortho(cgl.pMatrix, 0, glLayer.framebufferWidth, glLayer.framebufferHeight, 0, -10, 10);
            cgl.gl.viewport(0, 0, glLayer.framebufferWidth, glLayer.framebufferHeight);

            if (!mesh)rebuildRectangle();

            cgl.setTexture(0, outTex.get().tex);

            if (inShader.isLinked())mesh.render(inShader.get());
            else mesh.render(shader);

            cgl.popPMatrix();
            cgl.popViewMatrix();
        }

        cgl.renderEnd(cgl);

        outMs.set(msEyes);

        CGL.MESH.lastShader = null;
        CGL.MESH.lastMesh = null;
        op.patch.cg = null;
    }
    catch (e)
    {
        op.error(e);
        hadError = true;
    }
}

inMainloop.onTriggered = () =>
{
    if (!xrSession)
    {
        next.trigger();
    }
};

function renderPre()
{
    cgl.pushDepthTest(true);
    cgl.pushDepthWrite(true);
    cgl.pushDepthFunc(cgl.gl.LEQUAL);

    CGL.MESH.lastShader = null;
    CGL.MESH.lastMesh = null;
}

function renderPost()
{
    cgl.popDepthTest();
    cgl.popDepthWrite();
    cgl.popDepthFunc();
}

function renderEye(view)
{
    cgl.pushBlend(true);
    cgl.gl.blendEquationSeparate(cgl.gl.FUNC_ADD, cgl.gl.FUNC_ADD);
    cgl.gl.blendFuncSeparate(cgl.gl.SRC_ALPHA, cgl.gl.ONE_MINUS_SRC_ALPHA, cgl.gl.ONE, cgl.gl.ONE_MINUS_SRC_ALPHA);

    cgl.pushPMatrix();

    cgl.pMatrix = view.projectionMatrix;

    cgl.pushViewMatrix();

    mat4.invert(cgl.vMatrix, xrViewerPose.transform.matrix);

    let viewport = glLayer.getViewport(view);
    cgl.gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

    next.trigger();

    cgl.popViewMatrix();
    cgl.popPMatrix();
    cgl.popBlend();
}

function initButton()
{
    if (buttonEle)
    {
        removeButton();
        buttonEle = null;
    }

    buttonEle = document.createElement("div");
    let container = op.patch.cgl.canvas.parentElement;
    if (container)container.appendChild(buttonEle);
    buttonEle.addEventListener("click", startVr);
    buttonEle.addEventListener("touchstart", startVr);
    buttonEle.style = inButtonStyle.get();
}

function removeButton()
{
    if (buttonEle)buttonEle.remove();
}

msaa.onChange = () =>
{
    if (fb) fb.delete();
    fb = null;
};

function r2texStart()
{
    const w = glLayer.framebufferWidth;
    const h = glLayer.framebufferHeight;

    if (!fb)
    {
        if (fb) fb.delete();

        let selectedWrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;
        let selectFilter = CGL.Texture.FILTER_NEAREST;

        let ms = true;
        let msSamples = 4;

        if (msaa.get() == "none")
        {
            msSamples = 0;
            ms = false;
        }
        if (msaa.get() == "2x") msSamples = 2;
        if (msaa.get() == "4x") msSamples = 4;
        if (msaa.get() == "8x") msSamples = 8;

        fb = new CGL.Framebuffer2(cgl, w, h,
            {
                "name": "render2texture " + op.id,
                "isFloatingPointTexture": false,
                "multisampling": ms,
                "wrap": selectedWrap,
                "filter": selectFilter,
                "depth": true,
                "multisamplingSamples": msSamples,
                "clear": true
            });

        outDepth.set(fb.getTextureDepth());
    }

    if (fb.getWidth() != Math.ceil(w) || fb.getHeight() != Math.ceil(h)) fb.setSize(w, h);

    fb.renderStart(cgl);
}

function r2texEnd()
{
    fb.renderEnd(cgl);

    outTex.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
    outTex.set(fb.getTextureColor());
}

let geom = new CGL.Geometry("webxr final texture draw rectangle");
let mesh = null;
const shader = new CGL.Shader(cgl, "fullscreenrectangle");
shader.fullscreenRectUniform = new CGL.Uniform(shader, "t", "tex", 0);
shader.setSource(attachments.present_vert, attachments.present_frag);

function rebuildRectangle()
{
    // const currentViewPort = cgl.getViewPort();

    // if (currentViewPort[2] == w && currentViewPort[3] == h && mesh) return;

    let xx = 0, xy = 0;

    const w = glLayer.framebufferWidth;
    const h = glLayer.framebufferHeight;

    geom.vertices = new Float32Array([
        xx + w, xy + h, 0,
        xx, xy + h, 0,
        xx + w, xy, 0,
        xx, xy, 0
    ]);

    let tc = null;

    // if (flipY.get())
    //     tc = new Float32Array([
    //         1.0, 0.0,
    //         0.0, 0.0,
    //         1.0, 1.0,
    //         0.0, 1.0
    //     ]);
    // else
    tc = new Float32Array([
        1.0, 1.0,
        0.0, 1.0,
        1.0, 0.0,
        0.0, 0.0
    ]);

    // if (flipX.get())
    // {
    //     tc[0] = 0.0;
    //     tc[2] = 1.0;
    //     tc[4] = 0.0;
    //     tc[6] = 1.0;
    // }

    geom.setTexCoords(tc);

    geom.verticesIndices = new Uint16Array([2, 1, 0, 3, 1, 2]);
    geom.vertexNormals = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,]);
    geom.tangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
    geom.biTangents == new Float32Array([0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0]);

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);
}


};

Ops.WebXr.Vr.Vr.prototype = new CABLES.Op();
CABLES.OPS["884b3def-9bb3-422a-8e1c-c85dcc346f5e"]={f:Ops.WebXr.Vr.Vr,objName:"Ops.WebXr.Vr.Vr"};




// **************************************************************
// 
// Ops.WebXr.Vr.VrController
// 
// **************************************************************

Ops.WebXr.Vr.VrController = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUpdate = op.inTrigger("Update"),
    inHand = op.inSwitch("Handedness", ["left", "right"], "right"),
    next = op.outTrigger("Next"),

    outAxis1 = op.outNumber("Axis 1"),
    outAxis2 = op.outNumber("Axis 2"),
    outAxis3 = op.outNumber("Axis 3"),
    outAxis4 = op.outNumber("Axis 4"),
    outButton1 = op.outBoolNum("Button 1 Pressed"),
    outButton2 = op.outBoolNum("Button 2 Pressed"),
    outButton3 = op.outBoolNum("Button 3 Pressed"),
    outButton4 = op.outBoolNum("Button 4 Pressed"),
    outButton5 = op.outBoolNum("Button 5 Pressed"),
    outButton6 = op.outBoolNum("Button 6 Pressed"),
    outButton7 = op.outBoolNum("Button 7 Pressed"),
    outButton1Touch = op.outBoolNum("Button 1 Touched"),
    outButton2Touch = op.outBoolNum("Button 2 Touched"),
    outButton3Touch = op.outBoolNum("Button 3 Touched"),
    outButton4Touch = op.outBoolNum("Button 4 Touched"),
    outButton5Touch = op.outBoolNum("Button 5 Touched"),
    outButton6Touch = op.outBoolNum("Button 6 Touched"),
    outButton7Touch = op.outBoolNum("Button 7 Touched"),

    outX = op.outNumber("Position X"),
    outY = op.outNumber("Position Y"),
    outZ = op.outNumber("Position Z"),

    outGp = op.outObject("Gamepad Values"),

    outTransformed = op.outTrigger("Transformed Position"),

    outFound = op.outBoolNum("Found");

const cgl = op.patch.cgl;

op.setPortGroup("Gamepad", [
    outButton1, outButton2, outButton3, outButton4, outButton5, outButton6, outButton7,
    outButton1Touch, outButton2Touch, outButton3Touch, outButton4Touch, outButton5Touch, outButton6Touch, outButton7Touch,
    outAxis1, outAxis2, outAxis3, outAxis4]);

inUpdate.onTriggered = () =>
{
    outGp.set(null);

    if (op.patch.cgl.frameStore.xrSession)
    {
        let found = false;
        let xrSession = op.patch.cgl.frameStore.xrSession;

        const inputSources = xrSession.inputSources;

        for (let i = 0; i < inputSources.length; i++)
        {
            if (inputSources[i].handedness === inHand.get())
            {
                found = true;

                if (inputSources[i].gamepad)setGamepadValues(inputSources[i].gamepad);

                let controlPose = cgl.frameStore.xrFrame.getPose(inputSources[i].gripSpace, cgl.frameStore.xrReferenceSpace);
                if (controlPose && controlPose.transform)
                {
                    cgl.pushModelMatrix();

                    mat4.multiply(cgl.mMatrix, cgl.mMatrix, controlPose.transform.matrix);
                    outX.set(controlPose.transform.position.x);
                    outY.set(controlPose.transform.position.y);
                    outZ.set(controlPose.transform.position.z);

                    outTransformed.trigger();

                    cgl.popModelMatrix();
                }
                else op.log("vr controller: no controlpose transform?!");

                break;
            }
        }

        outFound.set(found);
    }

    next.trigger();
};

function setGamepadValues(gp)
{
    outAxis1.set(gp.axes[0]);
    outAxis2.set(gp.axes[1]);

    outButton1.set(gp.buttons[0].pressed);
    outButton2.set(gp.buttons[1].pressed);
    outButton3.set(gp.buttons[2].pressed);
    outButton4.set(gp.buttons[3].pressed);
    outButton5.set(gp.buttons[4].pressed);
    outButton6.set(gp.buttons[5].pressed);
    outButton7.set(gp.buttons[6].pressed);

    outButton1Touch.set(gp.buttons[0].touched);
    outButton2Touch.set(gp.buttons[1].touched);
    outButton3Touch.set(gp.buttons[2].touched);
    outButton4Touch.set(gp.buttons[3].touched);
    outButton5Touch.set(gp.buttons[4].touched);
    outButton6Touch.set(gp.buttons[5].touched);
    outButton7Touch.set(gp.buttons[6].touched);

    const g = { "buttons": gp.buttons,
        "axes": gp.axes,
        "connected": gp.connected,
        "mapping": gp.mapping,
        "axes": gp.axes
    };

    outGp.set(g);
}


};

Ops.WebXr.Vr.VrController.prototype = new CABLES.Op();
CABLES.OPS["6959b43a-8c64-4aa1-a0f0-d4d5b7e2b1c3"]={f:Ops.WebXr.Vr.VrController,objName:"Ops.WebXr.Vr.VrController"};




// **************************************************************
// 
// Ops.Website.Cookie
// 
// **************************************************************

Ops.Website.Cookie = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    outCookie = op.outObject("Cookie"),
    outString = op.outString("Cookie String");

update();

function str_obj(str)
{
    str = str.split(";");
    const result = {};

    for (let i = 0; i < str.length; i++)
    {
        const cur = str[i].split("=");
        if (cur.length > 1) result[cur[0].trim()] = cur[1].trim();
    }
    return result;
}

function update()
{
    outCookie.set(str_obj(document.cookie));
    outString.set(document.cookie);
}


};

Ops.Website.Cookie.prototype = new CABLES.Op();
CABLES.OPS["a02b3bbe-eace-4a2e-b02b-1bf1e398d78a"]={f:Ops.Website.Cookie,objName:"Ops.Website.Cookie"};




// **************************************************************
// 
// Ops.Website.FilenameInfo
// 
// **************************************************************

Ops.Website.FilenameInfo = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inUrl=op.inString("URL",""),
    outProtocol=op.outString("Protocol"),
    outHost=op.outString("Host"),
    outFullPath=op.outString("Full Path"),
    outFilename=op.outString("Filename"),
    outIsURL=op.outString("Is URL"),
    outExt=op.outString("Suffix");

function isValidUrl(string)
{
    try { new URL(string); }
    catch (_) { return false; }

    return true;
}

inUrl.onChange=()=>
{
    const url=inUrl.get();
    const isUrl=isValidUrl(url);
    outIsURL.set(isUrl);

    if(url.indexOf(":")>-1)
    {
        const pathArray = url.split( ':' );
        outProtocol.set(pathArray[0]);
    }

    if(url.indexOf("/")>-1)
    {
        const hostArr = url.split( '/' );
        outHost.set(hostArr[2]);
    }

    if(url.indexOf(".")>-1)
    {
        const fnArray=url.split(".");
        outExt.set(fnArray[fnArray.length-1]);
    }
    else outExt.set("");

    if(url.indexOf("/")>-1 )
    {
        const hostArr = url.split( '/' );
        outFilename.set(hostArr[hostArr.length-1]);

        hostArr.length=hostArr.length-1;
        const fullPath=hostArr.join("/");
        outFullPath.set(fullPath);
    }
    else
    {
        if(!isUrl)outFilename.set(url);
    }
};


};

Ops.Website.FilenameInfo.prototype = new CABLES.Op();
CABLES.OPS["0a349745-20c8-44c4-8a70-214c7ccf87e9"]={f:Ops.Website.FilenameInfo,objName:"Ops.Website.FilenameInfo"};




// **************************************************************
// 
// Ops.Website.ForceHttps
// 
// **************************************************************

Ops.Website.ForceHttps = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};

if (location.href.indexOf("http://localhost"))
    if (location.protocol !== "https:") location.protocol = "https:";


};

Ops.Website.ForceHttps.prototype = new CABLES.Op();
CABLES.OPS["63eb8aad-4700-4760-ac0b-ae712ac01fd7"]={f:Ops.Website.ForceHttps,objName:"Ops.Website.ForceHttps"};




// **************************************************************
// 
// Ops.Website.InfoURL
// 
// **************************************************************

Ops.Website.InfoURL = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    outUrl = op.outString("URL"),
    outHost = op.outString("Host"),
    outHash = op.outString("Hash"),
    outPathname = op.outString("Pathname"),
    outProtocol = op.outString("Protocol"),
    outPort = op.outString("Port"),
    outChangeHash = op.outTrigger("Hash Changed");

op.onDelete = () =>
{
    window.removeEventListener("hashchange", hashChange);
};

window.addEventListener("hashchange", hashChange);

const l = document.location;
outUrl.set(l.href);
outHost.set(l.host);
outHash.set(l.hash);
outPathname.set(l.pathname);
outProtocol.set(l.protocol);
outPort.set(l.port);

function hashChange()
{
    const l = document.location;
    outHash.set(l.hash);

    outChangeHash.trigger();
}


};

Ops.Website.InfoURL.prototype = new CABLES.Op();
CABLES.OPS["e72fbd80-f9c7-4572-8b6d-a485ef474b74"]={f:Ops.Website.InfoURL,objName:"Ops.Website.InfoURL"};




// **************************************************************
// 
// Ops.Website.LocalStorageNumber
// 
// **************************************************************

Ops.Website.LocalStorageNumber = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inKey = op.inString("Key"),
    inValue = op.inFloat("Number"),
    inStore = op.inTriggerButton("Store"),
    outValue = op.outNumber("Stored Number"),
    outSupported = op.outBoolNum("Storage Support", true);

inKey.onChange = updateOutput;
inStore.onTriggered = storeValue;

const localStorageSupport = !!window.localStorage;
if (!localStorageSupport)
{
    op.logError("your browser does not support or blocks access to localStorage, output will be inValue!");
    outSupported.set(false);
}

updateOutput();
op.onLoaded = updateOutput;

function parse(val)
{
    if (val === "true" || val === true)val = 1;
    if (val === "false" || val === false)val = 0;
    val = parseFloat(val);
    if (val != val)val = 0;
    return val;
}

op.patch.on("localstorageStored", (key, val) =>
{
    if (key == inKey.get()) outValue.set(parse(val));
});

function getKey()
{
    return (op.patch.namespace || "") + inKey.get();
}

function updateOutput()
{
    if (localStorageSupport)
    {
        outValue.set(parse(window.localStorage.getItem(getKey())));
    }
    else
    {
        outValue.set(inValue.get());
    }
}

function storeValue()
{
    let val = parse(inValue.get());

    if (localStorageSupport)
    {
        window.localStorage.setItem(getKey(), val);
    }
    else
    {
        op.warn("not storing to localstorage, missing browsersupport!");
    }
    outValue.set(val);
    op.patch.emitEvent("localstorageStored", inKey.get(), val);
}


};

Ops.Website.LocalStorageNumber.prototype = new CABLES.Op();
CABLES.OPS["2894cca0-0c06-4034-9d38-04b72afad277"]={f:Ops.Website.LocalStorageNumber,objName:"Ops.Website.LocalStorageNumber"};




// **************************************************************
// 
// Ops.Website.LocalStorageString
// 
// **************************************************************

Ops.Website.LocalStorageString = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    inKey = op.inString("Key"),
    inValue = op.inString("String", ""),
    inStore = op.inTriggerButton("Store"),
    outValue = op.outString("Stored String"),
    outSupported = op.outBool("Storage Support", true);

const localStorageSupport = !!window.localStorage;
if (!localStorageSupport)
{
    op.logError("your browser does not support or blocks access to localStorage, output will be inValue!");
    outSupported.set(false);
}

updateOutput();
inKey.onChange = updateOutput;
inStore.onTriggered = storeValue;

function getKey()
{
    return (op.patch.namespace || "") + inKey.get();
}

function updateOutput()
{
    if (localStorageSupport)
    {
        outValue.set(window.localStorage.getItem(getKey()));
    }
    else
    {
        outValue.set(inValue.get());
    }
}

function storeValue()
{
    const val = inValue.get();
    if (localStorageSupport)
    {
        window.localStorage.setItem(getKey(), val);
    }
    else
    {
        op.warn("not storing to localstorage, missing browsersupport!");
    }
    outValue.set(val);
}


};

Ops.Website.LocalStorageString.prototype = new CABLES.Op();
CABLES.OPS["f908fc2e-70b6-4ca4-8afd-4302b35ff570"]={f:Ops.Website.LocalStorageString,objName:"Ops.Website.LocalStorageString"};




// **************************************************************
// 
// Ops.Website.LocationHashRoute
// 
// **************************************************************

Ops.Website.LocationHashRoute = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const routeIn = op.inString("Route");
const parsedOut = op.outObject("Values", {});
const changedOut = op.outTrigger("Changed");
const outMatching = op.outBool("Matching");

let router = null;
let lastHref = null;
let hashChangeListener = null;

op.onLoaded, op.onCreate = init;

function init()
{
    if ("onhashchange" in window)
    {
        router = new Navigo("/", { "hash": true, "noMatchWarning": true });
        const eventWrapper = (event) =>
        {
            event.internal = true;
            hashChange(event);
        };

        if (hashChangeListener)
        {
            op.patch.removeEventListener(hashChangeListener);
            hashChangeListener = null;
        }
        hashChangeListener = op.patch.addEventListener("LocationHashChange", eventWrapper);
        window.removeEventListener("hashchange", hashChangeFromBrowser);
        window.addEventListener("hashchange", hashChangeFromBrowser);
        hashChange({ "newURL": window.location.href });
    }
    else
    {
        op.setUiError("unsupported", "Your browser does not support listening to hashchanges!");
    }
}

function hashChangeFromBrowser(event)
{
    hashChange(event);
}

op.onDelete = function ()
{
    if (hashChangeListener)
    {
        op.patch.removeEventListener(hashChangeListener);
        hashChangeListener = null;
    }
    window.removeEventListener("hashchange", hashChangeFromBrowser);
};

routeIn.onChange = function ()
{
    if (router)
    {
        hashChange({ "newURL": window.location.href }, true);
    }
};

function hashChange(event, forceUpdate)
{
    let hash = "";
    if (!forceUpdate && (event.newURL === lastHref))
    {
        return;
    }
    lastHref = event.newURL;
    op.setUiError("unsupported", null);
    let values = {};
    const fields = event.newURL.split("#");
    let hasMatch = false;
    if (routeIn.get())
    {
        if (router && fields.length > 1)
        {
            hasMatch = false;
            for (let i = 1; i < fields.length; i++)
            {
                let route = routeIn.get();
                let match = fields[i];
                hash += "#" + fields[i];
                const matched = router.matchLocation(route, match);
                if (matched)
                {
                    if (matched.data)
                    {
                        const keys = Object.keys(matched.data);
                        keys.forEach((key) =>
                        {
                            matched.data[key] = getTypedValue(matched.data[key]);
                        });
                        values = Object.assign(values, matched.data);
                    }
                    if (matched.params)
                    {
                        const keys = Object.keys(matched.params);
                        keys.forEach((key) =>
                        {
                            matched.params[key] = getTypedValue(matched.params[key]);
                        });
                        values = Object.assign(values, matched.params);
                    }
                    hasMatch = true;
                }
            }
        }
    }
    else
    {
        const all = event.newURL.split("#", 2);
        hash = all[1] || "";
        hasMatch = true;
    }

    if (hasMatch)
    {
        let paramStr = hash.split("?", 2);
        let params = parseQuery(paramStr[1]);
        let keys = Object.keys(params);
        keys.forEach((key) =>
        {
            if (!values.hasOwnProperty(key)) values[key] = params[key];
        });
    }

    outMatching.set(hasMatch);

    if (!(parsedOut.get().length === 0 && values.length === 0))
    {
        parsedOut.set(values);
    }

    if (hasMatch && !event.silent)
    {
        changedOut.trigger();
    }
}

function getTypedValue(val)
{
    let value = decodeURIComponent(val || "");
    if (value !== "")
    {
        switch (value)
        {
        case "true":
            value = true;
            break;

        case "false":
            value = false;
            break;

        default:
            if (!isNaN(value))
            {
                value = Number(value);
            }
        }
    }
    return value;
}

function parseQuery(str)
{
    if (typeof str != "string" || str.length == 0) return {};
    let s = str.split("&");
    let s_length = s.length;
    let bit, query = {}, first, second;
    for (let i = 0; i < s_length; i++)
    {
        bit = s[i].split("=");
        first = decodeURIComponent(bit[0]);
        if (first.length == 0) continue;
        second = decodeURIComponent(bit[1]);
        if (typeof query[first] == "undefined") query[first] = second;
        else if (query[first] instanceof Array) query[first].push(second);
        else query[first] = [query[first], second];
    }
    return query;
}


};

Ops.Website.LocationHashRoute.prototype = new CABLES.Op();
CABLES.OPS["1e76f92b-1eed-4575-96e1-fcff6ed08c04"]={f:Ops.Website.LocationHashRoute,objName:"Ops.Website.LocationHashRoute"};




// **************************************************************
// 
// Ops.Website.SetLocationHash
// 
// **************************************************************

Ops.Website.SetLocationHash = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    hashIn = op.inString("Hash", ""),
    inUpdate = op.inTriggerButton("Update"),
    activeIn = op.inBool("Active", false),
    silentIn = op.inBool("Silent", true),
    reloadIn = op.inBool("Allow Empty", false);

inUpdate.onTriggered = update;

function update()
{
    if (!activeIn.get()) return;

    let hash = "";
    if (hashIn.get())
    {
        hash = "#" + hashIn.get();
    }

    if (window.location.hash == hash)
    {
        return;
    }

    try
    {
        op.setUiError("overload", null);
        const event = new Event("hashchange");
        event.oldURL = window.location.href;
        if (silentIn.get()) event.silent = true;

        if (hash)
        {
            history.replaceState(null, null, window.location.pathname + hash);
        }
        else if (reloadIn.get())
        {
            history.replaceState(null, null, window.location.pathname);
        }
        event.newURL = window.location.href;
        op.patch.emitEvent("LocationHashChange", event);
        window.dispatchEvent(event);
    }
    catch (e)
    {
        op.setUiError("overload", "too many changes to the location hash, throttle down");
        op.log(e.message);
    }
}


};

Ops.Website.SetLocationHash.prototype = new CABLES.Op();
CABLES.OPS["82492357-c11d-4b76-bd57-b296d3b79b83"]={f:Ops.Website.SetLocationHash,objName:"Ops.Website.SetLocationHash"};




// **************************************************************
// 
// Ops.Website.UrlQueryParams_v2
// 
// **************************************************************

Ops.Website.UrlQueryParams_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments={};
const
    paramName = op.inString("parameter"),
    def = op.inString("Default"),
    result = op.outString("result");

def.onChange = update;
paramName.onChange = updateParam;

const query = {};
const a = window.location.search.substr(1).split("&");

update();

for (let i = 0; i < a.length; i++)
{
    const b = a[i].split("=");
    query[decodeURIComponent(b[0])] = decodeURIComponent(b[1] || "");
}

function updateParam()
{
    op.setUiAttrib({ "extendTitle": paramName.get() });
    update();
}

function update()
{
    if (!query.hasOwnProperty(paramName.get()))
    {
        const value = def.get() || null;
        result.set(value);
    }
    else
    {
        let v = query[paramName.get()];
        if (v === "true")v = true;
        else if (v === "false")v = false;

        result.set(v);
    }
}


};

Ops.Website.UrlQueryParams_v2.prototype = new CABLES.Op();
CABLES.OPS["2e1b645c-c463-465d-abec-bf06ee4b970c"]={f:Ops.Website.UrlQueryParams_v2,objName:"Ops.Website.UrlQueryParams_v2"};


